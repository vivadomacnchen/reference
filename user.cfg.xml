<options>
	<misc.options n="misc.options" version="1">
		<app_theme v="Dark"/>
		<search_flags v="0x1"/>
	</misc.options>
	<misc.tag_file_list n="misc.tag_file_list" version="1" configs="win">
		<p n="cs" v='%SLICKEDITCONFIGVERSION%tagfiles\unity.vtg;"C:\Users\User\Documents\My SlickEdit Config\24.0.2\tagfiles\dotnet.vtg"'/>
		<p n="bas" v='"C:\Users\User\Documents\My SlickEdit Config\24.0.2\tagfiles\dotnet.vtg"'/>
		<p n="c" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="e" v="%SLICKEDITCONFIGVERSION%tagfiles\slickc.vtg"/>
	</misc.tag_file_list>
	<misc.def_vars n="misc.def_vars" version="1">
		<p n="def_color_scheme" v="Slate"/>
		<p n="def_refactor_active_config" v="Visual Studio 2008"/>
		<p n="def_toolbar_tree_pic_size" v="12"/>
		<p n="def_toolbartab" configs="win unix">
			<array>
				<class._TOOLBAR>
					<FormName v="_tbstandard_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbproject_tools_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x1"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbtools_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbedit_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbseldisp_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbxml_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x800"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbhtml_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbtagging_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x4"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbcontext_form"/>
					<tbflags v="0x8"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x400"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbdebugbb_form"/>
					<tbflags v="0x49"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x2"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbdebug_sessions_form"/>
					<tbflags v="0x48"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x2"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbvc_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x8"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbandroid_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x1"/>
				</class._TOOLBAR>
			</array>
		</p>
		<p n="def_symbol_color_profile" v="All symbols - Dark background"/>
		<p n="def_mozilla_modified" v="1"/>
		<p n="def_eao_file_date2" v="20200401124714000"/>
		<p n="def_lldb_debug_server" v=""/>
		<p n="def_workspace_info" configs="win">
			<array>
				<class.WORKSPACE_LIST>
					<isFolder v="1"/>
					<filename/>
					<caption v="Sample Workspaces"/>
					<u>
						<array>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\clang\clang.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\csharp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\vcpp_csharp.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\vcpp_csharp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\DevStudio\2013\VS2013.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\DevStudio\2015\VS2015.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\java\java.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\ucpp\cpp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
						</array>
					</u>
					<projectname/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\workspace\testse\testse.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\workspace\testse\testse.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\workspace\netEx.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\workspace\netEx.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\NetEx\NetEx.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\NetEx\NetEx.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\crypto\wolfssl\wolfsslLEARN\wolfssl.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\crypto\wolfssl\wolfsslLEARN\wolfssl.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\crypto\openssl\opensslLEARN\openssltest\openssltest.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\crypto\openssl\opensslLEARN\openssltest\openssltest.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\usb4java\testjavausb.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\usb4java\testjavausb.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Japan\Repo\TestJP\TestJP.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Japan\Repo\TestJP\TestJP\TestJP.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswing.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswing.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswing2\testswing2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswing2\testswing2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testawtapplet\testawtapplet.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testawtapplet\testawtapplet.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswtapp\testswtapp.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswtapp\testswtapp.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testjfcapplet\testjfcapplet.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testjfcapplet\testjfcapplet.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testjfcapplication\testjfcapplication.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testjfcapplication\testjfcapplication.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\CH4.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\CH4.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testCross.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testCross.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testc.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testc.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testalg\testalg.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testalg\testalg\testalg.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\myalg\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\myalg\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testalg2\testalg2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testCordinateECC\testCordinateECC\testECCCordinate\vsporj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testCordinateECC\testCordinateECC\testECCCordinate\vsporj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\se\se.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\se\se.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch02\se_proj\se_proj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch02\se_proj\se_proj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch03\seprj\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch03\seprj\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch07\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch07\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch08\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch08\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vc_string\stringhandle\test2\test2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vc_string\stringhandle\test2\test2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vcplusplus\lisbox\lisbox\testlistbox.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vcplusplus\lisbox\lisbox\testlistbox.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vcplusplus\vcplusplus\lisbox\lisbox\testlistbox.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vcplusplus\vcplusplus\lisbox\lisbox\testlistbox.vpj"/>
				</class.WORKSPACE_LIST>
			</array>
		</p>
		<p n="def_open_style" v="0"/>
		<p n="def_jdk_install_dir" v="C:\Program Files\Java\jdk-14.0.1\" configs="win"/>
		<p n="def_java_live_errors_jdk_6_dir" v="C:\Program Files\Java\jdk-14.0.1\" configs="win"/>
		<p n="def_java_live_errors_jvm_lib" v="C:\Program Files\Java\jdk-14.0.1\bin\server\jvm.dll"/>
		<p n="def_encoding" v="+futf8s"/>
		<p n="def_git_browser_url_list">
			<array>
				<p v="C:\W\java\repo\myjava\"/>
			</array>
		</p>
		<p n="def_debug_number_formats">
			<dict>
				<p n="char">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="double">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="float">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="int">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="long">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="short">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="unsigned">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
			</dict>
		</p>
		<p n="def_project_auto_build" v="1"/>
		<p n="def_keys" v="eclipse-keys" configs="win unix"/>
		<p n="def_deselect_copy" v="0"/>
		<p n="def_vcpp_word" v="1"/>
		<p n="def_subword_nav" v="1"/>
		<p n="def_re_search_flags" v="0x4004000"/>
		<p n="def_vcproj_debug_prefs" v="2"/>
		<p n="def_mfsearch_init_flags" v="0xA"/>
		<p n="def_active_java_config" v="JDK 14.0.1"/>
	</misc.def_vars>
	<misc.tag_file_list_all n="misc.tag_file_list_all" version="1" configs="win">
		<p n="cs" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg;%SLICKEDITCONFIGVERSION%tagfiles\unity.vtg"/>
		<p n="c" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="bas" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="e" v="%SLICKEDITCONFIGVERSION%tagfiles\slickc.vtg"/>
	</misc.tag_file_list_all>
	<misc.fonts n="misc.fonts" version="1">
		<sbcs_dbcs_source_window font_name="Fixedsys" sizex10="120" flags="0x0" configs="win"/>
		<unicode_source_window font_name="Fixedsys" sizex10="120" flags="0x0" configs="win"/>
	</misc.fonts>
	<language n="language.dll" version="1">
		<p n="mode_name" v="dll"/>
	</language>
	<misc.file_extensions n="misc.file_extensions" version="1">
		<p n="encoding-def" v=""/>
		<p n="encoding-cs" v=""/>
		<p n="encoding-rb" v=""/>
		<p n="encoding-mp3" v=""/>
		<p n="encoding-7zip" v=""/>
		<p n="encoding-f90" v=""/>
		<p n="encoding-cfm" v=""/>
		<p n="encoding-f" v=""/>
		<p n="encoding-cpio" v=""/>
		<p n="encoding-coffee" v=""/>
		<p n="encoding-p4gl" v=""/>
		<p n="encoding-xhtml" v=""/>
		<p n="encoding-tagdoc" v=""/>
		<p n="encoding-cghlsl" v=""/>
		<p n="encoding-properties" v=""/>
		<p n="encoding-vtg" v=""/>
		<p n="encoding-exp" v=""/>
		<p n="encoding-plist" v=""/>
		<p n="encoding-c" v=""/>
		<p n="encoding-verilog" v=""/>
		<p n="encoding-bin" v=""/>
		<p n="encoding-adb" v=""/>
		<p n="encoding-vcproj" v=""/>
		<p n="encoding-docx" v=""/>
		<p n="encoding-w" v=""/>
		<p n="encoding-txt" v=""/>
		<p n="encoding-py" v=""/>
		<p n="encoding-ada" v=""/>
		<p n="encoding-aspx" v=""/>
		<p n="encoding-cob" v=""/>
		<p n="encoding-rpm" v=""/>
		<p n="encoding-build" v=""/>
		<p n="encoding-pas" v=""/>
		<p n="encoding-less" v=""/>
		<p n="encoding-ttcn" v=""/>
		<p n="encoding-cbl" v=""/>
		<p n="encoding-antlr" v=""/>
		<p n="encoding-svh" v=""/>
		<p n="encoding-sqlserver" v=""/>
		<p n="encoding-h" v=""/>
		<p n="encoding-fs" v=""/>
		<p n="encoding-plsql" v=""/>
		<p n="encoding-h++" v=""/>
		<p n="encoding-mk" v=""/>
		<p n="encoding-asax" v=""/>
		<p n="encoding-bat" v=""/>
		<p n="encoding-dll" v=""/>
		<p n="encoding-pm" v=""/>
		<p n="encoding-plm" v=""/>
		<p n="encoding-fsx" v=""/>
		<p n="encoding-php3" v=""/>
		<p n="encoding-pdf" v=""/>
		<p n="encoding-vsm" v=""/>
		<p n="encoding-inc" v=""/>
		<p n="encoding-xaml" v=""/>
		<p n="encoding-png" v=""/>
		<p n="encoding-asm390" v=""/>
		<p n="encoding-plx" v=""/>
		<p n="encoding-m" v=""/>
		<p n="encoding-db2" v=""/>
		<p n="encoding-htm" v=""/>
		<p n="encoding-i" v=""/>
		<p n="encoding-gsh" v=""/>
		<p n="encoding-exe" v=""/>
		<p n="encoding-dpr" v=""/>
		<p n="encoding-rs" v=""/>
		<p n="encoding-rul" v=""/>
		<p n="encoding-masm" v=""/>
		<p n="encoding-dtd" v=""/>
		<p n="encoding-docbook" v=""/>
		<p n="encoding-xpm" v=""/>
		<p n="encoding-xml" v=""/>
		<p n="encoding-rexx" v=""/>
		<p n="encoding-mpeg" v=""/>
		<p n="encoding-suo" v=""/>
		<p n="encoding-cpy" v=""/>
		<p n="encoding-tld" v=""/>
		<p n="encoding-winmd" v=""/>
		<p n="encoding-pl" v=""/>
		<p n="encoding-ascx" v=""/>
		<p n="encoding-class" v=""/>
		<p n="encoding-pro" v=""/>
		<p n="encoding-gl" v=""/>
		<p n="encoding-cob85" v=""/>
		<p n="encoding-vlx" v=""/>
		<p n="encoding-editorconfig" v=""/>
		<p n="encoding-perl" v=""/>
		<p n="encoding-cfscript" v=""/>
		<p n="encoding-vhdl" v=""/>
		<p n="encoding-hlsl" v=""/>
		<p n="encoding-rmd" v=""/>
		<p n="encoding-rhtml" v=""/>
		<p n="encoding-phpscript" v=""/>
		<p n="encoding-tiff" v=""/>
		<p n="encoding-l" v=""/>
		<p n="encoding-sdef" v=""/>
		<p n="encoding-for" v=""/>
		<p n="encoding-ruby" v=""/>
		<p n="encoding-qml" v=""/>
		<p n="encoding-psm1" v=""/>
		<p n="encoding-vsdelta" v=""/>
		<p n="encoding-cginc" v=""/>
		<p n="encoding-mak" v=""/>
		<p n="encoding-groovy" v=""/>
		<p n="encoding-g" v=""/>
		<p n="encoding-chf" v=""/>
		<p n="encoding-yaml" v=""/>
		<p n="encoding-pp" v=""/>
		<p n="encoding-mdown" v=""/>
		<p n="encoding-inl" v=""/>
		<p n="encoding-m4" v=""/>
		<p n="encoding-applescript" v=""/>
		<p n="encoding-tex" v=""/>
		<p n="encoding-gz" v=""/>
		<p n="encoding-p" v=""/>
		<p n="encoding-ansic" v=""/>
		<p n="encoding-v2k" v=""/>
		<p n="encoding-hp" v=""/>
		<p n="encoding-g4" v=""/>
		<p n="encoding-bbc" v=""/>
		<p n="encoding-rc" v=""/>
		<p n="encoding-scala" v=""/>
		<p n="encoding-frm" v=""/>
		<p n="encoding-prg" v=""/>
		<p n="encoding-vri" v=""/>
		<p n="encoding-ps1" v=""/>
		<p n="encoding-svgz" v=""/>
		<p n="encoding-ds" v=""/>
		<p n="encoding-asp" v=""/>
		<p n="encoding-slk" v=""/>
		<p n="encoding-csh" v=""/>
		<p n="encoding-cfml" v=""/>
		<p n="encoding-qth" v=""/>
		<p n="encoding-ps" v=""/>
		<p n="encoding-patch" v=""/>
		<p n="encoding-js" v=""/>
		<p n="encoding-jpeg" v=""/>
		<p n="encoding-awk" v=""/>
		<p n="encoding-ocb" v=""/>
		<p n="encoding-cpp" v=""/>
		<p n="encoding-xmldoc" v=""/>
		<p n="encoding-tcl" v=""/>
		<p n="encoding-r" v=""/>
		<p n="encoding-bas" v=""/>
		<p n="encoding-ansisql" v=""/>
		<p n="encoding-projitems" v=""/>
		<p n="encoding-zip" v=""/>
		<p n="encoding-hxx" v=""/>
		<p n="encoding-lex" v=""/>
		<p n="encoding-vcxproj" v=""/>
		<p n="encoding-shader" v=""/>
		<p n="encoding-erl" v=""/>
		<p n="encoding-ads" v=""/>
		<p n="encoding-tsv" v=""/>
		<p n="encoding-wxi" v=""/>
		<p n="encoding-d" v=""/>
		<p n="encoding-xslt" v=""/>
		<p n="encoding-mm" v=""/>
		<p n="encoding-cc" v=""/>
		<p n="encoding-cics" v=""/>
		<p n="encoding-npasm" v=""/>
		<p n="encoding-cfc" v=""/>
		<p n="encoding-ini" v=""/>
		<p n="encoding-master" v=""/>
		<p n="encoding-yacc" v=""/>
		<p n="encoding-pli" v=""/>
		<p n="encoding-java" v=""/>
		<p n="encoding-seq" v=""/>
		<p n="encoding-lib" v=""/>
		<p n="encoding-vb" v=""/>
		<p n="encoding-html" v=""/>
		<p n="encoding-a" v=""/>
		<p n="encoding-di" v=""/>
		<p n="encoding-sh" v=""/>
		<p n="encoding-asm" v=""/>
		<p n="encoding-proto" v=""/>
		<p n="encoding-err" v=""/>
		<p n="encoding-csv" v=""/>
		<p n="encoding-asc" v=""/>
		<p n="encoding-log" v=""/>
		<p n="encoding-vr" v=""/>
		<p n="encoding-sv" v=""/>
		<p n="encoding-hpp" v=""/>
		<p n="encoding-gvy" v=""/>
		<p n="encoding-itk" v=""/>
		<p n="encoding-if" v=""/>
		<p n="encoding-sql" v=""/>
		<p n="encoding-so" v=""/>
		<p n="encoding-obj" v=""/>
		<p n="encoding-mod" v=""/>
		<p n="encoding-bib" v=""/>
		<p n="encoding-cp" v=""/>
		<p n="encoding-hh" v=""/>
		<p n="encoding-sybase" v=""/>
		<p n="encoding-jar" v=""/>
		<p n="encoding-lua" v=""/>
		<p n="encoding-css" v=""/>
		<p n="encoding-md" v=""/>
		<p n="encoding-y" v=""/>
		<p n="encoding-ninja" v=""/>
		<p n="encoding-kt" v=""/>
		<p n="encoding-scriptterminology" v=""/>
		<p n="encoding-wxl" v=""/>
		<p n="encoding-vbproj" v=""/>
		<p n="encoding-cpgz" v=""/>
		<p n="encoding-wxs" v=""/>
		<p n="encoding-ch" v=""/>
		<p n="encoding-avi" v=""/>
		<p n="encoding-bourneshell" v=""/>
		<p n="encoding-pl1" v=""/>
		<p n="encoding-cljs" v=""/>
		<p n="encoding-jsfl" v=""/>
		<p n="encoding-ico" v=""/>
		<p n="encoding-cgfx" v=""/>
		<p n="encoding-bmp" v=""/>
		<p n="encoding-vpt" v=""/>
		<p n="encoding-cg" v=""/>
		<p n="encoding-matlab" v=""/>
		<p n="encoding-vsdelta2" v=""/>
		<p n="encoding-vpw" v=""/>
		<p n="encoding-swift" v=""/>
		<p n="encoding-eventhandlers" v=""/>
		<p n="encoding-itcl" v=""/>
		<p n="encoding-cmd" v=""/>
		<p n="encoding-imakefile" v=""/>
		<p n="encoding-cmake" v=""/>
		<p n="encoding-gradle" v=""/>
		<p n="encoding-xslx" v=""/>
		<p n="encoding-pdb" v=""/>
		<p n="encoding-sl" v=""/>
		<p n="encoding-xsl" v=""/>
		<p n="encoding-vhd" v=""/>
		<p n="encoding-tlib" v=""/>
		<p n="encoding-hrl" v=""/>
		<p n="encoding-diff" v=""/>
		<p n="encoding-cljc" v=""/>
		<p n="encoding-e" v=""/>
		<p n="encoding-clj" v=""/>
		<p n="encoding-bash" v=""/>
		<p n="encoding-svg" v=""/>
		<p n="encoding-php" v=""/>
		<p n="encoding-scriptsuite" v=""/>
		<p n="encoding-tsx" v=""/>
		<p n="encoding-vpj" v=""/>
		<p n="encoding-war" v=""/>
		<p n="encoding-vbs" v=""/>
		<p n="encoding-tar" v=""/>
		<p n="encoding-jpg" v=""/>
		<p n="encoding-as" v=""/>
		<p n="encoding-s" v=""/>
		<p n="encoding-z" v=""/>
		<p n="encoding-diffpatch" v=""/>
		<p n="encoding-vrh" v=""/>
		<p n="encoding-sca" v=""/>
		<p n="encoding-xz" v=""/>
		<p n="encoding-v" v=""/>
		<p n="encoding-ts" v=""/>
		<p n="encoding-7z" v=""/>
		<p n="encoding-hs" v=""/>
		<p n="encoding-setemplate" v=""/>
		<p n="encoding-mathml" v=""/>
		<p n="encoding-jsp" v=""/>
		<p n="encoding-csproj" v=""/>
		<p n="encoding-sta" v=""/>
		<p n="encoding-idl" v=""/>
		<p n="encoding-4gl" v=""/>
		<p n="encoding-rar" v=""/>
		<p n="encoding-tif" v=""/>
		<p n="encoding-conf" v=""/>
		<p n="encoding-tgz" v=""/>
		<p n="encoding-jsl" v=""/>
		<p n="encoding-xsd" v=""/>
		<p n="encoding-vpe" v=""/>
		<p n="encoding-unixasm" v=""/>
		<p n="encoding-tcc" v=""/>
		<p n="encoding-cxx" v=""/>
		<p n="encoding-go" v=""/>
		<p n="encoding-kts" v=""/>
		<p n="encoding-o" v=""/>
		<p n="encoding-msi" v=""/>
		<p n="encoding-vbscript" v=""/>
		<p n="encoding-yml" v=""/>
		<p n="encoding-c++" v=""/>
		<p n="encoding-chm" v=""/>
		<p n="encoding-xlsx" v=""/>
		<p n="encoding-cls" v=""/>
		<p n="encoding-shtml" v=""/>
		<p n="encoding-svi" v=""/>
		<p n="encoding-resx" v=""/>
		<p n="encoding-gy" v=""/>
		<p n="encoding-bz2" v=""/>
		<p n="encoding-gif" v=""/>
		<p n="encoding-markdown" v=""/>
		<p n="encoding-cljx" v=""/>
		<p n="encoding-wmv" v=""/>
		<p n="encoding-ex" v=""/>
		<p n="encoding-rby" v=""/>
		<p n="encoding-jcl" v=""/>
		<p n="encoding-json" v=""/>
		<p n="encoding-cf" v=""/>
		<p n="encoding-f95" v=""/>
		<p n="encoding-sas" v=""/>
		<p n="encoding-chs" v=""/>
		<p n="encoding-model204" v=""/>
		<p n="encoding-1" v=""/>
		<p n="encoding-backup" v=""/>
		<p n="encoding-0" v=""/>
		<p n="encoding-bak2" v=""/>
		<p n="encoding-4" v=""/>
		<p n="encoding-orig" v=""/>
		<p n="encoding-2" v=""/>
		<p n="encoding-working" v=""/>
		<p n="encoding-bak" v=""/>
		<p n="encoding-copy" v=""/>
		<p n="encoding-bak3" v=""/>
		<p n="encoding-mine" v=""/>
		<p n="encoding-3" v=""/>
		<p n="encoding-bak1" v=""/>
		<p n="encoding-save" v=""/>
	</misc.file_extensions>
	<language n="language.*ALL_LANGUAGES*" version="1">
		<line_numbers_flags v="0x3"/>
		<indent_with_tabs v="1"/>
	</language>
	<language.ada.beautifier_profiles n="language.ada.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.ada.beautifier_profiles>
	<language.android.beautifier_profiles n="language.android.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.android.beautifier_profiles>
	<language.ant.beautifier_profiles n="language.ant.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.ant.beautifier_profiles>
	<language.as.beautifier_profiles n="language.as.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.as.beautifier_profiles>
	<language.bas.beautifier_profiles n="language.bas.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.bas.beautifier_profiles>
	<language.c.beautifier_profiles n="language.c.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.c.beautifier_profiles>
	<language.cfml.beautifier_profiles n="language.cfml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.cfml.beautifier_profiles>
	<language.cs.beautifier_profiles n="language.cs.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.cs.beautifier_profiles>
	<language.docbook.beautifier_profiles n="language.docbook.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.docbook.beautifier_profiles>
	<language.groovy.beautifier_profiles n="language.groovy.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.groovy.beautifier_profiles>
	<language.html.beautifier_profiles n="language.html.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.html.beautifier_profiles>
	<language.java.beautifier_profiles n="language.java.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.java.beautifier_profiles>
	<language.js.beautifier_profiles n="language.js.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.js.beautifier_profiles>
	<language.json.beautifier_profiles n="language.json.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.json.beautifier_profiles>
	<language.m.beautifier_profiles n="language.m.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.m.beautifier_profiles>
	<language n="language.ninja" version="1">
		<indent_with_tabs v="1"/>
	</language>
	<language.phpscript.beautifier_profiles n="language.phpscript.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.phpscript.beautifier_profiles>
	<language.scala.beautifier_profiles n="language.scala.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.scala.beautifier_profiles>
	<language.systemverilog.beautifier_profiles n="language.systemverilog.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.systemverilog.beautifier_profiles>
	<language.tld.beautifier_profiles n="language.tld.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.tld.beautifier_profiles>
	<language.vbs.beautifier_profiles n="language.vbs.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.vbs.beautifier_profiles>
	<language.verilog.beautifier_profiles n="language.verilog.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.verilog.beautifier_profiles>
	<language.vpj.beautifier_profiles n="language.vpj.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.vpj.beautifier_profiles>
	<language.xhtml.beautifier_profiles n="language.xhtml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xhtml.beautifier_profiles>
	<language.xml.beautifier_profiles n="language.xml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xml.beautifier_profiles>
	<language.xsd.beautifier_profiles n="language.xsd.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xsd.beautifier_profiles>
	<language n="language.clojure" version="1">
		<tabs v="+4"/>
	</language>
	<language n="language.protocolbuf" version="1">
		<tabs v="+4"/>
	</language>
	<language n="language.c" version="1">
		<smart_paste v="0"/>
	</language>
	<language.aliases n="language.c.aliases" version="1">
		<p n="xc_printf">
			<text>
				<![CDATA[#include <stdio.h>
#include <limits.h>     // Contains the macros CHAR_MIN, INT_MIN, etc.


  printf("Storage sizes and value ranges of the types char and int\n\n");

  printf("The type char is %s.\n\n", CHAR_MIN < 0 ? "signed" :"unsigned");

  printf(" Type   Size (in bytes)   Minimum         Maximum\n"
         "---------------------------------------------------\n");
  printf(" char %8zu %20d %15d\n", sizeof(char), CHAR_MIN, CHAR_MAX );
  printf(" int  %8zu %20d %15d\n", sizeof(int), INT_MIN, INT_MAX );

%\l]]>
			</text>
		</p>
		<p n="xc_printf2">
			<text>
				<![CDATA[#include <stdio.h>
#include <float.h>

printf("Storage size: %d bytes\n"
          "Smallest positive value: %E\n"
          "Greatest positive value: %E\n"
          "Precision: %d decimal digits\n",
          sizeof(float), FLT_MIN, FLT_MAX, FLT_DIG);

   puts("\nAn example of float precision:\n");
   double d_var = 12345.6;          // A variable of type double.
   float f_var = (float)d_var;      // Initializes the float
                                    // variable with the value of d_var.
   printf("The floating-point number    "
          "%18.10f\n", d_var);
   printf("has been stored in a variable\n"
          "of type float as the value   "
          "%18.10f\n", f_var);
   printf("The rounding error is        "
          "%18.10f\n", d_var - f_var);
%\l]]>
			</text>
		</p>
		<p n="xc_rand">
			<text>
				<![CDATA[#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int i,                              // Obtain some storage space.
       *pNumbers = malloc(ARR_LEN * sizeof(int));

   if ( pNumbers == NULL )
   {
      fprintf(stderr, "Insufficient memory.\n");
      exit(1);
   }

   srand( (unsigned)time(NULL) );      // Initialize the
                                       // random number generator.

   for ( i=0; i < ARR_LEN; ++i )
      pNumbers[i] = rand() % 10000;    // Store some random numbers.

   printf("\n%d random numbers between 0 and 9999:\n", ARR_LEN );
   for ( i=0; i < ARR_LEN; ++i )       // Output loop:
   {
     printf("%6d", pNumbers[i]);       // Print one number per loop %\S
     if ( i % 10 == 9 ) putchar('\n'); // iteration and a newline after
                                       // every 10 numbers.
   }
   free( pNumbers );                   // Release the storage space.
%\l]]>
			</text>
		</p>
		<p n="xc_qsort">
			<text>
				<![CDATA[#include <stdlib.h>
#define ARR_LEN 20
#include <stdio.h>
#include <time.h>

float *pNumbers = malloc( ARR_LEN * sizeof(float) );

   /* ... Handle errors, initialize array elements ... */
   if( pNumbers == NULL)
   {
       fprintf(stderr, "Insufficient memory.\n");
       exit(1);
   }
   srand( (unsigned)time(NULL));
   for( int i=0; i < ARR_LEN; ++i)              // random numbers
       pNumbers[i] = (rand() - RAND_MAX/2) * (100.0F /RAND_MAX);

   /* Sort the array: */
   qsort( pNumbers, ARR_LEN, sizeof(float), floatcmp );

   /* ... Work with the sorted array ... */
   for( int i=0; i < ARR_LEN; ++i)              // The sorted array
       printf("%8.2f", pNumbers[i]);]]>
			</text>
		</p>
		<p n="xc_mv_element">
			<text>
				<![CDATA[#include <stdio.h>


  double dArr[5] = { 0.0, 1.1, 2.2, 3.3, 4.4 },  // Initialize an array and
  *dPtr = dArr;                                  // a pointer to its first
                                                 // element.
  int i = 0;                         // An index variable.
  dPtr = dPtr + 1;                   // Advance dPtr to the second element.
  dPtr = 2 + dPtr;                   // Addends can be in either order.
                                     // dPtr now points to dArr[3].

  printf( "%.1f\n", *dPtr );         // Print the element referenced by dPtr.
  printf( "%.1f\n", *(dPtr -1) );    // Print the element before that, without
                                     // modifying the pointer dPtr.
  i = dPtr - dArr;                   // Result: the index of the
                                     // array element that dPtr points to.
  printf( "%.d\n", i );              // Print the index (3).

%\l]]>
			</text>
		</p>
		<p n="xc_setbit">
			<text>
				<![CDATA[#include <limits.h>

unsigned int setBit( unsigned int mask, unsigned int p )
{
   if ( p >= CHAR_BIT * sizeof(int) )
      return mask;
   else
      return mask | (1 << p);
}]]>
			</text>
		</p>
		<p n="xc_strcpy_">
			<text>char *strcpy_( char* restrict s1, const char* restrict s2 )
{
   int i = 0;
   do
      s1[i] = s2[i];           // The loop body: copy each character
   while ( s2[i++] != '\0' );  // End the loop if we just copied a '\0'.
   return s1;
}</text>
		</p>
		<p n="xc_menu">
			<text>int menu( void )               // Prints the menu and returns
{                              // a character that the user types.
   static char menuStr[] =
   "\n               A = Action 1"
   "\n               B = Action 2"
   "\n               Q = Quit the program"
   "\n Your choice:  ";

   fputs( menuStr,stdout);

   int choice = 0;
   do %\S
     if( (choice = getchar()) == EOF)
         choice = 'Q'; %\S
   while( isspace(choice) );

   return choice;
}</text>
		</p>
		<p n="xc_bubblesort">
			<text>
				<![CDATA[void bubbleSort( float arr[], int len )   // The array arr and
{                                         // its length len.
   int isSorted = 0;
   do
   {
      float temp;             // Holder for values being swapped.
      isSorted = 1;
      --len;
      for ( int i = 0; i < len; ++i )
        if ( arr[i] > arr[i+1] )
        {
           isSorted = 0;      // Not finished yet.
           temp = arr[i];     // Swap adjacent values.
           arr[i] = arr[i+1];
           arr[i+1] = temp;
        }
   } while ( !isSorted );
}]]>
			</text>
		</p>
		<p n="xc_str_reverse">
			<text>
				<![CDATA[#include <string.h>

void strReverse( char* str)
{
   char ch;
   for ( size_t i = 0, j = strlen(str)-1; i < j; ++i, --j )
       ch = str[i], str[i] = str[j], str[j] = ch;
}]]>
			</text>
		</p>
		<p n="xc_selectionsort">
			<text>
				<![CDATA[// With gcc use the option -O  
// GCC does not inline any functions when not optimizing

// The function swapf() exchanges the values of two float variables.
// Arguments:    Two pointers to float.
// Return value: None.

inline void swapf( float *p1, float *p2 )      // An inline function.
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;
}

// The function selection_sortf() uses the selection-sort
// algorithm to sort an array of float elements.
// Arguments:    An array of float, and its length.
// Return value: None.

void selection_sortf( float a[], int n )   // Sort an array a of length n.
{
   register int i, j, mini;                // Three index variables.
   for ( i = 0; i < n - 1; ++i )
   {
      mini = i;             // Search for the minimum starting at index i.
      for ( j = i+1; j < n; ++j )
         if ( a[j] < a[mini] )
           mini = j;
      swapf( a+i, a+mini); // Swap the minimum with the element at index i.
   }
}]]>
			</text>
		</p>
		<p n="xc_factorial">
			<text>
				<![CDATA[// factorial() calculates n!, the factorial of a non-negative number n.
// For n > 0, n! is the product of all integers from 1 to n inclusive.
// 0! equals 1.
// Argument: A whole number, with type unsigned int.
// Return value: The factorial of the argument, with type long double.

long double factorial( register unsigned int n )
{
   long double f = 1;
   while ( n > 1 )
     f *= n--;
   return f;
}
%\l]]>
			</text>
		</p>
		<p n="xc_max">
			<text>
				<![CDATA[// The function maximum() obtains the greatest value in a
// two-dimensional matrix of double values.
// Arguments:    The number of rows, the number of columns, and the matrix.
// Return value: The value of the greatest element.

double maximum( int nrows, int ncols, double matrix[nrows][ncols] )
{
   double max = matrix[0][0];
   for ( int r = 0; r < nrows; ++r )
      for ( int c = 0; c < ncols; ++c )
         if ( max < matrix[r][c] )
            max = matrix[r][c];
   return max;
}]]>
			</text>
		</p>
		<p n="xc_swapf">
			<text>// With gcc use the option -O  
// GCC does not inline any functions when not optimizing

// The function swapf() exchanges the values of two float variables.
// Arguments:    Two pointers to float.
// Return value: None.

inline void swapf( float *p1, float *p2 )      // An inline function.
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;
}</text>
		</p>
		<p n="xc_binarysearch">
			<text>
				<![CDATA[// The binarySearch() function searches a sorted array.
// Arguments:    The value of the element to find;
//               the array of long to search; the array length.
// Return value: A pointer to the element found,
//               or NULL if the element is not present in the array.

long *binarySearch( long val, long array[ ], int n )
{
   int m = n/2;
   if ( n <= 0 )          return NULL;
   if ( val == array[m] ) return array + m;
   if ( val < array[m] )  return binarySearch( val, array, m );
   else                   return binarySearch( val, array+m+1, n-m-1 );
}

int main()
{
  long lArr[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
  int len = sizeof(lArr)/sizeof(*lArr);

  for ( int i = 0; i < len; ++i )
     printf("%6ld", lArr[i]);
  putchar('\n');

  long value = 0;
  printf( "\nEnter a whole number: ");
  scanf( "%ld", &value );

  long *ptr = binarySearch( value, lArr, len);

  if( ptr == NULL)
    printf("%ld is not an element of the array.\n", value);
  else
  { %\S
    int n = ptr+1 - lArr;
    printf("%ld is the %dth element in the arry.\n", value, n );
  }
  return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_strcat_">
			<text>char *strcat_( char * restrict s1, const char * restrict s2 )
{
   char *rtnPtr = s1;
   while ( *s1 != '\0' )               // Find the end of string s1.
      ++s1;
   while (( *s1++ = *s2++ ) != '\0' )  // The first character from s2
     ;                                 // replaces the terminator of s1.
   return rtnPtr;
}</text>
		</p>
		<p n="xc_printMatrix">
			<text>
				<![CDATA[#define NCOLS 10                    // The number of columns.
typedef float ROW_t[NCOLS];         // A type for the "row"

// Print one "row" array.
void printRow( const ROW_t pRow )
{
   for( int c = 0; c < NCOLS; ++c )
      printf( "%6.2f", pRow[c] );
   putchar( '\n' );
}

// Print the whole matrix.
void printMatrix( ROW_t *pMat, int nRows )
{
   for( int r = 0; r < nRows; ++r )
      printRow( pMat[r] );           // Print each row.
}]]>
			</text>
		</p>
		<p n="xc_selection_sort_ptr">
			<text>
				<![CDATA[inline void swapf( float *p1, float *p2 )
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;      // Swap *p1 and *p2.
}

// The function selection_sortf() uses the selection-sort
// algorithm to sort an array of float elements.
// Arguments: An array of float, and its length.

void selection_sortf( float a[], int n )       // Sort an array a of
{                                              // n float elements.
   if ( n <= 1 ) return;               // Nothing to sort.

   register float *last = a + n-1,     // A pointer to the last element.
                  *p,                  // A pointer to a selected element.
                  *minPtr;             // A pointer to the current minimum.

   for ( ; a < last; ++a )             // Walk pointer a through the array.
   {
      minPtr = a;                      // Find the smallest element
      for ( p = a+1; p <= last; ++p )  // between a and the last element.
         if ( *p < *minPtr )
           minPtr = p;
      swapf( a, minPtr );              // Swap the smallest element
   }                                   // with the element at a.
}]]>
			</text>
		</p>
		<p n="xc_sorttext">
			<text>
				<![CDATA[// Example 9-4. A simple program to sort lines of text
// sorttext.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *getLine(void);                // Reads a line of text
int str_compare(const void *, const void *);

#define NLINES_MAX 1000             // Maximum number of text lines.
char *linePtr[NLINES_MAX];          // Array of pointers to char.

int main()
{
   // Read lines:
   int n = 0;                       // Number of lines read.
   for ( ; n < NLINES_MAX && (linePtr[n] = getLine()) != NULL; ++n )
     ;

   if ( !feof(stdin) )              // Handle errors.
   {
      if ( n == NLINES_MAX )
         fputs( "sorttext: too many lines.\n", stderr );
      else
         fputs( "sorttext: error reading from stdin.\n", stderr );
   }
   else                             // Sort and print.
   {
      qsort( linePtr, n, sizeof(char*), str_compare );   // Sort.
      for ( char **p = linePtr; p < linePtr+n; ++p )     // Print.
         puts(*p);
   }
   return 0;
}

// Reads a line of text from stdin; drops the terminating
// newline character.
// Return value: A pointer to the string read, or
//               NULL at end-of-file, or if an error occurred.

#define LEN_MAX 512                 // Maximum length of a line.

char *getLine()
{
   char buffer[LEN_MAX], *linePtr = NULL;

   if ( fgets( buffer, LEN_MAX, stdin ) != NULL )
   {
      size_t len = strlen( buffer );

      if ( buffer[len-1] == '\n' )   // Trim the newline character.
         buffer[len-1] = '\0';
      else
         ++len;

      if ( (linePtr = malloc( len )) != NULL )   // Get memory for the line.
         strcpy( linePtr, buffer );  // Copy the line to the allocated block.
   }
   return linePtr;
}

// Comparison function for use by qsort().
// Arguments: Pointers to two elements in the array being sorted:
//            here, two pointers to pointers to char (char **).

int str_compare( const void *p1, const void *p2 )
{
   return strcmp( *(char **)p1, *(char **)p2 );
}
%\l]]>
			</text>
		</p>
		<p n="xc_func_ptr">
			<text>double Add( double x, double y ) { return x + y; }
double Sub( double x, double y ) { return x - y; }
double Mul( double x, double y ) { return x * y; }
double Div( double x, double y ) { return x / y; }

// Array of 5 pointers to functions that take two double parameters
// and return a double:

// double (*funcTable[5])(double, double)
//          = { Add, Sub, Mul, Div, pow };       // Initializer list.

typedef double func_t( double, double );    // The functions' type is
                                            // now named func_t.
func_t *funcTable[5] = { Add, Sub, Mul, Div, pow };

// An array of pointers to strings for output:
char *msgTable[5] = {"Sum", "Difference", "Product", "Quotient", "Power"};</text>
		</p>
		<p n="xc_BSTree_c">
			<text>
				<![CDATA[// A binary search tree (BST)
// BSTree.c

#include <string.h>          // memcpy()
#include <stdlib.h>          // malloc(), free()
#include "BSTree.h"

typedef struct Node { struct Node *left,    // Pointers to the left and
                                  *right;   // right child nodes.
                      size_t size;          // Size of the data payload.
                      char data[];          // The data itself.
                    } Node_t;

const void *defaultGetKey( const void *pData) { return pData; }

// -----------------------------------------------------------------------------
// The function newBST() creates a new binary search tree. The pointer to BST_t
// returned by newBST() is the first argument to all the other binary-tree functions.

BST_t *newBST( CmpFunc_t *cmp, GetKeyFunc_t *getKey)
{
   BST_t *pBST = NULL;
   if( cmp != NULL )
       pBST = malloc( sizeof( BST_t));
   if( pBST != NULL)
   {
       pBST->pRoot = NULL;
       pBST->cmp = cmp;
       pBST->getKey = (getKey != NULL) ? getKey : defaultGetKey;
   }
   return pBST;
}

// -----------------------------------------------------------------------------
// The function BST_insert() copies a data item to a new leaf node in the tree.
// The function inserts the new leaf at a position that is consistent with the
// binary treeî–¸ sorting condition.
// BST_insert() returns true if it succeeds in inserting the new data; %\S
// otherwise, false.

static _Bool insert( BST_t *pBST, Node_t **ppNode, const void *pData, size_t size);

_Bool BST_insert( BST_t *pBST, const void *pData, size_t size)
{
    if( pBST == NULL || pData == NULL || size == 0)
       return false;
    return insert( pBST, &(pBST->pRoot), pData, size);
}

// The recursive helper function insert():
static _Bool insert( BST_t *pBST, Node_t **ppNode, const void *pData, size_t size )
{
   Node_t *pNode = *ppNode;                 // Pointer to the root node of the
                                            // subtree to insert the new node in.
   if ( pNode == NULL )
   {                                        // There's a place for a new leaf here.
     pNode = malloc( sizeof(Node_t) + size );
     if ( pNode != NULL )
     {
       pNode->left = pNode->right = NULL;   // Initialize the new node's
                                            // members.
       memcpy( pNode->data, pData, size );
       *ppNode = pNode;                     // Insert the new node.
       return true;
     }
     else
       return false;
   }
   else                                     // Continue looking for a place ...
   {
     const void *key1 = pBST->getKey( pData ),
                *key2 = pBST->getKey( pNode->data );
     if ( pBST->cmp( key1, key2 ) < 0 )     // ... in the left subtree,
       return insert( pBST, &(pNode->left), pData, size );
     else                                   // or in the right subtree.
       return insert( pBST, &(pNode->right), pData, size );
   }
}

// -------------------------------------------------------------------------------
// The function BST_search() uses the binary search algorithm to find a data item
// that matches a given key. The return value is a pointer to the data item
// of the first node that matches the key, or a null pointer if no match was found.

static const void *search( BST_t *pBST, const Node_t *pNode, const void *pKey);

const void *BST_search( BST_t *pBST, const void *pKey )
{
    if( pBST == NULL || pKey == NULL ) %\S
      return NULL;
    return search( pBST, pBST->pRoot, pKey);    // Start at the root of the tree.
}

// The recursive helper function search():
static const void *search( BST_t *pBST, const Node_t *pNode, const void *pKey )
{
    if ( pNode == NULL )
      return NULL;                                    // No subtree to search;
                                                      // no match found.
    else
    {                                                 // Compare data:
       int cmp_res = pBST->cmp( pKey, pBST->getKey(pNode->data) );
       if( cmp_res == 0 )                             // Found a match.
          return pNode->data;
       else if( cmp_res < 0 )                         // Continue the search
          return search( pBST, pNode->left, pKey );   // in the left subtree,
       else
          return search( pBST, pNode->right, pKey );  // or in the right subtree.
    }
}

// -------------------------------------------------------------------------------
// The BST_erase() function searches for a node that matches the specified key, and
// deletes it if found. The function returns false if it fails to find a matching %\S
// node to delete, or true if successful.

// The removal algorithm uses the recursive helper function detachMin() that plucks
// the minimum node from a specified subtree, and returns a pointer to the node:

static Node_t *detachMin( Node_t **ppNode )
{
    Node_t *pNode = *ppNode;                  // A pointer to the current node.
    if ( pNode == NULL )
      return NULL;                            // pNode is an empty subtree.
    else if ( pNode->left != NULL )
      return detachMin( &(pNode->left) );     // The minimum is in the left subtree.
    else
    {                                         // pNode points to the minimum node.
      *ppNode = pNode->right;                 // Attach the right child to the parent.
      return pNode;
    }
}

static _Bool erase(BST_t *pBST, Node_t **ppNode, const void *pKey);

_Bool BST_erase(BST_t *pBST, const void *pKey)
{
    if( pBST == NULL || pKey == NULL) %\S
      return false;
    return erase( pBST, &(pBST->pRoot), pKey);      // Start at the root of the tree.
}

// The recursive helper function erase():
static _Bool erase( BST_t *pBST, Node_t **ppNode, const void *pKey )
{
   Node_t *pNode = *ppNode;            // Pointer to the current node.
   if ( pNode == NULL )
      return false;                    // No match found.
                                       // Compare data:
   int cmp_res = pBST->cmp( pKey, pBST->getKey(pNode->data) );

   if ( cmp_res < 0 )                            // Continue the search
     return erase( pBST, &(pNode->left), pKey);  // in the left subtree,
   else if ( cmp_res > 0 )
     return erase( pBST, &(pNode->right), pKey); // or in the right subtree.
   else
   {                                   // Found the node to be deleted.
     if ( pNode->left == NULL )        // If no more than one child,
       *ppNode = pNode->right;         // attach the child to the parent.
     else if ( pNode->right == NULL )
       *ppNode = pNode->left;
     else                              // Two children: replace the node with
     {                                 // the minimum from the right subtree.
       Node_t *pMin = detachMin( &(pNode->right) );
       *ppNode = pMin;            // Graft it onto the deleted node's parent.
       pMin->left = pNode->left;       // Graft the deleted node's children.
       pMin->right = pNode->right;
     }
     free( pNode );                    // Release the deleted node's storage.
     return true;
   }
}

// -------------------------------------------------------------------------------
// The BST_clear() function deletes all the nodes of a tree.

static void clear( Node_t *pNode );
void BST_clear( BST_t *pBST )
{
    if ( pBST != NULL)
    {
       clear( pBST->pRoot );
       pBST->pRoot = NULL;
    }
}

// The recursive helper function clear():
static void clear( Node_t *pNode )
{
    if ( pNode != NULL )
    {
       clear( pNode->left );
       clear( pNode->right );
       free( pNode );
    }
}

// -------------------------------------------------------------------------------
// Each of the following traversal functions takes as its second argument a pointer
// to an î™ƒction?function that it calls for each node visited. %\S
// The return value is the number of times the action was performed successfully.

static int inorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_inorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return inorder( pBST->pRoot, action);
}

// The recursive helper function inorder():
static int inorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = inorder( pNode->left, action );        // L: Traverse the left
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.
    count += inorder( pNode->right, action );      // R: Traverse the right
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int rev_inorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_rev_inorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return rev_inorder( pBST->pRoot, action);
}

// The recursive helper function rev_inorder():
static int rev_inorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = rev_inorder( pNode->right, action );   // R: Traverse the right
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.
    count += rev_inorder( pNode->left, action );   // L: Traverse the left
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int preorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_preorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return preorder( pBST->pRoot, action);
}

// The recursive helper function preorder():
static int preorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    if ( action( pNode->data ))                    // N: The current node.
      ++count;
    count += preorder( pNode->left, action );      // L: Traverse the left
                                                   // subtree.
    count += preorder( pNode->right, action );     // R: Traverse the right
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int postorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_postorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return postorder( pBST->pRoot, action);
}

// The recursive helper function postorder():
static int postorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = postorder( pNode->left, action );      // L: Traverse the left
                                                   // subtree.
    count += postorder( pNode->right, action );    // R: Traverse the right
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.

    return count;
}
%\l]]>
			</text>
		</p>
		<p n="xc_BSTree_h">
			<text>
				<![CDATA[// A binary search tree (BST)
// BSTree.h

#include <stdbool.h>

typedef int CmpFunc_t( const void *pKey1, const void *pKey2);
typedef const void *GetKeyFunc_t( const void *pData);

typedef struct { struct Node  *pRoot;       // Pointer to the root.
                 CmpFunc_t    *cmp;         // Compares two keys.
                 GetKeyFunc_t *getKey;      // Converts data into a key value
               } BST_t;

BST_t *     newBST( CmpFunc_t *cmp, GetKeyFunc_t *getKey);
_Bool       BST_insert( BST_t *pBST, const void *pData, size_t size);
const void *BST_search( BST_t *pBST, const void *pKey);
_Bool       BST_erase( BST_t *pBST, const void *pKey);
void        BST_clear( BST_t *pBST);

// Each of the folowing functions traverses the tree in a certain order, and %\S
// calls the function referenced by action for each node. If the action modifies %\S
// the node's data, then at least the key value must remain unchanged to preserve %\S
// the tree's sorting order.
int BST_inorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_rev_inorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_preorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_postorder( BST_t *pBST, _Bool (*action)(void *pData));
%\l]]>
			</text>
		</p>
		<p n="xc_sortline">
			<text>
				<![CDATA[// Example 12-3. The sortlines program
// sortlines.c

// This program reads each line of text into a node of a binary tree,
// and then prints the text in sorted order.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "BSTree.h"               // Prototypes of the BST functions.

#define LEN_MAX 1000              // Maximum length of a line.
char buffer[LEN_MAX];

// Action to perform for each line:
_Bool printStr( void *str ) { return printf( "%s", str ) >= 0; }

int main()
{
    BST_t *pStrTree = newBST( (CmpFunc_t*)strcmp, NULL );
    int n;

    while ( fgets( buffer, LEN_MAX, stdin ) != NULL )   // Read each line.
    {
       size_t len = strlen( buffer );                   // Length incl.
                                                        // newline character.
       if ( !BST_insert( pStrTree, buffer, len+1 ))     // Insert the line in
          break;                                        // the tree.
    }
    if ( !feof(stdin) )
    {                                     // If unable to read the entire text:
       fprintf( stderr, "sortlines: "
                "Error reading or storing text input.\n" );
       exit( EXIT_FAILURE );
    }

    n = BST_inorder( pStrTree, printStr );     // Print each line, in sorted order.

    fprintf( stderr, "\nsortlines: Printed %d lines.\n", n );

    BST_clear( pStrTree );                     // Discard all nodes.
    return 0;
}]]>
			</text>
		</p>
		<p n="xc_getline">
			<text>
				<![CDATA[// Read a line of text from stdin into a dynamically allocated buffer.
// Replace the newline character with a string terminator.
// Arguments:    The maximum line length to read.
// Return value: A pointer to the string read, or
//               NULL if end-of-file was read or if an error occurred.

char *getLine( unsigned int len_max )
{
   char *linePtr = malloc( len_max+1 );  // Reserve storage for "worst case."
   if ( linePtr != NULL )
   {
     // Read a line of text and replace the newline characters with
     // a string terminator:
     int c = EOF;
     unsigned int i = 0;
     while ( i < len_max && ( c = getchar() ) != '\n' && c != EOF )
       linePtr[i++] = (char)c;
     linePtr[i] = '\0';

     if ( c == EOF && i == 0 )          // If end-of-file before any
     {                                  // characters were read,
        free( linePtr );                // release the whole buffer.
        linePtr = NULL;
     }
     else                               // Otherwise, release the unused portion.
        linePtr = realloc( linePtr, i+1 );           // i is the string length.
   }
   return linePtr;
}]]>
			</text>
		</p>
		<p n="xc_createDataFile">
			<text>
				<![CDATA[#include <stdio.h>
#include "record.h"

char dataFile[ ] = "records.dat";                  // Filename.

int main()// Creates a file records.dat (inFile) with some test data.
{
    FILE *fp;
    Record_t records[] = { { 1789L, "George" },
                           { 1797L, "John" }, %\S
                           {    0L, "Harry" },
                           { 1801L, "Thomas"},
                           { 1809L, "James"},
                           { 1825L, "Quincy" }
                         };
    size_t n = sizeof(records) / sizeof(*records); %\S
 %\S
    if( (fp = fopen( dataFile, "wb")) == NULL)
    {
        fprintf( stderr, "Error on opening output file \"%s\".\n", dataFile);
        return 1;
    }
    if( fwrite( records, sizeof(Record_t), n, fp) < n)
    {
        fprintf( stderr, "Error on writing to output file \"%s\".\n", dataFile);
        return 1;
    }
    printf( "%d records written.\n", n);
    return 0;
}]]>
			</text>
		</p>
		<p n="xc_isReadWriteable">
			<text>_Bool isReadWriteable( const char *filename )
{
    FILE *fp = fopen( filename, "r+" );    // Open a file to read and write.

    if ( fp != NULL )                      // Did fopen() succeed?
    {
        fclose(fp);                        // Yes: close the file; no error handling.
        return true;
    }
    else                                   // No.
        return false;
}</text>
		</p>
		<p n="xc_searchFile">
			<text>int searchFile( FILE *fpIn, const char *keyword )
{
   #define MAX_LINE 256
   char line[MAX_LINE] = "";
   int count = 0;

   if ( fpIn == NULL || keyword == NULL )
      return -1;
   else
      rewind( fpIn );

   while ( fgets( line, MAX_LINE, fpIn ) != NULL )
      if ( strstr( line, keyword ) != NULL )
      {
         ++count;
         fputs( line, stdout );
      }

   if ( !feof( fpIn ) )
      return -1;
   else
      return count;
}</text>
		</p>
		<p n="xc_searchNewName">
			<text>
				<![CDATA[// setNewName.c : 
// The following example uses an index table to store the positions of records in the
// file. This approach permits direct access to a record that needs to be updated.

// setNewName(): Finds a keyword in an index table
// and updates the corresponding record in the file.
// The file containing the records must be opened in
// "update mode"; i.e., with the mode string "r+b".
// Arguments: - A FILE pointer to the open data file;
//            - The key;
//            - The new name.
// Return value: A pointer to the updated record,
//               or NULL if no such record was found.
// ---------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include "record.h"   // Defines the types Record_t, IndexEntry_t:
                      // typedef struct { long key; char name[32];
                      //                  /* ... */ } Record_t;
                      // typedef struct { long key, pos; } IndexEntry_t;

extern IndexEntry_t indexTab[];         // The index table.
extern int indexLen;                    // The number of table entries.

Record_t *setNewName( FILE *fp, long key, const char *newname )
{
   static Record_t record;
   int i;

   for ( i = 0; i < indexLen; ++i )
   {
      if ( key == indexTab[i].key )
         break;                             // Found the specified key.
   }
   if ( i == indexLen )
      return NULL;                          // No match found.

   // Set the file position to the record:
   if (fseek( fp, indexTab[i].pos, SEEK_SET ) != 0 )
      return NULL;                          // Positioning failed.

   // Read the record:
   if ( fread( &record, sizeof(Record_t), 1, fp ) != 1 )
      return NULL; // Error on reading.
   if ( key != record.key )                 // Test the key.
      return NULL;
   else
   {                                        // Update the record:
      size_t size = sizeof(record.name);
      strncpy( record.name, newname, size-1 );
      record.name[size-1] = '\0';

      if ( fseek( fp, indexTab[i].pos, SEEK_SET ) != 0 )
         return NULL;                       // Error setting file position.
      if ( fwrite( &record, sizeof(Record_t), 1, fp ) != 1 )
         return NULL;                       // Error writing to file.

      return &record;
   }
}
%\l]]>
			</text>
		</p>
		<p n="xc_searNewNAme_call">
			<text>
				<![CDATA[// setNewName_call.c : 
// The main function creates an index table for the file records.dat
// and calls the setNewName() function.

#include <stdio.h>
#include <string.h>
#include "record.h"   // Defines the types Record_t, IndexEntry_t:
                      // typedef struct { long key; char name[32];
                      //                  /* ... */ } Record_t;
                      // typedef struct { long key, pos; } IndexEntry_t;

#define TAB_LEN 100
IndexEntry_t indexTab[TAB_LEN];         // The index table.
int indexLen = 0;                       // The number of table entries.

char dataFile[] = "records.dat";

int main()
{
    FILE *fpData = NULL;
    Record_t record;
    int i;

    if( (fpData = fopen( dataFile, "r+b")) == NULL)
    {
        fprintf( stderr, "Error on opening the file \"%s\".\n", dataFile);
        return 1;
    }
    for( i = 0; i < TAB_LEN; ++i)
    {
        indexTab[i].pos = ftell(fpData);          // current file position.
        if( fread( &record, sizeof(Record_t), 1, fpData) < 1)
            break;
        indexTab[i].key = record.key;
//        printf("%4ld : %ld\n", indexTab[i].key, indexTab[i].pos);
    }
    if( !feof( fpData))
    {
        fprintf( stderr, "Error on reading the file \"%s\".\n", dataFile);
        return 2;
    }
    indexLen = i;

    if( setNewName( fpData, 1825L, "John Quincy") == NULL)
       fprintf( stderr, "Error on updating the file \"%s\".\n", dataFile);

    // List the records:
    rewind( fpData);
    while( fread( &record, sizeof(Record_t), 1, fpData) == 1) %\S
    {
       printf("%8ld : %s\n", record.key, record.name);
    }

    fclose( fpData);
    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_cputime_dif">
			<text>
				<![CDATA[#include <time.h>
clock_t t1 = clock();
clock_t t2 = clock();]]>
			</text>
		</p>
		<p n="xc_parallel_sum">
			<text>
				<![CDATA[// Example 14-1. Calculating the sum of array elements in several parallel threads
// parallelSum.c
// ----------------------------------------------------------------------------
#include <stdbool.h>
#include <threads.h>

#define MAX_THREADS 8             // 1, 2, 4, 8 ... Maximum number
                                  // of threads to create.
#define MIN_BLOCK_SIZE 100        // Minimum size of an array block.

typedef struct                    // Arguments for the parallel_sum() function.
{
    float *start;                 // Start and length of the
    int len;                      // array block passed to parallel_sum().
    int block_size;               // Size of the smallest blocks.
    double sum;                   // The result.
} Sum_arg;

int parallel_sum(void *arg);      // Prototype of the thread function.

// ---------------------------------------------------------------
// Calculate the sum of array elements and write it to *sumPtr.
// sum() calls the function parallel_sum() for parallel processing.
// Return value: true if no error occurs, otherwise false.

bool sum(float arr[], int len, double* sumPtr)
{
    int block_size = len / MAX_THREADS;
    if (block_size < MIN_BLOCK_SIZE) block_size = len;

    Sum_arg args = { arr, len, block_size, 0.0 };
    if (parallel_sum(&args))
    { %\S
        *sumPtr = args.sum; %\S
        return true;
    }
    else
        return false;
}

// ---------------------------------------------------------------
// Recursive helper function to divide the work among several threads.

int parallel_sum(void *arg)
{
    Sum_arg *argp = (Sum_arg*)arg;       // A pointer to the arguments.
    if (argp->len <= argp->block_size)   // If length <= block_size,
    {                                    // add up the elements.
        for (int i = 0; i < argp->len; ++i)
        argp->sum += argp->start[i];
        return 1;
    }
    else                                  // If length > block_size,
    {                                     // divide the array.
        int mid = argp->len / 2;
        Sum_arg arg2 = { argp->start+mid, argp->len-mid,
                         argp->block_size, 0};   // Specifies 2nd half
        argp->len = mid;                         // Length of first half

        thrd_t th;                     // Process 1st half in a new thread.
        int res = 0;

        if (thrd_create(&th, parallel_sum, arg) != thrd_success)
            return 0;                  // Couldn't spawn a thread

        if (!parallel_sum(&arg2))      // Process 2nd half by recursion
                                       // in the current thread.
        {
            thrd_detach(th); return 0; // Recursive call failed
        }
        thrd_join(th, &res);
        if (!res)
            return 0;                  // Sibling thread reported failure

        argp->sum += arg2.sum;
        return 1;
    }
}
%\l]]>
			</text>
		</p>
		<p n="xc_thread">
			<text>
				<![CDATA[// Example 14-2. Concurrent memory access without synchronization
// inc_dec.c

#include <stdio.h>
#include <threads.h>
//#include <stdatomic.h>

#define COUNT 10000000L

long counter = 0;
//_Atomic long counter = ATOMIC_VAR_INIT(0L);

void incFunc(void) { for (long i = 0; i < COUNT; ++i) ++counter; }
void decFunc(void) { for (long i = 0; i < COUNT; ++i) --counter; }

int main(void)
{
    clock_t cl = clock();
    thrd_t th1, th2;

    if( thrd_create(&th1, (thrd_start_t)incFunc, NULL) != thrd_success
        || thrd_create(&th2, (thrd_start_t)decFunc, NULL) != thrd_success)
    {
        fprintf(stderr,"Error creating thread\n"); return -1;
    }
    thrd_join(th1, NULL);
    thrd_join(th2, NULL);

    printf("Counter: %ld \t", counter);
    printf("CPU time: %ld ms\n", (clock()-cl)*1000L/CLOCKS_PER_SEC);

    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_mutex">
			<text>
				<![CDATA[// Example 14-3. Adding a mutex to the program in Example 14-2

#include <stdio.h>
#include <threads.h>

#define COUNT 10000000L

long counter = 0;
mtx_t mtx;                        // A mutex for access to counter

void incFunc(void)
{
    for (long i = 0; i < COUNT; ++i)
    { mtx_lock(&mtx); ++counter; mtx_unlock(&mtx); }
}
void decFunc(void)
{
    for (long i = 0; i < COUNT; ++i)
    { mtx_lock(&mtx); --counter; mtx_unlock(&mtx); }
}

int main(void)
{
    if (mtx_init(&mtx, mtx_plain) != thrd_success)
    {
        fprintf(stderr, "Error initializing the mutex.\n");
        return -1;
    }

    // As in Example 14-2: %\S
    // start threads, wait for them to finish, print output:
    clock_t cl = clock();
    thrd_t th1, th2;

    if( thrd_create(&th1, (thrd_start_t)incFunc, NULL) != thrd_success
        || thrd_create(&th2, (thrd_start_t)decFunc, NULL) != thrd_success)
    {
        fprintf(stderr,"Error creating thread\n"); return -1;
    }
    thrd_join(th1, NULL);
    thrd_join(th2, NULL);

    printf("Counter: %ld \t", counter);
    printf("CPU time: %ld ms\n", (clock()-cl)*1000L/CLOCKS_PER_SEC);

    mtx_destroy(&mtx);
    return 0;
}

%\l]]>
			</text>
		</p>
		<p n="xc_ring_buffer_c">
			<text>
				<![CDATA[// Example 14-4. A ring buffer for the producer-consumer model

/* -------------------------------------------------------------
 * buffer.c
 * Definitions of functions operating on Buffer.
 */

#include "buffer.h"
#include <stdlib.h>           // For malloc() and free()

bool bufInit( Buffer *bufPtr, size_t size)
{
    if ((bufPtr->data = malloc( size * sizeof(int))) == NULL)
       return false;
    bufPtr->size = size;
    bufPtr->count = 0;
    bufPtr->tip = bufPtr->tail = 0;
    return    mtx_init( &bufPtr->mtx, mtx_plain) == thrd_success
           && cnd_init( &bufPtr->cndPut) == thrd_success
           && cnd_init( &bufPtr->cndGet) == thrd_success;
}

void bufDestroy(Buffer *bufPtr)
{
    cnd_destroy( &bufPtr->cndGet );
    cnd_destroy( &bufPtr->cndPut );
    mtx_destroy( &bufPtr->mtx );
    free( bufPtr->data );
}

// Insert a new element in the buffer:
bool bufPut(Buffer *bufPtr, int data)
{
    mtx_lock( &bufPtr->mtx );

    while (bufPtr->count == bufPtr->size)
       if (cnd_wait( &bufPtr->cndPut, &bufPtr->mtx ) != thrd_success)
          return false;

    bufPtr->data[bufPtr->tip] = data;
    bufPtr->tip = (bufPtr->tip + 1) % bufPtr->size;
    ++bufPtr->count;

    mtx_unlock( &bufPtr->mtx );
    cnd_signal( &bufPtr->cndGet );

    return true;
}

// Remove an element from the buffer. If the buffer is empty,
// wait no more than sec seconds.
bool bufGet(Buffer *bufPtr, int *dataPtr, int sec)
{
    struct timespec ts;
    timespec_get( &ts, TIME_UTC );     // The current time
    ts.tv_sec += sec;                  // + sec seconds delay.

    mtx_lock( &bufPtr->mtx );

    while ( bufPtr->count == 0 )
       if (cnd_timedwait(&bufPtr->cndGet,
                         &bufPtr->mtx, &ts) != thrd_success)
           return false;

    *dataPtr = bufPtr->data[bufPtr->tail];
    bufPtr->tail = (bufPtr->tail + 1) % bufPtr->size;
    --bufPtr->count;

    mtx_unlock( &bufPtr->mtx );
    cnd_signal( &bufPtr->cndPut );

    return true;
}

%\l]]>
			</text>
		</p>
		<p n="xc_ring_buffer_h">
			<text>
				<![CDATA[#include <stdbool.h>
#include <threads.h>

typedef struct Buffer
{
    int *data;              // Pointer to the array of data.
    size_t size, count;     // Maximum and current numbers of elements.
    size_t tip, tail;       // tip = index of the next free spot.
    mtx_t mtx;              // A mutex and
    cnd_t cndPut, cndGet;   // two condition variables.
} Buffer;

bool bufInit( Buffer *bufPtr, size_t size );
void bufDestroy(Buffer *bufPtr);

bool bufPut(Buffer *bufPtr, int data);
bool bufGet(Buffer *bufPtr, int *dataPtr, int sec);]]>
			</text>
		</p>
		<p n="xc_abort_ex">
			<text>void abort_ex()
{   %\S
   /* ... */
   struct record *new = (struct record *)malloc( sizeof(struct record) );
   if ( new != NULL )                   // Check whether malloc failed!
   {
       fprintf( stderr, "%s: out of memory!\n", __func__ );
       abort();
   }
   else
   { %\S
       puts("working ...");
       // a fatal error occurs:
       abort();                          // abort the programm.
   }
}</text>
		</p>
		<p n="xc_asctime_ex">
			<text>
				<![CDATA[time_t now;
time( &now );          /* Get the time (seconds since 1/1/70) */
printf( "Date: %.24s GMT\n", asctime( gmtime( &now ) ));]]>
			</text>
		</p>
		<p n="xc_acos">
			<text>#define PI 3.141593
#define DEG_PER_RAD (180.0/PI)


    double floor_width = 30.0;
    double roof_width = 34.6;

    double roof_pitch = acos( floor_width / roof_width ) * DEG_PER_RAD ;
%\l</text>
		</p>
		<p n="xc_abs_ex">
			<text>
				<![CDATA[int amount = -1234;
    char currencysym[2] = "$";
    char sign[2] = "-";
    div_t dollarsandcents = { 0, 0 };

    if ( amount >= 0 )
       sign[0] = '\0';

    dollarsandcents = div(abs( amount ), 100 );]]>
			</text>
		</p>
		<p n="xc_acosh_ex">
			<text>double x, y1, y2;
errno = 0;
y1 = acosh(x);
if ( errno == EDOM)
{
perror("acosh"); break;
}
y2 = log( x + sqrt( x*x - 1));
printf("x = %f; acosh(x) = %f; log(x + sqrt(x*x-1)) = %f\n",x, y1, y2);</text>
		</p>
		<p n="xc_asctime_s_ex">
			<text>
				<![CDATA[#include <time.h>
time_t now;
struct tm timeStruct;
char timeStr[26];
time(&now);                       // Date and time as an integer.
localtime_s(&now, &timeStruct);   // Convert to a structure.
if( asctime_s( timeStr, sizeof(timeStr), &timeStruct) == 0)
printf("Date and time: %s", timeStr);]]>
			</text>
		</p>
		<p n="xc_asin_ex">
			<text>
				<![CDATA[#include <math.h> 
#define PI 3.141593
#define DEG_PER_RAD (180.0/PI)
float height = 2.20F;
float length = 1.23F;
float altitude = asinf( height / sqrtf( height*height + length*length));]]>
			</text>
		</p>
		<p n="xc_asinh_ex">
			<text>
				<![CDATA[#include <math.h> 
for ( double x = -2.0; x < 2.1; x += 0.5)
printf("%6.2f %15f %20f\n", x, asinh(x), log( x + sqrt(x*x+1)));]]>
			</text>
		</p>
		<p n="xc_assert_ex">
			<text>
				<![CDATA[#include <assert.h>
int units_in_stock = 10;
int units_shipped = 9;
units_shipped++;
units_in_stock--;
units_in_stock -= units_shipped;
assert(units_in_stock >= 0);]]>
			</text>
		</p>
		<p n="xc_at_quick_exit_ex">
			<text>
				<![CDATA[void nexit(void) { puts("Program terminated normally."); }
void qexit(void) { puts("Programm terminated by \"quick_exit()\"."); }
int a = -1;
atexit( nexit);
at_quick_exit( qexit);
if( a < 0)
quick_exit(EXIT_FAILURE);]]>
			</text>
		</p>
		<p n="xc_atan_ex">
			<text>  #ifdef PI
    printf("The symbol PI was already defined.\n");
    long double pi = (long double) PI;
  #else
    long double pi = 4.0L * atanl( 1.0L );    // Because tan(pi/4) = 1
  #endif
    printf( "Assume pi equals %.17Lf.\n", pi);</text>
		</p>
		<p n="xc_atoi">
			<text>
				<![CDATA[%\l
#include <stdlib.h>       // int atoi( const char *s );
                          // long atol( const char *s );
                          // long long atoll( const char *s );
#include <stdio.h>

int main()
{
    char *s = " -135792468.00 Balance on Dec. 31";
    printf("\"%s\" becomes %ld\n", s, atol(s));

    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_atof">
			<text>%\l</text>
		</p>
		<p n="xc_erf">
			<text>
				<![CDATA[// erf_ex.c : erf() example
// -------------------------------------------------------------

#include <math.h>   // double erf( double x );
                    // float erff( float x );
                    // long double erfl( long double x );
#include <stdio.h>

/*
 * Given a normal distribution with mean 0 and standard deviation 1,
 * calculate the probability that the random variable is within the
 * range [0, 1.125]
 */

int main()
{
    double sigma = 1.0;     // The standard deviation
    double bound = 1.125;
    double probability;     // probability that mean <= value <= bound

    probability = 0.5 *erf( bound / (sigma * sqrt(2.0)) );

    printf("Given a normal distribution with mean 0 and standard deviation 1,\n"
           "the probability that a random variable is within the range [0, 1.125]\n"
           "is %%lf.\n", probability ); 

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exit_ex">
			<text>
				<![CDATA[// exit_ex.c : exit() example
// -------------------------------------------------------------

#include <stdlib.h>     // _Noreturn void exit( int status );
#include <stdio.h>

int main( int argc, char *argv[])
{
    FILE *f_in, *f_out;

    enum { X_OK = 0, X_ARGS, X_NOIN, X_NOOUT };

    if ( argc != 3 ) {
       fprintf( stderr, "Usage: program input-file output-file\n");
       exit( X_ARGS );
    }

    f_in = fopen(argv[1], "r");
    if ( f_in == NULL ) {
       fprintf( stderr, "Unable to open input file.\n");
       exit( X_NOIN );
    }
    f_out = fopen(argv[2], "a+");
    if ( f_out == NULL ) {
       fprintf( stderr, "Unable to open output file.\n");
       exit( X_NOOUT );
    }

    /* ... read, process, write, close files ... */

    exit( X_OK );           //  return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exp2_ex">
			<text>
				<![CDATA[// exp2_ex.c : exp2() example
// -------------------------------------------------------------

#include <math.h>        // double exp2( double x );
                         // float exp2f( float x );
                         // long double exp2l( long double x );
#include <stdio.h>

// The famous grains-of-rice-on-a-chessboard problem.
// The sultan loses a chess game. The wager was one grain for square 1
// on the chessboard, then double the last number for each successive
// square. How much rice in all?

int main()
{
    int squares = 64;
    long double gramspergrain = 0.0025L;   // A grain of rice weighs 25 mg.
    long double sum = 0.0L;

    for ( int i = 0; i < squares; i++ )
        sum += gramspergrain * exp2l( (long double)i );

    printf( "The sultan's wager costs him %%.3Lf metric tons of rice.\n",
             sum / 1000000.0L );           // A million grams per ton.

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exp_ex">
			<text>
				<![CDATA[// exp_ex.c : exp() example
// -------------------------------------------------------------

#include <math.h>        // double exp( double x );
                         // float expf( float x );
                         // long double expl( long double x );
#include <stdio.h>

int main()
{
    /* Amount owed = principal * e^(interest_rate * time) */

    int principal = 10000;   // Initial debt is ten thousand dollars.
    int balance = 0;
    double rate = 0.055;     // Interest rate is 5.5%% annually.
    double time = 1.5;       // Period is eighteen months.

    balance = principal * exp( rate * time );

    printf("Invest %%d dollars at %%.1f%%%% compound interest, and "
           "in %%.1f years \nyou'll have %%d dollars.\n",
           principal, rate*100.0, time, balance );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fclose_ex">
			<text>
				<![CDATA[// fclose_ex.c : fclose() example
// -------------------------------------------------------------

#include <stdio.h>   // int fclose( FILE *fp );

/* Print a file to the console, line by line. */

int main()
{
    FILE *fp_infile;
    char linebuffer[512];

    if (( fp_infile= fopen("input.dat", "r")) == NULL )
    {
       fprintf(stderr, "Couldn't open input file.\n");
       return -1;
    }

    while ( fgets( linebuffer, sizeof(linebuffer), fp_infile ) != NULL )
        fputs( linebuffer, stdout );

    if ( ! feof(fp_infile) )         // This means "if not end of file"
       fprintf( stderr, "Error reading from input file.\n" );

    if ( fclose(fp_infile) != 0 )
    {
       fprintf(stderr, "Error closing input file.\n");
       return -2;
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fdim_ex">
			<text>
				<![CDATA[// fdim_ex.c : fdim() example
// -------------------------------------------------------------

#include <math.h>        // double fdim( double x, double y );
                         // float fdimf( float x, float y );
                         // long double fdiml( long double x, long double y );
#include <stdio.h>

int main()
{
    /* Make sure an argument is within the domain of asin() */

    double sign, argument = -1.5, result;
    /* ... */

    sign = copysign( 1.0, argument );           // Save the sign ...
    argument = copysign( argument, 1.0 );       // then use only positive values

    argument = 1.0 - fdim( 1.0, argument );     // Trim excess beyond 1.0
    result = asin( copysign(argument, sign) );  // Restore sign and
                                                // call asin()
    printf( "For the argument %%.2lf the asin function returns %%lf.\n",
             copysign(argument, sign), result );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_deholdexcept_ex">
			<text>
				<![CDATA[// feholdexcept_ex.c : feholdexcept() example
// -------------------------------------------------------------

#include <fenv.h>     // int feholdexcept( fenv_t *envp );
#include <math.h>
#include <float.h>

/*
 * Compute the hypotenuse of a right triangle, avoiding intermediate
 * overflow or underflow.
 *
 * (This example ignores the case of one argument having
 * great magnitude and the other small, causing both overflow
 * and underflow!)
 */
double hypotenuse(double sidea, double sideb)
{
#pragma STDC FENV_ACCESS ON
    double sum, scale, ascaled, bscaled, invscale;
    fenv_t fpenv;
    int fpeflags;

    if ( signbit(sidea))  sidea = fabs(sidea);
    if ( signbit(sideb))  sideb = fabs(sideb);

    feholdexcept(&fpenv);        // Save previous environment,
                                 // clear exceptions,
                                 // switch to nonstop processing.
    invscale = 1.0;
    sum = sidea * sidea + sideb * sideb;    // First try whether a^2 + b^2
                                            // causes any exceptions.

    fpeflags = fetestexcept(FE_UNDERFLOW | FE_OVERFLOW);    // Did it?
    if (fpeflags & FE_OVERFLOW && sidea > 1.0 && sideb > 1.0)
    {
        /* a^2 + b^2 caused an overflow. Scale the triangle down. */
        feclearexcept(FE_OVERFLOW);
        scale = scalbn( 1.0, (DBL_MIN_EXP / 2));

        invscale = 1.0 / scale;
        ascaled = scale * sidea;
        bscaled = scale * sideb;
        sum = ascaled * ascaled + bscaled * bscaled;
    }
    else if (fpeflags & FE_UNDERFLOW && sidea < 1.0 && sideb < 1.0)
    {
        /* a^2 + b^2 caused an underflow. Scale the triangle up. */
        feclearexcept(FE_UNDERFLOW);
        scale = scalbn( 1.0, (DBL_MAX_EXP / 2));

        invscale = 1.0 / scale;
        ascaled = scale * sidea;
        bscaled = scale * sideb;
        sum = ascaled * ascaled + bscaled * bscaled;
    }

    feupdateenv(&fpenv);     // restore the caller's environment, and
                             // raise any new exceptions

    /* c = (1/scale) * sqrt((a * scale)^2 + (b * scale)^2): */
    return invscale * sqrt(sum);
}

#include <stdio.h>

int main()
{
    double sidec = hypotenuse( 1E-10, 2E-200);
    printf("The hypotenuse of the right triangle is %%.10lG\n", sidec);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_deraiseexcept_ex">
			<text>
				<![CDATA[// feraiseexcept_ex.c : feraiseexcept() example
// -------------------------------------------------------------

#include <fenv.h>     // int feraiseexcept( int excepts );
//#include <math.h>
#include <stdlib.h>
#include <stdio.h>

// Although user programs rarely need to raise a floating-point exception by artificial
// means, the following example illustrates how to do so:

int main()
{
    int result, except_set, except_test;

    #pragma STDC FENV_ACCESS ON

    feclearexcept (FE_ALL_EXCEPT);

    except_set = FE_OVERFLOW;
    result = feraiseexcept( except_set );
    if ( result != 0 )
    {
        printf( "feraisexcept() failed (%%d)\n", result );
        exit( result );
    }

    except_test = fetestexcept( except_set );
    if ( except_test != except_set )
        printf( "Tried to raise flags %%X, but only raised flags %%X.\n",
                 except_set, except_test );
    else
       printf( "Raised the floating-point exception FE_ALL_EXCEPT = %%X\n",
                except_set );       
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fflush_ex">
			<text>
				<![CDATA[// fflush_ex.c : fflush() example
// -------------------------------------------------------------

#include <stdio.h>   // int fflush( FILE *fp );
#include <signal.h>

/* Tests the effect of flushing output file buffers. */

int main()
{
    FILE *fp;

#ifdef FLUSH
    char filename[ ] = "twice.txt";
#else
    char filename[ ] = "once.txt";
#endif  /* FLUSH */

    fp = fopen( filename, "w" );
    if ( fp == NULL)
       fprintf( stderr, "Failed to open file '%%s' to write.\n", filename );

    fputs( "Going once ...\n", fp );
    fflush( fp );                 // Flush the output unconditionally

    fputs( "Going twice ...\n", fp );

#ifdef FLUSH
    fflush( fp );                 // Now flush only if compiled with '-DFLUSH'
#endif

    raise( SIGKILL );             // End the program abruptly.

    fputs( "Gone.\n", fp );       // These three lines will never be executed.
    fclose( fp );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgets_ex">
			<text>
				<![CDATA[// fgets_ex.c : fgets() example
// -------------------------------------------------------------

#include <stdio.h>   // char *fgets( char * restrict buffer, int n,
                     //              FILE * restrict fp );
#include <string.h>

int main()
{
    FILE *titlefile;
    char title[256];
    int counter = 0;

    if ((titlefile = fopen("titles.txt", "r")) == NULL)
       perror( "Opening title file" );
    else
    {
       while ( fgets( title, 256, titlefile ) != NULL )
       {
          title[ strlen(title) -1 ] = '\0';   // Trim off newline character.
          printf( "%%3d: \"%%s\"\n", ++counter, title );
       }
       /* fgets() returned NULL: either EOF or an error occurred. */
       if ( feof(titlefile) )
         printf("Total: %%d titles.\n", counter);
    }
    fclose( titlefile );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgetwc_ex">
			<text>
				<![CDATA[// fgetwc_ex.c : fgetwc() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>   // wint_t fgetwc( FILE *fp );
#include <stdlib.h>
#include <locale.h>

int main()
{
    char file_in[ ]  = "local_in.txt",
         file_out[ ] = "local_out.txt";
    FILE *fp_in_wide, *fp_out_wide;
    wint_t wc;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
       fwprintf( stderr,
                 L"Sorry, couldn't change to the system's native locale.\n"),
       exit(1);

    if (( fp_in_wide = fopen( file_in, "r" )) == NULL )
       fprintf( stderr, "Error opening the file %%s\n", file_in), exit(2);

    if (( fp_out_wide = fopen( file_out, "w" )) == NULL )
       fprintf( stderr, "Error opening the file %%s\n", file_out), exit(3);

    fwide( fp_in_wide, 1);            // Not strictly necessary, since first
    fwide( fp_out_wide, 1);           // file access also sets wide or byte mode.

    while (( wc = fgetwc( fp_in_wide )) != WEOF )
    {
       // ... process each wide character read ...

       if ( fputwc( (wchar_t)wc, fp_out_wide) == WEOF)
         break;
    }
    if ( ferror( fp_in_wide))
       fprintf( stderr, "Error reading the file %%s\n", file_in);
    if ( ferror( fp_out_wide))
       fprintf( stderr, "Error writing to the file %%s\n", file_out);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgetws_ex">
			<text>
				<![CDATA[// fgetws_ex.c : fgetws() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>   // wchar_t *fgetws( wchar_t * restrict buffer,
                     //                  int n, FILE * restrict fp );
//#include <stdlib.h>
#include <locale.h>

int main()
{
    FILE *fp_in_wide;
    wchar_t buffer[4096];
    wchar_t *line = buffer;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr, L"Sorry, couldn't change to the system's native locale.\n");
       return -1;
    }
    if (( fp_in_wide = fopen( "local_in.txt", "r" )) == NULL )
    {   perror( "Opening input file");  return -1;   }

    fwide( fp_in_wide, 1);

    line = fgetws( buffer, sizeof(buffer), fp_in_wide );
    if ( line == NULL )
       perror( "Reading from input file" );
    else
       if( fputws( line, stdout) < 0)
          perror( "Writing to stdout" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fma_ex">
			<text>
				<![CDATA[// fma_ex.c : fma() example
// -------------------------------------------------------------

#include <math.h>   // double fma( double x, double y, double z );
                    // float fmaf( float x, float y, float z );
                    // long double fmal( long double x, 
                    //             long double y, long double z );
#include <stdio.h>

int main()
{
    double x, y, z;

    x = nextafter( 3.0, 4.0 );     // Smallest possible double value
                                   // greater than 3
    y = 1.0/3.0;
    z = -1.0;

    printf( "x = %%.15G\n"
            "y = %%.15G\n"
            "z = %%.15G\n", x, y, z );

// #ifdef FP_FAST_FMA

    printf( "fma( x, y, z) = %%.15G\n", fma( x, y, z) );

// #else // i.e., not def FP_FAST_FMA

   double product = x * y;
   printf( "x times y = %%.15G\n", product );
   printf( "%%.15G + z = %%.15G\n", product, product + z );

// #endif // def FP_FAST_FMA
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fmax_ex">
			<text>
				<![CDATA[// fmax_ex.c : fmax() example
// -------------------------------------------------------------

#include <math.h>   // double fmax( double x, double y );
                    // float fmaxf( float x, float y );
                    // long double fmaxl( long double x , long double y );
#include <float.h>
#include <stdio.h>

int main()
{
    // Let big equal the second-greatest-possible double value ...
    const double big = nextafter( DBL_MAX, 0.0 );
    // ... and small the second-least possible-double value:
    const double small = nextafter( DBL_MIN, 0.0 );

    double a, b, c;
    /* ... */
    a = DBL_MIN;  b = 0.0;  c = 1.0;

    if ( fmin( fmin( a, b ), c ) <= small )
       printf( "At least one value is too small.\n" );
    if ( fmax( fmax( a, b ), c ) >= big )
       printf( "At least one value is too great.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fmod_ex">
			<text>
				<![CDATA[// fmod_ex.c : fmod() example
// -------------------------------------------------------------

#include <math.h>   // double fmod( double x, double y );
                    // float fmodf( float x, float y );
                    // long double fmodl( long double x, long double y );
#include <fenv.h>
#include <stdio.h>

int main()
{
    double people = -2.25, 
           apples = 3.3, 
           eachgets = 0.0, 
           someleft = 0.0;

    int saverounding = fegetround();       // Save previous setting
    fesetround(FE_TOWARDZERO);

    eachgets = rint( apples / people );
    someleft = fmod( apples, people );

    printf( "If there are %%+.2f of us and %%+.2f apples, \n"
            "each of us gets %%+.2f, with %%+.2f left over.\n",
            people, apples, eachgets, someleft );

    fesetround( saverounding );            // Restore previous setting

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fopen_ex">
			<text>
				<![CDATA[// fopen_ex.c : fopen() example
// -------------------------------------------------------------

#include <stdio.h>   // FILE *fopen( const char * restrict name,
                     //              const char * restrict mode );
#include <stdlib.h>
#include <string.h>

int main( int argc, char *argv[])
{
    FILE *in, *out;
    int c;

    if ( argc != 3 )
       fprintf( stderr, "Usage: program input-file output-file\n"), exit(1);

    // If "-" appears in place of input filename, use stdin:
    in = (strcmp(argv[1], "-") == 0) ? stdin : fopen(argv[1], "r");
    if ( in == NULL )
    {  perror( "Opening input file" ); return -1;  }

    // If "-" appears in place of output filename, use stdout:
    out = (strcmp(argv[2], "-") == 0) ? stdout : fopen(argv[2], "a+");
    if ( out == NULL )
    {   perror( "Opening output file" ); return -1; }

    while (( c = fgetc( in )) != EOF)
       if ( fputc(c, out) == EOF )
          break;

    if ( !feof( in ))
       perror( "Error while copying" );

    fclose(in), fclose(out);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fpclassify_ex">
			<text>
				<![CDATA[// fpclassify_ex.c : fpclassify() example
// -------------------------------------------------------------

#include <math.h>       // int fpclassify( x );
#include <stdio.h>

double minimum( double a, double b )
{
    register int aclass = fpclassify( a );
    register int bclass = fpclassify( b );

    if ( aclass == FP_NAN || bclass == FP_NAN )
       return NAN; 

    if ( aclass == FP_INFINITE )         // -Inf is less than anything;
       return ( signbit( a ) ? a : b );  // +inf is greater than anything.

    if ( bclass == FP_INFINITE )
       return ( signbit( b ) ? b : a );

    return ( a < b ? a : b );
}

int main()
{
    double x = 0.0;

    double min = minimum( x, -HUGE_VAL); 

    printf( "min = %%G\n", min);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fputws_ex">
			<text>
				<![CDATA[// fputws_ex.c : fputws() example
// -------------------------------------------------------------

#include <wchar.h>   // int fputws( const wchar_t * restrict ws,
                     //              FILE * restrict fp );
#include <stdio.h>
#include <locale.h>

int main()
{
    FILE *fpw;
    char fname_wide[] = "widetest.txt";
    int widemodeflag = 1;
    int result;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr, L"Sorry, couldn't change to the system's native locale.\n");
       return -1;
    }
    wchar_t widestring[] = L"How many umlauts are there in FahrvergnÃ¼gen?\n";

    if ((fpw = fopen(fname_wide, "a")) == NULL)
    {    perror( "Opening output file" ); return -1; }

    // Set file to wide-character orientation:
    widemodeflag = fwide(fpw, widemodeflag);
    if ( widemodeflag <= 0 )
    {
       fprintf(stderr, "Unable to set output file %%s to wide characters\n",
                       fname_wide);
       (void)fclose(fpw);
       return -1;
    }
    // Write wide-character string to the file:
    result = fputws( widestring, fpw );
    if ( result < 0 )
    {
       fprintf(stderr, "Error on writing file %%s.\n", fname_wide);
       return -1;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_freopen_s_ex">
			<text>
				<![CDATA[// freopen_s_ex.c : freopen_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdio.h>   // errno_t freopen_s( FILE * restrict * restrict fpPtr,
                     //                    const char * restrict name,
                     // const char * restrict mode,
                     // FILE * restrict fp );
#include <stdlib.h>
#include <errno.h>

int main()      // Redirect standard output to the file redirect.txt:
{
    char filename[] = "redirect.txt";
    FILE *fp;

    errno_t err = freopen_s( &fp, filename, "w", stdout);
    if( err != 0)
    { 
       fprintf( stderr, "Unable to redirect stdout to %%s\n", filename);
       exit(err);
    }

    printf("This text is being written to the file %%s.\n", filename);

    fclose(stdout);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_frexp_ex">
			<text>
				<![CDATA[// frexp_ex.c : frexp() example
// -------------------------------------------------------------

#include <math.h>    // double frexp( double x, int *exp );
                     // float frexpf( float x, int *exp );
                     // long double frexpl( long double x, int *exp );
#include <stdio.h>
#include <stdlib.h>

double fourthrt( double x )
{
    int exponent, exp_mod_4;
    double mantissa = frexp( x, &exponent );

    exp_mod_4 = exponent %% 4;
    exponent -= ( exp_mod_4 );    // Get an exponent that's
                                  // divisible by four ...
    for ( int i = abs( exp_mod_4 ); i > 0; i-- )
    {
        if ( exp_mod_4 > 0 )      // ... and compensate in the mantissa.
           mantissa *= 2.0;
       else
           mantissa /= 2.0;
    }
    return ldexp( sqrt( sqrt( mantissa )), exponent / 4 );
}

int main()
{
    double x = 64.0;      // 16 * 4

    printf( "The fourth root of %%f is %%G.\n", x, fourthrt(x) );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fscnf_ex">
			<text>
				<![CDATA[// fscanf_ex.c : fscanf() example
//
// The example code reads information about a user from a file, which we will
// suppose contains a line of colon-separated strings like this:
//    tony:x:1002:31:Tony Crawford,,:/home/tony:/bin/bash// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for fscanf_s()
#include <stdio.h> 
// int fscanf( FILE * restrict fp, const char * restrict format, ... );
// int fscanf_s( FILE * restrict fp, const char * restrict format, ... ); 

#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct pwrecord {             // Structure for contents of passwd fields.
    unsigned int uid;
    unsigned int gid;
    char user[32];
    char pw [32];
    char realname[128];
    char home [128];
    char shell [128];
};

int main()
{
    FILE *fp;
    char pwfile[] = "pwfile.txt";
    int results = 0;
    struct pwrecord record, *recptr = &record;;
    char gecos[256] = "";

    /* ... Open the password file to read ... */

    fp = fopen( pwfile, "r");
    if ( fp == NULL )
    {  perror( "Opening input file" ); return -1;  }

    /* 1. Read login name, password, UID and GID. */

    record = (struct pwrecord) { UINT_MAX, UINT_MAX, "", "", "", "", "" };
    results = fscanf( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                      recptr->user, recptr->pw, &recptr->uid, &recptr->gid );

    // If the implementation supports the secure functions, the function fscanf_s()
    // can be used as an alternative to fscanf():
    /*
    results = fscanf_s( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                        recptr->user, sizeof(recptr->user),
                        recptr->pw, sizeof(recptr->pw),
                        &recptr->uid, &recptr->gid );
    */
    if ( results < 4 )
    {
       fprintf( stderr, "Unable to parse line.\n" );
       fscanf( fp, "%%*[^\n]\n" ); // Read and discard rest of line.
    }

    /* 2. Read the "gecos" field, which may contain nothing, or just the
     * real name, or comma-separated sub-fields.
    */
    results = fscanf( fp, "%%255[^:]:", gecos );
    if ( results < 1 )
       strcpy( recptr->realname, "[No real name available]" );
    else
       sscanf( gecos, "%%127[^,]", recptr->realname );    // Truncate at
                                                         // first comma.

    /* 3. Read two more fields before the end of the line. */

    results = fscanf( fp, "%%127[^:]:%%127[^:\n]\n", recptr->home, recptr->shell );
    if ( results < 2 )
    {
        fprintf( stderr, "Unable to parse line.\n" );
        fscanf( fp, "%%*[^\n]\n" );            // Read and discard rest of line.
    }
    printf( "The user account %%s with UID %%u belongs to %%s.\n",
             recptr->user, recptr->uid, recptr->realname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fscanf_ex">
			<text>
				<![CDATA[// fscanf_ex.c : fscanf() example
//
// The example code reads information about a user from a file, which we will
// suppose contains a line of colon-separated strings like this:
//    tony:x:1002:31:Tony Crawford,,:/home/tony:/bin/bash// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for fscanf_s()
#include <stdio.h> 
// int fscanf( FILE * restrict fp, const char * restrict format, ... );
// int fscanf_s( FILE * restrict fp, const char * restrict format, ... ); 

#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct pwrecord {             // Structure for contents of passwd fields.
    unsigned int uid;
    unsigned int gid;
    char user[32];
    char pw [32];
    char realname[128];
    char home [128];
    char shell [128];
};

int main()
{
    FILE *fp;
    char pwfile[] = "pwfile.txt";
    int results = 0;
    struct pwrecord record, *recptr = &record;;
    char gecos[256] = "";

    /* ... Open the password file to read ... */

    fp = fopen( pwfile, "r");
    if ( fp == NULL )
    {  perror( "Opening input file" ); return -1;  }

    /* 1. Read login name, password, UID and GID. */

    record = (struct pwrecord) { UINT_MAX, UINT_MAX, "", "", "", "", "" };
    results = fscanf( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                      recptr->user, recptr->pw, &recptr->uid, &recptr->gid );

    // If the implementation supports the secure functions, the function fscanf_s()
    // can be used as an alternative to fscanf():
    /*
    results = fscanf_s( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                        recptr->user, sizeof(recptr->user),
                        recptr->pw, sizeof(recptr->pw),
                        &recptr->uid, &recptr->gid );
    */
    if ( results < 4 )
    {
       fprintf( stderr, "Unable to parse line.\n" );
       fscanf( fp, "%%*[^\n]\n" ); // Read and discard rest of line.
    }

    /* 2. Read the "gecos" field, which may contain nothing, or just the
     * real name, or comma-separated sub-fields.
    */
    results = fscanf( fp, "%%255[^:]:", gecos );
    if ( results < 1 )
       strcpy( recptr->realname, "[No real name available]" );
    else
       sscanf( gecos, "%%127[^,]", recptr->realname );    // Truncate at
                                                         // first comma.

    /* 3. Read two more fields before the end of the line. */

    results = fscanf( fp, "%%127[^:]:%%127[^:\n]\n", recptr->home, recptr->shell );
    if ( results < 2 )
    {
        fprintf( stderr, "Unable to parse line.\n" );
        fscanf( fp, "%%*[^\n]\n" );            // Read and discard rest of line.
    }
    printf( "The user account %%s with UID %%u belongs to %%s.\n",
             recptr->user, recptr->uid, recptr->realname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fseek_ex">
			<text>
				<![CDATA[// fseek_ex.c : fseek() example
// -------------------------------------------------------------

#include <stdio.h>   // int fseek( FILE *fp, long offset, int origin );

typedef struct { long id;
                 double value;
               } record;

// void writeRecords();

int main()
{
    FILE *fp;
    record cur_rec = (record) { 0, 0.0 };
    int reclength_file = sizeof(record);
    long seek_id = 123L;

    if ( (fp = fopen("records", "rb")) == NULL)
        perror( "Unable to open records file" );
    else do
    {
        if ( 1 > fread( &cur_rec.id, sizeof (long), 1, fp ))
        {
           fprintf( stderr, "Record with ID %%ld not found.\n", seek_id );
           break;
        }
        else                                      // Skip rest of record
           if ( fseek( fp, reclength_file - sizeof(long), 1 ) )
           {
              perror( "fseek failed" );
              break;
           }
    } while ( cur_rec.id != seek_id );

    if( cur_rec.id == seek_id )
        printf( "Record with ID %%ld found.\n", seek_id );
   
    return 0;
}
/*
void writeRecords()
{
    FILE *fp;
    record someRecords[] = {  { 101L, 10.0 }, { 123L, 20.0 },{ 146L, 30.0 } };
    size_t n = sizeof( someRecords) / sizeof( *someRecords);

    if ((fp = fopen("records", "wb")) == NULL)
       perror( "Unable to open records file" );
    else 
    {
       if( fwrite( someRecords, sizeof(record), n, fp) < n) 
          perror( "Unable to write records" );
       fclose(fp);
    }
}
*/
]]>
			</text>
		</p>
		<p n="xc_ftell_ex">
			<text>
				<![CDATA[// ftell_ex.c : ftell() example
// -------------------------------------------------------------

// This example searches in a file, whose name is the second command-line
// argument, for a string, which the user can specify in the first
// command-line argument.

#include <stdio.h>       // long ftell( FILE *fp );
#include <stdlib.h>
#include <string.h>

#define MAX_LINE 256

int main( int argc, char *argv[])
{
    FILE *fp;
    long lOffset = 0L;
    char sLine[MAX_LINE] = "";
    int  lineno = 0;

    if ( argc != 3 )
       fprintf( stderr, "Usage: program search_string file_name\n"), exit(1);

    if ((fp = fopen(argv[2], "r")) == NULL)
    {
        fprintf(stderr, "Unable to open file %%s\n", argv[2]);
        exit(-1);
    }
    do
    {
        lOffset = ftell(fp);      // Bookmark the beginning of
                                  // the line we're about to read.
        if ( -1L == lOffset )
            fprintf(stderr, "Unable to obtain offset in %%s\n", argv[2]);
        else
            lineno++;

        if ( !fgets(sLine, MAX_LINE, fp))     // Read next line from file.
            break;
    } while ( strstr( sLine, argv[1]) == NULL);    // Test for argument
                                                   // in sLine.

    /* Dropped out of loop: Found search keyword or EOF */
    if ( feof(fp) || ferror(fp) )
    {
        fprintf(stderr, "Unable to find \"%%s\" in %%s\n", argv[1], argv[2]);
        rewind(fp);
    }
    else
    {
        printf( "%%s (%%d): %%s\n", argv[2], lineno, sLine);
        fseek( fp, lOffset, 0);           // Set file pointer at beginning of
                                          // the line containing the keyword
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fwprintf_ex">
			<text>
				<![CDATA[// fwprintf_ex.c : fwprintf() example
// -------------------------------------------------------------

#include <stdio.h>     // int fwprintf( FILE * restrict fp,
#include <wchar.h>     //               const wchar_t * restrict format, ... );
                       // int fwprintf_s( FILE * restrict fp,
                       //                 const wchar_t * restrict format, ...);
#include <wchar.h>
#include <locale.h>

int main()
{
    wchar_t name_local[ ] = L"Ka\u0142u\u017Cny";
    char name_portable[ ]= "Kaluzny";
    char locale[ ] = "pl_PL.UTF-8";
    char * newlocale;

    newlocale = setlocale( LC_ALL, locale );
    if ( newlocale == NULL )
       fprintf( stderr, "Sorry, couldn't change the locale to %%s.\n"
                "The current locale is %%s.\n",
                locale, setlocale( LC_ALL, NULL ));

    fwprintf( stdout,
              L"Customer's name: %%ls (Single-byte transliteration: %%s)\n",
              name_local, name_portable );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_getenv_s_ex">
			<text>
				<![CDATA[// getenv_s_ex.c : getenv_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // errno_t getenv_s( size_t * restrict len,
                     //                   char * restrict value,
                     //                   rsize_t maxsize,
                     //                   const char * restrict name);
#include <stdio.h>
#include <errno.h>

int main()
{
    char envStr[512];
    size_t len;

    if( getenv_s( &len, envStr, sizeof(envStr),"PATH") == 0)
        printf("PATH variable (%%zu characters): \n%%s\n", len, envStr);
    else if( len > 0)
        printf("The PATH variable (%%zu characters) is more than "
               "%%zu bytes long.\n", len, sizeof(envStr));
    else
        printf("PATH variable not found.\n");

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_gmtime_ex">
			<text>
				<![CDATA[// gmtime_ex.c : gmtime() example
// -------------------------------------------------------------

#include <time.h>   // struct tm *gmtime( const time_t *timer );
#include <stdio.h>
#include <string.h>

int main()
{
    time_t rawtime;
    struct tm utc_tm, local_tm, *ptr_tm;
    char buffer[1024] = "";

    time( &rawtime );                 // Get current time as an integer.

    ptr_tm = gmtime( &rawtime );      // Convert to UTC in a struct tm.
    memcpy( &utc_tm, ptr_tm, sizeof(struct tm) ); // Save a local copy.

    ptr_tm = localtime( &rawtime );   // Do the same for local time zone.
    memcpy( &local_tm, ptr_tm, sizeof(struct tm) );

    if ( strftime( buffer, sizeof(buffer),
                   "It's %%A, %%B %%d, %%Y, %%R o'clock, UTC.", &utc_tm ) )
       puts( buffer );

    if ( strftime( buffer, sizeof(buffer),
                   "Here it's %%A, %%B %%d, %%Y, %%R o'clock, UTC %%z.", &local_tm ) )
       puts( buffer );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_hypot_ex">
			<text>
				<![CDATA[// hypot_ex.c : hypot() example
// -------------------------------------------------------------

#include <math.h>   // double hypot( double x, double y );
                    // float hypotf( float x, float y );
                    // long double hypotl( long double x, long double y );
#include <stdio.h>
#include <errno.h>

int main()
{
    double x, y, h;        // Three sides of a triangle

    printf( "How many kilometers do you want to go westward? " );
    scanf( "%%lf", &x );

    printf( "And how many southward? " );
    scanf( "%%lf", &y );

    errno = 0;
    h = hypot( x, y );
    if ( errno )
       perror( __FILE__ );
    else
       printf( "Then you'll be %%4.2lf km from where you started.\n", h );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ignore_handler_s_ex">
			<text>
				<![CDATA[// ignore_handler_s_ex.c : ignore_handler_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // void ignore_handler_s( const char * restrict msg,
                     //                        void * restrict ptr, 
                     //                        errno_t error);
#include <string.h>
#include <stdio.h>
#include <errno.h>

// Handle runtime constraint violations using only
// the return value of secure functions.

int main()
{
    char message[20] = "Hello, ",
         name[20];
    set_constraint_handler_s(ignore_handler_s);

    printf("Please enter your name: ");
    if( gets_s( name, sizeof(name)) == NULL)
    { 
       puts("Error: You entered more than 19 characters."); 
       // ...
    }
    else if( strcat_s( message, sizeof(message), name) != 0)
    {
       puts("Error: message array is too small.");
       // ...
    }
    else
       puts( message);

    // ...

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ilogb_ex">
			<text>
				<![CDATA[// ilogb_ex.c : ilogb() example
// -------------------------------------------------------------

#include <math.h>    // int ilogb( double x )
                     // int ilogbf( float x )
                     // int ilogbl( long double x )
#include <stdio.h>
#include <limits.h>

int main()
{
    int exponent = 0;
    double x = -1.509812734e200;

    while ( exponent < INT_MAX )
    {
       exponent = ilogb( x );
       printf( "The exponent of %%g is %%d.\n", x, exponent );

       if ( x < 0.0 && x * x > 1.0 )
          x /= 1e34;
       else
          x += 1.1, x *= 2.2e34 ;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_imaxdiv_ex">
			<text>
				<![CDATA[// imaxdiv_ex.c : imaxdiv() example
// -------------------------------------------------------------

#include <inttypes.h>  // imaxdiv_t imaxdiv( intmax_t dividend, 
                       //                    intmax_t divisor );
#include <stdio.h>

int main()
{
    intmax_t people = 110284, apples = 9043291;
    imaxdiv_t share;

    if ( people == 0 )       // Avoid dividing by zero.
    {
       printf( "There's no one here to take the apples.\n" ); 
       return -1;
    }
    else
       share = imaxdiv( apples, people );

    printf( "If there are %%ji of us and %%ji apples,\n"
            "each of us gets %%ji, with %%ji left over.\n",
            people, apples, share.quot, share.rem );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_isfinite_ex">
			<text>
				<![CDATA[// isfinite_ex.c : isfinite() example
// -------------------------------------------------------------

#include <math.h>     // int isfinite( float x );
                      // int isfinite( double x );
                      // int isfinite( long double x );

#include <stdarg.h>

double vsum( int n, ... )
// n is the number of arguments in the list
{
    va_list argptr;
    double sum = 0.0, next = 0.0;

    va_start( argptr, n );
    while ( n-- )
    {
        next = va_arg( argptr, double );
        sum += next;
        if ( isfinite( sum ) == 0 )
           break;         // If sum reaches infinity, stop adding.
    }
    va_end( argptr );
    return sum;
}

#include <stdio.h>
#include <float.h>

int main()
{
    printf( "1. Sum: %%lf\n", vsum( 3, 1.0, 2.0, 3.0) );

    double x = DBL_MAX;
    printf( "2. Sum: %%lf\n", vsum( 2, x, x) );
   
    return 0;
}

]]>
			</text>
		</p>
		<p n="xc_isprintf_ex">
			<text>
				<![CDATA[// isprint_ex.c : isprint() example
// And also an example for
// isalnum(), isalpha(), isblank(), iscntrl(), isdigit(),
// isgraph(), islower(), ispunct(), isspace().
// -------------------------------------------------------------

#include <ctype.h>    // int isprint( int c); int isalnum( int c); ...
#include <stdio.h>
#include <locale.h>

int main()
{
    unsigned int c;

//    setlocale(LC_CTYPE, "");
    printf("\nThe current locale for the 'is ...' functions is '%%s'.\n",
           setlocale(LC_CTYPE, NULL));

    printf("Here is a table of the 'is ...' values for the characters"
           " from 0 to 127 in this locale:\n\n");

    for ( c = 0; c < 128; c++ )   // Loop iteration for each table row.
    {
        if ( c %% 24 == 0 )        // Repeat table header every 24 rows.
        {
            printf("Code char alnum alpha blank cntrl digit graph lower"
                   " print punct space\n");
            printf("---------------------------------------------------"
                   "------------------\n");
        }
        printf( "%%4u %%4c %%3c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c\n",
                 c,                             // Print numeric character code.
                 ( isprint( c ) ?  c  : ' ' ),  // Print the glyph, or a space
                                                // if it's not printable.
                 ( isalnum( c ) ? 'X' : '-' ),  // In a column for each category,
                 ( isalpha( c ) ? 'X' : '-' ),  // print X for yes or - for no.
                 ( isblank( c ) ? 'X' : '-' ),
                 ( iscntrl( c ) ? 'X' : '-' ),
                 ( isdigit( c ) ? 'X' : '-' ),
                 ( isgraph( c ) ? 'X' : '-' ),
                 ( islower( c ) ? 'X' : '-' ),
                 ( isprint( c ) ? 'X' : '-' ),
                 ( ispunct( c ) ? 'X' : '-' ),
                 ( isspace( c ) ? 'X' : '-' ) );
    }  // end of loop for each character value

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswalnum_ex">
			<text>
				<![CDATA[// iswalnum_ex.c : iswalnum() example
// -------------------------------------------------------------

#include <wctype.h>     // int iswalnum( wint_t wc );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wint_t wc;
    int i, dummy;

    setlocale( LC_CTYPE, "" );
    wprintf( L"\nThe current locale for the 'is ...' functions is '%%s'.\n",
             setlocale( LC_CTYPE, NULL ) );

    wprintf( L"These are the alphanumeric wide characters"
             " in this locale:\n\n" );
    for ( wc = 0, i = 0; wc < 1024; wc++ )
    if ( iswalnum( wc ) )
    {
       if ( i %% 25 == 0 )
       {
           wprintf( L"... more ...\n" );
           dummy = getchar();              // Wait before printing more
           wprintf( L"Wide character Code\n" );
           wprintf( L"-----------------------\n" );
       }
       wprintf( L"%%5lc %%4lu\n", wc, wc );
       i++;
    }
    wprintf( L"-----------------------\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswalpha_Ex">
			<text>
				<![CDATA[// iswalpha_ex.c : iswalpha() example
// And also an example for
// iswalnum(), iswblank(), iswcntrl(), iswdigit(), iswgraph(),
// iswlower(), iswprint(), iswpunct(), iswspace().
// -------------------------------------------------------------

#include <wctype.h>    // int iswalpha( wint_t wc);  ...
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wint_t wc;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr,
                 L"Sorry, couldn't change to the system's native locale.\n");
       return 1;
    }
    wprintf( L"The current locale for the 'isw ...' functions is '%%s'.\n",
             setlocale(LC_CTYPE, NULL));

    wprintf( L"Here is a table of the 'isw ...' values for the characters "
             L"from 128 to 255 in this locale:\n\n");

    for ( wc = 128; wc < 255; ++wc ) // Loop iteration for each table row.
    {
       if ( (wc-128) %% 24 == 0 ) // Repeat table header every 24 rows.
       {
         wprintf(L"Code char alnum alpha blank cntrl digit graph lower"
                 L" print punct space\n");
         wprintf(L"---------------------------------------------------"
                 L"------------------\n");
       }
       wprintf(L"%%4u %%4lc %%3c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c\n",
               wc,                              // Print numeric character code.
               ( iswprint( wc ) ? wc  : ' ' ),  // Print the glyph, or a space
                                                // if it's not printable.
               ( iswalnum( wc ) ? 'X' : '-' ),  // In a column for each
               ( iswalpha( wc ) ? 'X' : '-' ),  // category, print X for
               ( iswblank( wc ) ? 'X' : '-' ),  // yes or - for no.
               ( iswcntrl( wc ) ? 'X' : '-' ),
               ( iswdigit( wc ) ? 'X' : '-' ),
               ( iswgraph( wc ) ? 'X' : '-' ),
               ( iswlower( wc ) ? 'X' : '-' ),
               ( iswprint( wc ) ? 'X' : '-' ),
               ( iswpunct( wc ) ? 'X' : '-' ),
               ( iswspace( wc ) ? 'X' : '-' ) );
    } // end of loop for each character value

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswctype_ex">
			<text>
				<![CDATA[// iswctype_ex.c : iswctype() example
// -------------------------------------------------------------

#include <wctype.h>    // int iswctype( wint_t wc, wctype_t description );
#include <wchar.h>
#include <locale.h>

int main()
{
    wint_t wc = L'ÃŸ';

    setlocale( LC_CTYPE, "de_DE.UTF-8" );
    if ( iswctype( wc, wctype( "alpha" )) )
    {
        if ( iswctype( wc, wctype( "lower" ) ))
           wprintf( L"The character %%lc is lowercase.\n", wc );
        if ( iswctype( wc, wctype( "upper" ) ))
           wprintf( L"The character %%lc is uppercase.\n", wc );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_localtime_s_ex">
			<text>
				<![CDATA[// gmtime_ex.c : gmtime() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <time.h>    // struct tm *localtime_s( const time_t * restrict timer,
                     //                         struct tm * restrict result);
#include <stdio.h>

int main()
{
    time_t now;    struct tm timeStruct;    char timeStr[26];

    time(&now);                           // Current time as an integer.

    // Convert to local time as a struct tm:
    if( localtime_s(&now, &timeStruct) != NULL)
    {
        timeStruct.tm_year += 1;          // One year later.
        if( asctime_s( timeStr, sizeof(timeStr), &timeStruct) == 0)
            printf("A year from today: %%s", timeStr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log1p_ex">
			<text>
				<![CDATA[// log1p_ex.c : log1p() example
// -------------------------------------------------------------

#include <math.h>    // double log1p( double x )
                     // float log1pf( float x )
                     // long double log1pl( long double x )
#include <stdio.h>

// atanh(x) is defined as 0.5 * ( log(x+1) - log(-x+1).
// Rounding errors can result in different results
// for different methods.

int main()
{
    puts("   x         atanh(x)    atanh(x) - 0.5*(log1p(x) - log1p(-x))\n"
         "--------------------------------------------------------------");
    for ( double x = -0.8; x < 1.0; x += 0.4)
    {
       double y = atanh(x);
       printf("%%6.2f %%14f %%20E\n", x, y, y - 0.5*(log1p(x) - log1p(-x)) );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log2_ex">
			<text>
				<![CDATA[// log2_ex.c : log2() example
// -------------------------------------------------------------

#include <math.h>    // double log2( double x )
                     // float log2f( float x )
                     // long double log2l( long double x )
#include <errno.h>
#include <stdio.h>

int main()
{
    double x[] = { 0, 0.7, 1.8, 1234, INFINITY };

    for ( int i = 0; i < sizeof( x ) / sizeof( double ); i++ )
    {
        errno = 0;
        printf( "The base 2 log of  %%.1f is %%.3f.\n", x[i], log2( x[i] ) );
        if ( errno == EDOM || errno == ERANGE )
           perror( __FILE__ );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log_ex">
			<text>
				<![CDATA[// log_ex.c : log() example
// The following code prints some sample values for base 2, 
// base e, and base 10 logarithms.
// -------------------------------------------------------------

#include <math.h>    // double log( double x )
                     // float logf( float x )
                     // long double logl( long double x )
#include <stdio.h>

int main()
{
    double x[] = { 1E-100, 0.5, 2, exp(1), 10, 1E+100 };

    puts("       x           log2(x)            log(x)          log10(x)\n"
         " ---------------------------------------------------------------");
    for ( int i = 0; i < sizeof(x) / sizeof(x[0]); ++i )
    {
        printf("%%#10.3G %%+17.10G %%+17.10G %%+17.10G\n",
                x[i], log2(x[i]), log(x[i]), log10(x[i]) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_logb_ex">
			<text>
				<![CDATA[// logb_ex.c : logb() example
// -------------------------------------------------------------

#include <math.h>    // double logb( double x )
                     // float logbf( float x )
                     // long double logbl( long double x )
#include <errno.h>
#include <stdio.h>

int main()
{
    double x[] = { 0, 0, 0.7, 1.8, 1234, INFINITY };

    x[1] = nextafter( 0.0, 1.0 );

    for ( int i = 0; i < sizeof( x ) / sizeof( double ); i++ )
    {
        errno = 0;
        printf( "The exponent in the binary representation of %%g is %%g.\n",
                x[i], logb( x[i] ) );
        if ( errno == EDOM || errno == ERANGE )
           perror( __FILE__ );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_malloc_ex">
			<text>
				<![CDATA[// malloc_ex.c : malloc() example
// -------------------------------------------------------------

#include <stdlib.h>    // void *malloc( size_t size );
#include <stdio.h>
#include <string.h>
//#include <errno.h>

int main()
{
    struct linelink { char *line;
                      struct linelink *next;
    };
    struct linelink *head = NULL, *tail = NULL;

    char buffer[2048];
    FILE *fp_in;

    /* ... 0pen input file ... */
    char filename[] = "malloc.txt";
    if ((fp_in = fopen( filename, "r")) == NULL)
       perror( "Opening input file" );

    while ( NULL != fgets(buffer, sizeof(buffer), fp_in ))
    {
        if ( head == NULL )    /* Chain not yet started; add first link */
        {
            head = tail = malloc( sizeof(struct linelink));
            if ( head != NULL )
            {
               head->line = malloc( strlen( buffer ) + 1 );
               if ( head->line != NULL )
               {  strcpy( head->line, buffer);  head->next = NULL; }
               else
               {  fprintf( stderr, "Out of memory\n" ); return -1; }
            }
            else
            {  fprintf( stderr, "Out of memory\n" ); return -1; }
         }
         else          /* Chain already started; add another link ... */
         {
             puts( "Adding another link ...");
             /* ... */ 
             break;
         }
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mblen_ex">
			<text>
				<![CDATA[// mblen_ex.c : mblen() example
// -------------------------------------------------------------

#include <stdlib.h>   // int mblen( const char *s, size_t maxsize );
#include <wchar.h>
#include <string.h>

size_t mbsrcat( char * restrict s1, char * restrict s2,
                mbstate_t * restrict p_s1state, size_t n )
/* mbsrcat: multibyte string restartable concatenation.
 * Appends s2 to s1, respecting final shift state of destination string,
 * indicated by *p_s1state. String s2 must start in the initial shift
 * state.
 * Returns: number of bytes written, or (size_t)-1 on encoding error.
 * Max. total length (incl. terminating null byte) is <= n;
 * stores ending state of concatenated string in *s1state.
 */
{
   int result;
   size_t i = strlen( s1 );
   size_t j = 0;

   if ( i >= n - (MB_CUR_MAX+1))   // Sanity check: room for 1 multibyte
                                   // char + string terminator.
      return 0;                    // Report 0 bytes written.

   // Shift s1 down to initial state:

   if ( !mbsinit( p_s1state ))     // If not initial state, then append
   {                               // shift sequence to get initial state.
      if ( ( result = wcrtomb( s1+i, L'\0', p_s1state )) == -1 )
      {                            // Encoding error:
         s1[i] = '\0';             // Try restoring termination.
         return (size_t)-1;        // Report error to caller.
      }
      else
        i += result;
   }

   // Copy only whole multibyte characters at a time.
   // Get length of next char w/o changing state:
   while (( result = mblen( s2+j, MB_CUR_MAX )) <= (n - ( 1 + i )) )
   {
      if ( result == 0 ) break;
      if ( result == -1 )
      {                        // Encoding error:
         s1[i] = '\0';         // Terminate now.
         return (size_t)-1;    // Report error to caller.
      }
      // Next character fits; copy it and update state:
      strncpy( s1+i, s2+j, mbrlen( s2+j, MB_CUR_MAX, p_s1state ));
      i += result;
      j += result;
   }
   s1[i] = '\0';
   return j;
}

#include <locale.h>
#include <stdio.h>

int main()
{
   if( setlocale(LC_ALL, "") == NULL)
      fputs("Unable to set the locale.\n", stderr);
   printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

   char str1[100] = "";
   mbstate_t mbstate = {0};
   size_t nChars = 0;

   nChars = mbsrcat( str1, "groÃŸe ", &mbstate, sizeof(str1) );
   if( (int)nChars < 0)
   {   fputs("Error ...", stderr);  return -1;  }
   printf("%%zu characters.\n", nChars);

   nChars = mbsrcat( str1, "FÃ¼ÃŸe", &mbstate, sizeof(str1) );
   if( (int)nChars < 0)
   {   fputs("Error ...", stderr);  return -1;  }
   printf("%%zu characters.\n", nChars);

   puts( str1);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbrtoc16_ex">
			<text>
				<![CDATA[// mbrtoc16_ex.c : mbrtoc16() example
// -------------------------------------------------------------

#include <uchar.h>     // size_t mbrtoc16( char16_t * restrict pc16,
                       //                  const char * restrict s,
                       //                  size_t n, 
                       //                  mbstate_t * restrict state );
//#include <stdlib.h>
#include <string.h>

// The function mbsToC16s() uses mbrtoc16() to convert a string of
// multibyte characters into a string of 16-bit characters
// (typically in UTF-16 encoding).
// Return value: the number of char16_t characters produced, or
//               -1 if an error occurred.

int mbsToC16s( const char *mbStr, char16_t *c16Str, size_t len)
{
   if( mbStr == NULL || c16Str == NULL || len == 0)   // Sanity checks.
      return -1;

   mbstate_t mbstate = {0};
   char16_t c16;
   int count = 0, i = 0, rv = 0,
       nBytes = (int)strlen(mbStr)+1;

   do {
      rv = (int)mbrtoc16( &c16, mbStr+i, nBytes-i, &mbstate);
      switch( rv)
      {
        case 0:  c16Str[count] = 0; i = nBytes;   // End of string.
                 break;
        case -1:                                  // Encoding error.
        case -2: count = -1;
                 break;
        default:
           if( count < (int)len-1 )
           {
              c16Str[count++] = c16;
              if( rv > 0) i += rv;                // rv != -3
           }
           else count = -1;
      }
   } while( count > 0 && i < nBytes);

   return count;
}

#include <locale.h>
#include <stdio.h>

int main(void)
{
   if( setlocale(LC_ALL, "en_US.utf8") == NULL)
      fputs("Unable to set the locale.\n", stderr);

   char *u8Str = u8"GrÃ¼ÃŸe";
   char16_t c16Str[100];
   int nChars = 0;

   nChars = mbsToC16s( u8Str, c16Str, 100);
   if( nChars < 0)
      fputs("Error ...", stderr);
   else
   {
      printf("%%d UTF-16 characters.\n", nChars);
      // ...
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbrtowc_ex">
			<text>
				<![CDATA[// mbrtowc_ex.c : mbrtowc() example
// -------------------------------------------------------------

#include <wchar.h>    // size_t mbrtowc( wchar_t * restrict widebuffer,
                      //                 const char * restrict string,
                      //                 size_t maxsize, 
                      //                 mbstate_t * restrict state );
#include <wctype.h>
#include <stdlib.h>
#include <string.h>

size_t mbstoupper( char *s1, char *s2, size_t n )
/* Copies the multibyte string from s2 to s1, converting all the
   characters to uppercase on the way.
   Because there are no standard functions for case-mapping in multibyte
   encodings, converts to and from the wide-character encoding (using the
   current locale setting for the LC_CTYPE category). The source string
   must begin in the initial shift state.
   Returns: the number of bytes written;
            or (size_t)-1 on an encoding error.
*/
{
   char *inptr = s2, *outptr = s1;
   wchar_t thiswc[1];
   size_t inresult, outresult;

   mbstate_t states[2], *instate = &states[0], *outstate = &states[1];

   memset( states, '\0', sizeof states );

   do
   {
      inresult = mbrtowc( thiswc, inptr, MB_CUR_MAX, instate );
      switch ( inresult )
      {
      case (size_t)-2:     // The (MB_CUR_MAX) bytes at inptr do not make
                           // a complete mb character. Maybe there is a
                           // redundant sequence of shift codes. Treat the
                           // same as an encoding error.
         *outptr = '\0';
         return (size_t)-1;

      case (size_t)-1:     // Found an invalid mb sequence at inptr:
         return inresult;  // pass the error to the caller.

      case 0:              // Got a null character. Make a last null wc.
                           // The default action, with wcrtomb, does this
                           // nicely, so *no break statement* necessary here.

      default:             // Read <result> mb characters to get one wide
                           // character.
      /* Check for length limit before writing anything but a null.
         Note: Using inresult as an approximation for the output
         length.
         The actual output length could conceivably be different
         due to a different succession of state-shift sequences.
      */
      if (( outptr - s1 ) + inresult + MB_CUR_MAX > n )
      {   // i.e., if bytes written + bytes to write + termination > n,
          // then terminate now by simulating a null-character input.
         thiswc[0] = L'\0';
         inresult = 0;
      }
      inptr += inresult;
      if (( outresult = wcrtomb( outptr,
                                (wchar_t)towupper(thiswc[0]),
                                 outstate )) == -1 )
      {                               // Encoding error on output:
         *outptr = '\0';              // Terminate and return error.
         return outresult;
      }
      else
         outptr += outresult;
      }
   } while ( inresult );              // Drop out after handling '\0'.
   return outptr - s1;
}

#include <locale.h>
#include <stdio.h>

int main()
{
   if( setlocale(LC_ALL, "en_US.utf-8") == NULL)
      fputs("Unable to set the locale.\n", stderr);
   printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

   char strin[] = "GrÃ¼ÃŸe", strout[64];
   size_t nByte = 0;

   nByte = mbstoupper( strout, strin, 64 );

   if( (int)nByte < 0)
   {   fputs("Error ...", stderr);  return -1;  }

   puts( strout);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbsrtowcs_ex">
			<text>
				<![CDATA[// mbsrtowcs_ex.c : mbsrtowcs() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t mbsrtowcs( wchar_t * restrict dest, 
                     //                   const char ** restrict src,
                     //                   size_t n,
                     //                   mbstate_t * restrict state );
#include <string.h>
#include <locale.h>
#include <stdio.h>

int main()
{
   size_t result;

   char mbstring[ ] = "This is originally a multibyte string.\n";
   const char *mbsptr = mbstring;

   wchar_t widestring[256] = { L'\0' };

   mbstate_t state;
   memset( &state, '\0', sizeof state );

   printf( "The current locale is %%s.\n", setlocale( LC_CTYPE, "" ));

   result = mbsrtowcs( widestring, &mbsptr, 256, &state );
   if ( result == (size_t)-1 )
   {
      fputs( "Encoding error in multibyte string", stderr );
      return -1;
   }
   else
   {
      printf( "Converted %%u multibyte characters. The result:\n", result );
      printf( "%%ls", widestring );
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbsrtowcs_s_ex">
			<text>
				<![CDATA[// mbsrtowcs_s_ex.c : mbsrtowcs_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t mbsrtowcs_s(size_t * restrict retval,
                     //                     wchar_t * restrict dst,
                     //                     size_t dstmax,
                     //                     const char ** restrict src,
                     //                     size_t n,
                     //                     mbstate_t * restrict state );
#include <stdio.h>

int main()
{
    const char *mbptr = "Any multibyte string";
    wchar_t wcstr[10];            // A buffer for wide characters
    size_t len;                   // and its capacity.
    mbstate_t state = {0};

    if( mbsrtowcs_s( &len, wcstr, 10, &mbptr, 9, &state) != 0)
        printf("The array contains an invalid multibyte character.\n");
    else
    {
       printf("Length: %%zu; text: %%ls\n", len, wcstr);
       printf("The remaining characters: %%s\n", mbptr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbtowc_ex">
			<text>
				<![CDATA[// mbtowc_ex.c : mbtowc() example
// -------------------------------------------------------------

#include <stdlib.h>   // int mbtowc( wchar_t * restrict wc,
                      //             const char * restrict s,
                      //             size_t maxsize );
#include <locale.h>
#include <stdio.h>

int main()
{
    int i = 0, n = 0;
    wchar_t wc;
    char mbstring[256] = "This is originally a multibyte string.\n";

    printf( "The current locale is %%s.\n", setlocale(LC_CTYPE, "" ));
    while ( (n = mbtowc( &wc, &mbstring[i], MB_CUR_MAX )) != 0 )
    {
        if ( n == -1 )
        {
           fputs( "Encoding error in multibyte string", stderr );
           break;
        }
        printf( "%%lc", (wint_t)wc );
        i += n;
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mktime_ex">
			<text>
				<![CDATA[// mktime_ex.c : mkctime() example
// -------------------------------------------------------------

#include <time.h>    // time_t mktime( struct tm *timeptr );
#include <stdio.h>

int main()
{
    time_t seconds;
    struct tm sometime;

    sometime.tm_sec   = 10;
    sometime.tm_min   = 80;
    sometime.tm_hour  = 40;
    sometime.tm_mday  = 23;
    sometime.tm_mon   = 1;
    sometime.tm_year  = 105;
    sometime.tm_wday  = 11;
    sometime.tm_yday  = 111;
    sometime.tm_isdst = -1;

    seconds = mktime( &sometime );

    if ( seconds == -1 )
    {
        printf( "mktime() couldn't make sense of its input.\n" );
        return -1;
    }

    printf( "The return value, %%ld, represents %%s",
            (long)seconds, ctime(&seconds) );

    printf( "The structure has been adjusted as follows:\n"
            "tm_sec   == %%d\n"
            "tm_min   == %%d\n"
            "tm_hour  == %%d\n"
            "tm_mday  == %%d\n"
            "tm_mon   == %%d\n"
            "tm_year  == %%d\n"
            "tm_wday  == %%d\n"
            "tm_yday  == %%d\n"
            "tm_isdst == %%d\n",

            sometime.tm_sec,
            sometime.tm_min,
            sometime.tm_hour,
            sometime.tm_mday,
            sometime.tm_mon,
            sometime.tm_year,
            sometime.tm_wday,
            sometime.tm_yday,
            sometime.tm_isdst );

    printf( "The structure now represents %%s", asctime( &sometime ));
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mtx_timedlock_ex">
			<text>
				<![CDATA[// mtx_timedlock_ex.c : mtx_timedlock() example
// -------------------------------------------------------------

#include <threads.h>   // int mtx_timedlock( mtx_t *restrict mtx,
                       //                    const struct timespec *restrict ts);
#include <stdio.h>

mtx_t mtx;
int func(void * thrd);                   // Thread function.

int main()
{
    thrd_t th;
    if( mtx_init(&mtx, mtx_timed) != thrd_success)
    { fputs("Initialization error.\n", stderr); return 1; }

    mtx_lock(&mtx);                      // Lock the mutex.
    if( thrd_create(&th, func, "Thread A") != thrd_success)
    { fputs("Thread error.\n", stderr); return 2; }

    thrd_join(th, NULL);
    mtx_destroy( &mtx);
    return 0;
}

int func(void * thrd)
{
    struct timespec ts;
    timespec_get( &ts, TIME_UTC);        // The current time;
    ts.tv_sec += 3;                      // 3 seconds from now.

    printf("%%s waiting ...\n", (char*)thrd);
    int res = mtx_timedlock(&mtx, &ts);
    switch(res)
    {
        case thrd_success:
           puts("Obtained mutex\n... releasing ...");
           mtx_unlock(&mtx);   break;
        case thrd_timedout:
           puts("Timed out.");   break;
        default:
           puts("mtx_timedlock: error.");
    };
    return res;
}
]]>
			</text>
		</p>
		<p n="xc_mtx_trylock_ex">
			<text>
				<![CDATA[// mtx_trylock_ex.c : mtx_trylock() example
// -------------------------------------------------------------

#include <threads.h>   // int mtx_trylock( mtx_t *mtx);
#include <stdio.h>

#define NUM_THREADS 3
mtx_t mtx;

struct timespec duration = { .tv_nsec = 1 };   // One nanosecond.
int func(void * thrd_num)                      // Thread function.
{
    int num = *(int*)thrd_num;
    int res, count = 1;

    while( (res = mtx_trylock(&mtx)) == thrd_busy)
    { ++count;  thrd_sleep( &duration, NULL); }

    if( res == thrd_success)
    {
       printf("Thread %%d succeeded after %%d attempts.\n", num, count);
       thrd_sleep( &duration, NULL);
       mtx_unlock(&mtx);
       return 0;
    }
    else return -1;
}
int main(void)
{
    struct { thrd_t th; int id; } th_arr[NUM_THREADS];

    if( mtx_init(&mtx, mtx_plain) != thrd_success)
       return 1;

    // Create threads:
    for( int i = 0; i < NUM_THREADS; ++i)
    {
       th_arr[i].id = i;
       if( thrd_create( &th_arr[i].th, func, &th_arr[i].id) 
           != thrd_success)
          return -2;
    }
    // Wait for threads to finish:
    for( int i = 0; i < NUM_THREADS; ++i)
     thrd_join( th_arr[i].th, NULL);

    mtx_destroy( &mtx);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_nearbyint_ex">
			<text>
				<![CDATA[// nearbyint_ex.c : nearbyint() example
// -------------------------------------------------------------

#include <math.h>    // double nearbyint( double x );
                     // float nearbyintf( float x );
                     // long double nearbyintl( long double x );
#include <fenv.h>
#include <stdio.h>

int main()
{
    if ( fesetround( FE_TOWARDZERO) == 0)
       printf("The current rounding mode is \"round toward 0.\"\n");
    else
       printf("The rounding mode is unchanged.\n");

    printf( "nearbyint(1.9) = %%4.1f    nearbyint(-1.9) = %%4.1f\n",
            nearbyint(1.9), nearbyint(-1.9) );

    printf( "round(1.9) = %%4.1f        round(-1.9) = %%4.1f\n",
            round(1.9), round(-1.9) );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_perror_ex">
			<text>
				<![CDATA[// perror_ex.c : perror() example
// -------------------------------------------------------------

#include <stdio.h>      // void perror( const char *string );
#include <errno.h>

#define MSGLEN_MAX 256

int main( int argc, char *argv[] )
{
    FILE *fp;
    char msgbuf[MSGLEN_MAX] = "";

    if (( fp = fopen( "nonexistentfile", "r" )) == NULL )
    {
       snprintf( msgbuf, MSGLEN_MAX, "%%s, function %%s, file %%s, line %%d",
                 argv[0], __func__, __FILE__, __LINE__ );
       perror( msgbuf );
       return errno;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_printf_ex">
			<text>
				<![CDATA[// printf_ex.c : printf() example
// -------------------------------------------------------------

#include <stdio.h>      // int printf( const char * restrict format, ... );
#include <math.h>
#include <assert.h>

void print_line( double x);

int main()
{
    double pi = 3.1415926;
    double bignumber = 8 * 8 * 8 * pi * pi * pi;
    printf("512 times pi cubed equals %%.2e, or %%.2a.\n",
                                      bignumber, bignumber);

    print_line( 11.22);
    return 0;
}

// The print_line function illustrates the use of the %%n conversion specification
// to count the characters in the output string:
void print_line( double x)
{
    int n1, n2;
    printf("x = %%5.2f exp(x) = %%n%%10.5f%%n\n", x, &n1, exp(x), &n2);
    assert( n2-n1 <= 10);           // Did printf() stretch the field width?
}
]]>
			</text>
		</p>
		<p n="xc_putchar_ex">
			<text>
				<![CDATA[// putchar_ex.c : putchar() example
// -------------------------------------------------------------

// The following example reads the beginning of a file repetitively,
// and reports its progress on stdout.

#include <stdio.h>      // int putchar( int c );

int main()
{
    long count; const long CYCLES = 5000;
    char readback[1024];

    FILE *fp = fopen( "infile.txt", "r" );
    if( fp == NULL)
    { fprintf( stderr, "Couldn't open input file.\n" ); return -1; }

    for (count = 0; count <= CYCLES; ++count)
    {
      /* Start output with '\r' to re-use same screen line. */
       printf( "\rPerformed %%li file reads. ", count );

       rewind( fp );
       fgets( readback, 1024, fp );

      /* Scroll a new screen line every hundred cycles. */
       if (count %% 100 != 0) continue;
       putchar( '\n' );
    }
    puts( "Done." );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_qsort_ex">
			<text>
				<![CDATA[// qsort_ex.c : qsort() example
// -------------------------------------------------------------

#include <stdlib.h>
         // void qsort( void *array, size_t n, size_t size,
         //             int (*compare)( const void *, const void *) );

#include <stdio.h>

int strptrcmp( const void *sp1, const void *sp2 );

int main()
{
    char *words[] = { "Then", "he", "shouted", "What", "I",
                      "didn't", "hear", "what", "you", "said" };

    int n = sizeof(words) / sizeof(char *);

    qsort( words, n, sizeof(char *), strptrcmp );

    for ( int j = 0 ; j < n ; j++ )
        puts( words[j] );
}

#include <string.h>

int strptrcmp( const void *sp1, const void *sp2 )
// Compare two strings by reference.
{
    // qsort() passes a pointer to the pointer:
    // dereference it to pass a char * to strcmp.
    const char * s1 = *(char **)sp1;
    const char * s2 = *(char **)sp2;
    return strcmp( s1, s2 );
}
]]>
			</text>
		</p>
		<p n="xc_rand_ex">
			<text>
				<![CDATA[// rand_ex.c : rand() example
// -------------------------------------------------------------

#include <stdlib.h>       // int rand( void );
#include <time.h>
#include <ctype.h>
#include <stdio.h>

int main()
{
    printf( "Think of a number between one and twenty.\n"
            "Press Enter when you're ready." );
    getchar();

    srand( (unsigned)time( NULL ) );
    for ( int i = 0; i < 3; i++ )     // We get three guesses.
    {
        printf( "Is it %%u? (y or n) ", 1 + rand() %% 20 );
        if ( tolower( getchar() ) == 'y' )
        {
            printf( "Ha! I knew it!\n" );
            exit( 0 );
        }
        getchar();                     // Discard newline character.
    }
    printf( "I give up.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="ex_realloc_ex">
			<text>
				<![CDATA[// realloc_ex.c : realloc() example
// -------------------------------------------------------------

#include <stdlib.h>       // void *realloc( void *ptr, size_t n );
#include <stdio.h>

int main()
{
    typedef struct { int len;
                     float array[];
                   } DynArray_t;

    DynArray_t *daPtr = malloc( sizeof(DynArray_t) + 10*sizeof(float) );
    if ( daPtr == NULL ) return -1;

    daPtr->len = 10;

    for ( int i = 0; i < daPtr->len; ++i )
        daPtr->array[i] = 1.0F/(i+1);

    /* daPtr->array[10] = 0.1F               // Invalid array index! */

    DynArray_t *daResizePtr = realloc( daPtr,
                                       sizeof(DynArray_t) + 11*sizeof(float));
    if ( daResizePtr != NULL )
    {
       daPtr = daResizePtr ;
       daPtr->len = 11;
       daPtr->array[10] = 0.1F / 12;         // OK now.
    }
    else
    {
       /* We'll just have to get along with the array of 10 floats.
       ...   */
       return -1;
    }
      
    for ( int i = 0; i < daPtr->len; ++i )
        printf( "%%2d : %%8f\n", i, daPtr->array[i] );
    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remainder_ex">
			<text>
				<![CDATA[// remainder_ex.c : remainder() example
// -------------------------------------------------------------

#include <math.h>   // double remainder( double x, double y );
                    // float remainderf( float x, float y );
                    // long double remainderl( long double x, long double y );
#include <stdio.h>

int main()
{
    double apples = 0.0, people = 0.0, share = 0.0, left = 0.0;

    printf( "\nHow many people? ");
    scanf( "%%lf", &people );

    printf( "\nHow many apples? ");
    scanf( "%%lf", &apples );

    left = remainder( apples, people );     // left may be negative!
    share = ( apples - left ) / people;

    printf( "If there are %%.1lf of us and %%.1lf apples, "
            "each of us gets %%.1lf of %%s, with %%.1lf left over.\n",
             people, apples, share, ( share < 1 ) ? "one" : "them", left );
    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remove_ex">
			<text>
				<![CDATA[// remove_ex.c : remove() example
// -------------------------------------------------------------

#include <stdio.h>     // int remove( const char *filename );
#include <errno.h>

int main()
{
    char fname_tmp[L_tmpnam] = "";
    FILE *fp;
    int result;

    tmpnam( fname_tmp );
    fp = fopen( fname_tmp, "w+" );
    if( fp == NULL)
    {  fprintf(stderr, "Couldn't open file \"%%s\".\n", fname_tmp);
       return -1;
    }

    /* ... write something in the file, edit it ... */
    fputs( "hello ...\n", fp);

    fclose( fp );

    result = rename( fname_tmp, "finished.txt" );
    if ( result )     // Delete previous "finished.txt" and try again.
    {
        remove( "finished.txt" );
        result = rename( fname_tmp, "finished.txt" );
        if ( result )                   // Give up and log the error.
           fprintf( stderr, "Error %%d on trying to rename output file\n",
                                                                   errno );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remquo_ex">
			<text>
				<![CDATA[// remquo_ex.c : remquo() example
// -------------------------------------------------------------

#include <math.h>   // double remquo( double x, double y, int *quo );
                    // float remquof( float x, float y, int *quo );
                    // long double remquol( long double x, long double y,
                    //                      int *quo );
#include <stdio.h>

int main()
{
    double apples = 0.0, people = 0.0, left = 0.0, share = 0.0;
    int quotient = 0;

    printf( "\nHow many people? ");
    scanf( "%%lf", &people );

    printf( "\nHow many apples? ");
    scanf( "%%lf", &apples );

    share = nearbyint( apples / people );
    left = remquo( apples, people, &quotient );    

    printf( "If there are %%.2lf of us and %%.2lf apples, "
            "each of us gets %%.2lf apple%%s, with %%.2lf left over.\n",
            people, apples, share, ( share == 1 ) ? "" : "s", left );

    printf( "remquo() stored %%d as the quotient "
            " of the division (modulo 8).\n", quotient );

    printf( "Test: share modulo 8 - quotient = %%d\n",
            (int) share %% 8 - quotient );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_rewind_ex">
			<text>
				<![CDATA[// rewind_ex.c : rewind() example
// This example prints the contents of a file twice, converting 
// each character to lowercase the first time through, and to 
// uppercase the second time:
// -------------------------------------------------------------

#include <stdio.h>   // void rewind( FILE *fp );
#include <stdlib.h>
#include <ctype.h>

int main( int argc, char *argv[])
{
    FILE *fp; int c;

    if ( argc != 2 )
       printf( "Usage: program input-file\n"), exit(1);

    if (( fp = fopen( argv[1], "r" )) == NULL )
        fprintf( stderr, "Failed to open file %%s\n", argv[1] );
    else
    {
        puts( "Contents of the file in lowercase:" );
        while (( c = fgetc( fp )) != EOF )
            putchar( tolower( c ));

        rewind( fp );

        puts( "Same again in uppercase:" );
        while (( c = fgetc( fp )) != EOF )
            putchar( toupper( c ));

       fclose( fp );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_rint_ex">
			<text>
				<![CDATA[// rint_ex.c : rint() example
// -------------------------------------------------------------

#include <math.h>    // double rint( double x );
                     // float rintf( float x );
                     // long double rintl( long double x );
#include <fenv.h>
#include <stdio.h>

struct round_modes { int id; char *str; } arrModes[ ] =
{
 #ifdef FE_TONEAREST
   { FE_TONEAREST,
     "FE_TONEAREST: round to nearest representable value" },
 #endif
 #ifdef FE_DOWNWARD
    { FE_DOWNWARD, "FE_DOWNWARD: round toward -Inf" },
 #endif
 #ifdef FE_UPWARD
   { FE_UPWARD, "FE_UPWARD: round toward +Inf" },
 #endif
 #ifdef FE_TOWARDZERO
   { FE_TOWARDZERO, "FE_TOWARDZERO: round toward 0" }
 #endif
};

int main()
{
    int nModes = sizeof( arrModes) / sizeof(*arrModes);

    #pragma STDC FENV_ACCESS ON

    for ( int i = 0; i < nModes; ++i)
    {
        if ( fesetround( arrModes[i].id) != 0)
           break;
        printf( "Rounding mode: %%s\n", arrModes[i].str );

        printf( "rint(1.4)  = %%4.1f    rint(1.5)  = %%4.1f\n",
                rint(1.4), rint(1.5) );
        printf( "rint(-1.4) = %%4.1f    rint(-1.5) = %%4.1f\n",
                rint(-1.4), rint(-1.5) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_cacukate">
			<text>
				<![CDATA[// calculate.c: Perform some calculations.
// Functions: calculate1(), calculate2().
// -------------------------------------------------------------

#include <math.h>
#include <setjmp.h>
#include <errno.h>

extern jmp_buf jmp_dest;             // Destination for longjmp()

double calculate1( double x)
{
    if ( x < 0)
        longjmp( jmp_dest, EDOM);    // Domain error
    else
        return sqrt(x);
}

double calculate2( double x)
{
    double y = exp(x);
    if ( y == HUGE_VAL)
        longjmp( jmp_dest, ERANGE);  // Range error
    else
        return y;
}
]]>
			</text>
		</p>
		<p n="sc_set_constraint_handler_s_ex">
			<text>
				<![CDATA[// set_constraint_handler_s_ex.c : set_constraint_handler_s() example
// -------------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // constraint_handler_t set_constraint_handler_s(
                     //                      constraint_handler_t handler);
#include <errno.h>
#include <string.h>
#include <stdio.h>

// Use a custom handler:
void myConstraintHandler(const char* msg, void * ptr, errno_t error)
{
    printf("A runtime constraint violation "
           "occurred: \n%%s; ", msg);
    printf("error code: %%d\n", error);  fflush(stdout);
    exit(error);
}

void func( const char *str)
{
    constraint_handler_t prevHandler =
               set_constraint_handler_s(myConstraintHandler);
    printf_s("The argument: %%s\n", str);        // Error if str
                                                // is a null pointer.
    int len = strlen(str);
    char str2[len];
    strcpy_s( str2, len, str);    // Error: str2 is one byte too short.
    // . . .
    set_constraint_handler_s(prevHandler);
}

int main()
{
    func("Hi");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_set_constraint_handler_s_ex">
			<text>
				<![CDATA[// set_constraint_handler_s_ex.c : set_constraint_handler_s() example
// -------------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // constraint_handler_t set_constraint_handler_s(
                     //                      constraint_handler_t handler);
#include <errno.h>
#include <string.h>
#include <stdio.h>

// Use a custom handler:
void myConstraintHandler(const char* msg, void * ptr, errno_t error)
{
    printf("A runtime constraint violation "
           "occurred: \n%%s; ", msg);
    printf("error code: %%d\n", error);  fflush(stdout);
    exit(error);
}

void func( const char *str)
{
    constraint_handler_t prevHandler =
               set_constraint_handler_s(myConstraintHandler);
    printf_s("The argument: %%s\n", str);        // Error if str
                                                // is a null pointer.
    int len = strlen(str);
    char str2[len];
    strcpy_s( str2, len, str);    // Error: str2 is one byte too short.
    // . . .
    set_constraint_handler_s(prevHandler);
}

int main()
{
    func("Hi");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_setjmp_ex">
			<text>
				<![CDATA[// setjmp_ex.c : setjmp() - longjmp() example
// -------------------------------------------------------------

#include <setjmp.h>       // int setjmp( jmp_buf env );
                          // void longjmp( jmp_buf environment,
                          //               int returnval );
#include <stdlib.h> 
#include <stdio.h>
#include <errno.h>

double calculate1( double x);     // Functions defined
double calculate2( double x);     // in calculate.c.

jmp_buf jmp_dest;                 // Destination for longjmp()

int main()
{
    double x = 0, y1, y2;
    int n = 0;

    puts("--- Demonstrating non-local jumps ---\n");

    switch( setjmp( jmp_dest)) // Jump to here for error handling
    {
    case 0:                    // The original setjmp() call
        break;
    case EDOM:                 // Arrived via longjmp() call with EDOM
        puts("Domain error. "
             "Negative numbers are not permitted.");
        break;
    case ERANGE:               // Arrived via longjmp() call with ERANGE
        puts("Range error. "
             "The number you entered is too big.");
        break;
    default:                   // We should never arrive here.
        puts("Unknown error.");
        exit( EXIT_FAILURE );
    }

    printf("Enter a number: ");
    do
    {
        if ( (n = scanf("%%lf", &x)) < 0)  // Read in a number.
           exit( EXIT_FAILURE );          // Read end of file.
        while ( getchar() != '\n')        // Clear the input buffer.
          ;
        if ( n == 0 )
           printf("Invalid entry. Try again: ");
    }while ( n == 0 );

    y1 = calculate1(x);
    y2 = calculate2(x);

    printf("\nResult of Calculation 1: %%G\n", y1);
    printf(  "Result of Calculation 2: %%G\n", y2);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_setlocale_ex">
			<text>
				<![CDATA[// setlocale_ex.c : setlocale() example
// -------------------------------------------------------------

#include <locale.h>    // char *setlocale( int category, 
                       //                  const char *locale_name );
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_STRING 80

int main()
{
    char name[MAX_STRING];
    char locale[MAX_STRING];
    char *newlocale;
    int i;

    printf( "Who are you? " );
    fgets( name, sizeof(name), stdin );

    printf( "What is your locale? " );
    fgets( locale, sizeof(locale), stdin );

    name[ strlen(name) - 1 ] = '\0';     // Chomp off the newlines.
    locale[ strlen(locale) - 1 ] = '\0';

    newlocale = setlocale( LC_CTYPE, locale );
    if ( newlocale == NULL )
       printf( "Sorry, couldn't change the locale to %%s.\n"
               "The current locale is %%s. ",
               locale, setlocale( LC_CTYPE, NULL ));
    else
        printf( "The new locale is %%s. ", newlocale );

    name[0] = toupper( name[0] );   // Force the first letter to uppercase.

    i = 1;
    if ( isupper( name[i] ) )       // Is the second letter also uppercase?
    {
       while ( name[i] != '\0' )    // If so, force all the rest to lowercase.
       {
          name[i] = tolower( name[i] );
          ++i;
       }
    }
    printf( "Hello there, %%s!\n", name );

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_signal_ex">
			<text>
				<![CDATA[// signal_ex.c : signal() example
// -----------------------------------------------------------------------

#include <signal.h>   // void ( *signal( int sig, void (*handler)(int) ) )(int);
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdint.h>   // Defines SIG_ATOMIC_MAX

void sigint_handler(int sig);
volatile sig_atomic_t i;   // A counter accessed by main and the
                           // handler.

int main()
{
    if ( signal( SIGINT, sigint_handler ) == SIG_ERR )
    {
        perror("Failed to install SIGINT handler");
        exit(3);
    }

    while (1)
    {
        puts( "Press Ctrl+C to interrupt me.");
        for ( i = 0 ; i < SIG_ATOMIC_MAX ; i++ )
            if ( i %% 100000 == 0)
            {
                printf( "\r%%d ", i / 100000 );
                fflush( stdout );
            }
        raise( SIGINT );   // Simulate a Ctrl+C in case the user didn't
                           // type it.
    }
    return 0;
}

void sigint_handler( int sig )
{
    int c = 0;

    if ( sig != SIGINT ) exit( 1 );

    signal( SIGINT, SIG_IGN );         // Ignore a second Ctrl+C

    puts( "\nThis is the function sigint_handler()."
          "\nDo you want to exit the program now? [y/n]");
    while (( c = tolower( getchar( ) )) != 'y' && c != 'n' && c != EOF )
      ;

    if ( c != 'n' )
       exit(0);
    else
       i = 0;                          // Reset timer

    signal( SIGINT, sigint_handler );  // Reinstall this handler.

    /* No return value; just fall off the end of the function. */
}
]]>
			</text>
		</p>
		<p n="xc_signb_ex">
			<text>
				<![CDATA[// signbit_ex.c : signbit() example
// -------------------------------------------------------------

#include <math.h>   // int signbit(x );
#include <stdio.h>

int main()
{
    double x[ ] = { -0.0, 187.234, sqrt( -1.0 ), 1.0 / -0.0 };

    for ( int i = 0 ; i < ( sizeof(x) / sizeof(double)) ; i++ )
        printf( "x[%%d] equals %%lF, and is%%s negative.\n",
                 i, x[i], signbit( x[i] ) ? "" : " not" );    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sin_ex">
			<text>
				<![CDATA[// sin_ex.c : sin() example
// -------------------------------------------------------------

#include <math.h>    // double sin( double x );
                     // double sinf( float x );
                     // long double sinl( long double x );
#include <stdio.h>
#include <stdlib.h>

#define DEG_PER_RAD ( 180.0 / PI )

int main()
{
    const double PI = 4.0 * atan( 1.0 );
    double a[4];

    printf( "\nEnter an acute angle measure, in degrees: " );

    if ( scanf( "%%lf", a ) < 1 || ( a[0] <= 0 || a[0] >= 90 ) )
        printf( "\nThat's not an acute angle.\n" ), exit( 1 );
    else
    {
        a[1] = a[0] + 90 ;
        a[2] = 180 - a[0] ;
        a[3] = 225 + a[0] ;

        for ( int i = 0 ; i < 4 ; i ++ )
            printf( "The sine of %%6.2lf degrees is %%6.4lf.\n",
                    a[i], sin( a[i] / DEG_PER_RAD ) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sinh_ex">
			<text>
				<![CDATA[// sinh_ex.c : sinh() example
// -------------------------------------------------------------

#include <math.h>    // double sinh( double x );
                     // double sinhf( float x );
                     // long double sinhl( long double x );
#include <stdio.h>

// A chain hanging from two points forms a curve called a catenary.
// A catenary is a segment of the graph of the function
// cosh(k*x)/k, for some constant k.
// The length along the catenary over a certain span, bounded by the
// two vertical lines at x=a and x=b, is equal to
// sinh(k*b)/k - sinh(k*a)/k.

int main()
{
    double x, k;

    puts("Catenary f(x) = cosh(k*x)/k\n"
         "Length along the catenary from a to b: "
         "sinh(k*b)/k - sinh(k*a)/k)\n");

    puts("            f(-1.0)  f(0.0)   f(1.0)   f(2.0)   Length(-1.0 to 2.0)\n"
         "-------------------------------------------------------------------");
    for ( k = 0.5; k < 5; k *= 2)
    {
        printf("k = %%.1f: ", k);
        for ( x = -1.0; x < 2.1; x += 1.0)
           printf("%%8.2f ", cosh(k*x)/k );

        printf(" %%12.2f\n", (sinh(2*k) - sinh(-1*k))/ k);
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_snprintf_ex">
			<text>
				<![CDATA[// snprintf_ex.c : snprintf() example
// -------------------------------------------------------------

#include <stdio.h>   // int snprintf( char * restrict dest, size_t n,
                     //               const char * restrict format, ... );

int main()
{
    char buffer[80];
    double x = 1234.5, y = 678.9, z = -753.1, a = x * y + z;
    int output_len = 0;

    output_len = snprintf( buffer, 80, "For the input values %%lf, %%lf,"
                           " and %%lf,\nthe result was %%lf.\n",
                           x, y, z, a );
    puts( buffer );
    if ( output_len >= 80 )
       fprintf( stderr, "Output string truncated! Lost %%d characters.\n",
                output_len - 79 );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sprintf_ex">
			<text>
				<![CDATA[// sprintf_ex.c : sprintf() example
// -------------------------------------------------------------

#include <stdio.h>   // int sprintf( char * restrict dest, 
                     //              const char * restrict format, ... );

int main()
{
    char buffer[80];
    double x = 1234.5, y = 678.9, z = -753.1, a = x * y + z;
    int output_len = 0;

    output_len = sprintf( buffer, "For the input values %%lf, %%lf, and %%lf,"
                          "\nthe result was %%lf.\n",
                          x, y, z, a );
    puts( buffer );
    if ( output_len >= 80 )
       fprintf( stderr, "Output string overflowed by %%d characters.\n"
                "The variables x, y, z and a may have been corrupted:\n"
                "x now contains %%lf, y %%lf, z %%lf, and a %%lf.\n",
                 output_len - 79, x, y, z, a );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sqrt_ex">
			<text>
				<![CDATA[// sqrt_ex.c : sqrt() example
// -------------------------------------------------------------

#include <math.h>    // double sqrt( double x );
                     // double sqrtf( float x );
                     // long double sqrtl( long double x );
#include <stdio.h>
#include <errno.h>

int main()
{
    double x[ ] = { 0.5, 0.0, -0.0, -0.5 };

    for ( int i = 0; i < ( sizeof(x) / sizeof(double) ); i++)
    {
       printf("The square root of %%.2F equals %%.4F\n", x[i], sqrt( x[i] ) );
       if ( errno )
          perror( __FILE__ );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcat_ex">
			<text>
				<![CDATA[// strcat_ex.c : strcat(), strcat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for strcat_s()

#include <string.h>  // char *strcat( char * restrict s1, 
                     //               const char * restrict s2 );
                     // errno_t strcat_s( char * restrict s1, rsize_t s1max,
                     //                   const char * restrict s2 );
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char  lastname[32];
    char  firstname[32];
    _Bool ismale;
} Name;

int main()
{
    char displayname[80];
    Name *newName = calloc( 1, sizeof(Name) );

    /* ... check for calloc failure; read in the name parts ... */
    if( newName == NULL)
    {  fprintf( stderr, "Out of memory\n" ); return -1; }
    *newName = (Name) { "Lincoln", "Abraham", 1 };

    strcpy( displayname, ( newName->ismale ? "Mr. " : "Ms. " ) );

    strcat( displayname, newName->firstname );
    strcat( displayname, " " );
    strcat( displayname, newName->lastname );

    // Better to use strcat_s() in case the fields in the Name
    // structure are ever enlarged:
    // strcat_s( displayname, sizeof(displayname), newName->firstname );
    // strcat_s( displayname, sizeof(displayname), " " );
    // strcat_s( displayname, sizeof(displayname), newName->lastname );

    puts( displayname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strchr_ex">
			<text>
				<![CDATA[// strchr_ex.c : strchr() example
// -------------------------------------------------------------

#include <string.h>  // char *strchr( const char *s, int c );
#include <stdio.h>
#include <stdlib.h>

typedef struct { char street[32];
                 char city[32];
                 char stateprovince[32];
                 char zip[16];
               } Address;

char printaddr[128] = "720 S. Michigan Ave.\nChicago, IL 60605\n";

int main()
{
    int sublength;
    Address *newAddr = calloc( 1, sizeof(Address) );

    if ( newAddr != NULL )
    {
        sublength = strchr( printaddr, '\n' ) - printaddr;
        strncpy( newAddr->street, printaddr,
                 ( sublength < 31 ? sublength : 31 ) );
        /* ... */
        puts(newAddr->street);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcmp_ex">
			<text>
				<![CDATA[// strcmp_ex.c : strcmp() example
// -------------------------------------------------------------

#include <string.h>  // int strcmp( const char *s1, const char *s2);
#include <stdio.h>

int main()
{
    int result = 0;
    char word1[256], word2[256], *greaterlessequal;

    while ( result < 2 )
    {
        puts( "Type two words, please." );
        result = scanf( "%%s%%s", word1, word2 );
    }
    result = strcmp( word1, word2 );

    if ( result < 0 )
       greaterlessequal = "less than";
    else if ( result > 0 )
       greaterlessequal = "greater than";
    else
       greaterlessequal = "the same as";

    printf( "The word \"%%s\" is %%s the word \"%%s\".\n",
            word1, greaterlessequal, word2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcoll_ex">
			<text>
				<![CDATA[// strcoll_ex.c : strcoll() example
// -------------------------------------------------------------

#include <string.h>  // int strcoll( const char *s1, const char *s2 );
#include <stdio.h>
#include <locale.h>

int main()
{
    char *samples[ ] = { "curso", "churro" };

    if( setlocale( LC_COLLATE, "es_US.UTF-8" ) == NULL)
       fputs("Unable to set the locale.\n", stderr);

    int result = strcoll( samples[0], samples[1] );

    if ( result == 0 )
       printf( "The strings \"%%s\" and \"%%s\" are alphabetically "
               "equivalent.\n", samples[0], samples[1] );
    else if ( result < 0 )
       printf( "The string \"%%s\" comes before \"%%s\" alphabetically.\n",
               samples[0], samples[1] );
    else if ( result > 0 )
       printf( "The string \"%%s\" comes after \"%%s\" alphabetically.\n",
               samples[0], samples[1] );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcpy_ex">
			<text>
				<![CDATA[// strcpy_ex.c : strcpy(), strcpy_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for strcpy_s()

#include <string.h>  // char *strcpy( char * restrict dest,
                     //               const char * restrict src );
                     // errno_t strcpy_s( char * restrict dest, 
                     //                   rsize_t destmax,
                     //                   const char * restrict src );
#include <stdio.h>

int main()
{
    struct guest {
       char name[64]; int age; _Bool male, smoking, discount; } this;
    int result;

    printf( "Last name: " );
    result = scanf( "%%[^\n]", this.name );
    if ( result < 1 )
       strcpy( this.name, "[not available]" );
   // or
   // strcpy_s( this.name, sizeof(this.name), "[not available]" );

    printf( "Name: %%s\n", this.name );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcspn_ex">
			<text>
				<![CDATA[// strcspn_ex.c : strcspn() example
// -------------------------------------------------------------

#include <string.h>  // int strcspn( const char *s1, const char *s2 );
#include <stdio.h>

int main()
{
    char *path = "/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games";
    int separator;
    char *basename = "aprogram";
    char fullname[1024] = "";

    separator = strcspn( path, ":" );  // Obtain the index of the first
                                       // colon.
    strncpy( fullname, path, separator );
    fullname[separator] = '\0';        // Terminate the copied string
                                       // fragment.
    strncat( fullname, "/", sizeof(fullname) - strlen(fullname) -1 );
    strncat( fullname, basename, sizeof(fullname) - strlen(fullname) -1 );

    puts( fullname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strerror_ex">
			<text>
				<![CDATA[// strerror_ex.c : strerror() example
// -------------------------------------------------------------

#include <string.h>     // char *strerror( int errornumber );
#include <errno.h>
#include <stdio.h>

int main( int argc, char *argv[])
{
    FILE *fp;
    char msgbuf[1024] = { '\0' };

    /* Open input file: */
    if (( fp = fopen( "nonexistent", "r" )) == NULL)
    {
       int retval = errno;
       snprintf( msgbuf, sizeof(msgbuf),
                 "%%s: file %%s, function %%s, line %%d: error %%d,\n%%s.\n",
                 argv[0], __FILE__, __func__, __LINE__, retval,
                 strerror( retval ));
       fputs( msgbuf, stderr );
       return retval;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strerror_s_ex">
			<text>
				<![CDATA[// strerror_s_ex.c : strerror_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>     // errno_t strerror_s(char *s, rsize_t maxsize,
                        //                    errno_t errnum);
#include <stdio.h>
#include <errno.h>
#include <math.h>

int main()
{
    double x = -1.0, y = 0;
  // ...
    errno = 0;
    y = sqrt(x);
    if( errno == EDOM)
    {
        char msg[30] = "";
        strerror_s( msg, sizeof(msg), errno);
        fprintf( stderr, "sqrt: %%s\n", msg);
    }
  // ...
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strftime_ex">
			<text>
				<![CDATA[// strftime_ex.c : strftime() example
// -------------------------------------------------------------

#include <time.h>   // size_t strftime( char * restrict s, size_t n,
                    //                  const char * restrict format,
                    //                  const struct tm * restrict timeptr );
#include <stdio.h>

int main()
{
    time_t now;
    struct tm *localnow;
    char hdr_date[999] = "";

    time( &now );
    localnow = localtime( &now );

    if ( strftime( hdr_date, 78, "Date: %%a, %%d %%b %%Y %%T %%z", localnow ) )
        puts( hdr_date );
    else
        return -1;

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strlen_ex">
			<text>
				<![CDATA[// strlen_ex.c : strlen() example
// -------------------------------------------------------------

#include <string.h>  // size_t strlen( const char *s );
#include <stdio.h>

int main()
{
    char line[1024] =
         "This string could easily be hundreds of characters long.";
    char *readptr = line;
    int columns = 80;

    // While the text is longer than a row:
    while ( strlen( readptr ) > columns )
    {   // print a row with a backslash at the end:
        printf( "%%.*s\\", columns-1, readptr);
        readptr += columns -1;
    }   
    // Then print the rest with a newline at the end:
    printf( "%%s\n", readptr );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strncat_ex">
			<text>
				<![CDATA[// strncat_ex.c : strncat(), strncat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1    // For the secure functions.

#include <string.h>  // char *strncat( char * restrict s1,
                     //                const char * restrict s2, size_t n );
                     // errno_t strncat_s( char * restrict s1, rsize_t s1max,
                     //                    const char * restrict s2, rsize_t n);
#include <stdlib.h>
#include <stdio.h>

int main()
{
    char str1[] = "hello ",       // 7 bytes
         str2[10] = "hello ",     // 7 + 3 bytes
         str3[10] = "hello ";     // 7 + 3 bytes

 // strncat( str1, "Jimi", 1);    // Severe error: buffer overflow!
 // strncat( str2, "Jimi", 3);    // OK: "hello Jim"
 // strncat( str3, "Jim", 100);   // OK.

 // Or, using strncat_s(), with the variables defined above:
    int ret1, ret2, ret3;

    set_constraint_handler_s(ignore_handler_s);
    ret1 = strncat_s( str1, sizeof(str1), "Jimi", 1);   // ret1 != 0 and
                                                        // str1[0] == '\0'
    printf( "ret1: %%d    str1: %%s\n", ret1, str1 );

    ret2 = strncat_s( str2, sizeof(str2), "Jimi", 3);   // OK: ret2 == 0
    printf( "ret2: %%d    str2: %%s\n", ret2, str2 );

    ret3 = strncat_s( str3, sizeof(str3), "Jim", 100);  // OK: ret3 == 0
    printf( "ret3: %%d    str3: %%s\n", ret3, str3 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strneln_s_ex">
			<text>
				<![CDATA[// strnlen_s_ex.c : strnlen_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1    // For the secure functions.
#include <string.h>  // size_t strnlen_s(const char *s, size_t maxsize);
#include <stdio.h>

int main()
{
    char str[] = "hello";

    size_t len = strnlen_s( str, 1000);  // len = 5

    if( strnlen_s( str, 4) == 4)
    { 
        puts("str is more than 4 characters long."); 
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strpbrk_ex">
			<text>
				<![CDATA[// strpbrk_ex.c : strpbrk() example
// -------------------------------------------------------------

#include <string.h>    // char *strpbrk( const char *s1, 
                       //                const char *s2 );
#include <stdio.h>

int main()
{
    char *story = "He shouted: \"What? I can't hear you!\"\n";
    char separators[] = " \t\n.:?!\"";
    char *start = story, *end = NULL;
    char words[16][16];     // An array of char arrays to collect words in.
    int i = 0;

    while ( i < 16 && ( end = strpbrk( start, separators ) ) != NULL )
    {
      if ( end != start )   // If the separator wasn't the first character,
      {                     // then save a word in an array.
         strncpy( words[i], start, end - start );
         words[i][end - start] = '\0';     // And terminate it.
         i++;
      }
      start = end + 1;      // Next strpbrk call starts with
    }                       // the character after this separator.

    puts( story );

    for ( int j = 0 ; j < i ; j++ )
       puts( words[j] );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strrchr_ex">
			<text>
				<![CDATA[// strrchr_ex.c : strrchr() example
// -------------------------------------------------------------

#include <string.h>     // char *strrchr( const char *s, int c );
#include <stdio.h>

int main( int argc, char *argv[])
{
    char *mybasename = strrchr( argv[0], '/' );       // Find end of path.
    if ( mybasename != NULL )
        mybasename++;       // Point to the first character after the slash.
    else
        mybasename = argv[0];

    printf( "This program was invoked as %%s.\n", mybasename );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strspn_ex">
			<text>
				<![CDATA[// strspn_ex.c : strspn() example
// -------------------------------------------------------------

#include <string.h>  // int strspn( const char *s1, const char *s2 );
#include <stdio.h>

int main()
{
    char wordin[256];
    double val;

    puts( "Enter a floating-point number, please:" );
    scanf( "%%s", wordin );

    int index = strspn( wordin, "+-0123456789eE." );
    if ( index < strlen( wordin ) )
       printf( "Sorry, but the character %%c is not permitted.\n",
               wordin[index] );
    else
    {
        sscanf( wordin, "%%lg", &val );
        printf( "You entered the value %%g\n", val );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtod_ex">
			<text>
				<![CDATA[// strtod_ex.c : strtod() example
// -------------------------------------------------------------

#include <stdlib.h>  // double strtod( const char * restrict s,
                     //                char ** restrict endptr );
#include <stdio.h>

int main()
{
    char in[1024], *this = in, *next = in;
    double val;

    puts( "Enter some floating-point numbers, please:" );
    scanf( "%%[^\n]", in );

    puts( "Here are the values you entered:" );
    while ( 1 )
    {
        val = strtod( this, &next );
        if ( next == this )     // Means no conversion was possible.
            break ;
        printf( "\t%%g\n", val );
        this = next;            // Try again with the rest of the input string.
    }
    puts( "Done." );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtok_ex">
			<text>
				<![CDATA[// strtok_ex.c : strtok() example
// -------------------------------------------------------------

#include <string.h>  // char *strtok( char * restrict s1, 
                     //               const char * restrict s2 );
#include <stdio.h>

int main()
{
    char *command, *arg1, *arg2, *comment;
    char line[] = " mul eax,[ebp+4] ; Multiply by y\n";

    command = strtok(line," \t");   // First word, between spaces or tabs.
    arg1 = strtok( NULL, ",");      // From there to the comma is arg1.
                                    // (Trim off any spaces later.)
    arg2 = strtok( NULL, ";\n");    // From there to a semicolon or line end.
    comment = strtok( NULL, "\n\r\v\f" );  // From there to end of line or
                                           //page.
    printf( "Command:      %%s\n"
            "1st argument: %%s\n"
            "2nd argument: %%s\n"
            "Comment:      %%s\n\n",
            command, arg1, arg2, comment );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtok_s_ex">
			<text>
				<![CDATA[// strtok_s_ex.c : strtok_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>  // char *strtok_s( char * restrict s1, 
                     //                 rsize_t * restrict s1max,
                     //                 const char * restrict s2, 
                     //                 char ** restrict ptr);
#include <stdio.h>

int main()
{
    char str[] = "Lennon, John: 10/9/1940";
    char *ptr;
    size_t size = sizeof(str);
    char *firstname, *lastname, *birthday;

    lastname = strtok_s( str, &size, ", ", &ptr);
    if( lastname != NULL)
       firstname = strtok_s(NULL, &size, ": ", &ptr);
    if( firstname != NULL)
       birthday = strtok_s(NULL, &size, "", &ptr);
    if(birthday != NULL)
       printf("%%s %%s was born on %%s.\n",
              firstname, lastname, birthday);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtoul_ex">
			<text>
				<![CDATA[// strtoul_ex.c : strtoul() example
// -------------------------------------------------------------

#include <stdlib.h>  // unsigned long strtoul( const char * restrict s,
                     //                        char ** restrict endptr,
                     //                        int base );
#include <stdio.h>

int main()
{
    char dotted[ ] = "172.16.2.10", *ptr = dotted, *nextdot = NULL;
    unsigned long dest = 0;

    // This for loop uses stroul() to convert an IPv4 address from a 
    // dotted-decimal string to a 32-bit integer value:
    for ( int i = 0; i < 4; i++)
    {
        dest <<= 8;
        dest += strtoul( ptr, &nextdot, 10 );
        ptr = nextdot + 1;
    }
    printf( "The IPv4 address %%s\n"
            "represents the 32-bit integer value %%lu\n",
             dotted, dest );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strxfrm_ex">
			<text>
				<![CDATA[// strxfrm_ex.c : strxfrm() example
// -------------------------------------------------------------

#include <string.h>  // size_t strxfrm( char * restrict dest,
                     //                 const char * restrict src,
                     //                 size_t n );
#include <locale.h>
#include <stdlib.h>
#include <stdio.h>

typedef struct stringpair { char * original;
                            char * xformed; } Stringpair_t ;

Stringpair_t stringpairs[8] =
             { { "ChÃ¡vez", NULL },        { "Carron", NULL },
               { "Canoso", NULL },        { "CaÃ±oso", NULL },
               { "CarteÃ±o", NULL },       { "Cortillo", NULL },
               { "Cortiluz S.A.", NULL }, { "Corriando", NULL } };

char xformbuffer[1024];           // Space to catch each strxfrm() result.

int stringpaircmp( const void * p1, const void *p2 );
                                  // Defined externally.

int main()
{
    setlocale( LC_COLLATE, "");    // Use the host system's locale setting.
//    printf( "The locale is %%s.\n", setlocale( LC_COLLATE, NULL) );

    for ( int i = 0; i < 8 ; i++ )
    {
        stringpairs[i].xformed
        = malloc( strxfrm( xformbuffer, stringpairs[i].original, 1024 ) + 1 );
        if ( stringpairs[i].xformed != NULL )
           strcpy(stringpairs[i].xformed, xformbuffer);
    }

    qsort( stringpairs, 8, sizeof(Stringpair_t), stringpaircmp );

    for ( int i = 0; i < 8 ; i++ )
        puts( stringpairs[i].original );

    return 0;
}

int stringpaircmp( const void * sp1, const void *sp2 )
{
    const char * s1 = ((Stringpair_t *)sp1)->xformed;
    const char * s2 = ((Stringpair_t *)sp2)->xformed;
    return strcmp( s1, s2 );
}
]]>
			</text>
		</p>
		<p n="xc_swprintf_ex">
			<text>
				<![CDATA[// swprintf_ex.c : swprintf() example
// -------------------------------------------------------------

#include <wchar.h>  // int swprintf( wchar_t * restrict dest, size_t n,
                    //               const wchar_t * restrict format, ... );
#include <stdlib.h>

const wchar_t *dollar_as_wstr( long amount)
// Converts a number of cents into a wide string
// showing dollars and cents.
// For example, converts -123456 into the wide string L"-$1234.56"
{
    static wchar_t buffer[16];
    wchar_t sign[2] = L"";

    if ( amount < 0L)
       amount = -amount, sign[0] = '-';

    ldiv_t dollars_cents = ldiv( amount, 100);
    swprintf( buffer, sizeof(buffer),
              L"%%ls$%%ld.%%2ld", sign, dollars_cents.quot, dollars_cents.rem);

    return buffer;
}

#include <stdio.h>

int main()
{
    fputws( dollar_as_wstr( -123456), stdout );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_system_ex">
			<text>
				<![CDATA[// system_ex.c : system() example
// -------------------------------------------------------------

#include <stdlib.h>    // int system( const char *s );
#include <stdio.h>

int main()
{
    if ( system( NULL ))
       system( "echo \"Shell: $SHELL; process ID: $$\"");
    else
       printf( "No command processor available.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tan_ex">
			<text>
				<![CDATA[// tan_ex.c : tan() example
// -------------------------------------------------------------

#include <math.h>    // double tan( double x );
                     // float tanf( float x );
                     // long double tanl( long double x );
#include <stdio.h>

int main()
{
    const double pi = 4.0L * atan( 1.0 );     // Because tan(pi/4) = 1
    double shadow_length = 85.5,
           angle = 36.2;         // Sun's elevation from the horizon, in
                                 // degrees
    double height = shadow_length *tan ( angle * pi/180);

    printf("The tower is %%.2f meters high.\n", height);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tanh_ex">
			<text>
				<![CDATA[// tanh_ex.c : tanh() example
// -------------------------------------------------------------

#include <math.h>    // double tanh( double x );
                     // float tanhf( float x );
                     // long double tanhl( long double x );
#include <stdio.h>

int main()
{
    double x = -0.5, y1, y2;

    y1 = tanh(x);
    y2 = exp(2*x);
    y2 = (y2 -1) / (y2 + 1);

    printf("The tanh() function returns     %%.15f.\n", y1 );
    printf("Using the function exp() yields %%.15f.\n", y2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_create_ex">
			<text>
				<![CDATA[// thrd_create_ex.c : thrd_create() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
#include <stdio.h>

int th_func(void * arg)         // The thread function.
{
    puts("Hello from th_func ...");
    ++*(int*)arg;
    return 0;
}

int main()
{
    thrd_t th; int n = 1;

    if ( thrd_create(&th, th_func, &n) != thrd_success) {
       fprintf(stderr, "Error creating thread.\n"); return -1;
    }
    puts("Main thread here ...");

    thrd_join(th, NULL);
    printf("The value of n is %%d\n", n);       // n == 2

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_detach_ex">
			<text>
				<![CDATA[// thrd_detach_ex.c : thrd_detach() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_detach( thrd_t thr);
#include <stdio.h>

void independent_thread(void)
{
    puts("Working independently in the background ... ");
    // . . .
    thrd_exit(0);
}
int create_independent_thread(void)
{
    thrd_t th;
    if( thrd_create(&th, (thrd_start_t)independent_thread, "")
                                              != thrd_success)
      return -1;
    if( thrd_detach(th) != thrd_success)
       return -1;
    puts("Started independent thread.");
    return 0;
}

int main()
{
    create_independent_thread();

    puts("Main thread here ...");

    // Working ...
    struct timespec d = { .tv_nsec = 1E6 };  // 1 ms. 
    thrd_sleep( &d, NULL);

    puts("Main thread done.");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_equal_ex">
			<text>
				<![CDATA[// thrd_equal_ex.c : thrd_equal() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_equal(thrd_t thr1, thrd_t thr2);
#include <stdio.h>

thrd_t mainThrd;

int func(void)
{
    if( thrd_equal( thrd_current(), mainThrd) )
    { puts("Main thread here ...");  return 0; }
    else
    { puts("Other thread here ..."); return 1; }
}

int main()
{
    thrd_t th;

    mainThrd = thrd_current();

    if ( thrd_create(&th, (thrd_start_t)func, NULL) != thrd_success)
    { fprintf(stderr, "Error creating thread.\n"); return -1; }

    func();
    thrd_join(th, NULL);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_timespec_get_ex">
			<text>
				<![CDATA[// timespec_get_ex.c : timespec_get() example
// -------------------------------------------------------------

#include <time.h>   // int timespec_get(struct timespec *ts, int base);
#include <stdio.h>

int main()
{
    struct timespec ts;

    if( timespec_get( &ts, TIME_UTC) != 0)
        printf("The exact local time:\n"
               "%%.24s and %%09lu nanoseconds\n", ctime(&ts.tv_sec), ts.tv_nsec);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tmpfile_ex">
			<text>
				<![CDATA[// tmpfile_ex.c : tmpfile(), tmpfile_s() example
// -------------------------------------------------------------

#include <stdio.h>   // FILE *tmpfile( void );
                     // errno_t tmpfile_s(FILE * restrict * restrict streamPtr);
#include <errno.h>

int main()
{
    FILE *fpTmp, *fpRx;
    int c;

    /* ... open Rx stream ... */
    fpRx = stdin;

    if (( fpTmp = tmpfile() ) == NULL )
    // or
    // if( tmpfile_s( &fpTmp) != 0 )
        fputs( "Unable to open a temporary file.", stderr );
    else
    {
        while (( c = fgetc( fpRx )) != EOF )
            if ( fputc( c, fpTmp ) == EOF )
               break;
    }
    fclose( fpRx );

    /* ... process the data captured in fpTmp ... */

    rewind( fpTmp);
    while( (c = fgetc( fpTmp)) != EOF)
       putchar(c);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tmpnam_ex">
			<text>
				<![CDATA[// tmpnam_ex.c : tmpnam(), tmpnam_s() example
// -------------------------------------------------------------

#include <stdio.h>   // char *tmpnam( char *s );
                     // errno_t tmpnam_s(char *s, rsize_t maxsize);
#include <errno.h>

int main()
{
    char fname[L_tmpnam];
    // or
    // char fname[L_tmpnam_s];
    FILE *fpOut;

    if( tmpnam( fname) == NULL)
    // or
    // if( tmpnam_s( fname, sizeof(fname)) != 0)
    {
        fputs( "Error generating a temporary file name.", stderr );
        return -1;
    }

    fpOut = fopen( fname, "w+" );

    fputs( "... write and edit something in the file ...\n", fpOut );    
    fclose( fpOut );
    printf( "The results have been saved in %%s.\n", fname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_towctrans_ex">
			<text>
				<![CDATA[// towctrans_ex.c : towctrans() example
// -------------------------------------------------------------

#include <wctype.h>  // wint_t towctrans( wint_t wc, wctrans_t desc );
#include <wchar.h>

int main()
{
   wint_t before = L'\0', after = L'\0';
   wctrans_t mapping;
   mapping = wctrans("toupper");

   while (( before = getwchar() ) != WEOF )
   {
       after = towctrans( before, mapping );
       putwchar( after );
       if ( after == L'Q' )
          break;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_trunc_ex">
			<text>
				<![CDATA[// trunc_ex.c : trunc() example
// -------------------------------------------------------------

#include <math.h>    // double trunc( double x );
                     // float truncf( float x );
                     // long double truncl( long double x );
#include <stdio.h>

int main()
{
    printf("trunc(-1.7) = %%.2f  trunc(1.4) = %%.2f  trunc(1.5) = %%.2f\n",
            trunc(-1.7), trunc(1.4), trunc(1.5) );

    printf("round(-1.7) = %%.2f  round(1.4) = %%.2f  round(1.5) = %%.2f\n",
            round(-1.7), round(1.4), round(1.5) );

    return 0;
}
]]>
			</text>
		</p>
		<p n="tss_set_ex">
			<text>
				<![CDATA[// tss_set_ex.c : tss_set() example
// -------------------------------------------------------------

#include <threads.h>  // int tss_set(tss_t *key, void * ptr);
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

tss_t key;               // Global key for a TSS pointer
                         // tss_create(&key, ...) has been called.

typedef char Data_t;

size_t size_data( Data_t *dPtr)
{
    size_t size = strlen( dPtr) + 1;
    return size;
}

// Process some data of some type Data_t:
int process_data(void)   // Use thread-specific storage.
{
    Data_t *ptr = (Data_t*)tss_get(key); // Pointer to TSS

    puts("Process data ...");
    puts( ptr);
    return 0;
}

int thread_func( void* arg)
{
    size_t size = size_data( arg);   // A helper function to find the
                                     // required storage size.
    // Set thread-specific storage:
    if( tss_set(key, malloc(size)) != thrd_success)
       return -1;

    // Store and process data ...
    memcpy( tss_get(key), arg, size);
    return process_data();           // return calls the destructor, if
}                                    // the tss_create() call set one.

void destructor(void *data)
{
    printf("Destructor for %%s\n", (char*)data);
    free(data);                    // Release memory.
}

int main(void)
{
    thrd_t th1, th2;
    int result1 = 0, result2 = 0;

    // Create the TSS key:
    if (tss_create(&key, destructor) != thrd_success)
       return -2;

    // Create threads:
    if ( thrd_create(&th1, thread_func, "Thread_1 ... ")
                                           != thrd_success
         || thrd_create(&th2, thread_func, "... Thread_2 ")
                                           != thrd_success )
       return -3;

    thrd_join( th1, &result1);
    thrd_join( th2, &result2);
    if ( result1 != 0 || result2 != 0)
       fputs("Thread error\n", stderr);
    else
       puts("Threads finished without error.");

    tss_delete(key); // Free all resources of the TSS pointer.
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ungetc_ex">
			<text>
				<![CDATA[// ungetc_ex.c : ungetc() example
// -------------------------------------------------------------

#include <stdio.h>       // int ungetc( int c, FILE *fp );
#include <stdlib.h>
#include <ctype.h>

int main()
{
    char file[ ] = "input.dat";
    FILE *fp;
    int c;
    char numstr[64];

    if (( fp = fopen( file, "r" )) == NULL )
       fprintf( stderr, "Can't read the file %%s\n", file), exit(1);

    while ( (c = getc(fp)) != EOF )
    {
       if ( isdigit(c) )              // Collect a sequence of digits.
       {
          int i = 0;
          do
          {
             numstr[i++] = (char)c;
             c = getc(fp);
          }while ( isdigit(c) && i+1 < sizeof(numstr) );

          numstr[i] = '\0';            // Terminate the numeral string.

          /* ... process the numeral string ... */
          puts( numstr);

          if ( ungetc( c, fp) == EOF)  // Put back the first non-digit.
             break;
          continue;
       }

       /* ... process any non-digit characters ... */
    }
    if ( !feof( fp))
       fprintf( stderr, "Error processing the file %%s\n", file);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_va_arg_ex">
			<text>
				<![CDATA[// va_arg_ex.c : va_arg(), va_copy, va_end(), va_start() example
// -------------------------------------------------------------

#include <stdarg.h>  // void va_start( va_list argptr, last_fixed_arg );
                     // type va_arg( va_list argptr, type );
                     // void va_copy( va_list dest, va_list src );
                     // void va_end( va_list argptr );
#include <stdio.h>
#include <string.h>
#include <math.h>

double vproduct( int n, va_list argptr );
double vsum( int n, va_list argptr );

double vop( const char * op, int argcount, ... );

// main() calls vop() to perform calculations. vop()'s arguments are:
// (1) the name of the operation ("sum", "product",
//     "sum minus the product");
// (2) the number of operands;
// (3 through n) the operands themselves.
// Iterates through operations twice: once with three operands, once
// with six.

int main()
{
    double d1, d2, d3, d4, d5, d6;

    puts( "Enter six floating-point numbers, please:" );
    scanf( "%%lf%%lf%%lf%%lf%%lf%%lf", &d1, &d2, &d3, &d4, &d5, &d6 );

    char *operation[] = {"sum", "product", "product minus the sum",NULL};

    printf("\nUsing the three numbers %%lf, %%lf, and %%lf.\n", d1, d2, d3);
    for ( int i = 0; operation[i] != NULL; i++ )
    {
        printf( "The %%s of these %%d numbers is %%lf\n", 
                 operation[i], 3, vop( operation[i], 3, d1, d2, d3 ) );
    }

    printf( "\nUsing six numbers:"
            "\n\t%%lf \t%%lf \t%%lf \n\t%%lf \t%%lf \t%%lf\n",
            d1, d2, d3, d4, d5, d6 );
    for ( int i = 0; operation[i] != NULL; i++ )
    {
        printf( "The %%s of these %%d numbers is %%lf\n",
                operation[i], 6, 
                vop( operation[i], 6, d1, d2, d3, d4, d5, d6 ) );
    }
}

double vop( const char * op, int argcount, ... )
{
    va_list argptr;
    double result;

    va_start( argptr, argcount );
    if ( strcmp( op, "sum" ) == 0 )
       result = vsum( argcount, argptr );
    else if ( strcmp( op, "product" ) == 0 )
       result = vproduct( argcount, argptr );
    else if ( strcmp( op, "product minus the sum" ) == 0 )
    {
       va_list duplicate_argptr;       // Clone the va_list in its present
                                       // state.
       va_copy( duplicate_argptr, argptr );
       result = vproduct( argcount, argptr )
                - vsum( argcount, duplicate_argptr );
       va_end( duplicate_argptr );     // Clean up the clone.
    }

    else result = NAN;

    va_end( argptr ); // Clean up the original.
    return result;
}

double vproduct( int n, va_list argptr )
{
    double product = 1.0;

    for ( int i = 0; i < n; i ++ )
        product *= va_arg( argptr, double );

    return product;
}

double vsum( int n, va_list argptr )
{
    double sum = 0.0;

    for ( int i = 0; i < n; i ++ )
        sum += va_arg( argptr, double );

    return sum;
}
]]>
			</text>
		</p>
		<p n="xc_vfprintf_ex">
			<text>
				<![CDATA[// vfprintf_ex.c : vfprintf() example
// -------------------------------------------------------------

#include <stdio.h>   
#include <stdarg.h>
// int vfprintf( FILE * restrict fp, const char * restrict format, va_list argptr );
// int vprintf( const char * restrict format, va_list argptr );
// int vsprintf( char * restrict buffer, const char * restrict format,
//               va_list argptr );
// int vsnprintf( char * restrict buffer, size_t n, const char * restrict format, //                va_list argptr );

#include <time.h>

// write_log appends a line to the log file associated with the
// FILE pointer fp_log.
// The format string and optional arguments are the same as for printf().

FILE *fp_log;
 
void write_log(const char *function_name, unsigned int line_num,
               const char *format_str, ...)
{
    if ( fp_log == NULL)
       return;
    time_t timestamp = time(NULL);
    va_list argptr;

    // Set argptr to the first optional argument:
    va_start( argptr, format_str);

    // First print the timestamp, function name, and line number:
    fprintf( fp_log, "%%.8s %%s (line %%u): ",
                     ctime(&timestamp)+11, function_name, line_num);
    // Then print the rest of the message:
    vfprintf( fp_log, format_str, argptr);
}

void myFunc( int param)
{
    write_log( __func__, __LINE__, "param = %%d\n", param);
    /* ... */
}

int main()
{
    fp_log = stderr;
    myFunc( 777);    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_vfscanf_ex">
			<text>
				<![CDATA[// vfscanf_ex.c : vscanf() example
// -------------------------------------------------------------

#include <stdio.h>   
#include <stdarg.h>
// int vfscanf( FILE * restrict fp, const char * restrict format,
//              va_list argptr );
// int vscanf( const char * restrict format, va_list argptr );
// int vsscanf( const char * restrict src, const char * restrict format,
//              va_list argptr );


typedef struct {
    char lastname[20];
    char firstname[20];
    int dob_month;
    int dob_day;
    int dob_year;
} person;

person employee;

int read_person( char *lname, char *fname, ... )
// As variable arguments (...) use NULL
// or three int pointers (month, day, year).
{
    va_list args;
    int count;

    puts( "Enter the last name and first name (Example: Smith, Sally)");
    count = scanf( "%%[^,], %%[^\n]", lname, fname );      // Read the name.

    va_start(args, fname);    // Initialize args to start with the argument
                              // that follows fname in the function call.
    if ( count == 2 && va_arg(args, int*) != NULL )
    {
        va_end( args);
        va_start( args, fname);     // Initialize args again.

        printf( "Enter the date of birth. (Example: 9/21/1962)\n");
        count += vscanf( "%%d/%%d/%%d", args ); // Read date of birth.
    }
#ifdef DEBUG
    fprintf( stderr, "Read %%d fields.\n", count);
#endif // def DEBUG

    va_end( args );
    return count;
}

int main()
{
   person *pEmployee = &employee;
   int result;

   result = read_person( pEmployee->lastname,
                         pEmployee->firstname,
                         &pEmployee->dob_month,
                         &pEmployee->dob_day,
                         &pEmployee->dob_year );
#ifdef DEBUG
    fprintf( stderr, "Fields read: %%s, %%s; born %%d-%%d-%%d\n",
             pEmployee->lastname,
             pEmployee->firstname,
             pEmployee->dob_month,
             pEmployee->dob_day,
             pEmployee->dob_year );
#endif // def DEBUG
}
]]>
			</text>
		</p>
		<p n="xc_wcrtomb_s_ex">
			<text>
				<![CDATA[// wcrtomb_s_ex.c : wcrtomb_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t wcrtomb_s( size_t * restrict retval,
                     //                    char * restrict dest, rsize_t destmax,
                     //                    wchar_t wc, mbstate_t * restrict ps);
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);
    printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

    wchar_t wc = L'\u00b1';     //'Â±'
    char mbStr[MB_CUR_MAX];
    size_t nBytes = 0;
    mbstate_t state = {0};

    if( wcrtomb_s( &nBytes, mbStr, sizeof(mbStr), wc, &state ) != 0)
    { /* Handle the error ... */
        fputs("Error ...", stderr);  return -1;
    }

    printf("Character: '%%lc'; multibyte code:", wc);     // 'Â±'
    for( unsigned i = 0; i < nBytes; ++i)
        printf(" %%#04x", (unsigned char)mbStr[i]);       // 0xc2 0xb1
    putchar('\n');

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscat_ex">
			<text>
				<![CDATA[// wcscat_ex.c : wcscat(), wcscat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for wcscat_s()

#include <wchar.h>
   // wchar_t *wcscat( wchar_t * restrict s1, const wchar_t * restrict s2 );
   // errno_t wcscat_s( wchar_t * restrict s1, rsize_t s1max,
   //                   const wchar_t * restrict s2);
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    wchar_t  lastname[32];
    wchar_t  firstname[32];
    _Bool    ismale;
} Name;

int main()
{
    Name *newName = calloc( 1, sizeof(Name) );

    /* ... check for calloc failure; read in the name parts ... */
    if( newName == NULL)
    {  fprintf( stderr, "Out of memory\n" ); return -1; }
    *newName = (Name) { L"Lincoln", L"Abraham", 1 };

    // Then display the new name
    wchar_t displayname[80];
    wcscpy( displayname, ( newName->ismale ? L"Mr. " : L"Ms. " ) );
    wcscat( displayname, newName->firstname );
    wcscat( displayname, L" " );
    wcscat( displayname, newName->lastname );
    wcscat( displayname, L"\n" );

    // Better to use wcscat_s() in case the fields in the Name
    // structure are ever enlarged:
    // wcscat_s( displayname, sizeof(displayname), newName->firstname );
    // wcscat_s( displayname, sizeof(displayname), L" " );
    // wcscat_s( displayname, sizeof(displayname), newName->lastname );
    // wcscat_s( displayname, sizeof(displayname), L"\n" );

    fputws( displayname, stdout );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcschr_ex">
			<text>
				<![CDATA[// wcschr_ex.c : wcschr() example
// -------------------------------------------------------------

#include <wchar.h>   // wchar_t *wcschr( const wchar_t *s, wchar_t c );
#include <stdio.h>
#include <stdlib.h>

typedef struct { wchar_t street[32];
                 wchar_t city[32];
                 wchar_t stateprovince[32];
                 wchar_t zip[16];
               } Address;

wchar_t printaddr[128] = L"720 S. Michigan Ave.\nChicago, IL 60605\n";

int main()
{
    int sublength;
    Address *newAddr = calloc( 1, sizeof(Address) );

    if ( newAddr != NULL )
    {
        sublength = wcschr( printaddr, L'\n' ) - printaddr;
        wcsncpy( newAddr->street, printaddr,
                 (sublength < 31 ? sublength : 31) );
        /* ... */
        fputws( newAddr->street, stdout );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscmp_ex">
			<text>
				<![CDATA[// wcscmp_ex.c : wcscmp() example
// -------------------------------------------------------------

#include <wchar.h>   // int wcscmp( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>

int main()
{
    int result = 0;
    wchar_t word1[255]=L"X1", word2[256] = L"X2", *greaterlessequal;

    while ( result < 2 )
    {
        fputws( L"Type two words, please: ", stdout );
        result = wscanf( L"%%255ls %%255ls", word1, word2 );
        if ( result == EOF )
           return EOF;
    }
    result = wcscmp( word1, word2 );

    if ( result < 0 )
       greaterlessequal = L"less than";
    else if ( result > 0 )
       greaterlessequal = L"greater than";
    else
       greaterlessequal = L"the same as";

    wprintf( L"The word \"%%ls\" is %%ls the word \"%%ls\".\n", 
             word1, greaterlessequal, word2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscoll_ex">
			<text>
				<![CDATA[// wcscoll_ex.c : wcscoll() example
// -------------------------------------------------------------

#include <wchar.h>  // int wcscoll( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>
#include <locale.h>

int main()
{
    wchar_t *samples[ ] = { L"anejo", L"aÃ±eja",};

    setlocale( LC_COLLATE, "es_US.UTF-8" );
    
    int result = wcscoll( samples[0], samples[1] );

    wprintf( L"In the locale %%s, ", setlocale( LC_COLLATE, NULL ));

    if ( result == 0 )
        wprintf( L"the wide strings \"%%ls\" and \"%%ls\" are alphabetically "
                 "equivalent.\n", samples[0], samples[1] );
    else if ( result < 0 )
        wprintf( L"the wide string \"%%ls\" precedes \"%%ls\" "
                 "alphabetically.\n", samples[0], samples[1] );
    else if ( result > 0 )
        wprintf( L"the wide string \"%%ls\" comes after \"%%ls\" "
                 "alphabetically.\n", samples[0], samples[1] );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscpy_ex">
			<text>
				<![CDATA[// wcscpy_ex.c : wcscpy(), wcscpy_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for wcscpy_s()

#include <wchar.h>  // wchar_t *wcscpy(wchar_t * restrict dest,
                    //                 const wchar_t * restrict src);
                    // errno_t wcscpy_s(wchar_t * restrict dest,
                    //                  rsize_t destmax,
                    //                  const wchar_t * restrict src);
#include <stdio.h>

int main()
{
    struct record {
      wchar_t name[64];
      int age;
      _Bool male, smoking, discount;
    } this;
    int results;

    wprintf( L"Last name: " );
    results = wscanf( L"%%63l[^\n]", this.name );

    if ( results < 1 )
        wcscpy( this.name, L"[Name not available]" );
    // or:
    // wcscpy_s( this.name, sizeof(this.name)/sizeof(wchar_t),
    //           L"[Name not available]" );

    wprintf( L"%%ls\n", this.name );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscspn_ex">
			<text>
				<![CDATA[// wcscspn_ex.c : wcscspn() example
// -------------------------------------------------------------

#include <wchar.h>  // size_t wcscspn( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t *path = L"/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games";
    int separator;

    wchar_t *basename = L"aprogram";
    wchar_t fullname[1024] = L"";

    separator = wcscspn( path, L":" );  // Obtain the index of the first colon.

    wcsncpy( fullname, path, separator );
    fullname[separator] = '\0';

    wcsncat( fullname, L"/", sizeof(fullname) - wcslen(fullname) -1 );
    wcsncat( fullname, basename, sizeof(fullname) - wcslen(fullname) -1 );

    fputws( fullname, stdout );

    return 0;
}
]]>
			</text>
		</p>
		<p n="ex_wcsftime_ex">
			<text>
				<![CDATA[// wcsftime_ex.c : wcsftime() example
// -------------------------------------------------------------

#include <time.h>   // size_t wcsftime( wchar_t * restrict s, size_t n,
#include <wchar.h>  //                  const wchar_t * restrict format,
                    //                  const struct tm * restrict timeptr );
#include <stdio.h>

#define MAX_HDR 1024

int main()
{
    time_t now;
    struct tm *localnow;
    wchar_t hdr_date[MAX_HDR] = L"";

    time( &now );
    localnow = localtime( &now );

    if( wcsftime( hdr_date, MAX_HDR, L"Date: %%a, %%d %%b %%Y %%T %%z", localnow))
       fputws( hdr_date, stdout );
    else
       return -1;

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcslen_ex">
			<text>
				<![CDATA[// wcslen_ex.c : wcslen() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcslen( const wchar_t *s );

int main()
{
    wchar_t line[1024] =
            L"This string could easily be 400 or 500 characters long. "
            L"This string could easily be 400 or 500 characters long. "
            L"\n";
    wchar_t *readptr = line;

    int columns = 80;
    while( wcslen( readptr ) > columns)  // While remaining text is too long,
    {                                    // print a chunk with a final
       wprintf(L"%%.*ls\\\n", columns-1, readptr);  // backslash and newline.
       readptr += columns -1;
    }
    wprintf( L"%%ls\n", readptr);     // Print the rest, ending with a newline.

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsncmp_ex">
			<text>
				<![CDATA[// wcsncmp_ex.c : wcsncmp() example
// -------------------------------------------------------------

#include <wchar.h>   // int wcsncmp( const wchar_t *s1,
                     //              const wchar_t *s2, size_t n );

int main()
{
    wchar_t *months[] = { L"January", L"February", L"March", L"April",
                          L"May", L"June", L"July", L"August",
                          L"September", L"October", L"November", L"December"};

    wchar_t date[ ] = L"Thu, 10 Mar 2005 13:44:18 +0100";
    int mo = 0;
    while (( mo < 12 ) && ( wcsncmp( date + 8, months[mo], 3 ) != 0 ))
        mo++;

    if( mo < 12)
       wprintf( L"Month: %%ls\n", months[mo] ); 

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcspbrk_ex">
			<text>
				<![CDATA[// wcspbrk_ex.c : wcspbrk() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wcspbrk( const wchar_t *s1,
                       //                   const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t *story = L"He shouted: \"What? I can't hear you!\"\n";
    wchar_t separators[ ] = L" \t\n.:?!\"";
    wchar_t *start = story, *end = NULL;
    wchar_t words[16][16];   // An array of wchar_t arrays to collect words in. 
    int i = 0;

    while ( i < 16 && ( end = wcspbrk( start, separators ) ) != NULL )
    {
      if ( end != start )             // If the separator wasn't the first
      {                               // character in the substring,
         wcsncpy( words[i], start, end - start );  // then save a word.
         words[i][end - start] = L'\0';            // And terminate it.
         i++;
      }
      start = end + 1;                // Next wcspbrk call starts with the
    }                                 // character after this separator.

    fputws( story, stdout );

    for ( int j = 0 ; j < i ; j++ )
    {
       fputws( words[j], stdout );
       fputwc( L'\n', stdout );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsrchr_ex">
			<text>
				<![CDATA[// wcsrchr_ex.c : wcsrchr() example
// -------------------------------------------------------------

#include <wchar.h>  // wchar_t *wcsrchr( const wchar_t *s, wchar_t wc );
#include <stdlib.h>

int main( int argc, char ** argv )
{
    wchar_t wmyname[256];

    size_t result = mbstowcs( wmyname, argv[0], 256 );
    if ( result == -1 )
       return -1;

    wchar_t *mybasename = wcsrchr( wmyname, L'/' ); // End of path
    if ( mybasename != NULL )
      mybasename++;
    else
      mybasename = wmyname;

    wprintf( L"This program was invoked as %%ls.\n", mybasename );
}
]]>
			</text>
		</p>
		<p n="xc_wcsrtombs_ex">
			<text>
				<![CDATA[// wcsrtombs_ex.c : wcsrtombs() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcsrtombs( char * restrict dest,
                     //                   const wchar_t **restrict src,
                     //                   size_t n, 
                     //                   mbstate_t * restrict state );
#include <string.h>
#include <locale.h>
#include <stdio.h>

int main()
{
    int i = 0, n = 0;
    size_t result;
    wchar_t wc;
    char mbstring[256] = { '\0' };

    wchar_t widestring[]
            = L"This is originally a string of wide characters.";
    const wchar_t *wcsptr = widestring;
    mbstate_t state;

    printf( "The current locale is %%s.\n", setlocale(LC_CTYPE, "") );

    memset( &state, '\0', sizeof state );
    result = wcsrtombs( mbstring, &wcsptr, 256, &state );

    printf("The return value: %%d\n", (int)result );
    if( result > 0 && wcsptr == NULL )
       printf("The multibyte string: \"%%s\"\n", mbstring);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsrtombs_s_ex">
			<text>
				<![CDATA[// wcsrtombs_s_ex.c : wcsrtombs_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t wcsrtombs_s(size_t * restrict retval,
                     //                     char * restrict dest, 
                     //                     rsize_t destmax,
                     //                     const wchar_t ** restrict src,
                     //                     rsize_t n,
                     //                     mbstate_t * restrict state);
#include <locale.h>
#include <stdio.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);

    wchar_t widestr[] = L"A wide-character string ...";
    const wchar_t *wcptr = widestr;     // A pointer to a wide character.
    char mbstr[100] = "";               // For the multibyte string.
    size_t mblen = 0;
    mbstate_t mbstate = {0};            // Conversion state.

    if( wcsrtombs_s( &mblen, mbstr, sizeof(mbstr),
                     &wcptr, 3, &mbstate) == 0)
    {
        printf("Multibyte length: %%zu; character codes: [", mblen);
        for( size_t i = 0; i < mblen; ++i)
            printf(" %%X", (unsigned char)mbstr[i]);
        puts(" ]");

        if( wcptr != NULL)
            printf("Wide characters remaining: \"%%ls\"\n", wcptr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsspn_ex">
			<text>
				<![CDATA[// wcsspn_ex.c : wcsspn() example
// -------------------------------------------------------------

#include <wchar.h>     // size_t wcsspn( const wchar_t *s1,
                       //                const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t wordin[256];
    double val;

    fputws( L"Enter a floating-point number, please: ", stdout );
    wscanf( L"%%ls", wordin );

    int index = wcsspn( wordin, L"+-0123456789eE." );
    if ( index < wcslen( wordin ) )
       wprintf ( L"Sorry, but the character %%lc is not permitted.\n",
                 wordin[index] );
    else
    {
       swscanf( wordin, L"%%lg", &val );
       wprintf( L"You entered the value %%g\n", val );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsstr_ex">
			<text>
				<![CDATA[// wcsstr_ex.c : wcsstr() example
// -------------------------------------------------------------

#include <wchar.h>     // size_t wcsstr( const wchar_t *s1,
                       //                const wchar_t *s2 );
#include <stdlib.h>
#include <stdio.h>

#define MAX_LINE 1024

int main( int argc, char **argv )
{
    FILE *fpIn = NULL;
    wchar_t keyword[MAX_LINE] = { L'\0' };
    wchar_t line[MAX_LINE] = { L'\0' };

    if ( argc != 3 )
    {
        wprintf( L"Syntax: %%s <keyword> <filename>\n", argv[0] );
        return -1;
    }

    if (( fpIn = fopen( argv[2], "r" )) == NULL )
       return -2;
    else
       fwide( fpIn, 1 );

    if ( mbstowcs( keyword, argv[1], MAX_LINE ) == -1 )
       return -3;

    int count = 0;
    while ( fgetws( line, MAX_LINE, fpIn ) != NULL )
       if ( wcsstr( line, keyword ) != NULL )
       {
           ++count;
           fputws( line, stdout );
       }

    if ( !feof( fpIn ))
       return -4;
    else
       return count;
}
]]>
			</text>
		</p>
		<p n="xc_wcstod_ex">
			<text>
				<![CDATA[// wcstod_ex.c : wcstod() example
// -------------------------------------------------------------

#include <wchar.h>     // double wcstod( const wchar_t * restrict wcs,
                       //                wchar_t ** restrict endptr );
                       // float wcstof( const wchar_t * restrict wcs,
                       //               wchar_t ** restrict endptr ); 
                       // long double wcstold( const wchar_t * restrict wcs,
                       //                      wchar_t ** restrict endptr );
#include <stdio.h>

int main()
{
    wchar_t in[1024], *this = in, *next = in;
    double val;

    fputws( L"Enter some floating-point numbers, please:\n", stdout );
    wscanf( L"%%l[^\n]", in );

    fputws( L"Here are the values you entered:\n", stdout );
    while ( 1 )
    {
        val = wcstod( this, &next );
        if ( next == this )           // Means no conversion possible.
            break ;
        this = next;
        wprintf( L"\t%%g\n", val );
    }
    fputws( L"Done.\n", stdout );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstok_ex">
			<text>
				<![CDATA[// wcstok_ex.c : wcstok() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wcstok( wchar_t * restrict s1, 
                       //                  const wchar_t * restrict s2,
                       //                  wchar_t ** restrict ptr );

int main()
{
    wchar_t *mnemonic, *arg1, *arg2, *comment, *ptr;
    wchar_t line[ ] = L" mul eax,[ebp+4] ; Multiply by y\n";

    // First word between spaces or tabs
    mnemonic = wcstok( line, L" \t", &ptr );
    arg1 = wcstok( NULL, L",", &ptr );    // From there to the comma is arg1.
                                          // Trim off any spaces later.
    arg2 = wcstok( NULL, L";\n", &ptr );  // From there to the semicolon is
                                          // arg2.
    // To line or page end is comment:
    comment = wcstok( NULL, L"\n\r\v\f", &ptr );

    wprintf( L"Mnemonic:     %%ls\n"
             L"1st argument: %%ls\n"
             L"2nd argument: %%ls\n"
             L"Comment:      %%ls\n\n",
             mnemonic, arg1, arg2, comment );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstol_ex">
			<text>
				<![CDATA[// wcstol_ex.c : wcstol(), wcstoll() example
// -------------------------------------------------------------

#include <wchar.h>     // long int wcstol( const wchar_t * restrict wcs,
                       //                  wchar_t ** restrict endptr, int base );
                       // long long int wcstoll( const wchar_t * restrict wcs,
                       //                        wchar_t ** restrict endptr, 
                       //                        int base );

int main()
{
    wchar_t date[ ] = L"10/3/2005, 13:44:18 +0100", *more = date;
    long day, mo, yr, hr, min, sec, tzone;

    day = wcstol( more, &more, 10 ); // &more is the address of a
    mo  = wcstol( more+1, &more, 10 ); // pointer
    yr  = wcstol( more+1, &more, 10 );
    hr  = wcstol( more+1, &more, 10 );
    min = wcstol( more+1, &more, 10 );
    sec = wcstol( more+1, &more, 10 );
    tzone = wcstol( more+1, &more, 10 );

    wprintf( L"It's now %%02ld:%%02ld o'clock on %%02ld-%%02ld-%%02ld.\n",
             hr, min, mo, day, yr %% 100 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstombs_ex">
			<text>
				<![CDATA[// wcstombs_ex.c : wcstombs() example
// -------------------------------------------------------------

#include <stdlib.h>   // size_t wcstombs( char * restrict dest, 
                      //                  const wchar_t * restrict src,
                      //                  size_t n );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);

    wchar_t fmt_amount[128] = { L'\0' };
    wchar_t prefix[32]  = L"-";
    wchar_t suffix[32]  = L"â‚¬";
    wchar_t number[128] = L"123.456,78";
    char output_amount[256];

    wcscpy( fmt_amount, prefix );
    wcscat( fmt_amount, number );
    wcscat( fmt_amount, suffix );

    if ( -1 != wcstombs( output_amount, fmt_amount, 256 ))
        printf( "Full amount: %%s\n", output_amount );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstoumax_ex">
			<text>
				<![CDATA[// wcstoumax_ex.c : wcstoumax() example
// -------------------------------------------------------------

#include <stddef.h>
#include <inttypes.h>  // uintmax_t wcstoumax( const wchar_t * restrict wcs,
                       //                      wchar_t ** restrict endptr, int base );
#include <wchar.h>

typedef struct {
    uintmax_t packets, bytes;
    wchar_t policy[16];
    wchar_t protocol[6];
    /* ... */
} stats_t ;

int main()
{
    stats_t iface_in = {0};
    wchar_t wcsstat[] =
            L"25183 1633438 ACCEPT tcp -- eth2 * 0.0.0.0/0 tcp dpts:80";
    wchar_t *wcsptr = wcsstat;

    iface_in.packets = wcstoumax( wcsptr, &wcsptr, 10 );
    iface_in.bytes = wcstoumax( ++wcsptr, &wcsptr, 10 );
    /* ... */

    wprintf( L"Packets: %%" PRIuMAX "; bytes: %%" PRIuMAX "; policy: ...\n",
             iface_in.packets, iface_in.bytes );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsxfrm_ex">
			<text>
				<![CDATA[// wcsxfrm_ex.c : wcsxfrm() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcsxfrm( wchar_t * restrict dest, 
                     //                 const wchar_t * restrict src,
                     //                 size_t n );
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

typedef struct stringpair { wchar_t * original;
                            wchar_t * xformed;
                          } Stringpair_t ;

int stringpaircmp( const void *p1, const void *p2 );

int main()
{
    wchar_t *originals[] = { L"ChÃ¡vez", L"Carron", L"Canoso",
                             L"CaÃ±oso", L"CarteÃ±o", L"Corriando",
                             L"Carilo", L"CarillÃ³n", };
    wchar_t xformbuffer[1024];

    /* Make an array of structures out of the strings and their
       xformations */

    const int elementcount = sizeof(originals) / sizeof(wchar_t *);
    Stringpair_t stringpairs[elementcount];

    setlocale( LC_ALL, "es_US.UTF-8" );   // Set the locale to US Spanish
    wprintf( L"Sorting order in the locale %%s:\n",
             setlocale( LC_COLLATE, NULL ));

    for ( int i = 0; i < elementcount ; i++ )
    {
        stringpairs[i].original = originals[i];
        stringpairs[i].xformed
                    = malloc( wcsxfrm( xformbuffer, originals[i], 1024 ));
        if ( stringpairs[i].xformed != NULL )
           wcscpy( stringpairs[i].xformed, xformbuffer );
    }

    qsort( stringpairs, elementcount,
           sizeof(Stringpair_t), stringpaircmp );

    for ( int i = 0; i < elementcount ; i++ )
    {
        fputws( stringpairs[i].original, stdout );
        fputwc( L'\n', stdout );
    }
} // end of main()

/* A comparison function for use by qsort. Uses wcscmp() rather
 * that wcscoll(), assuming strings are paired with their wcsxfrm()
 * results in a Stringpair_t structure.
*/
int stringpaircmp( const void *p1, const void *p2 )
{
    const Stringpair_t * sp1 = (Stringpair_t *)p1;
    const Stringpair_t * sp2 = (Stringpair_t *)p2;

    return wcscmp( sp1->xformed, sp2->xformed );
}
]]>
			</text>
		</p>
		<p n="xc_wctomb_ex">
			<text>
				<![CDATA[// wctomb_ex.c : wctomb() example
// -------------------------------------------------------------

#include <stdlib.h>   // int wctomb( char *s, wchar_t wc );
#include <wchar.h>
#include <stdio.h>
#include <limits.h>
#include <locale.h>

int main()
{
    char mbbuffer[MB_LEN_MAX] = { '\0' };
    wchar_t wcs[] = L"Wir stehen auf den FÃ¼ÃŸen von Riesen";
    int n = 0, i = 0;

    printf( "The current locale is %%s.\n", setlocale( LC_CTYPE, "" ));
    printf( "The locale's multibyte encoding is %%s.\n",
             (wctomb( NULL, L'\0' ) ? "stateful" : "stateless" ));

    do {
        n += wctomb( mbbuffer, wcs[i] );
    } while ( wcs[i++] != L'\0' );

    printf( "The wide string \"%%ls\" \nis %%u wide characters long.\n"
            "Its multibyte representation requires a buffer of %%u bytes.\n",
            wcs, wcslen( wcs ), n );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wctomb_s_ex">
			<text>
				<![CDATA[// wctomb_s_ex.c : wctomb_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1         // For wctomb_s()

#include <stdlib.h>   // errno_t wctomb_s( int * restrict status,
                      //                   char * restrict s,
                      //                   rsize_t smax, 
                      //                   wchar_t wc);
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    setlocale(LC_ALL, "en_US.utf8");

    wchar_t wc = L'\u03B1';       // Greek lowercase alpha Î±
    char mbStr[MB_CUR_MAX];
    int nBytes = 0;

    // if( (nBytes = wctomb( mbStr, wc )) < 0)
    // is equivalent to
    if( wctomb_s( &nBytes, mbStr, sizeof(mbStr), wc ) != 0)
    { /* error: */ return -1; }

    printf("Wide-character code: %%#06x; character: '%%lc'; "
           "multibyte code:", wc, wc);
    for( int i = 0; i < nBytes; ++i)
        printf(" %%#04x", (unsigned char)mbStr[i]);
    putchar('\n');

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wctype_ex">
			<text>
				<![CDATA[// wctype_ex.c : wctype() example
// -------------------------------------------------------------

#include <wctype.h>   // wctype_t wctype( const char *property );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wctype_t wct_kanji, wct_kata, wct_hira  /* , ... */ ;

    if ( setlocale( LC_CTYPE, "ja_JP.UTF-8" ) == NULL)
        fputws(L"Unable to set the locale.\n", stderr);

    if (( wct_kata = wctype( "jkata" ) ) == 0 )
    {   wprintf( L"The locale doesn't support the wide-character type "
                  "string \"jkata\".\n" ); 
        return -1;
    }
    /* ... */
    wchar_t wc = fgetwc( stdin );
    if ( iswctype( wc, wct_kata ) )          // Mainly 0xFF66 âˆ’ 0xFF9F.
        wprintf( L"%%lc is a katakana character.\n", wc );
    else
        wprintf( L"%%lc is a not katakana character.\n", wc );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wmemcpy_ex">
			<text>
				<![CDATA[// wmemcpy_ex.c : wmemcpy(), wmemcpy_s() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wmemcpy( wchar_t * restrict dest, 
                       //                   const wchar_t * restrict src,
                       //                   size_t n );
                       // errno_t wmemcpy_s( wchar_t * restrict dest, rsize_t destmax,
                       //                    const wchar_t * restrict src, 
                       //                    rsize_t n);
#include <stdio.h>
#include <stdlib.h>

#define BUFFERSIZE 2048     // Size as a number of wchar_t elements.

wchar_t inputbuffer[BUFFERSIZE] = { L'\0' },
        *writeptr = inputbuffer;

struct block { wchar_t *text;
               struct block *next;
               struct block *prev;
             } firstblock = { NULL },  // The first block is the list head.
               *tmp = NULL;

struct block *newblock( struct block *lastblock );
                                           // Creates a linked-list member.
wchar_t *storetext( struct block *listhead,
                    wchar_t *buffer,
                    size_t bufsize );
                         // Copies input buffer to a new linked-list member.

int main()
{
    while( fgetws( writeptr, BUFFERSIZE - (writeptr - inputbuffer), stdin)
           != NULL )
    {
       // Set writeptr to end of the input string:
       writeptr = wmemchr( inputbuffer, L'\0',
                           sizeof(inputbuffer) / sizeof(wchar_t) );

       if ( BUFFERSIZE - (writeptr - inputbuffer) < 80 )
                                            // If block full, or nearly so:
       {                                    // copy buffer to a data block.
           writeptr = storetext( &firstblock, inputbuffer, BUFFERSIZE );
           if ( writeptr == NULL )          // Out of memory!
              abort();
       }
    }    // Here if fgetws() returns NULL.

    writeptr = storetext( &firstblock, inputbuffer, BUFFERSIZE );
    if ( writeptr == NULL )                 // Out of memory!
       abort();
}

// ----------------------------
wchar_t *storetext(struct block *listhead,
                   wchar_t *buffer, size_t bufsize)
    // Copies input buffer to a new chained-list member;
    // returns pointer to input buffer, or NULL on failure.
{
    struct block *tmp = listhead;     // create new block on end of list ...
    while ( tmp->next != NULL )
       tmp = tmp->next;
    if (( tmp = newblock( tmp )) != NULL )
       wmemcpy( tmp->text, buffer, bufsize );     // ... and copy the text.
    // Or:
    // wmemcpy_s( tmp->text, BUFFERSIZE, buffer, bufsize );
    else            // Out of memory!
       return NULL;

#ifdef DEBUG
    fwprintf( stderr, L"\nStored a block with this text:\n%%ls\n",
              tmp->text );
#endif

    return buffer;     // Return pointer to buffer, now ready for re-use.
}

// ----------------------------
struct block *newblock( struct block *lastblock )
   // Allocates a new block and appends it to the chained list;
   // returns pointer to new block, or NULL on failure.
{
   if (( lastblock->next = malloc( sizeof(struct block) )) != NULL
         && ( lastblock->next->text
                 = malloc( BUFFERSIZE * sizeof(wchar_t) )) != NULL)
   {
      lastblock->next->prev = lastblock;
      lastblock->next->next = NULL;
      return lastblock->next;
   }
   else            // Out of memory!
      return NULL;
}
]]>
			</text>
		</p>
		<p n="xc_wscanf_ex">
			<text>
				<![CDATA[// wscanf_ex.c : wscanf() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>
    // int wscanf( const wchar_t * restrict format, ... );
    // int wscanf_s( const wchar_t * restrict format, ... );

int main()
{
    wchar_t perms[12];
    wchar_t name[256];
    unsigned int ownerid, groupid, links;
    unsigned long size;
    int count;

    count = wscanf( L"%%11l[rwxsStTld-+]%%u%%u%%u%%lu%%*10s%%*5s%%256ls",
                    perms, &links, &ownerid, &groupid, &size, name );

wprintf(L"%%ls %%u %%u %%u %%lu %%ls\n", 
         perms, links, ownerid, groupid, size, name );
    wprintf( L"\nThe file %%ls has a length of %%lu bytes.\n", name, size );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_circle">
			<text>
				<![CDATA[// circle.c: Calculate the areas of circles and
// print them in ncurses mode
// $ gcc -o circle  circle.c -lncurses

#include <curses.h>               // Console control functions
double circularArea( double r );  // Function for the math
void circle();                    // Function for output

int main()        // Starts and stops curses display mode
{

/* Set up the console behavior: */
    (void) initscr();      // Initialize the curses system
    keypad(stdscr, TRUE);  // Enable keyboard mapping
    (void) nonl();         // Disable line-end translation
    (void) cbreak();       // Take single input characters

/* Run the circle routine: */
    circle(); 
    printw( "Press any key to exit." );
    refresh();             // Put the output on the screen

/* Finish: */
    getch();               // Wait for user to press a key
    endwin();              // Shut down curses console
    return 0;
}

// The circle.c program from Example 1.1, but replacing the
// standard library function printf() with printw() from the
// ncurses library.
void circle()
{
  double radius = 1.0, area = 0.0;
  printw("    Areas of Circles\n\n" );
  printw("     Radius          Area\n"
          "-------------------------\n" );
  area = circularArea( radius );
  printw( "%%10.1f     %%10.2f\n", radius, area ); 
  radius = 5.0;
  area = circularArea( radius );
  printw( "%%10.1f     %%10.2f\n", radius, area ); 
}

// Return the area of a circle with radius r
double circularArea( double r )
{
  const double pi = 3.1415926536; // Pi is a constant 
  return  pi * r * r;
}
]]>
			</text>
		</p>
		<p n="xlnx_epoll">
			<text>
				<![CDATA[/***************************************** 

* File Name : epoll.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : https://suchprogramming.com/epoll-in-3-easy-steps/

******************************************/

/**
 *  Purpose:
 *
 */

#define MAX_EVENTS 5
#define READ_SIZE 10
#include <stdio.h>     // for fprintf()
#include <unistd.h>    // for close(), read()
#include <sys/epoll.h> // for epoll_create1(), epoll_ctl(), struct epoll_event
#include <string.h>    // for strncmp

int main()
{
  int running = 1, event_count, i;
  size_t bytes_read;
  char read_buffer[READ_SIZE + 1];
  struct epoll_event event;
  struct epoll_event events[MAX_EVENTS];
  int epoll_fd = epoll_create1(0);

  if(epoll_fd == -1)
  {
    fprintf(stderr, "Failed to create epoll file descriptor\n");
    return 1;
  }

  event.events = EPOLLIN;
  event.data.fd = 0;

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, 0, &event))
  {
    fprintf(stderr, "Failed to add file descriptor to epoll\n");
    close(epoll_fd);
    return 1;
  }

  while(running)
  {
    printf("\nPolling for input...\n");
    event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, 30000);
    printf("%%d ready events\n", event_count);
    for(i = 0; i < event_count; i++)
    {
      printf("Reading file descriptor '%%d' -- ", events[i].data.fd);
      bytes_read = read(events[i].data.fd, read_buffer, READ_SIZE);
      printf("%%zd bytes read.\n", bytes_read);
      read_buffer[bytes_read] = '\0';
      printf("Read '%%s'\n", read_buffer);

      if(!strncmp(read_buffer, "stop\n", 5))
        running = 0;
    }
  }


  if(close(epoll_fd))
  {
    fprintf(stderr, "Failed to close epoll file descriptor\n");
    return 1;
  }
  return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_mmap">
			<text>
				<![CDATA[/***************************************** 

* File Name : mmap.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>

/**
 * ******************************************************
 * 
void * realloc (void *addr, size_t len)
{
        size_t old_size = look_up_mapping_size (addr);
        void *p;

        p = mremap (addr, old_size, len, MREMAP_MAYMOVE);
        if (p == MAP_FAILED)
                return NULL;
        return p;
}
 * ******************************************************
**/


/**
 * ******************************************************
 * #include <sys/mman.h>

int mprotect (const void *addr,
              size_t len,
              int prot);
 * ******************************************************
**/

/**
 * ******************************************************
 * #include <sys/mman.h>

int msync (void *addr, size_t len, int flags);
 * ******************************************************
**/


/**
 * ******************************************************
 * The only unfamiliar system call in this example should be 
 * fstat(), which we will cover in Chapter 8. All you need to
 * know at this point is that fstat() returns information 
 * about a given file. 
 *
 * The S_ISREG() macro can check some 
 * of this information so that we can ensure that the given
 * file is a regular file (as opposed to a device file or a 
 * directory) before we map it. 
 *
 * The behavior of nonregular
 * files when mapped depends on the backing device.
 * Some device files are mmap-able; other nonregular files 
 * are not mmap-able and will set errno to EACCES.
 *
 * The rest of the example should be straightforward. The program is
 * passed a filename as an argument. It opens the file, ensures 
 * it is a regular file, maps it, closes it, prints the file 
 * byte-by-byte to standard out, and then unmaps the file from memory.
 * ******************************************************
**/
int main (int argc, char *argv[])
{
        struct stat sb;
        off_t len;
        char *p;
        int fd;

        if (argc < 2) {
                fprintf (stderr, "usage: %%s <file>\n", argv[0]);
                return 1;
        }

        fd = open (argv[1], O_RDONLY);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        if (fstat (fd, &sb) == -1) {
                perror ("fstat");
                return 1;
        }

        if (!S_ISREG (sb.st_mode)) {
                fprintf (stderr, "%%s is not a file\n", argv[1]);
                return 1;
        }

        p = mmap (0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
        if (p == MAP_FAILED) {
                perror ("mmap");
                return 1;
        }

        if (close (fd) == -1) {
                perror ("close");
                return 1;
        }

        for (len = 0; len < sb.st_size; len++)
                putchar (p[len]);

        if (munmap (p, sb.st_size) == -1) {
                perror ("munmap");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_readv">
			<text>
				<![CDATA[/***************************************** 

* File Name : readv.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/uio.h>

int main ()
{
        char foo[48], bar[51], baz[49];
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        fd = open ("buccaneer.txt", O_RDONLY);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        /* set up our iovec structures */
        iov[0].iov_base = foo;
        iov[0].iov_len = sizeof (foo);
        iov[1].iov_base = bar;
        iov[1].iov_len = sizeof (bar);
        iov[2].iov_base = baz;
        iov[2].iov_len = sizeof (baz);

        /* read into the structures with a single call */
        nr = readv (fd, iov, 3);
        if (nr == -1) {
                perror ("readv");
                return 1;
        }

        for (i = 0; i < 3; i++)
                printf ("%%d: %%s", i, (char *) iov[i].iov_base);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_writev">
			<text>
				<![CDATA[/***************************************** 

* File Name : writev.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/uio.h>

int main ()
{
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        char *buf[] = {
                "The term buccaneer comes from the word boucan.\n",
                "A boucan is a wooden frame used for cooking meat.\n",
                "Buccaneer is the West Indies name for a pirate.\n" };

        fd = open ("buccaneer.txt", O_WRONLY | O_CREAT | O_TRUNC);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        /* fill out three iovec structures */
        for (i = 0; i < 3; i++) {
                iov[i].iov_base = buf[i];
                iov[i].iov_len = strlen(buf[i]) + 1;
        }
        /* with a single call, write them all out */
        nr = writev (fd, iov, 3);
        if (nr == -1) {
                perror ("writev");
                return 1;
        }
        printf ("wrote %%d bytes\n", (int)nr);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_processor_affinity">
			<text>
				<![CDATA[/***************************************** 

* File Name : processor_affinity.c

* Creation Date : 18-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#define _GNU_SOURCE

#include <sched.h>
#include <error.h>
#include <stdio.h>

#if 0
typedef struct cpu_set_t;

size_t CPU_SETSIZE;

void CPU_SET (unsigned long cpu, cpu_set_t *set);
void CPU_CLR (unsigned long cpu, cpu_set_t *set);
int CPU_ISSET (unsigned long cpu, cpu_set_t *set);
void CPU_ZERO (cpu_set_t *set);

int sched_setaffinity (pid_t pid, size_t setsize,
                       const cpu_set_t *set);

int sched_getaffinity (pid_t pid, size_t setsize,
                       cpu_set_t *set);
#endif


/**
 * ******************************************************
 *  Checks if the cpu is set
 * ******************************************************
**/
void check_set_processors() {
    cpu_set_t set;
    int ret, i;

    CPU_ZERO (&set);
    ret = sched_getaffinity (0, sizeof (cpu_set_t), &set);
    if (ret == -1)
            perror ("sched_getaffinity");

    for (i = 0; i < 8 /*nr of cores*/; i++) {
            int cpu;

            cpu = CPU_ISSET (i, &set);
            printf ("cpu=%%i is %%s\n", i,
                    cpu ? "set" : "unset");
    }
}

/**
 * ******************************************************
 *  Set the hard affinity for the process
 * ******************************************************
**/
void set_hard_affinity() {
    cpu_set_t set;
    int ret, i;

    CPU_ZERO (&set);        /* clear all CPUs */
    CPU_SET (0, &set);      /* allow CPU #0 */
    //CPU_CLR (1, &set);      /* disallow CPU #1 */
                              /* clearing is not necessary */
    ret = sched_setaffinity (0, sizeof (cpu_set_t), &set);
    if (ret == -1)
            perror ("sched_setaffinity");

    for (i = 0; i < 8 /*nr of cores*/; i++) {
            int cpu;

            cpu = CPU_ISSET (i, &set);
            printf ("cpu=%%i is %%s\n", i,
                    cpu ? "set" : "unset");
    }
}

int main(int argc, char ** argv) {
    check_set_processors();
    set_hard_affinity();
}
]]>
			</text>
		</p>
		<p n="xlnx_scheduling">
			<text>
				<![CDATA[/***************************************** 

* File Name : scheduling.c

* Creation Date : 18-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <sched.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>



void wrapper_sched_yield() {
    while(1) {
        sched_yield();
    }
}

/**
 * ******************************************************
 *  Sets the processor niceness:
 *  -20 to 19
 * ******************************************************
**/
void wrapper_nice() {
    int ret, val;

    /* get current nice value */
    val = nice (0);

    /* we want a nice value of 10 */
    val = 10 - val;
    errno = 0;
    ret = nice (val);
    if (ret == -1 && errno != 0)
            perror ("nice");
    else
            printf ("nice value is now %%d\n", ret);
}

/**
 * ******************************************************
 *  which: PRIO_PROCESS
 *         PRIO_PGRP
 *         PRIO_USER
 *
 *  who: PID
 *       0 means current process, group or user
 * ******************************************************
**/
void wrapper_getpriority(int which, int who) {
    int ret = getpriority(which, who);
    printf("nice value is %%d\n", ret);
}

void wrapper_setpriority(int which, int who, int prio) {
    int ret = setpriority(which, who, prio);
    if (ret == -1) perror ("setpriority");
}


int main(int argc, char ** argv) {

}
]]>
			</text>
		</p>
		<p n="xlnx_buffered_io">
			<text>
				<![CDATA[/***************************************** 

* File Name : main.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

/* fcloseall() */
#define _GNU_SOURCE

/* open(), creat(), lseek(), ftruncate */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <stdio.h>

/**
 * ******************************************************
 *  Fopen wrapper
 * ******************************************************
**/
void wrapper_fopen() {
    FILE *stream = NULL;

    stream = fopen("/etc/manifest", "r");
    if (!stream) perror("fopen");

    int close = fclose(stream);
    (void)close;
}

void wrapper_fdopen() {
    FILE *stream = NULL;
    int fd, close;

    fd = open("/tmp/test.txt", O_RDONLY);
    if (fd == -1) perror ("open:");

    stream = fdopen(fd, "r");
    if (!stream) perror("fopen");

    close = fclose(stream);
    (void)close;
}

/**
 * ******************************************************
 *  fgetc wrapper
 * ******************************************************
**/
void wrapper_getc() {
    FILE *stream = NULL;
    int c;

    c = fgetc(stream);

    if (c == EOF) perror("getc:");
    else printf("c=%%c'n", (char) c);

    int ret = ungetc(c, stream);
    (void)ret;
}


/**
 * ******************************************************
 *  fgets() wrapper
 * ******************************************************
**/
void wrapper_fgets() {
    int line_max = 100;
    char buf[line_max];
    FILE *stream = NULL;

    if (!fgets (buf, line_max, stream)) {
        perror("fgets:");
    }
}

/**
 * ******************************************************
 *  Reads a line of data. Also stops reading at delimiter 
 *  'd'
 * ******************************************************
**/
void fgets_substitute(int n, char d, char* str, FILE *stream) {
    char *s;
    int c;

    s = str;

    while (--n > 0 && (c = fgetc(stream)) != EOF && (*s++ = c) != d)
        ;

    if (c == d)
        *--s = '\0';
    else
        *s ='\0' ;
}


/**
 * ******************************************************
 *  Fread() wrapper
 * ******************************************************
**/
void wrapper_fread() {
    FILE *stream = NULL;
    size_t size = 100;
    char buf[(int)size];
    size_t  nr = 1;

    stream = fopen("/etc/manifest", "r");
    if (!stream) perror("fopen");

    size_t ret = fread(buf, size, nr, stream);

    if (ret == 0) perror("fread:");

    int close = fclose(stream);
    (void)close;
}


/**
 * ******************************************************
 *  Wrappers for writing
 * ******************************************************
**/
void wrapper_fputc(FILE *stream) {
    if (fputc('p', stream) == EOF) {
    }
}

void wrapper_fputs() {
    FILE *stream;

    stream = fopen("/tmp/test.txt", "a");
    if (!stream) {
        perror("fopen:");
    }

    if (fputs("The ship is made of wood.\n", stream) == EOF) perror("fputs");

    if (fclose(stream) == EOF) perror("fclose:");
}

void wrapper_fwrite(void *buf, size_t size, size_t nr, FILE *stream) {
    size_t ret = fwrite(buf, size, nr, stream);
    (void) ret;
}


#if 0
#include <stdio.h>
int fseek (FILE *stream, long offset, int whence);
#endif

#if 0
#include <stdio.h>
int fsetpos (FILE *stream, fpos_t *pos);
#endif

#if 0
#include <stdio.h>
void rewind (FILE *stream);o

errno = 0;
rewind (stream);
if (errno)
        /* error */
#endif


#if 0
#include <stdio.h>
long ftell (FILE *stream);
#endif

#if 0
#include <stdioh.h>
int fgetpos (FILE *stream, fpos_t *pos);
#endif


#if 0
#include <stdio.h>
int fflush (FILE *stream);
#endif


#if 0
#include <stdio.h>
int ferror (FILE *stream);
#endif

#if 0
#include <stdio.h>

int feof (FILE *stream);
#endif

#if 0
#include <stdio.h>

void clearerr (FILE *stream);
#endif


#if 0
#include <stdio.h>

int fileno (FILE *stream);
#endif

#if 0
#include <stdio.h>

int setvbuf (FILE *stream, char *buf, int mode, size_t size);
#endif


int main (void)
{
        FILE *in, *out;
        struct pirate {
                char            name[100]; /* real name */
                unsigned long   booty;     /* in pounds sterling */
                unsigned int    beard_len; /* in inches */
        } p, blackbeard = { "Edward Teach", 950, 48 };

        out = fopen ("data", "w");
        if (!out) {
                perror ("fopen");
                return 1;
        }

        if (!fwrite (&blackbeard, sizeof (struct pirate), 1, out)) {
                perror ("fwrite");
                return 1;
        }

        if (fclose (out)) {
                perror ("fclose");
                return 1;
        }

        in = fopen ("data", "r");
        if (!in) {
                perror ("fopen");
                return 1;
        }

        if (!fread (&p, sizeof (struct pirate), 1, in)) {
                perror ("fread");
                return 1;
        }

        if (fclose (in)) {
                perror ("fclose");
                return 1;
        }

        printf ("name=\"%%s\" booty=%%lu beard_len=%%u\n",
                p.name, p.booty, p.beard_len);

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_file_stat">
			<text>
				<![CDATA[/***************************************** 

* File Name : file_stat.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <sys/statvfs.h>
#include <stdlib.h>
#include <sys/types.h>
#include <grp.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <dirent.h>
#include <errno.h>
#include <string.h>
#include <sys/sysmacros.h>
#include <time.h>
#include <math.h>
#include <mntent.h>


/*
 * is_on_physical_device - returns a positive
 * integer if 'fd' resides on a physical device,
 * 0 if the file resides on a nonphysical or
 * virtual device (e.g., on an NFS mount), and
 * âˆ’1 on error.
 */
int is_on_physical_device (int fd)
{
        struct stat sb;
        int ret;

        ret = fstat (fd, &sb);
        if (ret) {
                perror ("fstat");
                return -1;
        }

        //return gnu_dev_major (sb.st_dev);
        return 0;
}

void wrapper_change_mod() {
    int ret;
    ret = chmod ("./map.png", S_IRUSR | S_IWUSR);

    if (ret) {
        perror("chmod");
    }
}

void wrapper_fchange_mod(int fd) {
    int ret;
    ret = fchmod (fd, S_IRUSR | S_IWUSR);

    if (ret) {
        perror("fchmod");
    }
}

void wrapper_owner() {
    struct group *gr;
    int ret;
    /*
     * getgrnam() returns information on a group
     * given its name.
     */
    gr = getgrnam ("officers");
    if (!gr) {
            /* likely an invalid group */
            perror ("getgrnam");
            return;
    }

    /* set manifest.txt's group to 'officers' */
    ret = chown("manifest.txt", -1, gr->gr_gid);
    if (ret)
            perror ("chown");
}


/*
 * make_root_owner - changes the owner and group of the file
 * given by 'fd' to root. Returns 0 on success and âˆ’1 on
 * failure.
 */
int make_root_owner (int fd)
{
        int ret;

        /* 0 is both the gid and the uid for root */
        ret = fchown (fd, 0, 0);
        if (ret)
                perror ("fchown");

        return ret;
}

/*
 * find_file_in_dir - searches the directory 'path' for a
 * file named 'file'.
 *
 * Returns 0 if 'file' exists in 'path' and a nonzero
 * value otherwise.
 */
int find_file_in_dir (const char *path, const char *file)
{
        struct dirent *entry;
        int ret = 1;
        DIR *dir;

        dir = opendir (path);

        errno = 0;
        while ((entry = readdir (dir)) != NULL) {
                if (strcmp(entry->d_name, file) == 0) {
                        ret = 0;
                        break;
                }
        }

        if (errno && !entry)
                perror ("readdir");

        closedir (dir);
        return ret;
}

void process(const char *filename)
{
	FILE *fp;
	struct mntent *fs;

	fp = setmntent(filename, "r");	/* read only */
	if (fp == NULL) {
		fprintf(stderr, "%%s: could not open: %%s\n",
			filename, strerror(errno));
		exit(1);
	}

	while ((fs = getmntent(fp)) != NULL) {
		//do_statvfs(fs);
        printf("MNT_DIR %%s", fs->mnt_dir);
        printf("fsname %%s", fs->mnt_fsname);
    }

	endmntent(fp);
}

int main (int argc, char *argv[])
{
#if 0
        struct stat sb;
        int ret;

        if (argc < 2) {
                fprintf (stderr,
                         "usage: %%s <file>\n", argv[0]);
                return 1;
        }

        ret = stat (argv[1], &sb);
        if (ret) {
                perror ("stat");
                return 1;
        }

        printf ("%%s is %%ld bytes\n",
                argv[1], sb.st_size);


        printf ("File type: ");
        switch (sb.st_mode & S_IFMT) {
        case S_IFBLK:
                printf("block device node\n");
                break;
        case S_IFCHR:
                printf("character device node\n");
                break;
        case S_IFDIR:
                printf("directory\n");
                break;
        case S_IFIFO:
                printf("FIFO\n");
                break;
        case S_IFLNK:
                printf("symbolic link\n");
                break;
        case S_IFREG:
                printf("regular file\n");
                break;
        case S_IFSOCK:
                printf("socket\n");
                break;
        default:
                printf("unknown\n");
                break;
        }

        return 0;
#endif
        struct stat sb;

        if (argc != 2) {
            fprintf(stderr, "Usage: %%s <pathname>\n", argv[0]);
            exit(1);
        }

        if (lstat(argv[1], &sb) == -1) {
            perror("lstat");
            exit(1);
        }

        printf("ID of containing device:  [%%lx,%%lx]\n",
               (long) major(sb.st_dev), (long) minor(sb.st_dev));

        printf("File type:		     ");

        switch (sb.st_mode & S_IFMT) {
            case S_IFBLK:  printf("block device\n");	       break;
            case S_IFCHR:  printf("character device\n");        break;
            case S_IFDIR:  printf("directory\n");	       break;
            case S_IFIFO:  printf("FIFO/pipe\n");	       break;
            case S_IFLNK:  printf("symlink\n");		       break;
            case S_IFREG:  printf("regular file\n");	       break;
            case S_IFSOCK: printf("socket\n");		       break;
            default:	  printf("unknown?\n"); 	       break;
        }

        printf("I-node number:	     %%ld\n", (long) sb.st_ino);

        printf("Mode:		     %%lo (octal)\n",
               (unsigned long) sb.st_mode);

        printf("Link count:		     %%ld\n", (long) sb.st_nlink);
        printf("Ownership:		     UID=%%ld   GID=%%ld\n",
               (long) sb.st_uid, (long) sb.st_gid);

        printf("Preferred I/O block size: %%ld bytes\n",
               (long) sb.st_blksize);
        printf("File size:		     %%lld bytes\n",
               (long long) sb.st_size);
        printf("Blocks allocated:	     %%lld\n",
               (long long) sb.st_blocks);

        printf("Last status change:	     %%s", ctime(&sb.st_ctime));
        printf("Last file access:	     %%s", ctime(&sb.st_atime));
        printf("Last file modification:   %%s", ctime(&sb.st_mtime));

        struct statvfs stat;

        if (statvfs(argv[1], &stat) != 0) {
            // error happens, just quits here
            return -1;
        }

        printf("Total space: %%.3f GB\n",  (stat.f_bsize * stat.f_blocks) / pow(1024, 3));
        printf("Available space: %%.3f GB\n", (stat.f_bsize * stat.f_bavail) / pow(1024, 3));

        process(argv[1]);

        exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_file_io_main">
			<text>
				<![CDATA[/***************************************** 

* File Name : main.c

* Creation Date : 13-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdbool.h>

/* open(), creat(), lseek(), ftruncate */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/* getcwd(), read(), write(), fsync(), close() */
/* lseek(), pread(), pwrite(), ftruncate() */
#include <unistd.h>

/* printf() */
#include <stdio.h>

/* PATH_MAX */
#include <limits.h>

/* str* calls */
#include <string.h>

/* errno */
#include <errno.h>

/* */
#include "multiplexed_io.h"


/**
 * ******************************************************
 * Opens a file. `man open` for all the flags.
 * ******************************************************
**/
int wrapper_open(const char* str, int flags) {
    int fd = 0;

    fd = open (str, flags);
    if (fd == -1) {
        perror("Error opening file:");
        return 1;
    } else {
        printf("Opened: %%s\n", str);
    }

    return fd;
}


/**
 * ******************************************************
 * The combination of O_WRONLY | O_CREAT | O_TRUNC is so 
 * common that a system call exists to provide just that 
 * behavior:
 * ******************************************************
**/
int wrapper_creat() {
    int fd;
    fd = creat ("some_file", 0644);
    if (fd == -1) {      /* error */
    }

    return 0;
}

/**
 * ******************************************************
 * Wrapper for read.
 * read() can have a plethora of results.
 * `man read` for  possible return values.
 * * also check pread()
 * ******************************************************
**/
ssize_t wrapper_blocking_read(int fd, void *buf, size_t len) {

    ssize_t ret, total_ret = 0;

    if (len > SSIZE_MAX) len = SSIZE_MAX;

    while (len != 0 && (ret = read(fd, buf, len)) != 0) {
        if (ret == -1) {
            if (errno == EINTR) continue;
            /* else */
            perror("blocking read");
            break;
        }
        len -= ret;
        buf += ret;
        total_ret += ret;
    }

    return total_ret;
}

ssize_t wrapper_nonblocking_read(int fd, void *buf, size_t len) {
    ssize_t ret = 0;

    if (len > SSIZE_MAX) len = SSIZE_MAX;

start:
    ret = read(fd, buf, len);
    if (ret == -1) {
        if (errno == EINTR) goto start;
        if (errno == EAGAIN) {
            /* Do some usefull stuff */
            /* Resubmit read again later */
        } else {
            /* else error */
            perror("non-blocking read");
        }
    }

    return ret;
}

/**
 * ******************************************************
 * Write wrapper
 * * also check pwrite()
 * ******************************************************
**/
ssize_t wrapper_write(int fd, const void *buf, size_t count) {
    ssize_t nr;
    int ret;
    bool essential_data_only = true;

    nr = write(fd, buf, strlen(buf));
    if (nr == -1) {
        perror("write error");
    } else if (nr != count) {
        /* possible error, but errno is not set*/
    }

    // Alternativley, open with O_SYNC, O_DSYNC, O_RSYNC
    if (essential_data_only ) {
        ret = fdatasync(fd);
        if (ret == -1) perror("fdatasync error:");
    } else {
        ret = fsync(fd);
        if (ret == -1) perror("fsync error:");
    }

    return nr;
}


ssize_t wrapper_socket_write(int fd, const void *buf, size_t len) {
    ssize_t ret, total_ret;

    /* Trying to write more than SSIZE_MAX results in 
     * undefined behaviour */
    if (len > SSIZE_MAX) len = SSIZE_MAX;

    while (len != 0 && (ret = write (fd, buf, len)) != 0) {
        if (ret == -1) {
            if (errno == EINTR) continue; 
            /*else */
            perror ("write");
            break;
        }
#if 0
        // Uncomment this if you want to flush the data to the hdd
        // Alternativley, open with O_SYNC, O_DSYNC, O_RSYNC
        if (essential_data_only ) {
            ret = fdatasync(fd);
            if (ret == -1) perror("fdatasync error:");
        } else {
            ret = fsync(fd);
            if (ret == -1) perror("fsync error:");
        }
#endif

        len -= ret;
        buf += ret;
        total_ret += ret;
    }

    return total_ret;
}

/**
 * ******************************************************
 *  Close wrapper
 * ******************************************************
**/
int wrapper_close(int fd) {
    int ret = 0;
    if ( (ret = close(fd)) == -1) {
        perror ("close");
    }

    return ret;
}

/**
 * ******************************************************
 *  Lseek wrapper. curr + pos
 *
 *   - SEEK_CUR: if pos = 0, sets cursor to curr pos
 *   - SEEK_END: if pos = 0, sets cursor to end
 *   - SEEK_SET: if pos = 0, sets cursor to beginning
 *
 *   * also check pread() and pwrite()
 *
 * ******************************************************
**/
off_t wrapper_lseek(int fd, off_t pos, int origin) {
    off_t ret;

    /* Set the cursor to poistion pos */
    ret = lseek(fd, pos, SEEK_SET);
    if (ret == (off_t) -1) {
        perror("lseek:");
    }

    return ret;
}

/**
 * ******************************************************
 *  Truncate wrapper
 * ******************************************************
**/
int wrapper_truncate(const char* path, off_t len) {
    int ret;
    ret = truncate ("./pirate.txt", 45);
    if (ret == -1) {
        perror ("truncate");
        return -1;
    } 
    return 0;
}

/**
 * ******************************************************
 *  Sscanf wrapper.
 * ******************************************************
**/
void wrapper_sscanf() {
    int nr = 10;
    const char * line = "10 ten(";
    char str[128];
    if (sscanf (line, "%%d %%64[^(]", &nr, str) < 2) {
        fprintf(stderr, "Bad command in wrapper scanf\n");
        printf("%%s\n", str);
    }
    else {
        printf("%%s\n", str);
    }
}

/**
 * ******************************************************
 *  Main
 * ******************************************************
**/
int main(int argc, char ** argv) {
    int fd;
    char cwd[PATH_MAX];
    char abs_path[PATH_MAX + 30];

    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("Current working dir: %%s\n", cwd);
    } else {
        perror("getcwd() error");
        return 1;
    }

    wrapper_sscanf();

    fd = wrapper_open("/home/teach/pearl", O_WRONLY | O_TRUNC);
    
    strcat(abs_path, cwd);
    strcat(abs_path, "/perl");

    fd = wrapper_open((const char*)abs_path, O_WRONLY | O_TRUNC);
    (void)fd;

    wrapper_select();
    wrapper_poll();

    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_file_io_multiplexed">
			<text>
				<![CDATA[/***************************************** 

* File Name : multiplexed_io.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include "multiplexed_io.h"

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <poll.h>

#define TIMEOUT 5
#define BUF_LEN 1024

/**
 * ******************************************************
 * @brief 
 * 1. Tell me when any of these fds become ready for i/o
 * 2. Sleep until one or more fds are ready
 * 3. Woken up! What is ready?
 * 4. Handle all fds ready for i/o without blocking
 * 5. go back to 1.
 * ******************************************************
**/
int wrapper_select() {
    int ret;
    struct timeval tv;
    fd_set readfds;

    /* Wait on stdin for input. */
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);

    /* Wait up to five seconds */
    /* !!!! 
     * This needs to be reinitialized on subsequent calls.
     * pselect() leaves the structure alone. 
     * !!!! */
    tv.tv_sec = TIMEOUT;
    tv.tv_usec = 0;

    /* Now block */
    ret = select(STDIN_FILENO + 1,
                &readfds,
                0,
                0,
                &tv);

    if (ret == -1) {
        perror("select:");
        return 1;
    } else if (!ret) {
        printf("%%d seconds elapsed.\n", TIMEOUT);
        /* The time structure is modified by the select() */
        printf("tv_sec %%d.\n", (int)tv.tv_sec);
        printf("tv_usec %%d.\n", (int)tv.tv_usec);
        return 0;
    }

    /* 
     * Is our fd ready to read?
     * Only one provided, so yes.
     * */
    if (FD_ISSET(STDIN_FILENO, &readfds)) {
        char buf[BUF_LEN + 1];
        int len;

        /* guaranteed to not block */
        len = read (STDIN_FILENO, buf, BUF_LEN);
        if (len == -1) {
            perror("read:");
            return 1;
        }

        if (len) {
            buf[len] = '\0';
            printf("read: %%s.\n", buf);
            /* The time structure is modified by the select() */
            printf("tv_sec %%d.\n", (int)tv.tv_sec);
            printf("tv_usec %%d.\n", (int)tv.tv_usec);
        }

        return 0;
    }

    fprintf(stderr, "This should not happen!\n");
    return 1;
}

/*
 * There are three differences between pselect() and select():
 *  - pselect() uses the timespec structure, not the timeval structure, for its 
 *    timeout parameter. The timespec structure uses seconds and nanoseconds,
 *    not seconds and microseconds, providing theoretically superior timeout 
 *    resolution. In practice, however, neither call reliably provides even
 *    microsecond resolution.
 *  - A call to pselect() does not modify the timeout parameter.
 *    Consequently, this parameter does not need to be
 *    reinitialized on subsequent invocations.
 *  - The select() system call does not have the sigmask parameter.
 *    With respect to signals, when this parameter is set to NULL, pselect()
 *    behaves like select().
 *
 *    The motivation for pselect() are the signals. The app can block indefinetly
 *    if the signall arives between the check for the global signal flag
 *    and the call to select().
 *    sigmask in pselect() blocks signals. Blocked signals are not handled
 *    until they are unblocked. Once pselec() returns, the kernel restors the
 *    old signal mask.
 */



int wrapper_poll() {
    int ret;

    struct pollfd fds[2];
    /* watch stdin for input */
    fds[0].fd = STDIN_FILENO;
    fds[0].events = POLLIN;
    /* watch stdout for ability to write (almost always true) */
    //fds[1].fd = STDOUT_FILENO;
    //fds[1].events = POLLOUT;
    /* All set, block! */
    ret = poll (fds, 1, TIMEOUT * 1000);
    if (ret == -1) {
        perror ("poll");
        return 1;
    }
    if (!ret) {
        printf ("%%d seconds elapsed.\n", TIMEOUT);
        return 0;
    }
    if (fds[0].revents & POLLIN) {
        char buf[BUF_LEN + 1];
        int len;

        /* guaranteed to not block */
        len = read (STDIN_FILENO, buf, BUF_LEN);
        if (len == -1) {
            perror("read:");
            return 1;
        }

        if (len) {
            buf[len] = '\0';
            printf("read: %%s.\n", buf);
        }
        printf ("stdin is readable\n");
    }
    if (fds[1].revents & POLLOUT)
        printf ("stdout is writable\n");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_mmap2">
			<text>
				<![CDATA[/***************************************** 

* File Name : mmap.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

/**
 * ******************************************************
 * As an alternative to standard file I/O, the kernel
 * provides an interface that allows an application to
 * map a file into memory, meaning that there is a 
 * one-to-one correspondence between a memory address 
 * and a word in the file. The programmer can then access
 * the file directly through memory, identically to any
 * other chunk of memory-resident dataâ€”it is even possible 
 * to allow writes to the memory region to transparently 
 * map back to the file on disk.
 *
 *  - or -
 *
 *  Perhaps because you want to force the use of a memory 
 *  mapping over the heap for a specific allocation, or 
 *  perhaps because you are writing your own memory allocation 
 *  system, you may want to manually create your own 
 *  anonymous memory mappingâ€”either way, Linux makes it easy. 
 *  Recall from ChapterÂ 4 that the system call mmap()
 *  creates a memory mapping and the system call munmap() 
 *  destroys a mapping:
 * ******************************************************
**/
int main(int argc, char ** argv) {
    void *p;
    int fd;

    /* open /dev/zero for reading and writing */
    fd = open ("/dev/zero", O_RDWR);
    if (fd < 0) {
            perror ("open");
            return âˆ’1;
    }

    /* map [0,page size) of /dev/zero */
    p = mmap (NULL,                   /* do not care where */
              getpagesize (),         /* map one page */
              PROT_READ | PROT_WRITE, /* map read/write */
              MAP_PRIVATE,            /* private mapping */
              fd,                     /* map /dev/zero */
              0);                     /* no offset */

    if (p == MAP_FAILED) {
            perror ("mmap");
            if (close (fd))
                    perror ("close");
            return âˆ’1;
    }

    /* close /dev/zero, no longer needed */
    if (close (fd))
            perror ("close");

    /* 'p' points at one page of memory, use it... */  
}
]]>
			</text>
		</p>
		<p n="xlnx_daemon">
			<text>
				<![CDATA[/***************************************** 

* File Name : daemon.c

* Creation Date : 17-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/fs.h>

/**
 * ******************************************************
 *  This main() actually is synonymous for:
 *  #include <unistd.h>
 *  int daemon (int nochdir, int noclose)
 * ******************************************************
**/
int main (void)
{
        pid_t pid;
//        int i;

        /* create new process */
        pid = fork ();
        if (pid == -1)
                return -1;
        else if (pid != 0)
                exit (EXIT_SUCCESS);

        /* create new session and process group */
        if (setsid () == -1)
                return -1;

        /* set the working directory to the root directory */
        if (chdir ("/") == -1)
                return -1;

        /* close all open files--NR_OPEN is overkill, but works */
//        for (i = 0; i < NR_OPEN; i++)
//                close (i);

        /* redirect fd's 0,1,2 to /dev/null */
        open ("/dev/null", O_RDWR);     /* stdin */
        dup (0);                        /* stdout */
        dup (0);                        /* stderror */

        /* do its daemon thing... */

        /* Just so you can see it with `ps | grep daemon` */
        while (1) {
            sleep(1);
        }

        return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_exec_prog">
			<text>
				<![CDATA[/***************************************** 

* File Name : exec_prog.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <errno.h>
#include <unistd.h>


int main(int argc, char ** argv) {

    char * const args[] = { "program_name_here", "/hooks.txt", NULL };
    int ret;

    ret = execv ("/usr/bin/vi", args);
    if (ret == -1) perror ("execvp");

    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_fork_call">
			<text>
				<![CDATA[/***************************************** 

* File Name : fork_call.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

void parent_out() {
    printf("parent atexit() succeeded!\n");
}

void child_out() {
    printf("child atexit() succeeded!\n");
}


int main(int argc, char ** argv) {

    pid_t pid;

    pid = fork ();
    if (pid == -1) perror ("fork");
    else if (pid > 0) {
        printf("I am the parent of pid=%%d.\n", pid);
        printf("My pid is =%%d.\n", getpid());

        /* Will call the parent_out function when falling of the 
         * edge. */
        if (atexit(parent_out)) {
            fprintf(stderr, "atexit() failed!\n");
        }

        return 0;
    }
    else if (!pid) {
        /* the child ... */
        printf(" -- I am the the child of pid=%%d.\n", getppid());
        printf(" -- My pid is =%%d.\n", getpid());
        printf(" -- I list files:\n");
        char *const args[] = { "list_child", NULL };
        int ret;

        if (atexit(child_out)) {
            fprintf(stderr, "atexit() failed!\n");
        }
        /* If I uncomment the line below then , the program ends with
         * "atexit() succeeded." Otherwise the execv() flushes all 
         * registered functions with atexit(). */
        //exit(0);

        ret = execv ("/bin/ls", args);
        if (ret == -1) {
                perror ("execv");
                exit (EXIT_FAILURE);
        }

        /* Other things which are lost on exec() family commands:
         *  - Any pending signals are lost.
         *  - Any signals that the process is catching (see Chapter 10)
         *    are returned to their default behavior, as the signal handlers
         *    no longer exist in the processâ€™s address space. 
         *  - Any memory locks (see Chapter 9) are dropped. 
         *  - Most thread attributes are returned to the default values. 
         *  - Most process statistics are reset.  
         *  - Anything related to the processâ€™s memory address space, including any mapped files, 
         *    is cleared. 
         *  - Anything that exists solely in user space, including features of the C library,
         *    such as atexit() behavior, is cleared.  
         *
         * Some properties of the process, 
         * however, do not change. For example, the pid, parent pid, priority, and owning 
         * user and group all remain the same.  Normally, open files are inherited across an exec.
         * This means the newly executed program has full access to all of the files open in the 
         * original process, assuming it knows the file descriptor values. However, this is
         * often not the desired behavior. 
         *
         * The usual practice is to close files before the exec, 
         * although it is also possible to instruct the kernel to 
         * do so automatically via fcntl().  
         */

        return 0;
    }

}
]]>
			</text>
		</p>
		<p n="xlnx_wait_call">
			<text>
				<![CDATA[/***************************************** 

* File Name : wait_call.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdlib.h>
#include <signal.h>


#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>

/**
 * ******************************************************
 *  system(): A short hand function for fork() -> exec()
 * ******************************************************
**/
void wrapper_system() {
    /*
     * During execution of the command, SIGCHLD is blocked, 
     * and SIGINT and SIGQUIT are ignored. Ignoring SIGINT 
     * and SIGQUIT has several implications,
     * particularly if system() is invoked inside a loop. 
     * If calling system() from within a loop, you should 
     * ensure that the program properly checks the exit status of the child.
     * For example:
     */
    do {
        int ret;

        ret = system ("pidof rudderd");
        if (WIFSIGNALED (ret) &&
            (WTERMSIG (ret) == SIGINT ||
             WTERMSIG (ret) == SIGQUIT))
                break; /* or otherwise handle */
    } while (1);
}

/**
 * ******************************************************
 *  The waitid(), more options than waitpid().
 * ******************************************************
**/
void wrapper_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {
    int ret = waitid (idtype, id, infop, options);

    (void)ret;
}

int main(int argc, char ** argv) {
    int status;
    pid_t pid;

    if (!fork ())
            return 1;

    //pid = wait (&status); // Weaksauce

    pid = waitpid(-1, &status, 0); // Better
    /*
     * < âˆ’1
     * Wait for any child process whose process group ID 
     * is equal to the absolute value of this value. 
     * For example, passing âˆ’500 waits for any process in process group 500.
     *
     * âˆ’1
     * Wait for any child process. This is the same behavior as wait().
     *
     * 0
     * Wait for any child process that belongs to the same process 
     * group as the calling process.
     *
     * > 0
     * Wait for any child process whose pid is exactly the value provided.
     * For example, passing 500 waits for the child process with pid 500.
     */

    /*
     * The options parameter is a binary OR of zero or more of the following 
     * options:
     * 
     *  - WNOHANG
     * Do not block, but return immediately if no matching child process has 
     * already terminated (or stopped or continued).
     *  
     *  - WUNTRACED
     * If set, the WIFSTOPPED bit in the returned status parameter is set,
     * even if the calling process is not tracing the child process. 
     * This flag allows for the implementation of more general job control,
     * as in a shell.
     *
     *  - WCONTINUED
     * If set, the WIFCONTINUED bit in the returned status parameter is
     * set even if the calling process is not tracing the child process.
     * As with WUNTRACED, this flag is useful for implementing a shell.
     */
    if (pid == -1)
            perror ("wait");

    printf ("pid=%%d\n", pid);

    if (WIFEXITED (status))
            printf ("Normal termination with exit status=%%d\n",
                    WEXITSTATUS (status));

    if (WIFSIGNALED (status))
            printf ("Killed by signal=%%d%%s\n",
                    WTERMSIG (status),
                    WCOREDUMP (status) ? " (dumped core)" : "");

    if (WIFSTOPPED (status))
            printf ("Stopped by signal=%%d\n",
                    WSTOPSIG (status));

    if (WIFCONTINUED (status))
            printf ("Continued\n");

   return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_signal_handling">
			<text>
				<![CDATA[/***************************************** 

* File Name : signal_handling.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 * https://en.wikipedia.org/wiki/Reentrancy_(computing)
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

/* handler for SIGINT and SIGTERM */
static void signal_handler (int signo)
{
        if (signo == SIGINT)
                printf ("Caught SIGINT!\n");
        else if (signo == SIGTERM)
                printf ("Caught SIGTERM!\n");
        else {
                /* this should never happen */
                fprintf (stderr, "Unexpected signal!\n");
                exit (EXIT_FAILURE);
        }
        exit (EXIT_SUCCESS);
}

int main (void)
{
        /*
         * Register signal_handler as our signal handler
         * for SIGINT.
         */
        if (signal (SIGINT, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGINT!\n");
                exit (EXIT_FAILURE);
        }

        /*
         * Register signal_handler as our signal handler
         * for SIGTERM.
         */
        if (signal (SIGTERM, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGTERM!\n");
                exit (EXIT_FAILURE);
        }

        /* Reset SIGPROF's behavior to the default. */
        if (signal (SIGPROF, SIG_DFL) == SIG_ERR) {
                fprintf (stderr, "Cannot reset SIGPROF!\n");
                exit (EXIT_FAILURE);
        }

        /* Ignore SIGHUP. */
        if (signal (SIGHUP, SIG_IGN) == SIG_ERR) {
                fprintf (stderr, "Cannot ignore SIGHUP!\n");
                exit (EXIT_FAILURE);
        }

        int i = 0;
        while (1) {
            i++;
            printf("Sleeping %%d\n", i);
            sleep(1);
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_threading">
			<text>
				<![CDATA[/***************************************** 

* File Name : threading.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

void * start_thread (void *message)
{
        printf ("%%s\n", (const char *) message);
        return message;
}

int main (void)
{
        pthread_t thing1, thing2;
        const char *message1 = "Thing 1";
        const char *message2 = "Thing 2";

        /* Create two threads, each with a different message. */
        pthread_create (&thing1, NULL, start_thread, (void *) message1);
        pthread_create (&thing2, NULL, start_thread, (void *) message2);

        /*
         * Wait for the threads to exit. If we didn't join here,
         * we'd risk terminating this main thread before the
         * other two threads finished.
         */
        pthread_join (thing1, NULL);
        pthread_join (thing2, NULL);

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_thread_safety_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : thread_saftey.h

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef _THREAD_SAFTEY_H_
#define _THREAD_SAFTEY_H_

/**
 * ******************************************************
 * #include <stdio.h>

void flockfile (FILE *stream);
 * ******************************************************
**/

/**
 * ******************************************************
 * #include <stdio.h>

void funlockfile (FILE *stream);
 * ******************************************************
**/


/**
 * ******************************************************
 *  #include <stdio.h>

int ftrylockfile (FILE *stream);
 * ******************************************************
**/


/**
 * ******************************************************
 * 
flockfile (stream);

fputs ("List of treasure:\n", stream);
fputs ("    (1) 500 gold coins\n", stream);
fputs ("    (2) Wonderfully ornate dishware\n", stream);

funlockfile (stream);
 * ******************************************************
**/


/**
 * ******************************************************
 * 
 * #define _GNU_SOURCE

#include <stdio.h>

int fgetc_unlocked (FILE *stream);
char *fgets_unlocked (char *str, int size, FILE *stream);
size_t fread_unlocked (void *buf, size_t size, size_t nr,
                       FILE *stream);
int fputc_unlocked (int c, FILE *stream);
int fputs_unlocked (const char *str, FILE *stream);
size_t fwrite_unlocked (void *buf, size_t size, size_t nr,
                        FILE *stream);
int fflush_unlocked (FILE *stream);
int feof_unlocked (FILE *stream);
int ferror_unlocked (FILE *stream);
int fileno_unlocked (FILE *stream);
void clearerr_unlocked (FILE *stream);
 * ******************************************************
**/


#endif
]]>
			</text>
		</p>
		<p n="xlnx_multiplexed_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : multiplexed_io.h

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef __MULTIPLEXED_IO_H_
#define __MULTIPLEXED_IO_H_

#include <sys/select.h>
#include <sys/time.h>

/**
 * ******************************************************
 * @brief 
 * 1. Tell me when any of these fds become ready for i/o
 * 2. Sleep until one or more fds are ready
 * 3. Woken up! What is ready?
 * 4. Handle all fds ready for i/o without blocking
 * 5. go back to 1.
 * ******************************************************
**/
int wrapper_select();

int wrapper_poll();

#endif
]]>
			</text>
		</p>
	</language.aliases>
</options>
