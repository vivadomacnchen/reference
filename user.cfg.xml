<options>
	<misc.options n="misc.options" version="1">
		<app_theme v="Dark"/>
		<search_flags v="0x1"/>
	</misc.options>
	<misc.tag_file_list n="misc.tag_file_list" version="1" configs="win">
		<p n="cs" v='%SLICKEDITCONFIGVERSION%tagfiles\unity.vtg;"C:\Users\User\Documents\My SlickEdit Config\24.0.2\tagfiles\dotnet.vtg"'/>
		<p n="bas" v='"C:\Users\User\Documents\My SlickEdit Config\24.0.2\tagfiles\dotnet.vtg"'/>
		<p n="c" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="e" v="%SLICKEDITCONFIGVERSION%tagfiles\slickc.vtg"/>
	</misc.tag_file_list>
	<misc.def_vars n="misc.def_vars" version="1">
		<p n="def_color_scheme" v="Slate"/>
		<p n="def_refactor_active_config" v="Visual Studio 2008"/>
		<p n="def_toolbar_tree_pic_size" v="12"/>
		<p n="def_toolbartab" configs="win unix">
			<array>
				<class._TOOLBAR>
					<FormName v="_tbstandard_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbproject_tools_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x1"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbtools_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbedit_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbseldisp_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbxml_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x800"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbhtml_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbtagging_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x4"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbcontext_form"/>
					<tbflags v="0x8"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x400"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbdebugbb_form"/>
					<tbflags v="0x49"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x2"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbdebug_sessions_form"/>
					<tbflags v="0x48"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x2"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbvc_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x8"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbandroid_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x1"/>
				</class._TOOLBAR>
			</array>
		</p>
		<p n="def_symbol_color_profile" v="All symbols - Dark background"/>
		<p n="def_mozilla_modified" v="1"/>
		<p n="def_eao_file_date2" v="20200401124714000"/>
		<p n="def_lldb_debug_server" v=""/>
		<p n="def_workspace_info" configs="win">
			<array>
				<class.WORKSPACE_LIST>
					<isFolder v="1"/>
					<filename/>
					<caption v="Sample Workspaces"/>
					<u>
						<array>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\clang\clang.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\csharp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\vcpp_csharp.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\vcpp_csharp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\DevStudio\2013\VS2013.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\DevStudio\2015\VS2015.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\java\java.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\ucpp\cpp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
						</array>
					</u>
					<projectname/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\workspace\testse\testse.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\workspace\testse\testse.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\workspace\netEx.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\workspace\netEx.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\NetEx\NetEx.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\NetEx\NetEx.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\crypto\wolfssl\wolfsslLEARN\wolfssl.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\crypto\wolfssl\wolfsslLEARN\wolfssl.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\crypto\openssl\opensslLEARN\openssltest\openssltest.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\crypto\openssl\opensslLEARN\openssltest\openssltest.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\usb4java\testjavausb.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\usb4java\testjavausb.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Japan\Repo\TestJP\TestJP.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Japan\Repo\TestJP\TestJP\TestJP.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswing.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswing.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswing2\testswing2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswing2\testswing2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testawtapplet\testawtapplet.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testawtapplet\testawtapplet.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswtapp\testswtapp.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswtapp\testswtapp.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testjfcapplet\testjfcapplet.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testjfcapplet\testjfcapplet.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testjfcapplication\testjfcapplication.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testjfcapplication\testjfcapplication.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\CH4.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\CH4.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testCross.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testCross.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testc.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testc.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testalg\testalg.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testalg\testalg\testalg.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\myalg\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\myalg\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testalg2\testalg2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testCordinateECC\testCordinateECC\testECCCordinate\vsporj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testCordinateECC\testCordinateECC\testECCCordinate\vsporj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\se\se.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\se\se.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch02\se_proj\se_proj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch02\se_proj\se_proj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch03\seprj\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch03\seprj\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch07\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch07\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch08\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch08\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vc_string\stringhandle\test2\test2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vc_string\stringhandle\test2\test2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vcplusplus\lisbox\lisbox\testlistbox.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vcplusplus\lisbox\lisbox\testlistbox.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vcplusplus\vcplusplus\lisbox\lisbox\testlistbox.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vcplusplus\vcplusplus\lisbox\lisbox\testlistbox.vpj"/>
				</class.WORKSPACE_LIST>
			</array>
		</p>
		<p n="def_open_style" v="0"/>
		<p n="def_jdk_install_dir" v="C:\Program Files\Java\jdk-14.0.1\" configs="win"/>
		<p n="def_java_live_errors_jdk_6_dir" v="C:\Program Files\Java\jdk-14.0.1\" configs="win"/>
		<p n="def_java_live_errors_jvm_lib" v="C:\Program Files\Java\jdk-14.0.1\bin\server\jvm.dll"/>
		<p n="def_encoding" v="+futf8s"/>
		<p n="def_git_browser_url_list">
			<array>
				<p v="C:\W\java\repo\myjava\"/>
			</array>
		</p>
		<p n="def_debug_number_formats">
			<dict>
				<p n="char">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="double">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="float">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="int">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="long">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="short">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="unsigned">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
			</dict>
		</p>
		<p n="def_project_auto_build" v="1"/>
		<p n="def_keys" v="eclipse-keys" configs="win unix"/>
		<p n="def_deselect_copy" v="0"/>
		<p n="def_vcpp_word" v="1"/>
		<p n="def_subword_nav" v="1"/>
		<p n="def_re_search_flags" v="0x4004000"/>
		<p n="def_vcproj_debug_prefs" v="2"/>
		<p n="def_mfsearch_init_flags" v="0xA"/>
		<p n="def_active_java_config" v="JDK 14.0.1"/>
	</misc.def_vars>
	<misc.tag_file_list_all n="misc.tag_file_list_all" version="1" configs="win">
		<p n="cs" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg;%SLICKEDITCONFIGVERSION%tagfiles\unity.vtg"/>
		<p n="c" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="bas" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="e" v="%SLICKEDITCONFIGVERSION%tagfiles\slickc.vtg"/>
	</misc.tag_file_list_all>
	<misc.fonts n="misc.fonts" version="1">
		<sbcs_dbcs_source_window font_name="Fixedsys" sizex10="120" flags="0x0" configs="win"/>
		<unicode_source_window font_name="Fixedsys" sizex10="120" flags="0x0" configs="win"/>
	</misc.fonts>
	<language n="language.dll" version="1">
		<p n="mode_name" v="dll"/>
	</language>
	<misc.file_extensions n="misc.file_extensions" version="1">
		<p n="encoding-def" v=""/>
		<p n="encoding-cs" v=""/>
		<p n="encoding-rb" v=""/>
		<p n="encoding-mp3" v=""/>
		<p n="encoding-7zip" v=""/>
		<p n="encoding-f90" v=""/>
		<p n="encoding-cfm" v=""/>
		<p n="encoding-f" v=""/>
		<p n="encoding-cpio" v=""/>
		<p n="encoding-coffee" v=""/>
		<p n="encoding-p4gl" v=""/>
		<p n="encoding-xhtml" v=""/>
		<p n="encoding-tagdoc" v=""/>
		<p n="encoding-cghlsl" v=""/>
		<p n="encoding-properties" v=""/>
		<p n="encoding-vtg" v=""/>
		<p n="encoding-exp" v=""/>
		<p n="encoding-plist" v=""/>
		<p n="encoding-c" v=""/>
		<p n="encoding-verilog" v=""/>
		<p n="encoding-bin" v=""/>
		<p n="encoding-adb" v=""/>
		<p n="encoding-vcproj" v=""/>
		<p n="encoding-docx" v=""/>
		<p n="encoding-w" v=""/>
		<p n="encoding-txt" v=""/>
		<p n="encoding-py" v=""/>
		<p n="encoding-ada" v=""/>
		<p n="encoding-aspx" v=""/>
		<p n="encoding-cob" v=""/>
		<p n="encoding-rpm" v=""/>
		<p n="encoding-build" v=""/>
		<p n="encoding-pas" v=""/>
		<p n="encoding-less" v=""/>
		<p n="encoding-ttcn" v=""/>
		<p n="encoding-cbl" v=""/>
		<p n="encoding-antlr" v=""/>
		<p n="encoding-svh" v=""/>
		<p n="encoding-sqlserver" v=""/>
		<p n="encoding-h" v=""/>
		<p n="encoding-fs" v=""/>
		<p n="encoding-plsql" v=""/>
		<p n="encoding-h++" v=""/>
		<p n="encoding-mk" v=""/>
		<p n="encoding-asax" v=""/>
		<p n="encoding-bat" v=""/>
		<p n="encoding-dll" v=""/>
		<p n="encoding-pm" v=""/>
		<p n="encoding-plm" v=""/>
		<p n="encoding-fsx" v=""/>
		<p n="encoding-php3" v=""/>
		<p n="encoding-pdf" v=""/>
		<p n="encoding-vsm" v=""/>
		<p n="encoding-inc" v=""/>
		<p n="encoding-xaml" v=""/>
		<p n="encoding-png" v=""/>
		<p n="encoding-asm390" v=""/>
		<p n="encoding-plx" v=""/>
		<p n="encoding-m" v=""/>
		<p n="encoding-db2" v=""/>
		<p n="encoding-htm" v=""/>
		<p n="encoding-i" v=""/>
		<p n="encoding-gsh" v=""/>
		<p n="encoding-exe" v=""/>
		<p n="encoding-dpr" v=""/>
		<p n="encoding-rs" v=""/>
		<p n="encoding-rul" v=""/>
		<p n="encoding-masm" v=""/>
		<p n="encoding-dtd" v=""/>
		<p n="encoding-docbook" v=""/>
		<p n="encoding-xpm" v=""/>
		<p n="encoding-xml" v=""/>
		<p n="encoding-rexx" v=""/>
		<p n="encoding-mpeg" v=""/>
		<p n="encoding-suo" v=""/>
		<p n="encoding-cpy" v=""/>
		<p n="encoding-tld" v=""/>
		<p n="encoding-winmd" v=""/>
		<p n="encoding-pl" v=""/>
		<p n="encoding-ascx" v=""/>
		<p n="encoding-class" v=""/>
		<p n="encoding-pro" v=""/>
		<p n="encoding-gl" v=""/>
		<p n="encoding-cob85" v=""/>
		<p n="encoding-vlx" v=""/>
		<p n="encoding-editorconfig" v=""/>
		<p n="encoding-perl" v=""/>
		<p n="encoding-cfscript" v=""/>
		<p n="encoding-vhdl" v=""/>
		<p n="encoding-hlsl" v=""/>
		<p n="encoding-rmd" v=""/>
		<p n="encoding-rhtml" v=""/>
		<p n="encoding-phpscript" v=""/>
		<p n="encoding-tiff" v=""/>
		<p n="encoding-l" v=""/>
		<p n="encoding-sdef" v=""/>
		<p n="encoding-for" v=""/>
		<p n="encoding-ruby" v=""/>
		<p n="encoding-qml" v=""/>
		<p n="encoding-psm1" v=""/>
		<p n="encoding-vsdelta" v=""/>
		<p n="encoding-cginc" v=""/>
		<p n="encoding-mak" v=""/>
		<p n="encoding-groovy" v=""/>
		<p n="encoding-g" v=""/>
		<p n="encoding-chf" v=""/>
		<p n="encoding-yaml" v=""/>
		<p n="encoding-pp" v=""/>
		<p n="encoding-mdown" v=""/>
		<p n="encoding-inl" v=""/>
		<p n="encoding-m4" v=""/>
		<p n="encoding-applescript" v=""/>
		<p n="encoding-tex" v=""/>
		<p n="encoding-gz" v=""/>
		<p n="encoding-p" v=""/>
		<p n="encoding-ansic" v=""/>
		<p n="encoding-v2k" v=""/>
		<p n="encoding-hp" v=""/>
		<p n="encoding-g4" v=""/>
		<p n="encoding-bbc" v=""/>
		<p n="encoding-rc" v=""/>
		<p n="encoding-scala" v=""/>
		<p n="encoding-frm" v=""/>
		<p n="encoding-prg" v=""/>
		<p n="encoding-vri" v=""/>
		<p n="encoding-ps1" v=""/>
		<p n="encoding-svgz" v=""/>
		<p n="encoding-ds" v=""/>
		<p n="encoding-asp" v=""/>
		<p n="encoding-slk" v=""/>
		<p n="encoding-csh" v=""/>
		<p n="encoding-cfml" v=""/>
		<p n="encoding-qth" v=""/>
		<p n="encoding-ps" v=""/>
		<p n="encoding-patch" v=""/>
		<p n="encoding-js" v=""/>
		<p n="encoding-jpeg" v=""/>
		<p n="encoding-awk" v=""/>
		<p n="encoding-ocb" v=""/>
		<p n="encoding-cpp" v=""/>
		<p n="encoding-xmldoc" v=""/>
		<p n="encoding-tcl" v=""/>
		<p n="encoding-r" v=""/>
		<p n="encoding-bas" v=""/>
		<p n="encoding-ansisql" v=""/>
		<p n="encoding-projitems" v=""/>
		<p n="encoding-zip" v=""/>
		<p n="encoding-hxx" v=""/>
		<p n="encoding-lex" v=""/>
		<p n="encoding-vcxproj" v=""/>
		<p n="encoding-shader" v=""/>
		<p n="encoding-erl" v=""/>
		<p n="encoding-ads" v=""/>
		<p n="encoding-tsv" v=""/>
		<p n="encoding-wxi" v=""/>
		<p n="encoding-d" v=""/>
		<p n="encoding-xslt" v=""/>
		<p n="encoding-mm" v=""/>
		<p n="encoding-cc" v=""/>
		<p n="encoding-cics" v=""/>
		<p n="encoding-npasm" v=""/>
		<p n="encoding-cfc" v=""/>
		<p n="encoding-ini" v=""/>
		<p n="encoding-master" v=""/>
		<p n="encoding-yacc" v=""/>
		<p n="encoding-pli" v=""/>
		<p n="encoding-java" v=""/>
		<p n="encoding-seq" v=""/>
		<p n="encoding-lib" v=""/>
		<p n="encoding-vb" v=""/>
		<p n="encoding-html" v=""/>
		<p n="encoding-a" v=""/>
		<p n="encoding-di" v=""/>
		<p n="encoding-sh" v=""/>
		<p n="encoding-asm" v=""/>
		<p n="encoding-proto" v=""/>
		<p n="encoding-err" v=""/>
		<p n="encoding-csv" v=""/>
		<p n="encoding-asc" v=""/>
		<p n="encoding-log" v=""/>
		<p n="encoding-vr" v=""/>
		<p n="encoding-sv" v=""/>
		<p n="encoding-hpp" v=""/>
		<p n="encoding-gvy" v=""/>
		<p n="encoding-itk" v=""/>
		<p n="encoding-if" v=""/>
		<p n="encoding-sql" v=""/>
		<p n="encoding-so" v=""/>
		<p n="encoding-obj" v=""/>
		<p n="encoding-mod" v=""/>
		<p n="encoding-bib" v=""/>
		<p n="encoding-cp" v=""/>
		<p n="encoding-hh" v=""/>
		<p n="encoding-sybase" v=""/>
		<p n="encoding-jar" v=""/>
		<p n="encoding-lua" v=""/>
		<p n="encoding-css" v=""/>
		<p n="encoding-md" v=""/>
		<p n="encoding-y" v=""/>
		<p n="encoding-ninja" v=""/>
		<p n="encoding-kt" v=""/>
		<p n="encoding-scriptterminology" v=""/>
		<p n="encoding-wxl" v=""/>
		<p n="encoding-vbproj" v=""/>
		<p n="encoding-cpgz" v=""/>
		<p n="encoding-wxs" v=""/>
		<p n="encoding-ch" v=""/>
		<p n="encoding-avi" v=""/>
		<p n="encoding-bourneshell" v=""/>
		<p n="encoding-pl1" v=""/>
		<p n="encoding-cljs" v=""/>
		<p n="encoding-jsfl" v=""/>
		<p n="encoding-ico" v=""/>
		<p n="encoding-cgfx" v=""/>
		<p n="encoding-bmp" v=""/>
		<p n="encoding-vpt" v=""/>
		<p n="encoding-cg" v=""/>
		<p n="encoding-matlab" v=""/>
		<p n="encoding-vsdelta2" v=""/>
		<p n="encoding-vpw" v=""/>
		<p n="encoding-swift" v=""/>
		<p n="encoding-eventhandlers" v=""/>
		<p n="encoding-itcl" v=""/>
		<p n="encoding-cmd" v=""/>
		<p n="encoding-imakefile" v=""/>
		<p n="encoding-cmake" v=""/>
		<p n="encoding-gradle" v=""/>
		<p n="encoding-xslx" v=""/>
		<p n="encoding-pdb" v=""/>
		<p n="encoding-sl" v=""/>
		<p n="encoding-xsl" v=""/>
		<p n="encoding-vhd" v=""/>
		<p n="encoding-tlib" v=""/>
		<p n="encoding-hrl" v=""/>
		<p n="encoding-diff" v=""/>
		<p n="encoding-cljc" v=""/>
		<p n="encoding-e" v=""/>
		<p n="encoding-clj" v=""/>
		<p n="encoding-bash" v=""/>
		<p n="encoding-svg" v=""/>
		<p n="encoding-php" v=""/>
		<p n="encoding-scriptsuite" v=""/>
		<p n="encoding-tsx" v=""/>
		<p n="encoding-vpj" v=""/>
		<p n="encoding-war" v=""/>
		<p n="encoding-vbs" v=""/>
		<p n="encoding-tar" v=""/>
		<p n="encoding-jpg" v=""/>
		<p n="encoding-as" v=""/>
		<p n="encoding-s" v=""/>
		<p n="encoding-z" v=""/>
		<p n="encoding-diffpatch" v=""/>
		<p n="encoding-vrh" v=""/>
		<p n="encoding-sca" v=""/>
		<p n="encoding-xz" v=""/>
		<p n="encoding-v" v=""/>
		<p n="encoding-ts" v=""/>
		<p n="encoding-7z" v=""/>
		<p n="encoding-hs" v=""/>
		<p n="encoding-setemplate" v=""/>
		<p n="encoding-mathml" v=""/>
		<p n="encoding-jsp" v=""/>
		<p n="encoding-csproj" v=""/>
		<p n="encoding-sta" v=""/>
		<p n="encoding-idl" v=""/>
		<p n="encoding-4gl" v=""/>
		<p n="encoding-rar" v=""/>
		<p n="encoding-tif" v=""/>
		<p n="encoding-conf" v=""/>
		<p n="encoding-tgz" v=""/>
		<p n="encoding-jsl" v=""/>
		<p n="encoding-xsd" v=""/>
		<p n="encoding-vpe" v=""/>
		<p n="encoding-unixasm" v=""/>
		<p n="encoding-tcc" v=""/>
		<p n="encoding-cxx" v=""/>
		<p n="encoding-go" v=""/>
		<p n="encoding-kts" v=""/>
		<p n="encoding-o" v=""/>
		<p n="encoding-msi" v=""/>
		<p n="encoding-vbscript" v=""/>
		<p n="encoding-yml" v=""/>
		<p n="encoding-c++" v=""/>
		<p n="encoding-chm" v=""/>
		<p n="encoding-xlsx" v=""/>
		<p n="encoding-cls" v=""/>
		<p n="encoding-shtml" v=""/>
		<p n="encoding-svi" v=""/>
		<p n="encoding-resx" v=""/>
		<p n="encoding-gy" v=""/>
		<p n="encoding-bz2" v=""/>
		<p n="encoding-gif" v=""/>
		<p n="encoding-markdown" v=""/>
		<p n="encoding-cljx" v=""/>
		<p n="encoding-wmv" v=""/>
		<p n="encoding-ex" v=""/>
		<p n="encoding-rby" v=""/>
		<p n="encoding-jcl" v=""/>
		<p n="encoding-json" v=""/>
		<p n="encoding-cf" v=""/>
		<p n="encoding-f95" v=""/>
		<p n="encoding-sas" v=""/>
		<p n="encoding-chs" v=""/>
		<p n="encoding-model204" v=""/>
		<p n="encoding-1" v=""/>
		<p n="encoding-backup" v=""/>
		<p n="encoding-0" v=""/>
		<p n="encoding-bak2" v=""/>
		<p n="encoding-4" v=""/>
		<p n="encoding-orig" v=""/>
		<p n="encoding-2" v=""/>
		<p n="encoding-working" v=""/>
		<p n="encoding-bak" v=""/>
		<p n="encoding-copy" v=""/>
		<p n="encoding-bak3" v=""/>
		<p n="encoding-mine" v=""/>
		<p n="encoding-3" v=""/>
		<p n="encoding-bak1" v=""/>
		<p n="encoding-save" v=""/>
	</misc.file_extensions>
	<language n="language.*ALL_LANGUAGES*" version="1">
		<line_numbers_flags v="0x3"/>
		<indent_with_tabs v="1"/>
	</language>
	<language.ada.beautifier_profiles n="language.ada.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.ada.beautifier_profiles>
	<language.android.beautifier_profiles n="language.android.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.android.beautifier_profiles>
	<language.ant.beautifier_profiles n="language.ant.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.ant.beautifier_profiles>
	<language.as.beautifier_profiles n="language.as.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.as.beautifier_profiles>
	<language.bas.beautifier_profiles n="language.bas.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.bas.beautifier_profiles>
	<language.c.beautifier_profiles n="language.c.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.c.beautifier_profiles>
	<language.cfml.beautifier_profiles n="language.cfml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.cfml.beautifier_profiles>
	<language.cs.beautifier_profiles n="language.cs.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.cs.beautifier_profiles>
	<language.docbook.beautifier_profiles n="language.docbook.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.docbook.beautifier_profiles>
	<language.groovy.beautifier_profiles n="language.groovy.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.groovy.beautifier_profiles>
	<language.html.beautifier_profiles n="language.html.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.html.beautifier_profiles>
	<language.java.beautifier_profiles n="language.java.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.java.beautifier_profiles>
	<language.js.beautifier_profiles n="language.js.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.js.beautifier_profiles>
	<language.json.beautifier_profiles n="language.json.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.json.beautifier_profiles>
	<language.m.beautifier_profiles n="language.m.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.m.beautifier_profiles>
	<language n="language.ninja" version="1">
		<indent_with_tabs v="1"/>
	</language>
	<language.phpscript.beautifier_profiles n="language.phpscript.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.phpscript.beautifier_profiles>
	<language.scala.beautifier_profiles n="language.scala.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.scala.beautifier_profiles>
	<language.systemverilog.beautifier_profiles n="language.systemverilog.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.systemverilog.beautifier_profiles>
	<language.tld.beautifier_profiles n="language.tld.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.tld.beautifier_profiles>
	<language.vbs.beautifier_profiles n="language.vbs.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.vbs.beautifier_profiles>
	<language.verilog.beautifier_profiles n="language.verilog.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.verilog.beautifier_profiles>
	<language.vpj.beautifier_profiles n="language.vpj.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.vpj.beautifier_profiles>
	<language.xhtml.beautifier_profiles n="language.xhtml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xhtml.beautifier_profiles>
	<language.xml.beautifier_profiles n="language.xml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xml.beautifier_profiles>
	<language.xsd.beautifier_profiles n="language.xsd.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xsd.beautifier_profiles>
	<language n="language.clojure" version="1">
		<tabs v="+4"/>
	</language>
	<language n="language.protocolbuf" version="1">
		<tabs v="+4"/>
	</language>
	<language n="language.c" version="1">
		<smart_paste v="0"/>
	</language>
	<language.aliases n="language.c.aliases" version="1">
		<p n="xc_printf">
			<text>
				<![CDATA[#include <stdio.h>
#include <limits.h>     // Contains the macros CHAR_MIN, INT_MIN, etc.


  printf("Storage sizes and value ranges of the types char and int\n\n");

  printf("The type char is %s.\n\n", CHAR_MIN < 0 ? "signed" :"unsigned");

  printf(" Type   Size (in bytes)   Minimum         Maximum\n"
         "---------------------------------------------------\n");
  printf(" char %8zu %20d %15d\n", sizeof(char), CHAR_MIN, CHAR_MAX );
  printf(" int  %8zu %20d %15d\n", sizeof(int), INT_MIN, INT_MAX );

%\l]]>
			</text>
		</p>
		<p n="xc_printf2">
			<text>
				<![CDATA[#include <stdio.h>
#include <float.h>

printf("Storage size: %d bytes\n"
          "Smallest positive value: %E\n"
          "Greatest positive value: %E\n"
          "Precision: %d decimal digits\n",
          sizeof(float), FLT_MIN, FLT_MAX, FLT_DIG);

   puts("\nAn example of float precision:\n");
   double d_var = 12345.6;          // A variable of type double.
   float f_var = (float)d_var;      // Initializes the float
                                    // variable with the value of d_var.
   printf("The floating-point number    "
          "%18.10f\n", d_var);
   printf("has been stored in a variable\n"
          "of type float as the value   "
          "%18.10f\n", f_var);
   printf("The rounding error is        "
          "%18.10f\n", d_var - f_var);
%\l]]>
			</text>
		</p>
		<p n="xc_rand">
			<text>
				<![CDATA[#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int i,                              // Obtain some storage space.
       *pNumbers = malloc(ARR_LEN * sizeof(int));

   if ( pNumbers == NULL )
   {
      fprintf(stderr, "Insufficient memory.\n");
      exit(1);
   }

   srand( (unsigned)time(NULL) );      // Initialize the
                                       // random number generator.

   for ( i=0; i < ARR_LEN; ++i )
      pNumbers[i] = rand() % 10000;    // Store some random numbers.

   printf("\n%d random numbers between 0 and 9999:\n", ARR_LEN );
   for ( i=0; i < ARR_LEN; ++i )       // Output loop:
   {
     printf("%6d", pNumbers[i]);       // Print one number per loop %\S
     if ( i % 10 == 9 ) putchar('\n'); // iteration and a newline after
                                       // every 10 numbers.
   }
   free( pNumbers );                   // Release the storage space.
%\l]]>
			</text>
		</p>
		<p n="xc_qsort">
			<text>
				<![CDATA[#include <stdlib.h>
#define ARR_LEN 20
#include <stdio.h>
#include <time.h>

float *pNumbers = malloc( ARR_LEN * sizeof(float) );

   /* ... Handle errors, initialize array elements ... */
   if( pNumbers == NULL)
   {
       fprintf(stderr, "Insufficient memory.\n");
       exit(1);
   }
   srand( (unsigned)time(NULL));
   for( int i=0; i < ARR_LEN; ++i)              // random numbers
       pNumbers[i] = (rand() - RAND_MAX/2) * (100.0F /RAND_MAX);

   /* Sort the array: */
   qsort( pNumbers, ARR_LEN, sizeof(float), floatcmp );

   /* ... Work with the sorted array ... */
   for( int i=0; i < ARR_LEN; ++i)              // The sorted array
       printf("%8.2f", pNumbers[i]);]]>
			</text>
		</p>
		<p n="xc_mv_element">
			<text>
				<![CDATA[#include <stdio.h>


  double dArr[5] = { 0.0, 1.1, 2.2, 3.3, 4.4 },  // Initialize an array and
  *dPtr = dArr;                                  // a pointer to its first
                                                 // element.
  int i = 0;                         // An index variable.
  dPtr = dPtr + 1;                   // Advance dPtr to the second element.
  dPtr = 2 + dPtr;                   // Addends can be in either order.
                                     // dPtr now points to dArr[3].

  printf( "%.1f\n", *dPtr );         // Print the element referenced by dPtr.
  printf( "%.1f\n", *(dPtr -1) );    // Print the element before that, without
                                     // modifying the pointer dPtr.
  i = dPtr - dArr;                   // Result: the index of the
                                     // array element that dPtr points to.
  printf( "%.d\n", i );              // Print the index (3).

%\l]]>
			</text>
		</p>
		<p n="xc_setbit">
			<text>
				<![CDATA[#include <limits.h>

unsigned int setBit( unsigned int mask, unsigned int p )
{
   if ( p >= CHAR_BIT * sizeof(int) )
      return mask;
   else
      return mask | (1 << p);
}]]>
			</text>
		</p>
		<p n="xc_strcpy_">
			<text>char *strcpy_( char* restrict s1, const char* restrict s2 )
{
   int i = 0;
   do
      s1[i] = s2[i];           // The loop body: copy each character
   while ( s2[i++] != '\0' );  // End the loop if we just copied a '\0'.
   return s1;
}</text>
		</p>
		<p n="xc_menu">
			<text>int menu( void )               // Prints the menu and returns
{                              // a character that the user types.
   static char menuStr[] =
   "\n               A = Action 1"
   "\n               B = Action 2"
   "\n               Q = Quit the program"
   "\n Your choice:  ";

   fputs( menuStr,stdout);

   int choice = 0;
   do %\S
     if( (choice = getchar()) == EOF)
         choice = 'Q'; %\S
   while( isspace(choice) );

   return choice;
}</text>
		</p>
		<p n="xc_bubblesort">
			<text>
				<![CDATA[void bubbleSort( float arr[], int len )   // The array arr and
{                                         // its length len.
   int isSorted = 0;
   do
   {
      float temp;             // Holder for values being swapped.
      isSorted = 1;
      --len;
      for ( int i = 0; i < len; ++i )
        if ( arr[i] > arr[i+1] )
        {
           isSorted = 0;      // Not finished yet.
           temp = arr[i];     // Swap adjacent values.
           arr[i] = arr[i+1];
           arr[i+1] = temp;
        }
   } while ( !isSorted );
}]]>
			</text>
		</p>
		<p n="xc_str_reverse">
			<text>
				<![CDATA[#include <string.h>

void strReverse( char* str)
{
   char ch;
   for ( size_t i = 0, j = strlen(str)-1; i < j; ++i, --j )
       ch = str[i], str[i] = str[j], str[j] = ch;
}]]>
			</text>
		</p>
		<p n="xc_selectionsort">
			<text>
				<![CDATA[// With gcc use the option -O  
// GCC does not inline any functions when not optimizing

// The function swapf() exchanges the values of two float variables.
// Arguments:    Two pointers to float.
// Return value: None.

inline void swapf( float *p1, float *p2 )      // An inline function.
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;
}

// The function selection_sortf() uses the selection-sort
// algorithm to sort an array of float elements.
// Arguments:    An array of float, and its length.
// Return value: None.

void selection_sortf( float a[], int n )   // Sort an array a of length n.
{
   register int i, j, mini;                // Three index variables.
   for ( i = 0; i < n - 1; ++i )
   {
      mini = i;             // Search for the minimum starting at index i.
      for ( j = i+1; j < n; ++j )
         if ( a[j] < a[mini] )
           mini = j;
      swapf( a+i, a+mini); // Swap the minimum with the element at index i.
   }
}]]>
			</text>
		</p>
		<p n="xc_factorial">
			<text>
				<![CDATA[// factorial() calculates n!, the factorial of a non-negative number n.
// For n > 0, n! is the product of all integers from 1 to n inclusive.
// 0! equals 1.
// Argument: A whole number, with type unsigned int.
// Return value: The factorial of the argument, with type long double.

long double factorial( register unsigned int n )
{
   long double f = 1;
   while ( n > 1 )
     f *= n--;
   return f;
}
%\l]]>
			</text>
		</p>
		<p n="xc_max">
			<text>
				<![CDATA[// The function maximum() obtains the greatest value in a
// two-dimensional matrix of double values.
// Arguments:    The number of rows, the number of columns, and the matrix.
// Return value: The value of the greatest element.

double maximum( int nrows, int ncols, double matrix[nrows][ncols] )
{
   double max = matrix[0][0];
   for ( int r = 0; r < nrows; ++r )
      for ( int c = 0; c < ncols; ++c )
         if ( max < matrix[r][c] )
            max = matrix[r][c];
   return max;
}]]>
			</text>
		</p>
		<p n="xc_swapf">
			<text>// With gcc use the option -O  
// GCC does not inline any functions when not optimizing

// The function swapf() exchanges the values of two float variables.
// Arguments:    Two pointers to float.
// Return value: None.

inline void swapf( float *p1, float *p2 )      // An inline function.
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;
}</text>
		</p>
		<p n="xc_binarysearch">
			<text>
				<![CDATA[// The binarySearch() function searches a sorted array.
// Arguments:    The value of the element to find;
//               the array of long to search; the array length.
// Return value: A pointer to the element found,
//               or NULL if the element is not present in the array.

long *binarySearch( long val, long array[ ], int n )
{
   int m = n/2;
   if ( n <= 0 )          return NULL;
   if ( val == array[m] ) return array + m;
   if ( val < array[m] )  return binarySearch( val, array, m );
   else                   return binarySearch( val, array+m+1, n-m-1 );
}

int main()
{
  long lArr[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
  int len = sizeof(lArr)/sizeof(*lArr);

  for ( int i = 0; i < len; ++i )
     printf("%6ld", lArr[i]);
  putchar('\n');

  long value = 0;
  printf( "\nEnter a whole number: ");
  scanf( "%ld", &value );

  long *ptr = binarySearch( value, lArr, len);

  if( ptr == NULL)
    printf("%ld is not an element of the array.\n", value);
  else
  { %\S
    int n = ptr+1 - lArr;
    printf("%ld is the %dth element in the arry.\n", value, n );
  }
  return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_strcat_">
			<text>char *strcat_( char * restrict s1, const char * restrict s2 )
{
   char *rtnPtr = s1;
   while ( *s1 != '\0' )               // Find the end of string s1.
      ++s1;
   while (( *s1++ = *s2++ ) != '\0' )  // The first character from s2
     ;                                 // replaces the terminator of s1.
   return rtnPtr;
}</text>
		</p>
		<p n="xc_printMatrix">
			<text>
				<![CDATA[#define NCOLS 10                    // The number of columns.
typedef float ROW_t[NCOLS];         // A type for the "row"

// Print one "row" array.
void printRow( const ROW_t pRow )
{
   for( int c = 0; c < NCOLS; ++c )
      printf( "%6.2f", pRow[c] );
   putchar( '\n' );
}

// Print the whole matrix.
void printMatrix( ROW_t *pMat, int nRows )
{
   for( int r = 0; r < nRows; ++r )
      printRow( pMat[r] );           // Print each row.
}]]>
			</text>
		</p>
		<p n="xc_selection_sort_ptr">
			<text>
				<![CDATA[inline void swapf( float *p1, float *p2 )
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;      // Swap *p1 and *p2.
}

// The function selection_sortf() uses the selection-sort
// algorithm to sort an array of float elements.
// Arguments: An array of float, and its length.

void selection_sortf( float a[], int n )       // Sort an array a of
{                                              // n float elements.
   if ( n <= 1 ) return;               // Nothing to sort.

   register float *last = a + n-1,     // A pointer to the last element.
                  *p,                  // A pointer to a selected element.
                  *minPtr;             // A pointer to the current minimum.

   for ( ; a < last; ++a )             // Walk pointer a through the array.
   {
      minPtr = a;                      // Find the smallest element
      for ( p = a+1; p <= last; ++p )  // between a and the last element.
         if ( *p < *minPtr )
           minPtr = p;
      swapf( a, minPtr );              // Swap the smallest element
   }                                   // with the element at a.
}]]>
			</text>
		</p>
		<p n="xc_sorttext">
			<text>
				<![CDATA[// Example 9-4. A simple program to sort lines of text
// sorttext.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *getLine(void);                // Reads a line of text
int str_compare(const void *, const void *);

#define NLINES_MAX 1000             // Maximum number of text lines.
char *linePtr[NLINES_MAX];          // Array of pointers to char.

int main()
{
   // Read lines:
   int n = 0;                       // Number of lines read.
   for ( ; n < NLINES_MAX && (linePtr[n] = getLine()) != NULL; ++n )
     ;

   if ( !feof(stdin) )              // Handle errors.
   {
      if ( n == NLINES_MAX )
         fputs( "sorttext: too many lines.\n", stderr );
      else
         fputs( "sorttext: error reading from stdin.\n", stderr );
   }
   else                             // Sort and print.
   {
      qsort( linePtr, n, sizeof(char*), str_compare );   // Sort.
      for ( char **p = linePtr; p < linePtr+n; ++p )     // Print.
         puts(*p);
   }
   return 0;
}

// Reads a line of text from stdin; drops the terminating
// newline character.
// Return value: A pointer to the string read, or
//               NULL at end-of-file, or if an error occurred.

#define LEN_MAX 512                 // Maximum length of a line.

char *getLine()
{
   char buffer[LEN_MAX], *linePtr = NULL;

   if ( fgets( buffer, LEN_MAX, stdin ) != NULL )
   {
      size_t len = strlen( buffer );

      if ( buffer[len-1] == '\n' )   // Trim the newline character.
         buffer[len-1] = '\0';
      else
         ++len;

      if ( (linePtr = malloc( len )) != NULL )   // Get memory for the line.
         strcpy( linePtr, buffer );  // Copy the line to the allocated block.
   }
   return linePtr;
}

// Comparison function for use by qsort().
// Arguments: Pointers to two elements in the array being sorted:
//            here, two pointers to pointers to char (char **).

int str_compare( const void *p1, const void *p2 )
{
   return strcmp( *(char **)p1, *(char **)p2 );
}
%\l]]>
			</text>
		</p>
		<p n="xc_func_ptr">
			<text>double Add( double x, double y ) { return x + y; }
double Sub( double x, double y ) { return x - y; }
double Mul( double x, double y ) { return x * y; }
double Div( double x, double y ) { return x / y; }

// Array of 5 pointers to functions that take two double parameters
// and return a double:

// double (*funcTable[5])(double, double)
//          = { Add, Sub, Mul, Div, pow };       // Initializer list.

typedef double func_t( double, double );    // The functions' type is
                                            // now named func_t.
func_t *funcTable[5] = { Add, Sub, Mul, Div, pow };

// An array of pointers to strings for output:
char *msgTable[5] = {"Sum", "Difference", "Product", "Quotient", "Power"};</text>
		</p>
		<p n="xc_BSTree_c">
			<text>
				<![CDATA[// A binary search tree (BST)
// BSTree.c

#include <string.h>          // memcpy()
#include <stdlib.h>          // malloc(), free()
#include "BSTree.h"

typedef struct Node { struct Node *left,    // Pointers to the left and
                                  *right;   // right child nodes.
                      size_t size;          // Size of the data payload.
                      char data[];          // The data itself.
                    } Node_t;

const void *defaultGetKey( const void *pData) { return pData; }

// -----------------------------------------------------------------------------
// The function newBST() creates a new binary search tree. The pointer to BST_t
// returned by newBST() is the first argument to all the other binary-tree functions.

BST_t *newBST( CmpFunc_t *cmp, GetKeyFunc_t *getKey)
{
   BST_t *pBST = NULL;
   if( cmp != NULL )
       pBST = malloc( sizeof( BST_t));
   if( pBST != NULL)
   {
       pBST->pRoot = NULL;
       pBST->cmp = cmp;
       pBST->getKey = (getKey != NULL) ? getKey : defaultGetKey;
   }
   return pBST;
}

// -----------------------------------------------------------------------------
// The function BST_insert() copies a data item to a new leaf node in the tree.
// The function inserts the new leaf at a position that is consistent with the
// binary tree sorting condition.
// BST_insert() returns true if it succeeds in inserting the new data; %\S
// otherwise, false.

static _Bool insert( BST_t *pBST, Node_t **ppNode, const void *pData, size_t size);

_Bool BST_insert( BST_t *pBST, const void *pData, size_t size)
{
    if( pBST == NULL || pData == NULL || size == 0)
       return false;
    return insert( pBST, &(pBST->pRoot), pData, size);
}

// The recursive helper function insert():
static _Bool insert( BST_t *pBST, Node_t **ppNode, const void *pData, size_t size )
{
   Node_t *pNode = *ppNode;                 // Pointer to the root node of the
                                            // subtree to insert the new node in.
   if ( pNode == NULL )
   {                                        // There's a place for a new leaf here.
     pNode = malloc( sizeof(Node_t) + size );
     if ( pNode != NULL )
     {
       pNode->left = pNode->right = NULL;   // Initialize the new node's
                                            // members.
       memcpy( pNode->data, pData, size );
       *ppNode = pNode;                     // Insert the new node.
       return true;
     }
     else
       return false;
   }
   else                                     // Continue looking for a place ...
   {
     const void *key1 = pBST->getKey( pData ),
                *key2 = pBST->getKey( pNode->data );
     if ( pBST->cmp( key1, key2 ) < 0 )     // ... in the left subtree,
       return insert( pBST, &(pNode->left), pData, size );
     else                                   // or in the right subtree.
       return insert( pBST, &(pNode->right), pData, size );
   }
}

// -------------------------------------------------------------------------------
// The function BST_search() uses the binary search algorithm to find a data item
// that matches a given key. The return value is a pointer to the data item
// of the first node that matches the key, or a null pointer if no match was found.

static const void *search( BST_t *pBST, const Node_t *pNode, const void *pKey);

const void *BST_search( BST_t *pBST, const void *pKey )
{
    if( pBST == NULL || pKey == NULL ) %\S
      return NULL;
    return search( pBST, pBST->pRoot, pKey);    // Start at the root of the tree.
}

// The recursive helper function search():
static const void *search( BST_t *pBST, const Node_t *pNode, const void *pKey )
{
    if ( pNode == NULL )
      return NULL;                                    // No subtree to search;
                                                      // no match found.
    else
    {                                                 // Compare data:
       int cmp_res = pBST->cmp( pKey, pBST->getKey(pNode->data) );
       if( cmp_res == 0 )                             // Found a match.
          return pNode->data;
       else if( cmp_res < 0 )                         // Continue the search
          return search( pBST, pNode->left, pKey );   // in the left subtree,
       else
          return search( pBST, pNode->right, pKey );  // or in the right subtree.
    }
}

// -------------------------------------------------------------------------------
// The BST_erase() function searches for a node that matches the specified key, and
// deletes it if found. The function returns false if it fails to find a matching %\S
// node to delete, or true if successful.

// The removal algorithm uses the recursive helper function detachMin() that plucks
// the minimum node from a specified subtree, and returns a pointer to the node:

static Node_t *detachMin( Node_t **ppNode )
{
    Node_t *pNode = *ppNode;                  // A pointer to the current node.
    if ( pNode == NULL )
      return NULL;                            // pNode is an empty subtree.
    else if ( pNode->left != NULL )
      return detachMin( &(pNode->left) );     // The minimum is in the left subtree.
    else
    {                                         // pNode points to the minimum node.
      *ppNode = pNode->right;                 // Attach the right child to the parent.
      return pNode;
    }
}

static _Bool erase(BST_t *pBST, Node_t **ppNode, const void *pKey);

_Bool BST_erase(BST_t *pBST, const void *pKey)
{
    if( pBST == NULL || pKey == NULL) %\S
      return false;
    return erase( pBST, &(pBST->pRoot), pKey);      // Start at the root of the tree.
}

// The recursive helper function erase():
static _Bool erase( BST_t *pBST, Node_t **ppNode, const void *pKey )
{
   Node_t *pNode = *ppNode;            // Pointer to the current node.
   if ( pNode == NULL )
      return false;                    // No match found.
                                       // Compare data:
   int cmp_res = pBST->cmp( pKey, pBST->getKey(pNode->data) );

   if ( cmp_res < 0 )                            // Continue the search
     return erase( pBST, &(pNode->left), pKey);  // in the left subtree,
   else if ( cmp_res > 0 )
     return erase( pBST, &(pNode->right), pKey); // or in the right subtree.
   else
   {                                   // Found the node to be deleted.
     if ( pNode->left == NULL )        // If no more than one child,
       *ppNode = pNode->right;         // attach the child to the parent.
     else if ( pNode->right == NULL )
       *ppNode = pNode->left;
     else                              // Two children: replace the node with
     {                                 // the minimum from the right subtree.
       Node_t *pMin = detachMin( &(pNode->right) );
       *ppNode = pMin;            // Graft it onto the deleted node's parent.
       pMin->left = pNode->left;       // Graft the deleted node's children.
       pMin->right = pNode->right;
     }
     free( pNode );                    // Release the deleted node's storage.
     return true;
   }
}

// -------------------------------------------------------------------------------
// The BST_clear() function deletes all the nodes of a tree.

static void clear( Node_t *pNode );
void BST_clear( BST_t *pBST )
{
    if ( pBST != NULL)
    {
       clear( pBST->pRoot );
       pBST->pRoot = NULL;
    }
}

// The recursive helper function clear():
static void clear( Node_t *pNode )
{
    if ( pNode != NULL )
    {
       clear( pNode->left );
       clear( pNode->right );
       free( pNode );
    }
}

// -------------------------------------------------------------------------------
// Each of the following traversal functions takes as its second argument a pointer
// to an ction?function that it calls for each node visited. %\S
// The return value is the number of times the action was performed successfully.

static int inorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_inorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return inorder( pBST->pRoot, action);
}

// The recursive helper function inorder():
static int inorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = inorder( pNode->left, action );        // L: Traverse the left
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.
    count += inorder( pNode->right, action );      // R: Traverse the right
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int rev_inorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_rev_inorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return rev_inorder( pBST->pRoot, action);
}

// The recursive helper function rev_inorder():
static int rev_inorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = rev_inorder( pNode->right, action );   // R: Traverse the right
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.
    count += rev_inorder( pNode->left, action );   // L: Traverse the left
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int preorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_preorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return preorder( pBST->pRoot, action);
}

// The recursive helper function preorder():
static int preorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    if ( action( pNode->data ))                    // N: The current node.
      ++count;
    count += preorder( pNode->left, action );      // L: Traverse the left
                                                   // subtree.
    count += preorder( pNode->right, action );     // R: Traverse the right
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int postorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_postorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return postorder( pBST->pRoot, action);
}

// The recursive helper function postorder():
static int postorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = postorder( pNode->left, action );      // L: Traverse the left
                                                   // subtree.
    count += postorder( pNode->right, action );    // R: Traverse the right
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.

    return count;
}
%\l]]>
			</text>
		</p>
		<p n="xc_BSTree_h">
			<text>
				<![CDATA[// A binary search tree (BST)
// BSTree.h

#include <stdbool.h>

typedef int CmpFunc_t( const void *pKey1, const void *pKey2);
typedef const void *GetKeyFunc_t( const void *pData);

typedef struct { struct Node  *pRoot;       // Pointer to the root.
                 CmpFunc_t    *cmp;         // Compares two keys.
                 GetKeyFunc_t *getKey;      // Converts data into a key value
               } BST_t;

BST_t *     newBST( CmpFunc_t *cmp, GetKeyFunc_t *getKey);
_Bool       BST_insert( BST_t *pBST, const void *pData, size_t size);
const void *BST_search( BST_t *pBST, const void *pKey);
_Bool       BST_erase( BST_t *pBST, const void *pKey);
void        BST_clear( BST_t *pBST);

// Each of the folowing functions traverses the tree in a certain order, and %\S
// calls the function referenced by action for each node. If the action modifies %\S
// the node's data, then at least the key value must remain unchanged to preserve %\S
// the tree's sorting order.
int BST_inorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_rev_inorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_preorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_postorder( BST_t *pBST, _Bool (*action)(void *pData));
%\l]]>
			</text>
		</p>
		<p n="xc_sortline">
			<text>
				<![CDATA[// Example 12-3. The sortlines program
// sortlines.c

// This program reads each line of text into a node of a binary tree,
// and then prints the text in sorted order.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "BSTree.h"               // Prototypes of the BST functions.

#define LEN_MAX 1000              // Maximum length of a line.
char buffer[LEN_MAX];

// Action to perform for each line:
_Bool printStr( void *str ) { return printf( "%s", str ) >= 0; }

int main()
{
    BST_t *pStrTree = newBST( (CmpFunc_t*)strcmp, NULL );
    int n;

    while ( fgets( buffer, LEN_MAX, stdin ) != NULL )   // Read each line.
    {
       size_t len = strlen( buffer );                   // Length incl.
                                                        // newline character.
       if ( !BST_insert( pStrTree, buffer, len+1 ))     // Insert the line in
          break;                                        // the tree.
    }
    if ( !feof(stdin) )
    {                                     // If unable to read the entire text:
       fprintf( stderr, "sortlines: "
                "Error reading or storing text input.\n" );
       exit( EXIT_FAILURE );
    }

    n = BST_inorder( pStrTree, printStr );     // Print each line, in sorted order.

    fprintf( stderr, "\nsortlines: Printed %d lines.\n", n );

    BST_clear( pStrTree );                     // Discard all nodes.
    return 0;
}]]>
			</text>
		</p>
		<p n="xc_getline">
			<text>
				<![CDATA[// Read a line of text from stdin into a dynamically allocated buffer.
// Replace the newline character with a string terminator.
// Arguments:    The maximum line length to read.
// Return value: A pointer to the string read, or
//               NULL if end-of-file was read or if an error occurred.

char *getLine( unsigned int len_max )
{
   char *linePtr = malloc( len_max+1 );  // Reserve storage for "worst case."
   if ( linePtr != NULL )
   {
     // Read a line of text and replace the newline characters with
     // a string terminator:
     int c = EOF;
     unsigned int i = 0;
     while ( i < len_max && ( c = getchar() ) != '\n' && c != EOF )
       linePtr[i++] = (char)c;
     linePtr[i] = '\0';

     if ( c == EOF && i == 0 )          // If end-of-file before any
     {                                  // characters were read,
        free( linePtr );                // release the whole buffer.
        linePtr = NULL;
     }
     else                               // Otherwise, release the unused portion.
        linePtr = realloc( linePtr, i+1 );           // i is the string length.
   }
   return linePtr;
}]]>
			</text>
		</p>
		<p n="xc_createDataFile">
			<text>
				<![CDATA[#include <stdio.h>
#include "record.h"

char dataFile[ ] = "records.dat";                  // Filename.

int main()// Creates a file records.dat (inFile) with some test data.
{
    FILE *fp;
    Record_t records[] = { { 1789L, "George" },
                           { 1797L, "John" }, %\S
                           {    0L, "Harry" },
                           { 1801L, "Thomas"},
                           { 1809L, "James"},
                           { 1825L, "Quincy" }
                         };
    size_t n = sizeof(records) / sizeof(*records); %\S
 %\S
    if( (fp = fopen( dataFile, "wb")) == NULL)
    {
        fprintf( stderr, "Error on opening output file \"%s\".\n", dataFile);
        return 1;
    }
    if( fwrite( records, sizeof(Record_t), n, fp) < n)
    {
        fprintf( stderr, "Error on writing to output file \"%s\".\n", dataFile);
        return 1;
    }
    printf( "%d records written.\n", n);
    return 0;
}]]>
			</text>
		</p>
		<p n="xc_isReadWriteable">
			<text>_Bool isReadWriteable( const char *filename )
{
    FILE *fp = fopen( filename, "r+" );    // Open a file to read and write.

    if ( fp != NULL )                      // Did fopen() succeed?
    {
        fclose(fp);                        // Yes: close the file; no error handling.
        return true;
    }
    else                                   // No.
        return false;
}</text>
		</p>
		<p n="xc_searchFile">
			<text>int searchFile( FILE *fpIn, const char *keyword )
{
   #define MAX_LINE 256
   char line[MAX_LINE] = "";
   int count = 0;

   if ( fpIn == NULL || keyword == NULL )
      return -1;
   else
      rewind( fpIn );

   while ( fgets( line, MAX_LINE, fpIn ) != NULL )
      if ( strstr( line, keyword ) != NULL )
      {
         ++count;
         fputs( line, stdout );
      }

   if ( !feof( fpIn ) )
      return -1;
   else
      return count;
}</text>
		</p>
		<p n="xc_searchNewName">
			<text>
				<![CDATA[// setNewName.c : 
// The following example uses an index table to store the positions of records in the
// file. This approach permits direct access to a record that needs to be updated.

// setNewName(): Finds a keyword in an index table
// and updates the corresponding record in the file.
// The file containing the records must be opened in
// "update mode"; i.e., with the mode string "r+b".
// Arguments: - A FILE pointer to the open data file;
//            - The key;
//            - The new name.
// Return value: A pointer to the updated record,
//               or NULL if no such record was found.
// ---------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include "record.h"   // Defines the types Record_t, IndexEntry_t:
                      // typedef struct { long key; char name[32];
                      //                  /* ... */ } Record_t;
                      // typedef struct { long key, pos; } IndexEntry_t;

extern IndexEntry_t indexTab[];         // The index table.
extern int indexLen;                    // The number of table entries.

Record_t *setNewName( FILE *fp, long key, const char *newname )
{
   static Record_t record;
   int i;

   for ( i = 0; i < indexLen; ++i )
   {
      if ( key == indexTab[i].key )
         break;                             // Found the specified key.
   }
   if ( i == indexLen )
      return NULL;                          // No match found.

   // Set the file position to the record:
   if (fseek( fp, indexTab[i].pos, SEEK_SET ) != 0 )
      return NULL;                          // Positioning failed.

   // Read the record:
   if ( fread( &record, sizeof(Record_t), 1, fp ) != 1 )
      return NULL; // Error on reading.
   if ( key != record.key )                 // Test the key.
      return NULL;
   else
   {                                        // Update the record:
      size_t size = sizeof(record.name);
      strncpy( record.name, newname, size-1 );
      record.name[size-1] = '\0';

      if ( fseek( fp, indexTab[i].pos, SEEK_SET ) != 0 )
         return NULL;                       // Error setting file position.
      if ( fwrite( &record, sizeof(Record_t), 1, fp ) != 1 )
         return NULL;                       // Error writing to file.

      return &record;
   }
}
%\l]]>
			</text>
		</p>
		<p n="xc_searNewNAme_call">
			<text>
				<![CDATA[// setNewName_call.c : 
// The main function creates an index table for the file records.dat
// and calls the setNewName() function.

#include <stdio.h>
#include <string.h>
#include "record.h"   // Defines the types Record_t, IndexEntry_t:
                      // typedef struct { long key; char name[32];
                      //                  /* ... */ } Record_t;
                      // typedef struct { long key, pos; } IndexEntry_t;

#define TAB_LEN 100
IndexEntry_t indexTab[TAB_LEN];         // The index table.
int indexLen = 0;                       // The number of table entries.

char dataFile[] = "records.dat";

int main()
{
    FILE *fpData = NULL;
    Record_t record;
    int i;

    if( (fpData = fopen( dataFile, "r+b")) == NULL)
    {
        fprintf( stderr, "Error on opening the file \"%s\".\n", dataFile);
        return 1;
    }
    for( i = 0; i < TAB_LEN; ++i)
    {
        indexTab[i].pos = ftell(fpData);          // current file position.
        if( fread( &record, sizeof(Record_t), 1, fpData) < 1)
            break;
        indexTab[i].key = record.key;
//        printf("%4ld : %ld\n", indexTab[i].key, indexTab[i].pos);
    }
    if( !feof( fpData))
    {
        fprintf( stderr, "Error on reading the file \"%s\".\n", dataFile);
        return 2;
    }
    indexLen = i;

    if( setNewName( fpData, 1825L, "John Quincy") == NULL)
       fprintf( stderr, "Error on updating the file \"%s\".\n", dataFile);

    // List the records:
    rewind( fpData);
    while( fread( &record, sizeof(Record_t), 1, fpData) == 1) %\S
    {
       printf("%8ld : %s\n", record.key, record.name);
    }

    fclose( fpData);
    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_cputime_dif">
			<text>
				<![CDATA[#include <time.h>
clock_t t1 = clock();
clock_t t2 = clock();]]>
			</text>
		</p>
		<p n="xc_parallel_sum">
			<text>
				<![CDATA[// Example 14-1. Calculating the sum of array elements in several parallel threads
// parallelSum.c
// ----------------------------------------------------------------------------
#include <stdbool.h>
#include <threads.h>

#define MAX_THREADS 8             // 1, 2, 4, 8 ... Maximum number
                                  // of threads to create.
#define MIN_BLOCK_SIZE 100        // Minimum size of an array block.

typedef struct                    // Arguments for the parallel_sum() function.
{
    float *start;                 // Start and length of the
    int len;                      // array block passed to parallel_sum().
    int block_size;               // Size of the smallest blocks.
    double sum;                   // The result.
} Sum_arg;

int parallel_sum(void *arg);      // Prototype of the thread function.

// ---------------------------------------------------------------
// Calculate the sum of array elements and write it to *sumPtr.
// sum() calls the function parallel_sum() for parallel processing.
// Return value: true if no error occurs, otherwise false.

bool sum(float arr[], int len, double* sumPtr)
{
    int block_size = len / MAX_THREADS;
    if (block_size < MIN_BLOCK_SIZE) block_size = len;

    Sum_arg args = { arr, len, block_size, 0.0 };
    if (parallel_sum(&args))
    { %\S
        *sumPtr = args.sum; %\S
        return true;
    }
    else
        return false;
}

// ---------------------------------------------------------------
// Recursive helper function to divide the work among several threads.

int parallel_sum(void *arg)
{
    Sum_arg *argp = (Sum_arg*)arg;       // A pointer to the arguments.
    if (argp->len <= argp->block_size)   // If length <= block_size,
    {                                    // add up the elements.
        for (int i = 0; i < argp->len; ++i)
        argp->sum += argp->start[i];
        return 1;
    }
    else                                  // If length > block_size,
    {                                     // divide the array.
        int mid = argp->len / 2;
        Sum_arg arg2 = { argp->start+mid, argp->len-mid,
                         argp->block_size, 0};   // Specifies 2nd half
        argp->len = mid;                         // Length of first half

        thrd_t th;                     // Process 1st half in a new thread.
        int res = 0;

        if (thrd_create(&th, parallel_sum, arg) != thrd_success)
            return 0;                  // Couldn't spawn a thread

        if (!parallel_sum(&arg2))      // Process 2nd half by recursion
                                       // in the current thread.
        {
            thrd_detach(th); return 0; // Recursive call failed
        }
        thrd_join(th, &res);
        if (!res)
            return 0;                  // Sibling thread reported failure

        argp->sum += arg2.sum;
        return 1;
    }
}
%\l]]>
			</text>
		</p>
		<p n="xc_thread">
			<text>
				<![CDATA[// Example 14-2. Concurrent memory access without synchronization
// inc_dec.c

#include <stdio.h>
#include <threads.h>
//#include <stdatomic.h>

#define COUNT 10000000L

long counter = 0;
//_Atomic long counter = ATOMIC_VAR_INIT(0L);

void incFunc(void) { for (long i = 0; i < COUNT; ++i) ++counter; }
void decFunc(void) { for (long i = 0; i < COUNT; ++i) --counter; }

int main(void)
{
    clock_t cl = clock();
    thrd_t th1, th2;

    if( thrd_create(&th1, (thrd_start_t)incFunc, NULL) != thrd_success
        || thrd_create(&th2, (thrd_start_t)decFunc, NULL) != thrd_success)
    {
        fprintf(stderr,"Error creating thread\n"); return -1;
    }
    thrd_join(th1, NULL);
    thrd_join(th2, NULL);

    printf("Counter: %ld \t", counter);
    printf("CPU time: %ld ms\n", (clock()-cl)*1000L/CLOCKS_PER_SEC);

    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_mutex">
			<text>
				<![CDATA[// Example 14-3. Adding a mutex to the program in Example 14-2

#include <stdio.h>
#include <threads.h>

#define COUNT 10000000L

long counter = 0;
mtx_t mtx;                        // A mutex for access to counter

void incFunc(void)
{
    for (long i = 0; i < COUNT; ++i)
    { mtx_lock(&mtx); ++counter; mtx_unlock(&mtx); }
}
void decFunc(void)
{
    for (long i = 0; i < COUNT; ++i)
    { mtx_lock(&mtx); --counter; mtx_unlock(&mtx); }
}

int main(void)
{
    if (mtx_init(&mtx, mtx_plain) != thrd_success)
    {
        fprintf(stderr, "Error initializing the mutex.\n");
        return -1;
    }

    // As in Example 14-2: %\S
    // start threads, wait for them to finish, print output:
    clock_t cl = clock();
    thrd_t th1, th2;

    if( thrd_create(&th1, (thrd_start_t)incFunc, NULL) != thrd_success
        || thrd_create(&th2, (thrd_start_t)decFunc, NULL) != thrd_success)
    {
        fprintf(stderr,"Error creating thread\n"); return -1;
    }
    thrd_join(th1, NULL);
    thrd_join(th2, NULL);

    printf("Counter: %ld \t", counter);
    printf("CPU time: %ld ms\n", (clock()-cl)*1000L/CLOCKS_PER_SEC);

    mtx_destroy(&mtx);
    return 0;
}

%\l]]>
			</text>
		</p>
		<p n="xc_ring_buffer_c">
			<text>
				<![CDATA[// Example 14-4. A ring buffer for the producer-consumer model

/* -------------------------------------------------------------
 * buffer.c
 * Definitions of functions operating on Buffer.
 */

#include "buffer.h"
#include <stdlib.h>           // For malloc() and free()

bool bufInit( Buffer *bufPtr, size_t size)
{
    if ((bufPtr->data = malloc( size * sizeof(int))) == NULL)
       return false;
    bufPtr->size = size;
    bufPtr->count = 0;
    bufPtr->tip = bufPtr->tail = 0;
    return    mtx_init( &bufPtr->mtx, mtx_plain) == thrd_success
           && cnd_init( &bufPtr->cndPut) == thrd_success
           && cnd_init( &bufPtr->cndGet) == thrd_success;
}

void bufDestroy(Buffer *bufPtr)
{
    cnd_destroy( &bufPtr->cndGet );
    cnd_destroy( &bufPtr->cndPut );
    mtx_destroy( &bufPtr->mtx );
    free( bufPtr->data );
}

// Insert a new element in the buffer:
bool bufPut(Buffer *bufPtr, int data)
{
    mtx_lock( &bufPtr->mtx );

    while (bufPtr->count == bufPtr->size)
       if (cnd_wait( &bufPtr->cndPut, &bufPtr->mtx ) != thrd_success)
          return false;

    bufPtr->data[bufPtr->tip] = data;
    bufPtr->tip = (bufPtr->tip + 1) % bufPtr->size;
    ++bufPtr->count;

    mtx_unlock( &bufPtr->mtx );
    cnd_signal( &bufPtr->cndGet );

    return true;
}

// Remove an element from the buffer. If the buffer is empty,
// wait no more than sec seconds.
bool bufGet(Buffer *bufPtr, int *dataPtr, int sec)
{
    struct timespec ts;
    timespec_get( &ts, TIME_UTC );     // The current time
    ts.tv_sec += sec;                  // + sec seconds delay.

    mtx_lock( &bufPtr->mtx );

    while ( bufPtr->count == 0 )
       if (cnd_timedwait(&bufPtr->cndGet,
                         &bufPtr->mtx, &ts) != thrd_success)
           return false;

    *dataPtr = bufPtr->data[bufPtr->tail];
    bufPtr->tail = (bufPtr->tail + 1) % bufPtr->size;
    --bufPtr->count;

    mtx_unlock( &bufPtr->mtx );
    cnd_signal( &bufPtr->cndPut );

    return true;
}

%\l]]>
			</text>
		</p>
		<p n="xc_ring_buffer_h">
			<text>
				<![CDATA[#include <stdbool.h>
#include <threads.h>

typedef struct Buffer
{
    int *data;              // Pointer to the array of data.
    size_t size, count;     // Maximum and current numbers of elements.
    size_t tip, tail;       // tip = index of the next free spot.
    mtx_t mtx;              // A mutex and
    cnd_t cndPut, cndGet;   // two condition variables.
} Buffer;

bool bufInit( Buffer *bufPtr, size_t size );
void bufDestroy(Buffer *bufPtr);

bool bufPut(Buffer *bufPtr, int data);
bool bufGet(Buffer *bufPtr, int *dataPtr, int sec);]]>
			</text>
		</p>
		<p n="xc_abort_ex">
			<text>void abort_ex()
{   %\S
   /* ... */
   struct record *new = (struct record *)malloc( sizeof(struct record) );
   if ( new != NULL )                   // Check whether malloc failed!
   {
       fprintf( stderr, "%s: out of memory!\n", __func__ );
       abort();
   }
   else
   { %\S
       puts("working ...");
       // a fatal error occurs:
       abort();                          // abort the programm.
   }
}</text>
		</p>
		<p n="xc_asctime_ex">
			<text>
				<![CDATA[time_t now;
time( &now );          /* Get the time (seconds since 1/1/70) */
printf( "Date: %.24s GMT\n", asctime( gmtime( &now ) ));]]>
			</text>
		</p>
		<p n="xc_acos">
			<text>#define PI 3.141593
#define DEG_PER_RAD (180.0/PI)


    double floor_width = 30.0;
    double roof_width = 34.6;

    double roof_pitch = acos( floor_width / roof_width ) * DEG_PER_RAD ;
%\l</text>
		</p>
		<p n="xc_abs_ex">
			<text>
				<![CDATA[int amount = -1234;
    char currencysym[2] = "$";
    char sign[2] = "-";
    div_t dollarsandcents = { 0, 0 };

    if ( amount >= 0 )
       sign[0] = '\0';

    dollarsandcents = div(abs( amount ), 100 );]]>
			</text>
		</p>
		<p n="xc_acosh_ex">
			<text>double x, y1, y2;
errno = 0;
y1 = acosh(x);
if ( errno == EDOM)
{
perror("acosh"); break;
}
y2 = log( x + sqrt( x*x - 1));
printf("x = %f; acosh(x) = %f; log(x + sqrt(x*x-1)) = %f\n",x, y1, y2);</text>
		</p>
		<p n="xc_asctime_s_ex">
			<text>
				<![CDATA[#include <time.h>
time_t now;
struct tm timeStruct;
char timeStr[26];
time(&now);                       // Date and time as an integer.
localtime_s(&now, &timeStruct);   // Convert to a structure.
if( asctime_s( timeStr, sizeof(timeStr), &timeStruct) == 0)
printf("Date and time: %s", timeStr);]]>
			</text>
		</p>
		<p n="xc_asin_ex">
			<text>
				<![CDATA[#include <math.h> 
#define PI 3.141593
#define DEG_PER_RAD (180.0/PI)
float height = 2.20F;
float length = 1.23F;
float altitude = asinf( height / sqrtf( height*height + length*length));]]>
			</text>
		</p>
		<p n="xc_asinh_ex">
			<text>
				<![CDATA[#include <math.h> 
for ( double x = -2.0; x < 2.1; x += 0.5)
printf("%6.2f %15f %20f\n", x, asinh(x), log( x + sqrt(x*x+1)));]]>
			</text>
		</p>
		<p n="xc_assert_ex">
			<text>
				<![CDATA[#include <assert.h>
int units_in_stock = 10;
int units_shipped = 9;
units_shipped++;
units_in_stock--;
units_in_stock -= units_shipped;
assert(units_in_stock >= 0);]]>
			</text>
		</p>
		<p n="xc_at_quick_exit_ex">
			<text>
				<![CDATA[void nexit(void) { puts("Program terminated normally."); }
void qexit(void) { puts("Programm terminated by \"quick_exit()\"."); }
int a = -1;
atexit( nexit);
at_quick_exit( qexit);
if( a < 0)
quick_exit(EXIT_FAILURE);]]>
			</text>
		</p>
		<p n="xc_atan_ex">
			<text>  #ifdef PI
    printf("The symbol PI was already defined.\n");
    long double pi = (long double) PI;
  #else
    long double pi = 4.0L * atanl( 1.0L );    // Because tan(pi/4) = 1
  #endif
    printf( "Assume pi equals %.17Lf.\n", pi);</text>
		</p>
		<p n="xc_atoi">
			<text>
				<![CDATA[%\l
#include <stdlib.h>       // int atoi( const char *s );
                          // long atol( const char *s );
                          // long long atoll( const char *s );
#include <stdio.h>

int main()
{
    char *s = " -135792468.00 Balance on Dec. 31";
    printf("\"%s\" becomes %ld\n", s, atol(s));

    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_atof">
			<text>%\l</text>
		</p>
		<p n="xc_erf">
			<text>
				<![CDATA[// erf_ex.c : erf() example
// -------------------------------------------------------------

#include <math.h>   // double erf( double x );
                    // float erff( float x );
                    // long double erfl( long double x );
#include <stdio.h>

/*
 * Given a normal distribution with mean 0 and standard deviation 1,
 * calculate the probability that the random variable is within the
 * range [0, 1.125]
 */

int main()
{
    double sigma = 1.0;     // The standard deviation
    double bound = 1.125;
    double probability;     // probability that mean <= value <= bound

    probability = 0.5 *erf( bound / (sigma * sqrt(2.0)) );

    printf("Given a normal distribution with mean 0 and standard deviation 1,\n"
           "the probability that a random variable is within the range [0, 1.125]\n"
           "is %%lf.\n", probability ); 

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exit_ex">
			<text>
				<![CDATA[// exit_ex.c : exit() example
// -------------------------------------------------------------

#include <stdlib.h>     // _Noreturn void exit( int status );
#include <stdio.h>

int main( int argc, char *argv[])
{
    FILE *f_in, *f_out;

    enum { X_OK = 0, X_ARGS, X_NOIN, X_NOOUT };

    if ( argc != 3 ) {
       fprintf( stderr, "Usage: program input-file output-file\n");
       exit( X_ARGS );
    }

    f_in = fopen(argv[1], "r");
    if ( f_in == NULL ) {
       fprintf( stderr, "Unable to open input file.\n");
       exit( X_NOIN );
    }
    f_out = fopen(argv[2], "a+");
    if ( f_out == NULL ) {
       fprintf( stderr, "Unable to open output file.\n");
       exit( X_NOOUT );
    }

    /* ... read, process, write, close files ... */

    exit( X_OK );           //  return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exp2_ex">
			<text>
				<![CDATA[// exp2_ex.c : exp2() example
// -------------------------------------------------------------

#include <math.h>        // double exp2( double x );
                         // float exp2f( float x );
                         // long double exp2l( long double x );
#include <stdio.h>

// The famous grains-of-rice-on-a-chessboard problem.
// The sultan loses a chess game. The wager was one grain for square 1
// on the chessboard, then double the last number for each successive
// square. How much rice in all?

int main()
{
    int squares = 64;
    long double gramspergrain = 0.0025L;   // A grain of rice weighs 25 mg.
    long double sum = 0.0L;

    for ( int i = 0; i < squares; i++ )
        sum += gramspergrain * exp2l( (long double)i );

    printf( "The sultan's wager costs him %%.3Lf metric tons of rice.\n",
             sum / 1000000.0L );           // A million grams per ton.

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exp_ex">
			<text>
				<![CDATA[// exp_ex.c : exp() example
// -------------------------------------------------------------

#include <math.h>        // double exp( double x );
                         // float expf( float x );
                         // long double expl( long double x );
#include <stdio.h>

int main()
{
    /* Amount owed = principal * e^(interest_rate * time) */

    int principal = 10000;   // Initial debt is ten thousand dollars.
    int balance = 0;
    double rate = 0.055;     // Interest rate is 5.5%% annually.
    double time = 1.5;       // Period is eighteen months.

    balance = principal * exp( rate * time );

    printf("Invest %%d dollars at %%.1f%%%% compound interest, and "
           "in %%.1f years \nyou'll have %%d dollars.\n",
           principal, rate*100.0, time, balance );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fclose_ex">
			<text>
				<![CDATA[// fclose_ex.c : fclose() example
// -------------------------------------------------------------

#include <stdio.h>   // int fclose( FILE *fp );

/* Print a file to the console, line by line. */

int main()
{
    FILE *fp_infile;
    char linebuffer[512];

    if (( fp_infile= fopen("input.dat", "r")) == NULL )
    {
       fprintf(stderr, "Couldn't open input file.\n");
       return -1;
    }

    while ( fgets( linebuffer, sizeof(linebuffer), fp_infile ) != NULL )
        fputs( linebuffer, stdout );

    if ( ! feof(fp_infile) )         // This means "if not end of file"
       fprintf( stderr, "Error reading from input file.\n" );

    if ( fclose(fp_infile) != 0 )
    {
       fprintf(stderr, "Error closing input file.\n");
       return -2;
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fdim_ex">
			<text>
				<![CDATA[// fdim_ex.c : fdim() example
// -------------------------------------------------------------

#include <math.h>        // double fdim( double x, double y );
                         // float fdimf( float x, float y );
                         // long double fdiml( long double x, long double y );
#include <stdio.h>

int main()
{
    /* Make sure an argument is within the domain of asin() */

    double sign, argument = -1.5, result;
    /* ... */

    sign = copysign( 1.0, argument );           // Save the sign ...
    argument = copysign( argument, 1.0 );       // then use only positive values

    argument = 1.0 - fdim( 1.0, argument );     // Trim excess beyond 1.0
    result = asin( copysign(argument, sign) );  // Restore sign and
                                                // call asin()
    printf( "For the argument %%.2lf the asin function returns %%lf.\n",
             copysign(argument, sign), result );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_deholdexcept_ex">
			<text>
				<![CDATA[// feholdexcept_ex.c : feholdexcept() example
// -------------------------------------------------------------

#include <fenv.h>     // int feholdexcept( fenv_t *envp );
#include <math.h>
#include <float.h>

/*
 * Compute the hypotenuse of a right triangle, avoiding intermediate
 * overflow or underflow.
 *
 * (This example ignores the case of one argument having
 * great magnitude and the other small, causing both overflow
 * and underflow!)
 */
double hypotenuse(double sidea, double sideb)
{
#pragma STDC FENV_ACCESS ON
    double sum, scale, ascaled, bscaled, invscale;
    fenv_t fpenv;
    int fpeflags;

    if ( signbit(sidea))  sidea = fabs(sidea);
    if ( signbit(sideb))  sideb = fabs(sideb);

    feholdexcept(&fpenv);        // Save previous environment,
                                 // clear exceptions,
                                 // switch to nonstop processing.
    invscale = 1.0;
    sum = sidea * sidea + sideb * sideb;    // First try whether a^2 + b^2
                                            // causes any exceptions.

    fpeflags = fetestexcept(FE_UNDERFLOW | FE_OVERFLOW);    // Did it?
    if (fpeflags & FE_OVERFLOW && sidea > 1.0 && sideb > 1.0)
    {
        /* a^2 + b^2 caused an overflow. Scale the triangle down. */
        feclearexcept(FE_OVERFLOW);
        scale = scalbn( 1.0, (DBL_MIN_EXP / 2));

        invscale = 1.0 / scale;
        ascaled = scale * sidea;
        bscaled = scale * sideb;
        sum = ascaled * ascaled + bscaled * bscaled;
    }
    else if (fpeflags & FE_UNDERFLOW && sidea < 1.0 && sideb < 1.0)
    {
        /* a^2 + b^2 caused an underflow. Scale the triangle up. */
        feclearexcept(FE_UNDERFLOW);
        scale = scalbn( 1.0, (DBL_MAX_EXP / 2));

        invscale = 1.0 / scale;
        ascaled = scale * sidea;
        bscaled = scale * sideb;
        sum = ascaled * ascaled + bscaled * bscaled;
    }

    feupdateenv(&fpenv);     // restore the caller's environment, and
                             // raise any new exceptions

    /* c = (1/scale) * sqrt((a * scale)^2 + (b * scale)^2): */
    return invscale * sqrt(sum);
}

#include <stdio.h>

int main()
{
    double sidec = hypotenuse( 1E-10, 2E-200);
    printf("The hypotenuse of the right triangle is %%.10lG\n", sidec);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_deraiseexcept_ex">
			<text>
				<![CDATA[// feraiseexcept_ex.c : feraiseexcept() example
// -------------------------------------------------------------

#include <fenv.h>     // int feraiseexcept( int excepts );
//#include <math.h>
#include <stdlib.h>
#include <stdio.h>

// Although user programs rarely need to raise a floating-point exception by artificial
// means, the following example illustrates how to do so:

int main()
{
    int result, except_set, except_test;

    #pragma STDC FENV_ACCESS ON

    feclearexcept (FE_ALL_EXCEPT);

    except_set = FE_OVERFLOW;
    result = feraiseexcept( except_set );
    if ( result != 0 )
    {
        printf( "feraisexcept() failed (%%d)\n", result );
        exit( result );
    }

    except_test = fetestexcept( except_set );
    if ( except_test != except_set )
        printf( "Tried to raise flags %%X, but only raised flags %%X.\n",
                 except_set, except_test );
    else
       printf( "Raised the floating-point exception FE_ALL_EXCEPT = %%X\n",
                except_set );       
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fflush_ex">
			<text>
				<![CDATA[// fflush_ex.c : fflush() example
// -------------------------------------------------------------

#include <stdio.h>   // int fflush( FILE *fp );
#include <signal.h>

/* Tests the effect of flushing output file buffers. */

int main()
{
    FILE *fp;

#ifdef FLUSH
    char filename[ ] = "twice.txt";
#else
    char filename[ ] = "once.txt";
#endif  /* FLUSH */

    fp = fopen( filename, "w" );
    if ( fp == NULL)
       fprintf( stderr, "Failed to open file '%%s' to write.\n", filename );

    fputs( "Going once ...\n", fp );
    fflush( fp );                 // Flush the output unconditionally

    fputs( "Going twice ...\n", fp );

#ifdef FLUSH
    fflush( fp );                 // Now flush only if compiled with '-DFLUSH'
#endif

    raise( SIGKILL );             // End the program abruptly.

    fputs( "Gone.\n", fp );       // These three lines will never be executed.
    fclose( fp );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgets_ex">
			<text>
				<![CDATA[// fgets_ex.c : fgets() example
// -------------------------------------------------------------

#include <stdio.h>   // char *fgets( char * restrict buffer, int n,
                     //              FILE * restrict fp );
#include <string.h>

int main()
{
    FILE *titlefile;
    char title[256];
    int counter = 0;

    if ((titlefile = fopen("titles.txt", "r")) == NULL)
       perror( "Opening title file" );
    else
    {
       while ( fgets( title, 256, titlefile ) != NULL )
       {
          title[ strlen(title) -1 ] = '\0';   // Trim off newline character.
          printf( "%%3d: \"%%s\"\n", ++counter, title );
       }
       /* fgets() returned NULL: either EOF or an error occurred. */
       if ( feof(titlefile) )
         printf("Total: %%d titles.\n", counter);
    }
    fclose( titlefile );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgetwc_ex">
			<text>
				<![CDATA[// fgetwc_ex.c : fgetwc() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>   // wint_t fgetwc( FILE *fp );
#include <stdlib.h>
#include <locale.h>

int main()
{
    char file_in[ ]  = "local_in.txt",
         file_out[ ] = "local_out.txt";
    FILE *fp_in_wide, *fp_out_wide;
    wint_t wc;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
       fwprintf( stderr,
                 L"Sorry, couldn't change to the system's native locale.\n"),
       exit(1);

    if (( fp_in_wide = fopen( file_in, "r" )) == NULL )
       fprintf( stderr, "Error opening the file %%s\n", file_in), exit(2);

    if (( fp_out_wide = fopen( file_out, "w" )) == NULL )
       fprintf( stderr, "Error opening the file %%s\n", file_out), exit(3);

    fwide( fp_in_wide, 1);            // Not strictly necessary, since first
    fwide( fp_out_wide, 1);           // file access also sets wide or byte mode.

    while (( wc = fgetwc( fp_in_wide )) != WEOF )
    {
       // ... process each wide character read ...

       if ( fputwc( (wchar_t)wc, fp_out_wide) == WEOF)
         break;
    }
    if ( ferror( fp_in_wide))
       fprintf( stderr, "Error reading the file %%s\n", file_in);
    if ( ferror( fp_out_wide))
       fprintf( stderr, "Error writing to the file %%s\n", file_out);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgetws_ex">
			<text>
				<![CDATA[// fgetws_ex.c : fgetws() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>   // wchar_t *fgetws( wchar_t * restrict buffer,
                     //                  int n, FILE * restrict fp );
//#include <stdlib.h>
#include <locale.h>

int main()
{
    FILE *fp_in_wide;
    wchar_t buffer[4096];
    wchar_t *line = buffer;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr, L"Sorry, couldn't change to the system's native locale.\n");
       return -1;
    }
    if (( fp_in_wide = fopen( "local_in.txt", "r" )) == NULL )
    {   perror( "Opening input file");  return -1;   }

    fwide( fp_in_wide, 1);

    line = fgetws( buffer, sizeof(buffer), fp_in_wide );
    if ( line == NULL )
       perror( "Reading from input file" );
    else
       if( fputws( line, stdout) < 0)
          perror( "Writing to stdout" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fma_ex">
			<text>
				<![CDATA[// fma_ex.c : fma() example
// -------------------------------------------------------------

#include <math.h>   // double fma( double x, double y, double z );
                    // float fmaf( float x, float y, float z );
                    // long double fmal( long double x, 
                    //             long double y, long double z );
#include <stdio.h>

int main()
{
    double x, y, z;

    x = nextafter( 3.0, 4.0 );     // Smallest possible double value
                                   // greater than 3
    y = 1.0/3.0;
    z = -1.0;

    printf( "x = %%.15G\n"
            "y = %%.15G\n"
            "z = %%.15G\n", x, y, z );

// #ifdef FP_FAST_FMA

    printf( "fma( x, y, z) = %%.15G\n", fma( x, y, z) );

// #else // i.e., not def FP_FAST_FMA

   double product = x * y;
   printf( "x times y = %%.15G\n", product );
   printf( "%%.15G + z = %%.15G\n", product, product + z );

// #endif // def FP_FAST_FMA
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fmax_ex">
			<text>
				<![CDATA[// fmax_ex.c : fmax() example
// -------------------------------------------------------------

#include <math.h>   // double fmax( double x, double y );
                    // float fmaxf( float x, float y );
                    // long double fmaxl( long double x , long double y );
#include <float.h>
#include <stdio.h>

int main()
{
    // Let big equal the second-greatest-possible double value ...
    const double big = nextafter( DBL_MAX, 0.0 );
    // ... and small the second-least possible-double value:
    const double small = nextafter( DBL_MIN, 0.0 );

    double a, b, c;
    /* ... */
    a = DBL_MIN;  b = 0.0;  c = 1.0;

    if ( fmin( fmin( a, b ), c ) <= small )
       printf( "At least one value is too small.\n" );
    if ( fmax( fmax( a, b ), c ) >= big )
       printf( "At least one value is too great.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fmod_ex">
			<text>
				<![CDATA[// fmod_ex.c : fmod() example
// -------------------------------------------------------------

#include <math.h>   // double fmod( double x, double y );
                    // float fmodf( float x, float y );
                    // long double fmodl( long double x, long double y );
#include <fenv.h>
#include <stdio.h>

int main()
{
    double people = -2.25, 
           apples = 3.3, 
           eachgets = 0.0, 
           someleft = 0.0;

    int saverounding = fegetround();       // Save previous setting
    fesetround(FE_TOWARDZERO);

    eachgets = rint( apples / people );
    someleft = fmod( apples, people );

    printf( "If there are %%+.2f of us and %%+.2f apples, \n"
            "each of us gets %%+.2f, with %%+.2f left over.\n",
            people, apples, eachgets, someleft );

    fesetround( saverounding );            // Restore previous setting

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fopen_ex">
			<text>
				<![CDATA[// fopen_ex.c : fopen() example
// -------------------------------------------------------------

#include <stdio.h>   // FILE *fopen( const char * restrict name,
                     //              const char * restrict mode );
#include <stdlib.h>
#include <string.h>

int main( int argc, char *argv[])
{
    FILE *in, *out;
    int c;

    if ( argc != 3 )
       fprintf( stderr, "Usage: program input-file output-file\n"), exit(1);

    // If "-" appears in place of input filename, use stdin:
    in = (strcmp(argv[1], "-") == 0) ? stdin : fopen(argv[1], "r");
    if ( in == NULL )
    {  perror( "Opening input file" ); return -1;  }

    // If "-" appears in place of output filename, use stdout:
    out = (strcmp(argv[2], "-") == 0) ? stdout : fopen(argv[2], "a+");
    if ( out == NULL )
    {   perror( "Opening output file" ); return -1; }

    while (( c = fgetc( in )) != EOF)
       if ( fputc(c, out) == EOF )
          break;

    if ( !feof( in ))
       perror( "Error while copying" );

    fclose(in), fclose(out);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fpclassify_ex">
			<text>
				<![CDATA[// fpclassify_ex.c : fpclassify() example
// -------------------------------------------------------------

#include <math.h>       // int fpclassify( x );
#include <stdio.h>

double minimum( double a, double b )
{
    register int aclass = fpclassify( a );
    register int bclass = fpclassify( b );

    if ( aclass == FP_NAN || bclass == FP_NAN )
       return NAN; 

    if ( aclass == FP_INFINITE )         // -Inf is less than anything;
       return ( signbit( a ) ? a : b );  // +inf is greater than anything.

    if ( bclass == FP_INFINITE )
       return ( signbit( b ) ? b : a );

    return ( a < b ? a : b );
}

int main()
{
    double x = 0.0;

    double min = minimum( x, -HUGE_VAL); 

    printf( "min = %%G\n", min);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fputws_ex">
			<text>
				<![CDATA[// fputws_ex.c : fputws() example
// -------------------------------------------------------------

#include <wchar.h>   // int fputws( const wchar_t * restrict ws,
                     //              FILE * restrict fp );
#include <stdio.h>
#include <locale.h>

int main()
{
    FILE *fpw;
    char fname_wide[] = "widetest.txt";
    int widemodeflag = 1;
    int result;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr, L"Sorry, couldn't change to the system's native locale.\n");
       return -1;
    }
    wchar_t widestring[] = L"How many umlauts are there in Fahrvergnügen?\n";

    if ((fpw = fopen(fname_wide, "a")) == NULL)
    {    perror( "Opening output file" ); return -1; }

    // Set file to wide-character orientation:
    widemodeflag = fwide(fpw, widemodeflag);
    if ( widemodeflag <= 0 )
    {
       fprintf(stderr, "Unable to set output file %%s to wide characters\n",
                       fname_wide);
       (void)fclose(fpw);
       return -1;
    }
    // Write wide-character string to the file:
    result = fputws( widestring, fpw );
    if ( result < 0 )
    {
       fprintf(stderr, "Error on writing file %%s.\n", fname_wide);
       return -1;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_freopen_s_ex">
			<text>
				<![CDATA[// freopen_s_ex.c : freopen_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdio.h>   // errno_t freopen_s( FILE * restrict * restrict fpPtr,
                     //                    const char * restrict name,
                     // const char * restrict mode,
                     // FILE * restrict fp );
#include <stdlib.h>
#include <errno.h>

int main()      // Redirect standard output to the file redirect.txt:
{
    char filename[] = "redirect.txt";
    FILE *fp;

    errno_t err = freopen_s( &fp, filename, "w", stdout);
    if( err != 0)
    { 
       fprintf( stderr, "Unable to redirect stdout to %%s\n", filename);
       exit(err);
    }

    printf("This text is being written to the file %%s.\n", filename);

    fclose(stdout);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_frexp_ex">
			<text>
				<![CDATA[// frexp_ex.c : frexp() example
// -------------------------------------------------------------

#include <math.h>    // double frexp( double x, int *exp );
                     // float frexpf( float x, int *exp );
                     // long double frexpl( long double x, int *exp );
#include <stdio.h>
#include <stdlib.h>

double fourthrt( double x )
{
    int exponent, exp_mod_4;
    double mantissa = frexp( x, &exponent );

    exp_mod_4 = exponent %% 4;
    exponent -= ( exp_mod_4 );    // Get an exponent that's
                                  // divisible by four ...
    for ( int i = abs( exp_mod_4 ); i > 0; i-- )
    {
        if ( exp_mod_4 > 0 )      // ... and compensate in the mantissa.
           mantissa *= 2.0;
       else
           mantissa /= 2.0;
    }
    return ldexp( sqrt( sqrt( mantissa )), exponent / 4 );
}

int main()
{
    double x = 64.0;      // 16 * 4

    printf( "The fourth root of %%f is %%G.\n", x, fourthrt(x) );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fscnf_ex">
			<text>
				<![CDATA[// fscanf_ex.c : fscanf() example
//
// The example code reads information about a user from a file, which we will
// suppose contains a line of colon-separated strings like this:
//    tony:x:1002:31:Tony Crawford,,:/home/tony:/bin/bash// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for fscanf_s()
#include <stdio.h> 
// int fscanf( FILE * restrict fp, const char * restrict format, ... );
// int fscanf_s( FILE * restrict fp, const char * restrict format, ... ); 

#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct pwrecord {             // Structure for contents of passwd fields.
    unsigned int uid;
    unsigned int gid;
    char user[32];
    char pw [32];
    char realname[128];
    char home [128];
    char shell [128];
};

int main()
{
    FILE *fp;
    char pwfile[] = "pwfile.txt";
    int results = 0;
    struct pwrecord record, *recptr = &record;;
    char gecos[256] = "";

    /* ... Open the password file to read ... */

    fp = fopen( pwfile, "r");
    if ( fp == NULL )
    {  perror( "Opening input file" ); return -1;  }

    /* 1. Read login name, password, UID and GID. */

    record = (struct pwrecord) { UINT_MAX, UINT_MAX, "", "", "", "", "" };
    results = fscanf( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                      recptr->user, recptr->pw, &recptr->uid, &recptr->gid );

    // If the implementation supports the secure functions, the function fscanf_s()
    // can be used as an alternative to fscanf():
    /*
    results = fscanf_s( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                        recptr->user, sizeof(recptr->user),
                        recptr->pw, sizeof(recptr->pw),
                        &recptr->uid, &recptr->gid );
    */
    if ( results < 4 )
    {
       fprintf( stderr, "Unable to parse line.\n" );
       fscanf( fp, "%%*[^\n]\n" ); // Read and discard rest of line.
    }

    /* 2. Read the "gecos" field, which may contain nothing, or just the
     * real name, or comma-separated sub-fields.
    */
    results = fscanf( fp, "%%255[^:]:", gecos );
    if ( results < 1 )
       strcpy( recptr->realname, "[No real name available]" );
    else
       sscanf( gecos, "%%127[^,]", recptr->realname );    // Truncate at
                                                         // first comma.

    /* 3. Read two more fields before the end of the line. */

    results = fscanf( fp, "%%127[^:]:%%127[^:\n]\n", recptr->home, recptr->shell );
    if ( results < 2 )
    {
        fprintf( stderr, "Unable to parse line.\n" );
        fscanf( fp, "%%*[^\n]\n" );            // Read and discard rest of line.
    }
    printf( "The user account %%s with UID %%u belongs to %%s.\n",
             recptr->user, recptr->uid, recptr->realname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fscanf_ex">
			<text>
				<![CDATA[// fscanf_ex.c : fscanf() example
//
// The example code reads information about a user from a file, which we will
// suppose contains a line of colon-separated strings like this:
//    tony:x:1002:31:Tony Crawford,,:/home/tony:/bin/bash// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for fscanf_s()
#include <stdio.h> 
// int fscanf( FILE * restrict fp, const char * restrict format, ... );
// int fscanf_s( FILE * restrict fp, const char * restrict format, ... ); 

#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct pwrecord {             // Structure for contents of passwd fields.
    unsigned int uid;
    unsigned int gid;
    char user[32];
    char pw [32];
    char realname[128];
    char home [128];
    char shell [128];
};

int main()
{
    FILE *fp;
    char pwfile[] = "pwfile.txt";
    int results = 0;
    struct pwrecord record, *recptr = &record;;
    char gecos[256] = "";

    /* ... Open the password file to read ... */

    fp = fopen( pwfile, "r");
    if ( fp == NULL )
    {  perror( "Opening input file" ); return -1;  }

    /* 1. Read login name, password, UID and GID. */

    record = (struct pwrecord) { UINT_MAX, UINT_MAX, "", "", "", "", "" };
    results = fscanf( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                      recptr->user, recptr->pw, &recptr->uid, &recptr->gid );

    // If the implementation supports the secure functions, the function fscanf_s()
    // can be used as an alternative to fscanf():
    /*
    results = fscanf_s( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                        recptr->user, sizeof(recptr->user),
                        recptr->pw, sizeof(recptr->pw),
                        &recptr->uid, &recptr->gid );
    */
    if ( results < 4 )
    {
       fprintf( stderr, "Unable to parse line.\n" );
       fscanf( fp, "%%*[^\n]\n" ); // Read and discard rest of line.
    }

    /* 2. Read the "gecos" field, which may contain nothing, or just the
     * real name, or comma-separated sub-fields.
    */
    results = fscanf( fp, "%%255[^:]:", gecos );
    if ( results < 1 )
       strcpy( recptr->realname, "[No real name available]" );
    else
       sscanf( gecos, "%%127[^,]", recptr->realname );    // Truncate at
                                                         // first comma.

    /* 3. Read two more fields before the end of the line. */

    results = fscanf( fp, "%%127[^:]:%%127[^:\n]\n", recptr->home, recptr->shell );
    if ( results < 2 )
    {
        fprintf( stderr, "Unable to parse line.\n" );
        fscanf( fp, "%%*[^\n]\n" );            // Read and discard rest of line.
    }
    printf( "The user account %%s with UID %%u belongs to %%s.\n",
             recptr->user, recptr->uid, recptr->realname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fseek_ex">
			<text>
				<![CDATA[// fseek_ex.c : fseek() example
// -------------------------------------------------------------

#include <stdio.h>   // int fseek( FILE *fp, long offset, int origin );

typedef struct { long id;
                 double value;
               } record;

// void writeRecords();

int main()
{
    FILE *fp;
    record cur_rec = (record) { 0, 0.0 };
    int reclength_file = sizeof(record);
    long seek_id = 123L;

    if ( (fp = fopen("records", "rb")) == NULL)
        perror( "Unable to open records file" );
    else do
    {
        if ( 1 > fread( &cur_rec.id, sizeof (long), 1, fp ))
        {
           fprintf( stderr, "Record with ID %%ld not found.\n", seek_id );
           break;
        }
        else                                      // Skip rest of record
           if ( fseek( fp, reclength_file - sizeof(long), 1 ) )
           {
              perror( "fseek failed" );
              break;
           }
    } while ( cur_rec.id != seek_id );

    if( cur_rec.id == seek_id )
        printf( "Record with ID %%ld found.\n", seek_id );
   
    return 0;
}
/*
void writeRecords()
{
    FILE *fp;
    record someRecords[] = {  { 101L, 10.0 }, { 123L, 20.0 },{ 146L, 30.0 } };
    size_t n = sizeof( someRecords) / sizeof( *someRecords);

    if ((fp = fopen("records", "wb")) == NULL)
       perror( "Unable to open records file" );
    else 
    {
       if( fwrite( someRecords, sizeof(record), n, fp) < n) 
          perror( "Unable to write records" );
       fclose(fp);
    }
}
*/
]]>
			</text>
		</p>
		<p n="xc_ftell_ex">
			<text>
				<![CDATA[// ftell_ex.c : ftell() example
// -------------------------------------------------------------

// This example searches in a file, whose name is the second command-line
// argument, for a string, which the user can specify in the first
// command-line argument.

#include <stdio.h>       // long ftell( FILE *fp );
#include <stdlib.h>
#include <string.h>

#define MAX_LINE 256

int main( int argc, char *argv[])
{
    FILE *fp;
    long lOffset = 0L;
    char sLine[MAX_LINE] = "";
    int  lineno = 0;

    if ( argc != 3 )
       fprintf( stderr, "Usage: program search_string file_name\n"), exit(1);

    if ((fp = fopen(argv[2], "r")) == NULL)
    {
        fprintf(stderr, "Unable to open file %%s\n", argv[2]);
        exit(-1);
    }
    do
    {
        lOffset = ftell(fp);      // Bookmark the beginning of
                                  // the line we're about to read.
        if ( -1L == lOffset )
            fprintf(stderr, "Unable to obtain offset in %%s\n", argv[2]);
        else
            lineno++;

        if ( !fgets(sLine, MAX_LINE, fp))     // Read next line from file.
            break;
    } while ( strstr( sLine, argv[1]) == NULL);    // Test for argument
                                                   // in sLine.

    /* Dropped out of loop: Found search keyword or EOF */
    if ( feof(fp) || ferror(fp) )
    {
        fprintf(stderr, "Unable to find \"%%s\" in %%s\n", argv[1], argv[2]);
        rewind(fp);
    }
    else
    {
        printf( "%%s (%%d): %%s\n", argv[2], lineno, sLine);
        fseek( fp, lOffset, 0);           // Set file pointer at beginning of
                                          // the line containing the keyword
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fwprintf_ex">
			<text>
				<![CDATA[// fwprintf_ex.c : fwprintf() example
// -------------------------------------------------------------

#include <stdio.h>     // int fwprintf( FILE * restrict fp,
#include <wchar.h>     //               const wchar_t * restrict format, ... );
                       // int fwprintf_s( FILE * restrict fp,
                       //                 const wchar_t * restrict format, ...);
#include <wchar.h>
#include <locale.h>

int main()
{
    wchar_t name_local[ ] = L"Ka\u0142u\u017Cny";
    char name_portable[ ]= "Kaluzny";
    char locale[ ] = "pl_PL.UTF-8";
    char * newlocale;

    newlocale = setlocale( LC_ALL, locale );
    if ( newlocale == NULL )
       fprintf( stderr, "Sorry, couldn't change the locale to %%s.\n"
                "The current locale is %%s.\n",
                locale, setlocale( LC_ALL, NULL ));

    fwprintf( stdout,
              L"Customer's name: %%ls (Single-byte transliteration: %%s)\n",
              name_local, name_portable );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_getenv_s_ex">
			<text>
				<![CDATA[// getenv_s_ex.c : getenv_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // errno_t getenv_s( size_t * restrict len,
                     //                   char * restrict value,
                     //                   rsize_t maxsize,
                     //                   const char * restrict name);
#include <stdio.h>
#include <errno.h>

int main()
{
    char envStr[512];
    size_t len;

    if( getenv_s( &len, envStr, sizeof(envStr),"PATH") == 0)
        printf("PATH variable (%%zu characters): \n%%s\n", len, envStr);
    else if( len > 0)
        printf("The PATH variable (%%zu characters) is more than "
               "%%zu bytes long.\n", len, sizeof(envStr));
    else
        printf("PATH variable not found.\n");

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_gmtime_ex">
			<text>
				<![CDATA[// gmtime_ex.c : gmtime() example
// -------------------------------------------------------------

#include <time.h>   // struct tm *gmtime( const time_t *timer );
#include <stdio.h>
#include <string.h>

int main()
{
    time_t rawtime;
    struct tm utc_tm, local_tm, *ptr_tm;
    char buffer[1024] = "";

    time( &rawtime );                 // Get current time as an integer.

    ptr_tm = gmtime( &rawtime );      // Convert to UTC in a struct tm.
    memcpy( &utc_tm, ptr_tm, sizeof(struct tm) ); // Save a local copy.

    ptr_tm = localtime( &rawtime );   // Do the same for local time zone.
    memcpy( &local_tm, ptr_tm, sizeof(struct tm) );

    if ( strftime( buffer, sizeof(buffer),
                   "It's %%A, %%B %%d, %%Y, %%R o'clock, UTC.", &utc_tm ) )
       puts( buffer );

    if ( strftime( buffer, sizeof(buffer),
                   "Here it's %%A, %%B %%d, %%Y, %%R o'clock, UTC %%z.", &local_tm ) )
       puts( buffer );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_hypot_ex">
			<text>
				<![CDATA[// hypot_ex.c : hypot() example
// -------------------------------------------------------------

#include <math.h>   // double hypot( double x, double y );
                    // float hypotf( float x, float y );
                    // long double hypotl( long double x, long double y );
#include <stdio.h>
#include <errno.h>

int main()
{
    double x, y, h;        // Three sides of a triangle

    printf( "How many kilometers do you want to go westward? " );
    scanf( "%%lf", &x );

    printf( "And how many southward? " );
    scanf( "%%lf", &y );

    errno = 0;
    h = hypot( x, y );
    if ( errno )
       perror( __FILE__ );
    else
       printf( "Then you'll be %%4.2lf km from where you started.\n", h );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ignore_handler_s_ex">
			<text>
				<![CDATA[// ignore_handler_s_ex.c : ignore_handler_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // void ignore_handler_s( const char * restrict msg,
                     //                        void * restrict ptr, 
                     //                        errno_t error);
#include <string.h>
#include <stdio.h>
#include <errno.h>

// Handle runtime constraint violations using only
// the return value of secure functions.

int main()
{
    char message[20] = "Hello, ",
         name[20];
    set_constraint_handler_s(ignore_handler_s);

    printf("Please enter your name: ");
    if( gets_s( name, sizeof(name)) == NULL)
    { 
       puts("Error: You entered more than 19 characters."); 
       // ...
    }
    else if( strcat_s( message, sizeof(message), name) != 0)
    {
       puts("Error: message array is too small.");
       // ...
    }
    else
       puts( message);

    // ...

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ilogb_ex">
			<text>
				<![CDATA[// ilogb_ex.c : ilogb() example
// -------------------------------------------------------------

#include <math.h>    // int ilogb( double x )
                     // int ilogbf( float x )
                     // int ilogbl( long double x )
#include <stdio.h>
#include <limits.h>

int main()
{
    int exponent = 0;
    double x = -1.509812734e200;

    while ( exponent < INT_MAX )
    {
       exponent = ilogb( x );
       printf( "The exponent of %%g is %%d.\n", x, exponent );

       if ( x < 0.0 && x * x > 1.0 )
          x /= 1e34;
       else
          x += 1.1, x *= 2.2e34 ;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_imaxdiv_ex">
			<text>
				<![CDATA[// imaxdiv_ex.c : imaxdiv() example
// -------------------------------------------------------------

#include <inttypes.h>  // imaxdiv_t imaxdiv( intmax_t dividend, 
                       //                    intmax_t divisor );
#include <stdio.h>

int main()
{
    intmax_t people = 110284, apples = 9043291;
    imaxdiv_t share;

    if ( people == 0 )       // Avoid dividing by zero.
    {
       printf( "There's no one here to take the apples.\n" ); 
       return -1;
    }
    else
       share = imaxdiv( apples, people );

    printf( "If there are %%ji of us and %%ji apples,\n"
            "each of us gets %%ji, with %%ji left over.\n",
            people, apples, share.quot, share.rem );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_isfinite_ex">
			<text>
				<![CDATA[// isfinite_ex.c : isfinite() example
// -------------------------------------------------------------

#include <math.h>     // int isfinite( float x );
                      // int isfinite( double x );
                      // int isfinite( long double x );

#include <stdarg.h>

double vsum( int n, ... )
// n is the number of arguments in the list
{
    va_list argptr;
    double sum = 0.0, next = 0.0;

    va_start( argptr, n );
    while ( n-- )
    {
        next = va_arg( argptr, double );
        sum += next;
        if ( isfinite( sum ) == 0 )
           break;         // If sum reaches infinity, stop adding.
    }
    va_end( argptr );
    return sum;
}

#include <stdio.h>
#include <float.h>

int main()
{
    printf( "1. Sum: %%lf\n", vsum( 3, 1.0, 2.0, 3.0) );

    double x = DBL_MAX;
    printf( "2. Sum: %%lf\n", vsum( 2, x, x) );
   
    return 0;
}

]]>
			</text>
		</p>
		<p n="xc_isprintf_ex">
			<text>
				<![CDATA[// isprint_ex.c : isprint() example
// And also an example for
// isalnum(), isalpha(), isblank(), iscntrl(), isdigit(),
// isgraph(), islower(), ispunct(), isspace().
// -------------------------------------------------------------

#include <ctype.h>    // int isprint( int c); int isalnum( int c); ...
#include <stdio.h>
#include <locale.h>

int main()
{
    unsigned int c;

//    setlocale(LC_CTYPE, "");
    printf("\nThe current locale for the 'is ...' functions is '%%s'.\n",
           setlocale(LC_CTYPE, NULL));

    printf("Here is a table of the 'is ...' values for the characters"
           " from 0 to 127 in this locale:\n\n");

    for ( c = 0; c < 128; c++ )   // Loop iteration for each table row.
    {
        if ( c %% 24 == 0 )        // Repeat table header every 24 rows.
        {
            printf("Code char alnum alpha blank cntrl digit graph lower"
                   " print punct space\n");
            printf("---------------------------------------------------"
                   "------------------\n");
        }
        printf( "%%4u %%4c %%3c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c\n",
                 c,                             // Print numeric character code.
                 ( isprint( c ) ?  c  : ' ' ),  // Print the glyph, or a space
                                                // if it's not printable.
                 ( isalnum( c ) ? 'X' : '-' ),  // In a column for each category,
                 ( isalpha( c ) ? 'X' : '-' ),  // print X for yes or - for no.
                 ( isblank( c ) ? 'X' : '-' ),
                 ( iscntrl( c ) ? 'X' : '-' ),
                 ( isdigit( c ) ? 'X' : '-' ),
                 ( isgraph( c ) ? 'X' : '-' ),
                 ( islower( c ) ? 'X' : '-' ),
                 ( isprint( c ) ? 'X' : '-' ),
                 ( ispunct( c ) ? 'X' : '-' ),
                 ( isspace( c ) ? 'X' : '-' ) );
    }  // end of loop for each character value

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswalnum_ex">
			<text>
				<![CDATA[// iswalnum_ex.c : iswalnum() example
// -------------------------------------------------------------

#include <wctype.h>     // int iswalnum( wint_t wc );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wint_t wc;
    int i, dummy;

    setlocale( LC_CTYPE, "" );
    wprintf( L"\nThe current locale for the 'is ...' functions is '%%s'.\n",
             setlocale( LC_CTYPE, NULL ) );

    wprintf( L"These are the alphanumeric wide characters"
             " in this locale:\n\n" );
    for ( wc = 0, i = 0; wc < 1024; wc++ )
    if ( iswalnum( wc ) )
    {
       if ( i %% 25 == 0 )
       {
           wprintf( L"... more ...\n" );
           dummy = getchar();              // Wait before printing more
           wprintf( L"Wide character Code\n" );
           wprintf( L"-----------------------\n" );
       }
       wprintf( L"%%5lc %%4lu\n", wc, wc );
       i++;
    }
    wprintf( L"-----------------------\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswalpha_Ex">
			<text>
				<![CDATA[// iswalpha_ex.c : iswalpha() example
// And also an example for
// iswalnum(), iswblank(), iswcntrl(), iswdigit(), iswgraph(),
// iswlower(), iswprint(), iswpunct(), iswspace().
// -------------------------------------------------------------

#include <wctype.h>    // int iswalpha( wint_t wc);  ...
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wint_t wc;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr,
                 L"Sorry, couldn't change to the system's native locale.\n");
       return 1;
    }
    wprintf( L"The current locale for the 'isw ...' functions is '%%s'.\n",
             setlocale(LC_CTYPE, NULL));

    wprintf( L"Here is a table of the 'isw ...' values for the characters "
             L"from 128 to 255 in this locale:\n\n");

    for ( wc = 128; wc < 255; ++wc ) // Loop iteration for each table row.
    {
       if ( (wc-128) %% 24 == 0 ) // Repeat table header every 24 rows.
       {
         wprintf(L"Code char alnum alpha blank cntrl digit graph lower"
                 L" print punct space\n");
         wprintf(L"---------------------------------------------------"
                 L"------------------\n");
       }
       wprintf(L"%%4u %%4lc %%3c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c\n",
               wc,                              // Print numeric character code.
               ( iswprint( wc ) ? wc  : ' ' ),  // Print the glyph, or a space
                                                // if it's not printable.
               ( iswalnum( wc ) ? 'X' : '-' ),  // In a column for each
               ( iswalpha( wc ) ? 'X' : '-' ),  // category, print X for
               ( iswblank( wc ) ? 'X' : '-' ),  // yes or - for no.
               ( iswcntrl( wc ) ? 'X' : '-' ),
               ( iswdigit( wc ) ? 'X' : '-' ),
               ( iswgraph( wc ) ? 'X' : '-' ),
               ( iswlower( wc ) ? 'X' : '-' ),
               ( iswprint( wc ) ? 'X' : '-' ),
               ( iswpunct( wc ) ? 'X' : '-' ),
               ( iswspace( wc ) ? 'X' : '-' ) );
    } // end of loop for each character value

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswctype_ex">
			<text>
				<![CDATA[// iswctype_ex.c : iswctype() example
// -------------------------------------------------------------

#include <wctype.h>    // int iswctype( wint_t wc, wctype_t description );
#include <wchar.h>
#include <locale.h>

int main()
{
    wint_t wc = L'ß';

    setlocale( LC_CTYPE, "de_DE.UTF-8" );
    if ( iswctype( wc, wctype( "alpha" )) )
    {
        if ( iswctype( wc, wctype( "lower" ) ))
           wprintf( L"The character %%lc is lowercase.\n", wc );
        if ( iswctype( wc, wctype( "upper" ) ))
           wprintf( L"The character %%lc is uppercase.\n", wc );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_localtime_s_ex">
			<text>
				<![CDATA[// gmtime_ex.c : gmtime() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <time.h>    // struct tm *localtime_s( const time_t * restrict timer,
                     //                         struct tm * restrict result);
#include <stdio.h>

int main()
{
    time_t now;    struct tm timeStruct;    char timeStr[26];

    time(&now);                           // Current time as an integer.

    // Convert to local time as a struct tm:
    if( localtime_s(&now, &timeStruct) != NULL)
    {
        timeStruct.tm_year += 1;          // One year later.
        if( asctime_s( timeStr, sizeof(timeStr), &timeStruct) == 0)
            printf("A year from today: %%s", timeStr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log1p_ex">
			<text>
				<![CDATA[// log1p_ex.c : log1p() example
// -------------------------------------------------------------

#include <math.h>    // double log1p( double x )
                     // float log1pf( float x )
                     // long double log1pl( long double x )
#include <stdio.h>

// atanh(x) is defined as 0.5 * ( log(x+1) - log(-x+1).
// Rounding errors can result in different results
// for different methods.

int main()
{
    puts("   x         atanh(x)    atanh(x) - 0.5*(log1p(x) - log1p(-x))\n"
         "--------------------------------------------------------------");
    for ( double x = -0.8; x < 1.0; x += 0.4)
    {
       double y = atanh(x);
       printf("%%6.2f %%14f %%20E\n", x, y, y - 0.5*(log1p(x) - log1p(-x)) );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log2_ex">
			<text>
				<![CDATA[// log2_ex.c : log2() example
// -------------------------------------------------------------

#include <math.h>    // double log2( double x )
                     // float log2f( float x )
                     // long double log2l( long double x )
#include <errno.h>
#include <stdio.h>

int main()
{
    double x[] = { 0, 0.7, 1.8, 1234, INFINITY };

    for ( int i = 0; i < sizeof( x ) / sizeof( double ); i++ )
    {
        errno = 0;
        printf( "The base 2 log of  %%.1f is %%.3f.\n", x[i], log2( x[i] ) );
        if ( errno == EDOM || errno == ERANGE )
           perror( __FILE__ );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log_ex">
			<text>
				<![CDATA[// log_ex.c : log() example
// The following code prints some sample values for base 2, 
// base e, and base 10 logarithms.
// -------------------------------------------------------------

#include <math.h>    // double log( double x )
                     // float logf( float x )
                     // long double logl( long double x )
#include <stdio.h>

int main()
{
    double x[] = { 1E-100, 0.5, 2, exp(1), 10, 1E+100 };

    puts("       x           log2(x)            log(x)          log10(x)\n"
         " ---------------------------------------------------------------");
    for ( int i = 0; i < sizeof(x) / sizeof(x[0]); ++i )
    {
        printf("%%#10.3G %%+17.10G %%+17.10G %%+17.10G\n",
                x[i], log2(x[i]), log(x[i]), log10(x[i]) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_logb_ex">
			<text>
				<![CDATA[// logb_ex.c : logb() example
// -------------------------------------------------------------

#include <math.h>    // double logb( double x )
                     // float logbf( float x )
                     // long double logbl( long double x )
#include <errno.h>
#include <stdio.h>

int main()
{
    double x[] = { 0, 0, 0.7, 1.8, 1234, INFINITY };

    x[1] = nextafter( 0.0, 1.0 );

    for ( int i = 0; i < sizeof( x ) / sizeof( double ); i++ )
    {
        errno = 0;
        printf( "The exponent in the binary representation of %%g is %%g.\n",
                x[i], logb( x[i] ) );
        if ( errno == EDOM || errno == ERANGE )
           perror( __FILE__ );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_malloc_ex">
			<text>
				<![CDATA[// malloc_ex.c : malloc() example
// -------------------------------------------------------------

#include <stdlib.h>    // void *malloc( size_t size );
#include <stdio.h>
#include <string.h>
//#include <errno.h>

int main()
{
    struct linelink { char *line;
                      struct linelink *next;
    };
    struct linelink *head = NULL, *tail = NULL;

    char buffer[2048];
    FILE *fp_in;

    /* ... 0pen input file ... */
    char filename[] = "malloc.txt";
    if ((fp_in = fopen( filename, "r")) == NULL)
       perror( "Opening input file" );

    while ( NULL != fgets(buffer, sizeof(buffer), fp_in ))
    {
        if ( head == NULL )    /* Chain not yet started; add first link */
        {
            head = tail = malloc( sizeof(struct linelink));
            if ( head != NULL )
            {
               head->line = malloc( strlen( buffer ) + 1 );
               if ( head->line != NULL )
               {  strcpy( head->line, buffer);  head->next = NULL; }
               else
               {  fprintf( stderr, "Out of memory\n" ); return -1; }
            }
            else
            {  fprintf( stderr, "Out of memory\n" ); return -1; }
         }
         else          /* Chain already started; add another link ... */
         {
             puts( "Adding another link ...");
             /* ... */ 
             break;
         }
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mblen_ex">
			<text>
				<![CDATA[// mblen_ex.c : mblen() example
// -------------------------------------------------------------

#include <stdlib.h>   // int mblen( const char *s, size_t maxsize );
#include <wchar.h>
#include <string.h>

size_t mbsrcat( char * restrict s1, char * restrict s2,
                mbstate_t * restrict p_s1state, size_t n )
/* mbsrcat: multibyte string restartable concatenation.
 * Appends s2 to s1, respecting final shift state of destination string,
 * indicated by *p_s1state. String s2 must start in the initial shift
 * state.
 * Returns: number of bytes written, or (size_t)-1 on encoding error.
 * Max. total length (incl. terminating null byte) is <= n;
 * stores ending state of concatenated string in *s1state.
 */
{
   int result;
   size_t i = strlen( s1 );
   size_t j = 0;

   if ( i >= n - (MB_CUR_MAX+1))   // Sanity check: room for 1 multibyte
                                   // char + string terminator.
      return 0;                    // Report 0 bytes written.

   // Shift s1 down to initial state:

   if ( !mbsinit( p_s1state ))     // If not initial state, then append
   {                               // shift sequence to get initial state.
      if ( ( result = wcrtomb( s1+i, L'\0', p_s1state )) == -1 )
      {                            // Encoding error:
         s1[i] = '\0';             // Try restoring termination.
         return (size_t)-1;        // Report error to caller.
      }
      else
        i += result;
   }

   // Copy only whole multibyte characters at a time.
   // Get length of next char w/o changing state:
   while (( result = mblen( s2+j, MB_CUR_MAX )) <= (n - ( 1 + i )) )
   {
      if ( result == 0 ) break;
      if ( result == -1 )
      {                        // Encoding error:
         s1[i] = '\0';         // Terminate now.
         return (size_t)-1;    // Report error to caller.
      }
      // Next character fits; copy it and update state:
      strncpy( s1+i, s2+j, mbrlen( s2+j, MB_CUR_MAX, p_s1state ));
      i += result;
      j += result;
   }
   s1[i] = '\0';
   return j;
}

#include <locale.h>
#include <stdio.h>

int main()
{
   if( setlocale(LC_ALL, "") == NULL)
      fputs("Unable to set the locale.\n", stderr);
   printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

   char str1[100] = "";
   mbstate_t mbstate = {0};
   size_t nChars = 0;

   nChars = mbsrcat( str1, "große ", &mbstate, sizeof(str1) );
   if( (int)nChars < 0)
   {   fputs("Error ...", stderr);  return -1;  }
   printf("%%zu characters.\n", nChars);

   nChars = mbsrcat( str1, "Füße", &mbstate, sizeof(str1) );
   if( (int)nChars < 0)
   {   fputs("Error ...", stderr);  return -1;  }
   printf("%%zu characters.\n", nChars);

   puts( str1);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbrtoc16_ex">
			<text>
				<![CDATA[// mbrtoc16_ex.c : mbrtoc16() example
// -------------------------------------------------------------

#include <uchar.h>     // size_t mbrtoc16( char16_t * restrict pc16,
                       //                  const char * restrict s,
                       //                  size_t n, 
                       //                  mbstate_t * restrict state );
//#include <stdlib.h>
#include <string.h>

// The function mbsToC16s() uses mbrtoc16() to convert a string of
// multibyte characters into a string of 16-bit characters
// (typically in UTF-16 encoding).
// Return value: the number of char16_t characters produced, or
//               -1 if an error occurred.

int mbsToC16s( const char *mbStr, char16_t *c16Str, size_t len)
{
   if( mbStr == NULL || c16Str == NULL || len == 0)   // Sanity checks.
      return -1;

   mbstate_t mbstate = {0};
   char16_t c16;
   int count = 0, i = 0, rv = 0,
       nBytes = (int)strlen(mbStr)+1;

   do {
      rv = (int)mbrtoc16( &c16, mbStr+i, nBytes-i, &mbstate);
      switch( rv)
      {
        case 0:  c16Str[count] = 0; i = nBytes;   // End of string.
                 break;
        case -1:                                  // Encoding error.
        case -2: count = -1;
                 break;
        default:
           if( count < (int)len-1 )
           {
              c16Str[count++] = c16;
              if( rv > 0) i += rv;                // rv != -3
           }
           else count = -1;
      }
   } while( count > 0 && i < nBytes);

   return count;
}

#include <locale.h>
#include <stdio.h>

int main(void)
{
   if( setlocale(LC_ALL, "en_US.utf8") == NULL)
      fputs("Unable to set the locale.\n", stderr);

   char *u8Str = u8"Grüße";
   char16_t c16Str[100];
   int nChars = 0;

   nChars = mbsToC16s( u8Str, c16Str, 100);
   if( nChars < 0)
      fputs("Error ...", stderr);
   else
   {
      printf("%%d UTF-16 characters.\n", nChars);
      // ...
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbrtowc_ex">
			<text>
				<![CDATA[// mbrtowc_ex.c : mbrtowc() example
// -------------------------------------------------------------

#include <wchar.h>    // size_t mbrtowc( wchar_t * restrict widebuffer,
                      //                 const char * restrict string,
                      //                 size_t maxsize, 
                      //                 mbstate_t * restrict state );
#include <wctype.h>
#include <stdlib.h>
#include <string.h>

size_t mbstoupper( char *s1, char *s2, size_t n )
/* Copies the multibyte string from s2 to s1, converting all the
   characters to uppercase on the way.
   Because there are no standard functions for case-mapping in multibyte
   encodings, converts to and from the wide-character encoding (using the
   current locale setting for the LC_CTYPE category). The source string
   must begin in the initial shift state.
   Returns: the number of bytes written;
            or (size_t)-1 on an encoding error.
*/
{
   char *inptr = s2, *outptr = s1;
   wchar_t thiswc[1];
   size_t inresult, outresult;

   mbstate_t states[2], *instate = &states[0], *outstate = &states[1];

   memset( states, '\0', sizeof states );

   do
   {
      inresult = mbrtowc( thiswc, inptr, MB_CUR_MAX, instate );
      switch ( inresult )
      {
      case (size_t)-2:     // The (MB_CUR_MAX) bytes at inptr do not make
                           // a complete mb character. Maybe there is a
                           // redundant sequence of shift codes. Treat the
                           // same as an encoding error.
         *outptr = '\0';
         return (size_t)-1;

      case (size_t)-1:     // Found an invalid mb sequence at inptr:
         return inresult;  // pass the error to the caller.

      case 0:              // Got a null character. Make a last null wc.
                           // The default action, with wcrtomb, does this
                           // nicely, so *no break statement* necessary here.

      default:             // Read <result> mb characters to get one wide
                           // character.
      /* Check for length limit before writing anything but a null.
         Note: Using inresult as an approximation for the output
         length.
         The actual output length could conceivably be different
         due to a different succession of state-shift sequences.
      */
      if (( outptr - s1 ) + inresult + MB_CUR_MAX > n )
      {   // i.e., if bytes written + bytes to write + termination > n,
          // then terminate now by simulating a null-character input.
         thiswc[0] = L'\0';
         inresult = 0;
      }
      inptr += inresult;
      if (( outresult = wcrtomb( outptr,
                                (wchar_t)towupper(thiswc[0]),
                                 outstate )) == -1 )
      {                               // Encoding error on output:
         *outptr = '\0';              // Terminate and return error.
         return outresult;
      }
      else
         outptr += outresult;
      }
   } while ( inresult );              // Drop out after handling '\0'.
   return outptr - s1;
}

#include <locale.h>
#include <stdio.h>

int main()
{
   if( setlocale(LC_ALL, "en_US.utf-8") == NULL)
      fputs("Unable to set the locale.\n", stderr);
   printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

   char strin[] = "Grüße", strout[64];
   size_t nByte = 0;

   nByte = mbstoupper( strout, strin, 64 );

   if( (int)nByte < 0)
   {   fputs("Error ...", stderr);  return -1;  }

   puts( strout);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbsrtowcs_ex">
			<text>
				<![CDATA[// mbsrtowcs_ex.c : mbsrtowcs() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t mbsrtowcs( wchar_t * restrict dest, 
                     //                   const char ** restrict src,
                     //                   size_t n,
                     //                   mbstate_t * restrict state );
#include <string.h>
#include <locale.h>
#include <stdio.h>

int main()
{
   size_t result;

   char mbstring[ ] = "This is originally a multibyte string.\n";
   const char *mbsptr = mbstring;

   wchar_t widestring[256] = { L'\0' };

   mbstate_t state;
   memset( &state, '\0', sizeof state );

   printf( "The current locale is %%s.\n", setlocale( LC_CTYPE, "" ));

   result = mbsrtowcs( widestring, &mbsptr, 256, &state );
   if ( result == (size_t)-1 )
   {
      fputs( "Encoding error in multibyte string", stderr );
      return -1;
   }
   else
   {
      printf( "Converted %%u multibyte characters. The result:\n", result );
      printf( "%%ls", widestring );
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbsrtowcs_s_ex">
			<text>
				<![CDATA[// mbsrtowcs_s_ex.c : mbsrtowcs_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t mbsrtowcs_s(size_t * restrict retval,
                     //                     wchar_t * restrict dst,
                     //                     size_t dstmax,
                     //                     const char ** restrict src,
                     //                     size_t n,
                     //                     mbstate_t * restrict state );
#include <stdio.h>

int main()
{
    const char *mbptr = "Any multibyte string";
    wchar_t wcstr[10];            // A buffer for wide characters
    size_t len;                   // and its capacity.
    mbstate_t state = {0};

    if( mbsrtowcs_s( &len, wcstr, 10, &mbptr, 9, &state) != 0)
        printf("The array contains an invalid multibyte character.\n");
    else
    {
       printf("Length: %%zu; text: %%ls\n", len, wcstr);
       printf("The remaining characters: %%s\n", mbptr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbtowc_ex">
			<text>
				<![CDATA[// mbtowc_ex.c : mbtowc() example
// -------------------------------------------------------------

#include <stdlib.h>   // int mbtowc( wchar_t * restrict wc,
                      //             const char * restrict s,
                      //             size_t maxsize );
#include <locale.h>
#include <stdio.h>

int main()
{
    int i = 0, n = 0;
    wchar_t wc;
    char mbstring[256] = "This is originally a multibyte string.\n";

    printf( "The current locale is %%s.\n", setlocale(LC_CTYPE, "" ));
    while ( (n = mbtowc( &wc, &mbstring[i], MB_CUR_MAX )) != 0 )
    {
        if ( n == -1 )
        {
           fputs( "Encoding error in multibyte string", stderr );
           break;
        }
        printf( "%%lc", (wint_t)wc );
        i += n;
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mktime_ex">
			<text>
				<![CDATA[// mktime_ex.c : mkctime() example
// -------------------------------------------------------------

#include <time.h>    // time_t mktime( struct tm *timeptr );
#include <stdio.h>

int main()
{
    time_t seconds;
    struct tm sometime;

    sometime.tm_sec   = 10;
    sometime.tm_min   = 80;
    sometime.tm_hour  = 40;
    sometime.tm_mday  = 23;
    sometime.tm_mon   = 1;
    sometime.tm_year  = 105;
    sometime.tm_wday  = 11;
    sometime.tm_yday  = 111;
    sometime.tm_isdst = -1;

    seconds = mktime( &sometime );

    if ( seconds == -1 )
    {
        printf( "mktime() couldn't make sense of its input.\n" );
        return -1;
    }

    printf( "The return value, %%ld, represents %%s",
            (long)seconds, ctime(&seconds) );

    printf( "The structure has been adjusted as follows:\n"
            "tm_sec   == %%d\n"
            "tm_min   == %%d\n"
            "tm_hour  == %%d\n"
            "tm_mday  == %%d\n"
            "tm_mon   == %%d\n"
            "tm_year  == %%d\n"
            "tm_wday  == %%d\n"
            "tm_yday  == %%d\n"
            "tm_isdst == %%d\n",

            sometime.tm_sec,
            sometime.tm_min,
            sometime.tm_hour,
            sometime.tm_mday,
            sometime.tm_mon,
            sometime.tm_year,
            sometime.tm_wday,
            sometime.tm_yday,
            sometime.tm_isdst );

    printf( "The structure now represents %%s", asctime( &sometime ));
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mtx_timedlock_ex">
			<text>
				<![CDATA[// mtx_timedlock_ex.c : mtx_timedlock() example
// -------------------------------------------------------------

#include <threads.h>   // int mtx_timedlock( mtx_t *restrict mtx,
                       //                    const struct timespec *restrict ts);
#include <stdio.h>

mtx_t mtx;
int func(void * thrd);                   // Thread function.

int main()
{
    thrd_t th;
    if( mtx_init(&mtx, mtx_timed) != thrd_success)
    { fputs("Initialization error.\n", stderr); return 1; }

    mtx_lock(&mtx);                      // Lock the mutex.
    if( thrd_create(&th, func, "Thread A") != thrd_success)
    { fputs("Thread error.\n", stderr); return 2; }

    thrd_join(th, NULL);
    mtx_destroy( &mtx);
    return 0;
}

int func(void * thrd)
{
    struct timespec ts;
    timespec_get( &ts, TIME_UTC);        // The current time;
    ts.tv_sec += 3;                      // 3 seconds from now.

    printf("%%s waiting ...\n", (char*)thrd);
    int res = mtx_timedlock(&mtx, &ts);
    switch(res)
    {
        case thrd_success:
           puts("Obtained mutex\n... releasing ...");
           mtx_unlock(&mtx);   break;
        case thrd_timedout:
           puts("Timed out.");   break;
        default:
           puts("mtx_timedlock: error.");
    };
    return res;
}
]]>
			</text>
		</p>
		<p n="xc_mtx_trylock_ex">
			<text>
				<![CDATA[// mtx_trylock_ex.c : mtx_trylock() example
// -------------------------------------------------------------

#include <threads.h>   // int mtx_trylock( mtx_t *mtx);
#include <stdio.h>

#define NUM_THREADS 3
mtx_t mtx;

struct timespec duration = { .tv_nsec = 1 };   // One nanosecond.
int func(void * thrd_num)                      // Thread function.
{
    int num = *(int*)thrd_num;
    int res, count = 1;

    while( (res = mtx_trylock(&mtx)) == thrd_busy)
    { ++count;  thrd_sleep( &duration, NULL); }

    if( res == thrd_success)
    {
       printf("Thread %%d succeeded after %%d attempts.\n", num, count);
       thrd_sleep( &duration, NULL);
       mtx_unlock(&mtx);
       return 0;
    }
    else return -1;
}
int main(void)
{
    struct { thrd_t th; int id; } th_arr[NUM_THREADS];

    if( mtx_init(&mtx, mtx_plain) != thrd_success)
       return 1;

    // Create threads:
    for( int i = 0; i < NUM_THREADS; ++i)
    {
       th_arr[i].id = i;
       if( thrd_create( &th_arr[i].th, func, &th_arr[i].id) 
           != thrd_success)
          return -2;
    }
    // Wait for threads to finish:
    for( int i = 0; i < NUM_THREADS; ++i)
     thrd_join( th_arr[i].th, NULL);

    mtx_destroy( &mtx);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_nearbyint_ex">
			<text>
				<![CDATA[// nearbyint_ex.c : nearbyint() example
// -------------------------------------------------------------

#include <math.h>    // double nearbyint( double x );
                     // float nearbyintf( float x );
                     // long double nearbyintl( long double x );
#include <fenv.h>
#include <stdio.h>

int main()
{
    if ( fesetround( FE_TOWARDZERO) == 0)
       printf("The current rounding mode is \"round toward 0.\"\n");
    else
       printf("The rounding mode is unchanged.\n");

    printf( "nearbyint(1.9) = %%4.1f    nearbyint(-1.9) = %%4.1f\n",
            nearbyint(1.9), nearbyint(-1.9) );

    printf( "round(1.9) = %%4.1f        round(-1.9) = %%4.1f\n",
            round(1.9), round(-1.9) );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_perror_ex">
			<text>
				<![CDATA[// perror_ex.c : perror() example
// -------------------------------------------------------------

#include <stdio.h>      // void perror( const char *string );
#include <errno.h>

#define MSGLEN_MAX 256

int main( int argc, char *argv[] )
{
    FILE *fp;
    char msgbuf[MSGLEN_MAX] = "";

    if (( fp = fopen( "nonexistentfile", "r" )) == NULL )
    {
       snprintf( msgbuf, MSGLEN_MAX, "%%s, function %%s, file %%s, line %%d",
                 argv[0], __func__, __FILE__, __LINE__ );
       perror( msgbuf );
       return errno;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_printf_ex">
			<text>
				<![CDATA[// printf_ex.c : printf() example
// -------------------------------------------------------------

#include <stdio.h>      // int printf( const char * restrict format, ... );
#include <math.h>
#include <assert.h>

void print_line( double x);

int main()
{
    double pi = 3.1415926;
    double bignumber = 8 * 8 * 8 * pi * pi * pi;
    printf("512 times pi cubed equals %%.2e, or %%.2a.\n",
                                      bignumber, bignumber);

    print_line( 11.22);
    return 0;
}

// The print_line function illustrates the use of the %%n conversion specification
// to count the characters in the output string:
void print_line( double x)
{
    int n1, n2;
    printf("x = %%5.2f exp(x) = %%n%%10.5f%%n\n", x, &n1, exp(x), &n2);
    assert( n2-n1 <= 10);           // Did printf() stretch the field width?
}
]]>
			</text>
		</p>
		<p n="xc_putchar_ex">
			<text>
				<![CDATA[// putchar_ex.c : putchar() example
// -------------------------------------------------------------

// The following example reads the beginning of a file repetitively,
// and reports its progress on stdout.

#include <stdio.h>      // int putchar( int c );

int main()
{
    long count; const long CYCLES = 5000;
    char readback[1024];

    FILE *fp = fopen( "infile.txt", "r" );
    if( fp == NULL)
    { fprintf( stderr, "Couldn't open input file.\n" ); return -1; }

    for (count = 0; count <= CYCLES; ++count)
    {
      /* Start output with '\r' to re-use same screen line. */
       printf( "\rPerformed %%li file reads. ", count );

       rewind( fp );
       fgets( readback, 1024, fp );

      /* Scroll a new screen line every hundred cycles. */
       if (count %% 100 != 0) continue;
       putchar( '\n' );
    }
    puts( "Done." );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_qsort_ex">
			<text>
				<![CDATA[// qsort_ex.c : qsort() example
// -------------------------------------------------------------

#include <stdlib.h>
         // void qsort( void *array, size_t n, size_t size,
         //             int (*compare)( const void *, const void *) );

#include <stdio.h>

int strptrcmp( const void *sp1, const void *sp2 );

int main()
{
    char *words[] = { "Then", "he", "shouted", "What", "I",
                      "didn't", "hear", "what", "you", "said" };

    int n = sizeof(words) / sizeof(char *);

    qsort( words, n, sizeof(char *), strptrcmp );

    for ( int j = 0 ; j < n ; j++ )
        puts( words[j] );
}

#include <string.h>

int strptrcmp( const void *sp1, const void *sp2 )
// Compare two strings by reference.
{
    // qsort() passes a pointer to the pointer:
    // dereference it to pass a char * to strcmp.
    const char * s1 = *(char **)sp1;
    const char * s2 = *(char **)sp2;
    return strcmp( s1, s2 );
}
]]>
			</text>
		</p>
		<p n="xc_rand_ex">
			<text>
				<![CDATA[// rand_ex.c : rand() example
// -------------------------------------------------------------

#include <stdlib.h>       // int rand( void );
#include <time.h>
#include <ctype.h>
#include <stdio.h>

int main()
{
    printf( "Think of a number between one and twenty.\n"
            "Press Enter when you're ready." );
    getchar();

    srand( (unsigned)time( NULL ) );
    for ( int i = 0; i < 3; i++ )     // We get three guesses.
    {
        printf( "Is it %%u? (y or n) ", 1 + rand() %% 20 );
        if ( tolower( getchar() ) == 'y' )
        {
            printf( "Ha! I knew it!\n" );
            exit( 0 );
        }
        getchar();                     // Discard newline character.
    }
    printf( "I give up.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="ex_realloc_ex">
			<text>
				<![CDATA[// realloc_ex.c : realloc() example
// -------------------------------------------------------------

#include <stdlib.h>       // void *realloc( void *ptr, size_t n );
#include <stdio.h>

int main()
{
    typedef struct { int len;
                     float array[];
                   } DynArray_t;

    DynArray_t *daPtr = malloc( sizeof(DynArray_t) + 10*sizeof(float) );
    if ( daPtr == NULL ) return -1;

    daPtr->len = 10;

    for ( int i = 0; i < daPtr->len; ++i )
        daPtr->array[i] = 1.0F/(i+1);

    /* daPtr->array[10] = 0.1F               // Invalid array index! */

    DynArray_t *daResizePtr = realloc( daPtr,
                                       sizeof(DynArray_t) + 11*sizeof(float));
    if ( daResizePtr != NULL )
    {
       daPtr = daResizePtr ;
       daPtr->len = 11;
       daPtr->array[10] = 0.1F / 12;         // OK now.
    }
    else
    {
       /* We'll just have to get along with the array of 10 floats.
       ...   */
       return -1;
    }
      
    for ( int i = 0; i < daPtr->len; ++i )
        printf( "%%2d : %%8f\n", i, daPtr->array[i] );
    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remainder_ex">
			<text>
				<![CDATA[// remainder_ex.c : remainder() example
// -------------------------------------------------------------

#include <math.h>   // double remainder( double x, double y );
                    // float remainderf( float x, float y );
                    // long double remainderl( long double x, long double y );
#include <stdio.h>

int main()
{
    double apples = 0.0, people = 0.0, share = 0.0, left = 0.0;

    printf( "\nHow many people? ");
    scanf( "%%lf", &people );

    printf( "\nHow many apples? ");
    scanf( "%%lf", &apples );

    left = remainder( apples, people );     // left may be negative!
    share = ( apples - left ) / people;

    printf( "If there are %%.1lf of us and %%.1lf apples, "
            "each of us gets %%.1lf of %%s, with %%.1lf left over.\n",
             people, apples, share, ( share < 1 ) ? "one" : "them", left );
    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remove_ex">
			<text>
				<![CDATA[// remove_ex.c : remove() example
// -------------------------------------------------------------

#include <stdio.h>     // int remove( const char *filename );
#include <errno.h>

int main()
{
    char fname_tmp[L_tmpnam] = "";
    FILE *fp;
    int result;

    tmpnam( fname_tmp );
    fp = fopen( fname_tmp, "w+" );
    if( fp == NULL)
    {  fprintf(stderr, "Couldn't open file \"%%s\".\n", fname_tmp);
       return -1;
    }

    /* ... write something in the file, edit it ... */
    fputs( "hello ...\n", fp);

    fclose( fp );

    result = rename( fname_tmp, "finished.txt" );
    if ( result )     // Delete previous "finished.txt" and try again.
    {
        remove( "finished.txt" );
        result = rename( fname_tmp, "finished.txt" );
        if ( result )                   // Give up and log the error.
           fprintf( stderr, "Error %%d on trying to rename output file\n",
                                                                   errno );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remquo_ex">
			<text>
				<![CDATA[// remquo_ex.c : remquo() example
// -------------------------------------------------------------

#include <math.h>   // double remquo( double x, double y, int *quo );
                    // float remquof( float x, float y, int *quo );
                    // long double remquol( long double x, long double y,
                    //                      int *quo );
#include <stdio.h>

int main()
{
    double apples = 0.0, people = 0.0, left = 0.0, share = 0.0;
    int quotient = 0;

    printf( "\nHow many people? ");
    scanf( "%%lf", &people );

    printf( "\nHow many apples? ");
    scanf( "%%lf", &apples );

    share = nearbyint( apples / people );
    left = remquo( apples, people, &quotient );    

    printf( "If there are %%.2lf of us and %%.2lf apples, "
            "each of us gets %%.2lf apple%%s, with %%.2lf left over.\n",
            people, apples, share, ( share == 1 ) ? "" : "s", left );

    printf( "remquo() stored %%d as the quotient "
            " of the division (modulo 8).\n", quotient );

    printf( "Test: share modulo 8 - quotient = %%d\n",
            (int) share %% 8 - quotient );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_rewind_ex">
			<text>
				<![CDATA[// rewind_ex.c : rewind() example
// This example prints the contents of a file twice, converting 
// each character to lowercase the first time through, and to 
// uppercase the second time:
// -------------------------------------------------------------

#include <stdio.h>   // void rewind( FILE *fp );
#include <stdlib.h>
#include <ctype.h>

int main( int argc, char *argv[])
{
    FILE *fp; int c;

    if ( argc != 2 )
       printf( "Usage: program input-file\n"), exit(1);

    if (( fp = fopen( argv[1], "r" )) == NULL )
        fprintf( stderr, "Failed to open file %%s\n", argv[1] );
    else
    {
        puts( "Contents of the file in lowercase:" );
        while (( c = fgetc( fp )) != EOF )
            putchar( tolower( c ));

        rewind( fp );

        puts( "Same again in uppercase:" );
        while (( c = fgetc( fp )) != EOF )
            putchar( toupper( c ));

       fclose( fp );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_rint_ex">
			<text>
				<![CDATA[// rint_ex.c : rint() example
// -------------------------------------------------------------

#include <math.h>    // double rint( double x );
                     // float rintf( float x );
                     // long double rintl( long double x );
#include <fenv.h>
#include <stdio.h>

struct round_modes { int id; char *str; } arrModes[ ] =
{
 #ifdef FE_TONEAREST
   { FE_TONEAREST,
     "FE_TONEAREST: round to nearest representable value" },
 #endif
 #ifdef FE_DOWNWARD
    { FE_DOWNWARD, "FE_DOWNWARD: round toward -Inf" },
 #endif
 #ifdef FE_UPWARD
   { FE_UPWARD, "FE_UPWARD: round toward +Inf" },
 #endif
 #ifdef FE_TOWARDZERO
   { FE_TOWARDZERO, "FE_TOWARDZERO: round toward 0" }
 #endif
};

int main()
{
    int nModes = sizeof( arrModes) / sizeof(*arrModes);

    #pragma STDC FENV_ACCESS ON

    for ( int i = 0; i < nModes; ++i)
    {
        if ( fesetround( arrModes[i].id) != 0)
           break;
        printf( "Rounding mode: %%s\n", arrModes[i].str );

        printf( "rint(1.4)  = %%4.1f    rint(1.5)  = %%4.1f\n",
                rint(1.4), rint(1.5) );
        printf( "rint(-1.4) = %%4.1f    rint(-1.5) = %%4.1f\n",
                rint(-1.4), rint(-1.5) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_cacukate">
			<text>
				<![CDATA[// calculate.c: Perform some calculations.
// Functions: calculate1(), calculate2().
// -------------------------------------------------------------

#include <math.h>
#include <setjmp.h>
#include <errno.h>

extern jmp_buf jmp_dest;             // Destination for longjmp()

double calculate1( double x)
{
    if ( x < 0)
        longjmp( jmp_dest, EDOM);    // Domain error
    else
        return sqrt(x);
}

double calculate2( double x)
{
    double y = exp(x);
    if ( y == HUGE_VAL)
        longjmp( jmp_dest, ERANGE);  // Range error
    else
        return y;
}
]]>
			</text>
		</p>
		<p n="sc_set_constraint_handler_s_ex">
			<text>
				<![CDATA[// set_constraint_handler_s_ex.c : set_constraint_handler_s() example
// -------------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // constraint_handler_t set_constraint_handler_s(
                     //                      constraint_handler_t handler);
#include <errno.h>
#include <string.h>
#include <stdio.h>

// Use a custom handler:
void myConstraintHandler(const char* msg, void * ptr, errno_t error)
{
    printf("A runtime constraint violation "
           "occurred: \n%%s; ", msg);
    printf("error code: %%d\n", error);  fflush(stdout);
    exit(error);
}

void func( const char *str)
{
    constraint_handler_t prevHandler =
               set_constraint_handler_s(myConstraintHandler);
    printf_s("The argument: %%s\n", str);        // Error if str
                                                // is a null pointer.
    int len = strlen(str);
    char str2[len];
    strcpy_s( str2, len, str);    // Error: str2 is one byte too short.
    // . . .
    set_constraint_handler_s(prevHandler);
}

int main()
{
    func("Hi");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_set_constraint_handler_s_ex">
			<text>
				<![CDATA[// set_constraint_handler_s_ex.c : set_constraint_handler_s() example
// -------------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // constraint_handler_t set_constraint_handler_s(
                     //                      constraint_handler_t handler);
#include <errno.h>
#include <string.h>
#include <stdio.h>

// Use a custom handler:
void myConstraintHandler(const char* msg, void * ptr, errno_t error)
{
    printf("A runtime constraint violation "
           "occurred: \n%%s; ", msg);
    printf("error code: %%d\n", error);  fflush(stdout);
    exit(error);
}

void func( const char *str)
{
    constraint_handler_t prevHandler =
               set_constraint_handler_s(myConstraintHandler);
    printf_s("The argument: %%s\n", str);        // Error if str
                                                // is a null pointer.
    int len = strlen(str);
    char str2[len];
    strcpy_s( str2, len, str);    // Error: str2 is one byte too short.
    // . . .
    set_constraint_handler_s(prevHandler);
}

int main()
{
    func("Hi");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_setjmp_ex">
			<text>
				<![CDATA[// setjmp_ex.c : setjmp() - longjmp() example
// -------------------------------------------------------------

#include <setjmp.h>       // int setjmp( jmp_buf env );
                          // void longjmp( jmp_buf environment,
                          //               int returnval );
#include <stdlib.h> 
#include <stdio.h>
#include <errno.h>

double calculate1( double x);     // Functions defined
double calculate2( double x);     // in calculate.c.

jmp_buf jmp_dest;                 // Destination for longjmp()

int main()
{
    double x = 0, y1, y2;
    int n = 0;

    puts("--- Demonstrating non-local jumps ---\n");

    switch( setjmp( jmp_dest)) // Jump to here for error handling
    {
    case 0:                    // The original setjmp() call
        break;
    case EDOM:                 // Arrived via longjmp() call with EDOM
        puts("Domain error. "
             "Negative numbers are not permitted.");
        break;
    case ERANGE:               // Arrived via longjmp() call with ERANGE
        puts("Range error. "
             "The number you entered is too big.");
        break;
    default:                   // We should never arrive here.
        puts("Unknown error.");
        exit( EXIT_FAILURE );
    }

    printf("Enter a number: ");
    do
    {
        if ( (n = scanf("%%lf", &x)) < 0)  // Read in a number.
           exit( EXIT_FAILURE );          // Read end of file.
        while ( getchar() != '\n')        // Clear the input buffer.
          ;
        if ( n == 0 )
           printf("Invalid entry. Try again: ");
    }while ( n == 0 );

    y1 = calculate1(x);
    y2 = calculate2(x);

    printf("\nResult of Calculation 1: %%G\n", y1);
    printf(  "Result of Calculation 2: %%G\n", y2);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_setlocale_ex">
			<text>
				<![CDATA[// setlocale_ex.c : setlocale() example
// -------------------------------------------------------------

#include <locale.h>    // char *setlocale( int category, 
                       //                  const char *locale_name );
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_STRING 80

int main()
{
    char name[MAX_STRING];
    char locale[MAX_STRING];
    char *newlocale;
    int i;

    printf( "Who are you? " );
    fgets( name, sizeof(name), stdin );

    printf( "What is your locale? " );
    fgets( locale, sizeof(locale), stdin );

    name[ strlen(name) - 1 ] = '\0';     // Chomp off the newlines.
    locale[ strlen(locale) - 1 ] = '\0';

    newlocale = setlocale( LC_CTYPE, locale );
    if ( newlocale == NULL )
       printf( "Sorry, couldn't change the locale to %%s.\n"
               "The current locale is %%s. ",
               locale, setlocale( LC_CTYPE, NULL ));
    else
        printf( "The new locale is %%s. ", newlocale );

    name[0] = toupper( name[0] );   // Force the first letter to uppercase.

    i = 1;
    if ( isupper( name[i] ) )       // Is the second letter also uppercase?
    {
       while ( name[i] != '\0' )    // If so, force all the rest to lowercase.
       {
          name[i] = tolower( name[i] );
          ++i;
       }
    }
    printf( "Hello there, %%s!\n", name );

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_signal_ex">
			<text>
				<![CDATA[// signal_ex.c : signal() example
// -----------------------------------------------------------------------

#include <signal.h>   // void ( *signal( int sig, void (*handler)(int) ) )(int);
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdint.h>   // Defines SIG_ATOMIC_MAX

void sigint_handler(int sig);
volatile sig_atomic_t i;   // A counter accessed by main and the
                           // handler.

int main()
{
    if ( signal( SIGINT, sigint_handler ) == SIG_ERR )
    {
        perror("Failed to install SIGINT handler");
        exit(3);
    }

    while (1)
    {
        puts( "Press Ctrl+C to interrupt me.");
        for ( i = 0 ; i < SIG_ATOMIC_MAX ; i++ )
            if ( i %% 100000 == 0)
            {
                printf( "\r%%d ", i / 100000 );
                fflush( stdout );
            }
        raise( SIGINT );   // Simulate a Ctrl+C in case the user didn't
                           // type it.
    }
    return 0;
}

void sigint_handler( int sig )
{
    int c = 0;

    if ( sig != SIGINT ) exit( 1 );

    signal( SIGINT, SIG_IGN );         // Ignore a second Ctrl+C

    puts( "\nThis is the function sigint_handler()."
          "\nDo you want to exit the program now? [y/n]");
    while (( c = tolower( getchar( ) )) != 'y' && c != 'n' && c != EOF )
      ;

    if ( c != 'n' )
       exit(0);
    else
       i = 0;                          // Reset timer

    signal( SIGINT, sigint_handler );  // Reinstall this handler.

    /* No return value; just fall off the end of the function. */
}
]]>
			</text>
		</p>
		<p n="xc_signb_ex">
			<text>
				<![CDATA[// signbit_ex.c : signbit() example
// -------------------------------------------------------------

#include <math.h>   // int signbit(x );
#include <stdio.h>

int main()
{
    double x[ ] = { -0.0, 187.234, sqrt( -1.0 ), 1.0 / -0.0 };

    for ( int i = 0 ; i < ( sizeof(x) / sizeof(double)) ; i++ )
        printf( "x[%%d] equals %%lF, and is%%s negative.\n",
                 i, x[i], signbit( x[i] ) ? "" : " not" );    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sin_ex">
			<text>
				<![CDATA[// sin_ex.c : sin() example
// -------------------------------------------------------------

#include <math.h>    // double sin( double x );
                     // double sinf( float x );
                     // long double sinl( long double x );
#include <stdio.h>
#include <stdlib.h>

#define DEG_PER_RAD ( 180.0 / PI )

int main()
{
    const double PI = 4.0 * atan( 1.0 );
    double a[4];

    printf( "\nEnter an acute angle measure, in degrees: " );

    if ( scanf( "%%lf", a ) < 1 || ( a[0] <= 0 || a[0] >= 90 ) )
        printf( "\nThat's not an acute angle.\n" ), exit( 1 );
    else
    {
        a[1] = a[0] + 90 ;
        a[2] = 180 - a[0] ;
        a[3] = 225 + a[0] ;

        for ( int i = 0 ; i < 4 ; i ++ )
            printf( "The sine of %%6.2lf degrees is %%6.4lf.\n",
                    a[i], sin( a[i] / DEG_PER_RAD ) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sinh_ex">
			<text>
				<![CDATA[// sinh_ex.c : sinh() example
// -------------------------------------------------------------

#include <math.h>    // double sinh( double x );
                     // double sinhf( float x );
                     // long double sinhl( long double x );
#include <stdio.h>

// A chain hanging from two points forms a curve called a catenary.
// A catenary is a segment of the graph of the function
// cosh(k*x)/k, for some constant k.
// The length along the catenary over a certain span, bounded by the
// two vertical lines at x=a and x=b, is equal to
// sinh(k*b)/k - sinh(k*a)/k.

int main()
{
    double x, k;

    puts("Catenary f(x) = cosh(k*x)/k\n"
         "Length along the catenary from a to b: "
         "sinh(k*b)/k - sinh(k*a)/k)\n");

    puts("            f(-1.0)  f(0.0)   f(1.0)   f(2.0)   Length(-1.0 to 2.0)\n"
         "-------------------------------------------------------------------");
    for ( k = 0.5; k < 5; k *= 2)
    {
        printf("k = %%.1f: ", k);
        for ( x = -1.0; x < 2.1; x += 1.0)
           printf("%%8.2f ", cosh(k*x)/k );

        printf(" %%12.2f\n", (sinh(2*k) - sinh(-1*k))/ k);
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_snprintf_ex">
			<text>
				<![CDATA[// snprintf_ex.c : snprintf() example
// -------------------------------------------------------------

#include <stdio.h>   // int snprintf( char * restrict dest, size_t n,
                     //               const char * restrict format, ... );

int main()
{
    char buffer[80];
    double x = 1234.5, y = 678.9, z = -753.1, a = x * y + z;
    int output_len = 0;

    output_len = snprintf( buffer, 80, "For the input values %%lf, %%lf,"
                           " and %%lf,\nthe result was %%lf.\n",
                           x, y, z, a );
    puts( buffer );
    if ( output_len >= 80 )
       fprintf( stderr, "Output string truncated! Lost %%d characters.\n",
                output_len - 79 );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sprintf_ex">
			<text>
				<![CDATA[// sprintf_ex.c : sprintf() example
// -------------------------------------------------------------

#include <stdio.h>   // int sprintf( char * restrict dest, 
                     //              const char * restrict format, ... );

int main()
{
    char buffer[80];
    double x = 1234.5, y = 678.9, z = -753.1, a = x * y + z;
    int output_len = 0;

    output_len = sprintf( buffer, "For the input values %%lf, %%lf, and %%lf,"
                          "\nthe result was %%lf.\n",
                          x, y, z, a );
    puts( buffer );
    if ( output_len >= 80 )
       fprintf( stderr, "Output string overflowed by %%d characters.\n"
                "The variables x, y, z and a may have been corrupted:\n"
                "x now contains %%lf, y %%lf, z %%lf, and a %%lf.\n",
                 output_len - 79, x, y, z, a );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sqrt_ex">
			<text>
				<![CDATA[// sqrt_ex.c : sqrt() example
// -------------------------------------------------------------

#include <math.h>    // double sqrt( double x );
                     // double sqrtf( float x );
                     // long double sqrtl( long double x );
#include <stdio.h>
#include <errno.h>

int main()
{
    double x[ ] = { 0.5, 0.0, -0.0, -0.5 };

    for ( int i = 0; i < ( sizeof(x) / sizeof(double) ); i++)
    {
       printf("The square root of %%.2F equals %%.4F\n", x[i], sqrt( x[i] ) );
       if ( errno )
          perror( __FILE__ );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcat_ex">
			<text>
				<![CDATA[// strcat_ex.c : strcat(), strcat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for strcat_s()

#include <string.h>  // char *strcat( char * restrict s1, 
                     //               const char * restrict s2 );
                     // errno_t strcat_s( char * restrict s1, rsize_t s1max,
                     //                   const char * restrict s2 );
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char  lastname[32];
    char  firstname[32];
    _Bool ismale;
} Name;

int main()
{
    char displayname[80];
    Name *newName = calloc( 1, sizeof(Name) );

    /* ... check for calloc failure; read in the name parts ... */
    if( newName == NULL)
    {  fprintf( stderr, "Out of memory\n" ); return -1; }
    *newName = (Name) { "Lincoln", "Abraham", 1 };

    strcpy( displayname, ( newName->ismale ? "Mr. " : "Ms. " ) );

    strcat( displayname, newName->firstname );
    strcat( displayname, " " );
    strcat( displayname, newName->lastname );

    // Better to use strcat_s() in case the fields in the Name
    // structure are ever enlarged:
    // strcat_s( displayname, sizeof(displayname), newName->firstname );
    // strcat_s( displayname, sizeof(displayname), " " );
    // strcat_s( displayname, sizeof(displayname), newName->lastname );

    puts( displayname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strchr_ex">
			<text>
				<![CDATA[// strchr_ex.c : strchr() example
// -------------------------------------------------------------

#include <string.h>  // char *strchr( const char *s, int c );
#include <stdio.h>
#include <stdlib.h>

typedef struct { char street[32];
                 char city[32];
                 char stateprovince[32];
                 char zip[16];
               } Address;

char printaddr[128] = "720 S. Michigan Ave.\nChicago, IL 60605\n";

int main()
{
    int sublength;
    Address *newAddr = calloc( 1, sizeof(Address) );

    if ( newAddr != NULL )
    {
        sublength = strchr( printaddr, '\n' ) - printaddr;
        strncpy( newAddr->street, printaddr,
                 ( sublength < 31 ? sublength : 31 ) );
        /* ... */
        puts(newAddr->street);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcmp_ex">
			<text>
				<![CDATA[// strcmp_ex.c : strcmp() example
// -------------------------------------------------------------

#include <string.h>  // int strcmp( const char *s1, const char *s2);
#include <stdio.h>

int main()
{
    int result = 0;
    char word1[256], word2[256], *greaterlessequal;

    while ( result < 2 )
    {
        puts( "Type two words, please." );
        result = scanf( "%%s%%s", word1, word2 );
    }
    result = strcmp( word1, word2 );

    if ( result < 0 )
       greaterlessequal = "less than";
    else if ( result > 0 )
       greaterlessequal = "greater than";
    else
       greaterlessequal = "the same as";

    printf( "The word \"%%s\" is %%s the word \"%%s\".\n",
            word1, greaterlessequal, word2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcoll_ex">
			<text>
				<![CDATA[// strcoll_ex.c : strcoll() example
// -------------------------------------------------------------

#include <string.h>  // int strcoll( const char *s1, const char *s2 );
#include <stdio.h>
#include <locale.h>

int main()
{
    char *samples[ ] = { "curso", "churro" };

    if( setlocale( LC_COLLATE, "es_US.UTF-8" ) == NULL)
       fputs("Unable to set the locale.\n", stderr);

    int result = strcoll( samples[0], samples[1] );

    if ( result == 0 )
       printf( "The strings \"%%s\" and \"%%s\" are alphabetically "
               "equivalent.\n", samples[0], samples[1] );
    else if ( result < 0 )
       printf( "The string \"%%s\" comes before \"%%s\" alphabetically.\n",
               samples[0], samples[1] );
    else if ( result > 0 )
       printf( "The string \"%%s\" comes after \"%%s\" alphabetically.\n",
               samples[0], samples[1] );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcpy_ex">
			<text>
				<![CDATA[// strcpy_ex.c : strcpy(), strcpy_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for strcpy_s()

#include <string.h>  // char *strcpy( char * restrict dest,
                     //               const char * restrict src );
                     // errno_t strcpy_s( char * restrict dest, 
                     //                   rsize_t destmax,
                     //                   const char * restrict src );
#include <stdio.h>

int main()
{
    struct guest {
       char name[64]; int age; _Bool male, smoking, discount; } this;
    int result;

    printf( "Last name: " );
    result = scanf( "%%[^\n]", this.name );
    if ( result < 1 )
       strcpy( this.name, "[not available]" );
   // or
   // strcpy_s( this.name, sizeof(this.name), "[not available]" );

    printf( "Name: %%s\n", this.name );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcspn_ex">
			<text>
				<![CDATA[// strcspn_ex.c : strcspn() example
// -------------------------------------------------------------

#include <string.h>  // int strcspn( const char *s1, const char *s2 );
#include <stdio.h>

int main()
{
    char *path = "/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games";
    int separator;
    char *basename = "aprogram";
    char fullname[1024] = "";

    separator = strcspn( path, ":" );  // Obtain the index of the first
                                       // colon.
    strncpy( fullname, path, separator );
    fullname[separator] = '\0';        // Terminate the copied string
                                       // fragment.
    strncat( fullname, "/", sizeof(fullname) - strlen(fullname) -1 );
    strncat( fullname, basename, sizeof(fullname) - strlen(fullname) -1 );

    puts( fullname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strerror_ex">
			<text>
				<![CDATA[// strerror_ex.c : strerror() example
// -------------------------------------------------------------

#include <string.h>     // char *strerror( int errornumber );
#include <errno.h>
#include <stdio.h>

int main( int argc, char *argv[])
{
    FILE *fp;
    char msgbuf[1024] = { '\0' };

    /* Open input file: */
    if (( fp = fopen( "nonexistent", "r" )) == NULL)
    {
       int retval = errno;
       snprintf( msgbuf, sizeof(msgbuf),
                 "%%s: file %%s, function %%s, line %%d: error %%d,\n%%s.\n",
                 argv[0], __FILE__, __func__, __LINE__, retval,
                 strerror( retval ));
       fputs( msgbuf, stderr );
       return retval;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strerror_s_ex">
			<text>
				<![CDATA[// strerror_s_ex.c : strerror_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>     // errno_t strerror_s(char *s, rsize_t maxsize,
                        //                    errno_t errnum);
#include <stdio.h>
#include <errno.h>
#include <math.h>

int main()
{
    double x = -1.0, y = 0;
  // ...
    errno = 0;
    y = sqrt(x);
    if( errno == EDOM)
    {
        char msg[30] = "";
        strerror_s( msg, sizeof(msg), errno);
        fprintf( stderr, "sqrt: %%s\n", msg);
    }
  // ...
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strftime_ex">
			<text>
				<![CDATA[// strftime_ex.c : strftime() example
// -------------------------------------------------------------

#include <time.h>   // size_t strftime( char * restrict s, size_t n,
                    //                  const char * restrict format,
                    //                  const struct tm * restrict timeptr );
#include <stdio.h>

int main()
{
    time_t now;
    struct tm *localnow;
    char hdr_date[999] = "";

    time( &now );
    localnow = localtime( &now );

    if ( strftime( hdr_date, 78, "Date: %%a, %%d %%b %%Y %%T %%z", localnow ) )
        puts( hdr_date );
    else
        return -1;

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strlen_ex">
			<text>
				<![CDATA[// strlen_ex.c : strlen() example
// -------------------------------------------------------------

#include <string.h>  // size_t strlen( const char *s );
#include <stdio.h>

int main()
{
    char line[1024] =
         "This string could easily be hundreds of characters long.";
    char *readptr = line;
    int columns = 80;

    // While the text is longer than a row:
    while ( strlen( readptr ) > columns )
    {   // print a row with a backslash at the end:
        printf( "%%.*s\\", columns-1, readptr);
        readptr += columns -1;
    }   
    // Then print the rest with a newline at the end:
    printf( "%%s\n", readptr );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strncat_ex">
			<text>
				<![CDATA[// strncat_ex.c : strncat(), strncat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1    // For the secure functions.

#include <string.h>  // char *strncat( char * restrict s1,
                     //                const char * restrict s2, size_t n );
                     // errno_t strncat_s( char * restrict s1, rsize_t s1max,
                     //                    const char * restrict s2, rsize_t n);
#include <stdlib.h>
#include <stdio.h>

int main()
{
    char str1[] = "hello ",       // 7 bytes
         str2[10] = "hello ",     // 7 + 3 bytes
         str3[10] = "hello ";     // 7 + 3 bytes

 // strncat( str1, "Jimi", 1);    // Severe error: buffer overflow!
 // strncat( str2, "Jimi", 3);    // OK: "hello Jim"
 // strncat( str3, "Jim", 100);   // OK.

 // Or, using strncat_s(), with the variables defined above:
    int ret1, ret2, ret3;

    set_constraint_handler_s(ignore_handler_s);
    ret1 = strncat_s( str1, sizeof(str1), "Jimi", 1);   // ret1 != 0 and
                                                        // str1[0] == '\0'
    printf( "ret1: %%d    str1: %%s\n", ret1, str1 );

    ret2 = strncat_s( str2, sizeof(str2), "Jimi", 3);   // OK: ret2 == 0
    printf( "ret2: %%d    str2: %%s\n", ret2, str2 );

    ret3 = strncat_s( str3, sizeof(str3), "Jim", 100);  // OK: ret3 == 0
    printf( "ret3: %%d    str3: %%s\n", ret3, str3 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strneln_s_ex">
			<text>
				<![CDATA[// strnlen_s_ex.c : strnlen_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1    // For the secure functions.
#include <string.h>  // size_t strnlen_s(const char *s, size_t maxsize);
#include <stdio.h>

int main()
{
    char str[] = "hello";

    size_t len = strnlen_s( str, 1000);  // len = 5

    if( strnlen_s( str, 4) == 4)
    { 
        puts("str is more than 4 characters long."); 
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strpbrk_ex">
			<text>
				<![CDATA[// strpbrk_ex.c : strpbrk() example
// -------------------------------------------------------------

#include <string.h>    // char *strpbrk( const char *s1, 
                       //                const char *s2 );
#include <stdio.h>

int main()
{
    char *story = "He shouted: \"What? I can't hear you!\"\n";
    char separators[] = " \t\n.:?!\"";
    char *start = story, *end = NULL;
    char words[16][16];     // An array of char arrays to collect words in.
    int i = 0;

    while ( i < 16 && ( end = strpbrk( start, separators ) ) != NULL )
    {
      if ( end != start )   // If the separator wasn't the first character,
      {                     // then save a word in an array.
         strncpy( words[i], start, end - start );
         words[i][end - start] = '\0';     // And terminate it.
         i++;
      }
      start = end + 1;      // Next strpbrk call starts with
    }                       // the character after this separator.

    puts( story );

    for ( int j = 0 ; j < i ; j++ )
       puts( words[j] );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strrchr_ex">
			<text>
				<![CDATA[// strrchr_ex.c : strrchr() example
// -------------------------------------------------------------

#include <string.h>     // char *strrchr( const char *s, int c );
#include <stdio.h>

int main( int argc, char *argv[])
{
    char *mybasename = strrchr( argv[0], '/' );       // Find end of path.
    if ( mybasename != NULL )
        mybasename++;       // Point to the first character after the slash.
    else
        mybasename = argv[0];

    printf( "This program was invoked as %%s.\n", mybasename );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strspn_ex">
			<text>
				<![CDATA[// strspn_ex.c : strspn() example
// -------------------------------------------------------------

#include <string.h>  // int strspn( const char *s1, const char *s2 );
#include <stdio.h>

int main()
{
    char wordin[256];
    double val;

    puts( "Enter a floating-point number, please:" );
    scanf( "%%s", wordin );

    int index = strspn( wordin, "+-0123456789eE." );
    if ( index < strlen( wordin ) )
       printf( "Sorry, but the character %%c is not permitted.\n",
               wordin[index] );
    else
    {
        sscanf( wordin, "%%lg", &val );
        printf( "You entered the value %%g\n", val );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtod_ex">
			<text>
				<![CDATA[// strtod_ex.c : strtod() example
// -------------------------------------------------------------

#include <stdlib.h>  // double strtod( const char * restrict s,
                     //                char ** restrict endptr );
#include <stdio.h>

int main()
{
    char in[1024], *this = in, *next = in;
    double val;

    puts( "Enter some floating-point numbers, please:" );
    scanf( "%%[^\n]", in );

    puts( "Here are the values you entered:" );
    while ( 1 )
    {
        val = strtod( this, &next );
        if ( next == this )     // Means no conversion was possible.
            break ;
        printf( "\t%%g\n", val );
        this = next;            // Try again with the rest of the input string.
    }
    puts( "Done." );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtok_ex">
			<text>
				<![CDATA[// strtok_ex.c : strtok() example
// -------------------------------------------------------------

#include <string.h>  // char *strtok( char * restrict s1, 
                     //               const char * restrict s2 );
#include <stdio.h>

int main()
{
    char *command, *arg1, *arg2, *comment;
    char line[] = " mul eax,[ebp+4] ; Multiply by y\n";

    command = strtok(line," \t");   // First word, between spaces or tabs.
    arg1 = strtok( NULL, ",");      // From there to the comma is arg1.
                                    // (Trim off any spaces later.)
    arg2 = strtok( NULL, ";\n");    // From there to a semicolon or line end.
    comment = strtok( NULL, "\n\r\v\f" );  // From there to end of line or
                                           //page.
    printf( "Command:      %%s\n"
            "1st argument: %%s\n"
            "2nd argument: %%s\n"
            "Comment:      %%s\n\n",
            command, arg1, arg2, comment );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtok_s_ex">
			<text>
				<![CDATA[// strtok_s_ex.c : strtok_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>  // char *strtok_s( char * restrict s1, 
                     //                 rsize_t * restrict s1max,
                     //                 const char * restrict s2, 
                     //                 char ** restrict ptr);
#include <stdio.h>

int main()
{
    char str[] = "Lennon, John: 10/9/1940";
    char *ptr;
    size_t size = sizeof(str);
    char *firstname, *lastname, *birthday;

    lastname = strtok_s( str, &size, ", ", &ptr);
    if( lastname != NULL)
       firstname = strtok_s(NULL, &size, ": ", &ptr);
    if( firstname != NULL)
       birthday = strtok_s(NULL, &size, "", &ptr);
    if(birthday != NULL)
       printf("%%s %%s was born on %%s.\n",
              firstname, lastname, birthday);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtoul_ex">
			<text>
				<![CDATA[// strtoul_ex.c : strtoul() example
// -------------------------------------------------------------

#include <stdlib.h>  // unsigned long strtoul( const char * restrict s,
                     //                        char ** restrict endptr,
                     //                        int base );
#include <stdio.h>

int main()
{
    char dotted[ ] = "172.16.2.10", *ptr = dotted, *nextdot = NULL;
    unsigned long dest = 0;

    // This for loop uses stroul() to convert an IPv4 address from a 
    // dotted-decimal string to a 32-bit integer value:
    for ( int i = 0; i < 4; i++)
    {
        dest <<= 8;
        dest += strtoul( ptr, &nextdot, 10 );
        ptr = nextdot + 1;
    }
    printf( "The IPv4 address %%s\n"
            "represents the 32-bit integer value %%lu\n",
             dotted, dest );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strxfrm_ex">
			<text>
				<![CDATA[// strxfrm_ex.c : strxfrm() example
// -------------------------------------------------------------

#include <string.h>  // size_t strxfrm( char * restrict dest,
                     //                 const char * restrict src,
                     //                 size_t n );
#include <locale.h>
#include <stdlib.h>
#include <stdio.h>

typedef struct stringpair { char * original;
                            char * xformed; } Stringpair_t ;

Stringpair_t stringpairs[8] =
             { { "Chávez", NULL },        { "Carron", NULL },
               { "Canoso", NULL },        { "Cañoso", NULL },
               { "Carteño", NULL },       { "Cortillo", NULL },
               { "Cortiluz S.A.", NULL }, { "Corriando", NULL } };

char xformbuffer[1024];           // Space to catch each strxfrm() result.

int stringpaircmp( const void * p1, const void *p2 );
                                  // Defined externally.

int main()
{
    setlocale( LC_COLLATE, "");    // Use the host system's locale setting.
//    printf( "The locale is %%s.\n", setlocale( LC_COLLATE, NULL) );

    for ( int i = 0; i < 8 ; i++ )
    {
        stringpairs[i].xformed
        = malloc( strxfrm( xformbuffer, stringpairs[i].original, 1024 ) + 1 );
        if ( stringpairs[i].xformed != NULL )
           strcpy(stringpairs[i].xformed, xformbuffer);
    }

    qsort( stringpairs, 8, sizeof(Stringpair_t), stringpaircmp );

    for ( int i = 0; i < 8 ; i++ )
        puts( stringpairs[i].original );

    return 0;
}

int stringpaircmp( const void * sp1, const void *sp2 )
{
    const char * s1 = ((Stringpair_t *)sp1)->xformed;
    const char * s2 = ((Stringpair_t *)sp2)->xformed;
    return strcmp( s1, s2 );
}
]]>
			</text>
		</p>
		<p n="xc_swprintf_ex">
			<text>
				<![CDATA[// swprintf_ex.c : swprintf() example
// -------------------------------------------------------------

#include <wchar.h>  // int swprintf( wchar_t * restrict dest, size_t n,
                    //               const wchar_t * restrict format, ... );
#include <stdlib.h>

const wchar_t *dollar_as_wstr( long amount)
// Converts a number of cents into a wide string
// showing dollars and cents.
// For example, converts -123456 into the wide string L"-$1234.56"
{
    static wchar_t buffer[16];
    wchar_t sign[2] = L"";

    if ( amount < 0L)
       amount = -amount, sign[0] = '-';

    ldiv_t dollars_cents = ldiv( amount, 100);
    swprintf( buffer, sizeof(buffer),
              L"%%ls$%%ld.%%2ld", sign, dollars_cents.quot, dollars_cents.rem);

    return buffer;
}

#include <stdio.h>

int main()
{
    fputws( dollar_as_wstr( -123456), stdout );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_system_ex">
			<text>
				<![CDATA[// system_ex.c : system() example
// -------------------------------------------------------------

#include <stdlib.h>    // int system( const char *s );
#include <stdio.h>

int main()
{
    if ( system( NULL ))
       system( "echo \"Shell: $SHELL; process ID: $$\"");
    else
       printf( "No command processor available.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tan_ex">
			<text>
				<![CDATA[// tan_ex.c : tan() example
// -------------------------------------------------------------

#include <math.h>    // double tan( double x );
                     // float tanf( float x );
                     // long double tanl( long double x );
#include <stdio.h>

int main()
{
    const double pi = 4.0L * atan( 1.0 );     // Because tan(pi/4) = 1
    double shadow_length = 85.5,
           angle = 36.2;         // Sun's elevation from the horizon, in
                                 // degrees
    double height = shadow_length *tan ( angle * pi/180);

    printf("The tower is %%.2f meters high.\n", height);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tanh_ex">
			<text>
				<![CDATA[// tanh_ex.c : tanh() example
// -------------------------------------------------------------

#include <math.h>    // double tanh( double x );
                     // float tanhf( float x );
                     // long double tanhl( long double x );
#include <stdio.h>

int main()
{
    double x = -0.5, y1, y2;

    y1 = tanh(x);
    y2 = exp(2*x);
    y2 = (y2 -1) / (y2 + 1);

    printf("The tanh() function returns     %%.15f.\n", y1 );
    printf("Using the function exp() yields %%.15f.\n", y2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_create_ex">
			<text>
				<![CDATA[// thrd_create_ex.c : thrd_create() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
#include <stdio.h>

int th_func(void * arg)         // The thread function.
{
    puts("Hello from th_func ...");
    ++*(int*)arg;
    return 0;
}

int main()
{
    thrd_t th; int n = 1;

    if ( thrd_create(&th, th_func, &n) != thrd_success) {
       fprintf(stderr, "Error creating thread.\n"); return -1;
    }
    puts("Main thread here ...");

    thrd_join(th, NULL);
    printf("The value of n is %%d\n", n);       // n == 2

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_detach_ex">
			<text>
				<![CDATA[// thrd_detach_ex.c : thrd_detach() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_detach( thrd_t thr);
#include <stdio.h>

void independent_thread(void)
{
    puts("Working independently in the background ... ");
    // . . .
    thrd_exit(0);
}
int create_independent_thread(void)
{
    thrd_t th;
    if( thrd_create(&th, (thrd_start_t)independent_thread, "")
                                              != thrd_success)
      return -1;
    if( thrd_detach(th) != thrd_success)
       return -1;
    puts("Started independent thread.");
    return 0;
}

int main()
{
    create_independent_thread();

    puts("Main thread here ...");

    // Working ...
    struct timespec d = { .tv_nsec = 1E6 };  // 1 ms. 
    thrd_sleep( &d, NULL);

    puts("Main thread done.");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_equal_ex">
			<text>
				<![CDATA[// thrd_equal_ex.c : thrd_equal() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_equal(thrd_t thr1, thrd_t thr2);
#include <stdio.h>

thrd_t mainThrd;

int func(void)
{
    if( thrd_equal( thrd_current(), mainThrd) )
    { puts("Main thread here ...");  return 0; }
    else
    { puts("Other thread here ..."); return 1; }
}

int main()
{
    thrd_t th;

    mainThrd = thrd_current();

    if ( thrd_create(&th, (thrd_start_t)func, NULL) != thrd_success)
    { fprintf(stderr, "Error creating thread.\n"); return -1; }

    func();
    thrd_join(th, NULL);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_timespec_get_ex">
			<text>
				<![CDATA[// timespec_get_ex.c : timespec_get() example
// -------------------------------------------------------------

#include <time.h>   // int timespec_get(struct timespec *ts, int base);
#include <stdio.h>

int main()
{
    struct timespec ts;

    if( timespec_get( &ts, TIME_UTC) != 0)
        printf("The exact local time:\n"
               "%%.24s and %%09lu nanoseconds\n", ctime(&ts.tv_sec), ts.tv_nsec);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tmpfile_ex">
			<text>
				<![CDATA[// tmpfile_ex.c : tmpfile(), tmpfile_s() example
// -------------------------------------------------------------

#include <stdio.h>   // FILE *tmpfile( void );
                     // errno_t tmpfile_s(FILE * restrict * restrict streamPtr);
#include <errno.h>

int main()
{
    FILE *fpTmp, *fpRx;
    int c;

    /* ... open Rx stream ... */
    fpRx = stdin;

    if (( fpTmp = tmpfile() ) == NULL )
    // or
    // if( tmpfile_s( &fpTmp) != 0 )
        fputs( "Unable to open a temporary file.", stderr );
    else
    {
        while (( c = fgetc( fpRx )) != EOF )
            if ( fputc( c, fpTmp ) == EOF )
               break;
    }
    fclose( fpRx );

    /* ... process the data captured in fpTmp ... */

    rewind( fpTmp);
    while( (c = fgetc( fpTmp)) != EOF)
       putchar(c);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tmpnam_ex">
			<text>
				<![CDATA[// tmpnam_ex.c : tmpnam(), tmpnam_s() example
// -------------------------------------------------------------

#include <stdio.h>   // char *tmpnam( char *s );
                     // errno_t tmpnam_s(char *s, rsize_t maxsize);
#include <errno.h>

int main()
{
    char fname[L_tmpnam];
    // or
    // char fname[L_tmpnam_s];
    FILE *fpOut;

    if( tmpnam( fname) == NULL)
    // or
    // if( tmpnam_s( fname, sizeof(fname)) != 0)
    {
        fputs( "Error generating a temporary file name.", stderr );
        return -1;
    }

    fpOut = fopen( fname, "w+" );

    fputs( "... write and edit something in the file ...\n", fpOut );    
    fclose( fpOut );
    printf( "The results have been saved in %%s.\n", fname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_towctrans_ex">
			<text>
				<![CDATA[// towctrans_ex.c : towctrans() example
// -------------------------------------------------------------

#include <wctype.h>  // wint_t towctrans( wint_t wc, wctrans_t desc );
#include <wchar.h>

int main()
{
   wint_t before = L'\0', after = L'\0';
   wctrans_t mapping;
   mapping = wctrans("toupper");

   while (( before = getwchar() ) != WEOF )
   {
       after = towctrans( before, mapping );
       putwchar( after );
       if ( after == L'Q' )
          break;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_trunc_ex">
			<text>
				<![CDATA[// trunc_ex.c : trunc() example
// -------------------------------------------------------------

#include <math.h>    // double trunc( double x );
                     // float truncf( float x );
                     // long double truncl( long double x );
#include <stdio.h>

int main()
{
    printf("trunc(-1.7) = %%.2f  trunc(1.4) = %%.2f  trunc(1.5) = %%.2f\n",
            trunc(-1.7), trunc(1.4), trunc(1.5) );

    printf("round(-1.7) = %%.2f  round(1.4) = %%.2f  round(1.5) = %%.2f\n",
            round(-1.7), round(1.4), round(1.5) );

    return 0;
}
]]>
			</text>
		</p>
		<p n="tss_set_ex">
			<text>
				<![CDATA[// tss_set_ex.c : tss_set() example
// -------------------------------------------------------------

#include <threads.h>  // int tss_set(tss_t *key, void * ptr);
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

tss_t key;               // Global key for a TSS pointer
                         // tss_create(&key, ...) has been called.

typedef char Data_t;

size_t size_data( Data_t *dPtr)
{
    size_t size = strlen( dPtr) + 1;
    return size;
}

// Process some data of some type Data_t:
int process_data(void)   // Use thread-specific storage.
{
    Data_t *ptr = (Data_t*)tss_get(key); // Pointer to TSS

    puts("Process data ...");
    puts( ptr);
    return 0;
}

int thread_func( void* arg)
{
    size_t size = size_data( arg);   // A helper function to find the
                                     // required storage size.
    // Set thread-specific storage:
    if( tss_set(key, malloc(size)) != thrd_success)
       return -1;

    // Store and process data ...
    memcpy( tss_get(key), arg, size);
    return process_data();           // return calls the destructor, if
}                                    // the tss_create() call set one.

void destructor(void *data)
{
    printf("Destructor for %%s\n", (char*)data);
    free(data);                    // Release memory.
}

int main(void)
{
    thrd_t th1, th2;
    int result1 = 0, result2 = 0;

    // Create the TSS key:
    if (tss_create(&key, destructor) != thrd_success)
       return -2;

    // Create threads:
    if ( thrd_create(&th1, thread_func, "Thread_1 ... ")
                                           != thrd_success
         || thrd_create(&th2, thread_func, "... Thread_2 ")
                                           != thrd_success )
       return -3;

    thrd_join( th1, &result1);
    thrd_join( th2, &result2);
    if ( result1 != 0 || result2 != 0)
       fputs("Thread error\n", stderr);
    else
       puts("Threads finished without error.");

    tss_delete(key); // Free all resources of the TSS pointer.
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ungetc_ex">
			<text>
				<![CDATA[// ungetc_ex.c : ungetc() example
// -------------------------------------------------------------

#include <stdio.h>       // int ungetc( int c, FILE *fp );
#include <stdlib.h>
#include <ctype.h>

int main()
{
    char file[ ] = "input.dat";
    FILE *fp;
    int c;
    char numstr[64];

    if (( fp = fopen( file, "r" )) == NULL )
       fprintf( stderr, "Can't read the file %%s\n", file), exit(1);

    while ( (c = getc(fp)) != EOF )
    {
       if ( isdigit(c) )              // Collect a sequence of digits.
       {
          int i = 0;
          do
          {
             numstr[i++] = (char)c;
             c = getc(fp);
          }while ( isdigit(c) && i+1 < sizeof(numstr) );

          numstr[i] = '\0';            // Terminate the numeral string.

          /* ... process the numeral string ... */
          puts( numstr);

          if ( ungetc( c, fp) == EOF)  // Put back the first non-digit.
             break;
          continue;
       }

       /* ... process any non-digit characters ... */
    }
    if ( !feof( fp))
       fprintf( stderr, "Error processing the file %%s\n", file);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_va_arg_ex">
			<text>
				<![CDATA[// va_arg_ex.c : va_arg(), va_copy, va_end(), va_start() example
// -------------------------------------------------------------

#include <stdarg.h>  // void va_start( va_list argptr, last_fixed_arg );
                     // type va_arg( va_list argptr, type );
                     // void va_copy( va_list dest, va_list src );
                     // void va_end( va_list argptr );
#include <stdio.h>
#include <string.h>
#include <math.h>

double vproduct( int n, va_list argptr );
double vsum( int n, va_list argptr );

double vop( const char * op, int argcount, ... );

// main() calls vop() to perform calculations. vop()'s arguments are:
// (1) the name of the operation ("sum", "product",
//     "sum minus the product");
// (2) the number of operands;
// (3 through n) the operands themselves.
// Iterates through operations twice: once with three operands, once
// with six.

int main()
{
    double d1, d2, d3, d4, d5, d6;

    puts( "Enter six floating-point numbers, please:" );
    scanf( "%%lf%%lf%%lf%%lf%%lf%%lf", &d1, &d2, &d3, &d4, &d5, &d6 );

    char *operation[] = {"sum", "product", "product minus the sum",NULL};

    printf("\nUsing the three numbers %%lf, %%lf, and %%lf.\n", d1, d2, d3);
    for ( int i = 0; operation[i] != NULL; i++ )
    {
        printf( "The %%s of these %%d numbers is %%lf\n", 
                 operation[i], 3, vop( operation[i], 3, d1, d2, d3 ) );
    }

    printf( "\nUsing six numbers:"
            "\n\t%%lf \t%%lf \t%%lf \n\t%%lf \t%%lf \t%%lf\n",
            d1, d2, d3, d4, d5, d6 );
    for ( int i = 0; operation[i] != NULL; i++ )
    {
        printf( "The %%s of these %%d numbers is %%lf\n",
                operation[i], 6, 
                vop( operation[i], 6, d1, d2, d3, d4, d5, d6 ) );
    }
}

double vop( const char * op, int argcount, ... )
{
    va_list argptr;
    double result;

    va_start( argptr, argcount );
    if ( strcmp( op, "sum" ) == 0 )
       result = vsum( argcount, argptr );
    else if ( strcmp( op, "product" ) == 0 )
       result = vproduct( argcount, argptr );
    else if ( strcmp( op, "product minus the sum" ) == 0 )
    {
       va_list duplicate_argptr;       // Clone the va_list in its present
                                       // state.
       va_copy( duplicate_argptr, argptr );
       result = vproduct( argcount, argptr )
                - vsum( argcount, duplicate_argptr );
       va_end( duplicate_argptr );     // Clean up the clone.
    }

    else result = NAN;

    va_end( argptr ); // Clean up the original.
    return result;
}

double vproduct( int n, va_list argptr )
{
    double product = 1.0;

    for ( int i = 0; i < n; i ++ )
        product *= va_arg( argptr, double );

    return product;
}

double vsum( int n, va_list argptr )
{
    double sum = 0.0;

    for ( int i = 0; i < n; i ++ )
        sum += va_arg( argptr, double );

    return sum;
}
]]>
			</text>
		</p>
		<p n="xc_vfprintf_ex">
			<text>
				<![CDATA[// vfprintf_ex.c : vfprintf() example
// -------------------------------------------------------------

#include <stdio.h>   
#include <stdarg.h>
// int vfprintf( FILE * restrict fp, const char * restrict format, va_list argptr );
// int vprintf( const char * restrict format, va_list argptr );
// int vsprintf( char * restrict buffer, const char * restrict format,
//               va_list argptr );
// int vsnprintf( char * restrict buffer, size_t n, const char * restrict format, //                va_list argptr );

#include <time.h>

// write_log appends a line to the log file associated with the
// FILE pointer fp_log.
// The format string and optional arguments are the same as for printf().

FILE *fp_log;
 
void write_log(const char *function_name, unsigned int line_num,
               const char *format_str, ...)
{
    if ( fp_log == NULL)
       return;
    time_t timestamp = time(NULL);
    va_list argptr;

    // Set argptr to the first optional argument:
    va_start( argptr, format_str);

    // First print the timestamp, function name, and line number:
    fprintf( fp_log, "%%.8s %%s (line %%u): ",
                     ctime(&timestamp)+11, function_name, line_num);
    // Then print the rest of the message:
    vfprintf( fp_log, format_str, argptr);
}

void myFunc( int param)
{
    write_log( __func__, __LINE__, "param = %%d\n", param);
    /* ... */
}

int main()
{
    fp_log = stderr;
    myFunc( 777);    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_vfscanf_ex">
			<text>
				<![CDATA[// vfscanf_ex.c : vscanf() example
// -------------------------------------------------------------

#include <stdio.h>   
#include <stdarg.h>
// int vfscanf( FILE * restrict fp, const char * restrict format,
//              va_list argptr );
// int vscanf( const char * restrict format, va_list argptr );
// int vsscanf( const char * restrict src, const char * restrict format,
//              va_list argptr );


typedef struct {
    char lastname[20];
    char firstname[20];
    int dob_month;
    int dob_day;
    int dob_year;
} person;

person employee;

int read_person( char *lname, char *fname, ... )
// As variable arguments (...) use NULL
// or three int pointers (month, day, year).
{
    va_list args;
    int count;

    puts( "Enter the last name and first name (Example: Smith, Sally)");
    count = scanf( "%%[^,], %%[^\n]", lname, fname );      // Read the name.

    va_start(args, fname);    // Initialize args to start with the argument
                              // that follows fname in the function call.
    if ( count == 2 && va_arg(args, int*) != NULL )
    {
        va_end( args);
        va_start( args, fname);     // Initialize args again.

        printf( "Enter the date of birth. (Example: 9/21/1962)\n");
        count += vscanf( "%%d/%%d/%%d", args ); // Read date of birth.
    }
#ifdef DEBUG
    fprintf( stderr, "Read %%d fields.\n", count);
#endif // def DEBUG

    va_end( args );
    return count;
}

int main()
{
   person *pEmployee = &employee;
   int result;

   result = read_person( pEmployee->lastname,
                         pEmployee->firstname,
                         &pEmployee->dob_month,
                         &pEmployee->dob_day,
                         &pEmployee->dob_year );
#ifdef DEBUG
    fprintf( stderr, "Fields read: %%s, %%s; born %%d-%%d-%%d\n",
             pEmployee->lastname,
             pEmployee->firstname,
             pEmployee->dob_month,
             pEmployee->dob_day,
             pEmployee->dob_year );
#endif // def DEBUG
}
]]>
			</text>
		</p>
		<p n="xc_wcrtomb_s_ex">
			<text>
				<![CDATA[// wcrtomb_s_ex.c : wcrtomb_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t wcrtomb_s( size_t * restrict retval,
                     //                    char * restrict dest, rsize_t destmax,
                     //                    wchar_t wc, mbstate_t * restrict ps);
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);
    printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

    wchar_t wc = L'\u00b1';     //'±'
    char mbStr[MB_CUR_MAX];
    size_t nBytes = 0;
    mbstate_t state = {0};

    if( wcrtomb_s( &nBytes, mbStr, sizeof(mbStr), wc, &state ) != 0)
    { /* Handle the error ... */
        fputs("Error ...", stderr);  return -1;
    }

    printf("Character: '%%lc'; multibyte code:", wc);     // '±'
    for( unsigned i = 0; i < nBytes; ++i)
        printf(" %%#04x", (unsigned char)mbStr[i]);       // 0xc2 0xb1
    putchar('\n');

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscat_ex">
			<text>
				<![CDATA[// wcscat_ex.c : wcscat(), wcscat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for wcscat_s()

#include <wchar.h>
   // wchar_t *wcscat( wchar_t * restrict s1, const wchar_t * restrict s2 );
   // errno_t wcscat_s( wchar_t * restrict s1, rsize_t s1max,
   //                   const wchar_t * restrict s2);
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    wchar_t  lastname[32];
    wchar_t  firstname[32];
    _Bool    ismale;
} Name;

int main()
{
    Name *newName = calloc( 1, sizeof(Name) );

    /* ... check for calloc failure; read in the name parts ... */
    if( newName == NULL)
    {  fprintf( stderr, "Out of memory\n" ); return -1; }
    *newName = (Name) { L"Lincoln", L"Abraham", 1 };

    // Then display the new name
    wchar_t displayname[80];
    wcscpy( displayname, ( newName->ismale ? L"Mr. " : L"Ms. " ) );
    wcscat( displayname, newName->firstname );
    wcscat( displayname, L" " );
    wcscat( displayname, newName->lastname );
    wcscat( displayname, L"\n" );

    // Better to use wcscat_s() in case the fields in the Name
    // structure are ever enlarged:
    // wcscat_s( displayname, sizeof(displayname), newName->firstname );
    // wcscat_s( displayname, sizeof(displayname), L" " );
    // wcscat_s( displayname, sizeof(displayname), newName->lastname );
    // wcscat_s( displayname, sizeof(displayname), L"\n" );

    fputws( displayname, stdout );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcschr_ex">
			<text>
				<![CDATA[// wcschr_ex.c : wcschr() example
// -------------------------------------------------------------

#include <wchar.h>   // wchar_t *wcschr( const wchar_t *s, wchar_t c );
#include <stdio.h>
#include <stdlib.h>

typedef struct { wchar_t street[32];
                 wchar_t city[32];
                 wchar_t stateprovince[32];
                 wchar_t zip[16];
               } Address;

wchar_t printaddr[128] = L"720 S. Michigan Ave.\nChicago, IL 60605\n";

int main()
{
    int sublength;
    Address *newAddr = calloc( 1, sizeof(Address) );

    if ( newAddr != NULL )
    {
        sublength = wcschr( printaddr, L'\n' ) - printaddr;
        wcsncpy( newAddr->street, printaddr,
                 (sublength < 31 ? sublength : 31) );
        /* ... */
        fputws( newAddr->street, stdout );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscmp_ex">
			<text>
				<![CDATA[// wcscmp_ex.c : wcscmp() example
// -------------------------------------------------------------

#include <wchar.h>   // int wcscmp( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>

int main()
{
    int result = 0;
    wchar_t word1[255]=L"X1", word2[256] = L"X2", *greaterlessequal;

    while ( result < 2 )
    {
        fputws( L"Type two words, please: ", stdout );
        result = wscanf( L"%%255ls %%255ls", word1, word2 );
        if ( result == EOF )
           return EOF;
    }
    result = wcscmp( word1, word2 );

    if ( result < 0 )
       greaterlessequal = L"less than";
    else if ( result > 0 )
       greaterlessequal = L"greater than";
    else
       greaterlessequal = L"the same as";

    wprintf( L"The word \"%%ls\" is %%ls the word \"%%ls\".\n", 
             word1, greaterlessequal, word2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscoll_ex">
			<text>
				<![CDATA[// wcscoll_ex.c : wcscoll() example
// -------------------------------------------------------------

#include <wchar.h>  // int wcscoll( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>
#include <locale.h>

int main()
{
    wchar_t *samples[ ] = { L"anejo", L"añeja",};

    setlocale( LC_COLLATE, "es_US.UTF-8" );
    
    int result = wcscoll( samples[0], samples[1] );

    wprintf( L"In the locale %%s, ", setlocale( LC_COLLATE, NULL ));

    if ( result == 0 )
        wprintf( L"the wide strings \"%%ls\" and \"%%ls\" are alphabetically "
                 "equivalent.\n", samples[0], samples[1] );
    else if ( result < 0 )
        wprintf( L"the wide string \"%%ls\" precedes \"%%ls\" "
                 "alphabetically.\n", samples[0], samples[1] );
    else if ( result > 0 )
        wprintf( L"the wide string \"%%ls\" comes after \"%%ls\" "
                 "alphabetically.\n", samples[0], samples[1] );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscpy_ex">
			<text>
				<![CDATA[// wcscpy_ex.c : wcscpy(), wcscpy_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for wcscpy_s()

#include <wchar.h>  // wchar_t *wcscpy(wchar_t * restrict dest,
                    //                 const wchar_t * restrict src);
                    // errno_t wcscpy_s(wchar_t * restrict dest,
                    //                  rsize_t destmax,
                    //                  const wchar_t * restrict src);
#include <stdio.h>

int main()
{
    struct record {
      wchar_t name[64];
      int age;
      _Bool male, smoking, discount;
    } this;
    int results;

    wprintf( L"Last name: " );
    results = wscanf( L"%%63l[^\n]", this.name );

    if ( results < 1 )
        wcscpy( this.name, L"[Name not available]" );
    // or:
    // wcscpy_s( this.name, sizeof(this.name)/sizeof(wchar_t),
    //           L"[Name not available]" );

    wprintf( L"%%ls\n", this.name );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscspn_ex">
			<text>
				<![CDATA[// wcscspn_ex.c : wcscspn() example
// -------------------------------------------------------------

#include <wchar.h>  // size_t wcscspn( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t *path = L"/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games";
    int separator;

    wchar_t *basename = L"aprogram";
    wchar_t fullname[1024] = L"";

    separator = wcscspn( path, L":" );  // Obtain the index of the first colon.

    wcsncpy( fullname, path, separator );
    fullname[separator] = '\0';

    wcsncat( fullname, L"/", sizeof(fullname) - wcslen(fullname) -1 );
    wcsncat( fullname, basename, sizeof(fullname) - wcslen(fullname) -1 );

    fputws( fullname, stdout );

    return 0;
}
]]>
			</text>
		</p>
		<p n="ex_wcsftime_ex">
			<text>
				<![CDATA[// wcsftime_ex.c : wcsftime() example
// -------------------------------------------------------------

#include <time.h>   // size_t wcsftime( wchar_t * restrict s, size_t n,
#include <wchar.h>  //                  const wchar_t * restrict format,
                    //                  const struct tm * restrict timeptr );
#include <stdio.h>

#define MAX_HDR 1024

int main()
{
    time_t now;
    struct tm *localnow;
    wchar_t hdr_date[MAX_HDR] = L"";

    time( &now );
    localnow = localtime( &now );

    if( wcsftime( hdr_date, MAX_HDR, L"Date: %%a, %%d %%b %%Y %%T %%z", localnow))
       fputws( hdr_date, stdout );
    else
       return -1;

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcslen_ex">
			<text>
				<![CDATA[// wcslen_ex.c : wcslen() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcslen( const wchar_t *s );

int main()
{
    wchar_t line[1024] =
            L"This string could easily be 400 or 500 characters long. "
            L"This string could easily be 400 or 500 characters long. "
            L"\n";
    wchar_t *readptr = line;

    int columns = 80;
    while( wcslen( readptr ) > columns)  // While remaining text is too long,
    {                                    // print a chunk with a final
       wprintf(L"%%.*ls\\\n", columns-1, readptr);  // backslash and newline.
       readptr += columns -1;
    }
    wprintf( L"%%ls\n", readptr);     // Print the rest, ending with a newline.

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsncmp_ex">
			<text>
				<![CDATA[// wcsncmp_ex.c : wcsncmp() example
// -------------------------------------------------------------

#include <wchar.h>   // int wcsncmp( const wchar_t *s1,
                     //              const wchar_t *s2, size_t n );

int main()
{
    wchar_t *months[] = { L"January", L"February", L"March", L"April",
                          L"May", L"June", L"July", L"August",
                          L"September", L"October", L"November", L"December"};

    wchar_t date[ ] = L"Thu, 10 Mar 2005 13:44:18 +0100";
    int mo = 0;
    while (( mo < 12 ) && ( wcsncmp( date + 8, months[mo], 3 ) != 0 ))
        mo++;

    if( mo < 12)
       wprintf( L"Month: %%ls\n", months[mo] ); 

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcspbrk_ex">
			<text>
				<![CDATA[// wcspbrk_ex.c : wcspbrk() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wcspbrk( const wchar_t *s1,
                       //                   const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t *story = L"He shouted: \"What? I can't hear you!\"\n";
    wchar_t separators[ ] = L" \t\n.:?!\"";
    wchar_t *start = story, *end = NULL;
    wchar_t words[16][16];   // An array of wchar_t arrays to collect words in. 
    int i = 0;

    while ( i < 16 && ( end = wcspbrk( start, separators ) ) != NULL )
    {
      if ( end != start )             // If the separator wasn't the first
      {                               // character in the substring,
         wcsncpy( words[i], start, end - start );  // then save a word.
         words[i][end - start] = L'\0';            // And terminate it.
         i++;
      }
      start = end + 1;                // Next wcspbrk call starts with the
    }                                 // character after this separator.

    fputws( story, stdout );

    for ( int j = 0 ; j < i ; j++ )
    {
       fputws( words[j], stdout );
       fputwc( L'\n', stdout );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsrchr_ex">
			<text>
				<![CDATA[// wcsrchr_ex.c : wcsrchr() example
// -------------------------------------------------------------

#include <wchar.h>  // wchar_t *wcsrchr( const wchar_t *s, wchar_t wc );
#include <stdlib.h>

int main( int argc, char ** argv )
{
    wchar_t wmyname[256];

    size_t result = mbstowcs( wmyname, argv[0], 256 );
    if ( result == -1 )
       return -1;

    wchar_t *mybasename = wcsrchr( wmyname, L'/' ); // End of path
    if ( mybasename != NULL )
      mybasename++;
    else
      mybasename = wmyname;

    wprintf( L"This program was invoked as %%ls.\n", mybasename );
}
]]>
			</text>
		</p>
		<p n="xc_wcsrtombs_ex">
			<text>
				<![CDATA[// wcsrtombs_ex.c : wcsrtombs() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcsrtombs( char * restrict dest,
                     //                   const wchar_t **restrict src,
                     //                   size_t n, 
                     //                   mbstate_t * restrict state );
#include <string.h>
#include <locale.h>
#include <stdio.h>

int main()
{
    int i = 0, n = 0;
    size_t result;
    wchar_t wc;
    char mbstring[256] = { '\0' };

    wchar_t widestring[]
            = L"This is originally a string of wide characters.";
    const wchar_t *wcsptr = widestring;
    mbstate_t state;

    printf( "The current locale is %%s.\n", setlocale(LC_CTYPE, "") );

    memset( &state, '\0', sizeof state );
    result = wcsrtombs( mbstring, &wcsptr, 256, &state );

    printf("The return value: %%d\n", (int)result );
    if( result > 0 && wcsptr == NULL )
       printf("The multibyte string: \"%%s\"\n", mbstring);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsrtombs_s_ex">
			<text>
				<![CDATA[// wcsrtombs_s_ex.c : wcsrtombs_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t wcsrtombs_s(size_t * restrict retval,
                     //                     char * restrict dest, 
                     //                     rsize_t destmax,
                     //                     const wchar_t ** restrict src,
                     //                     rsize_t n,
                     //                     mbstate_t * restrict state);
#include <locale.h>
#include <stdio.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);

    wchar_t widestr[] = L"A wide-character string ...";
    const wchar_t *wcptr = widestr;     // A pointer to a wide character.
    char mbstr[100] = "";               // For the multibyte string.
    size_t mblen = 0;
    mbstate_t mbstate = {0};            // Conversion state.

    if( wcsrtombs_s( &mblen, mbstr, sizeof(mbstr),
                     &wcptr, 3, &mbstate) == 0)
    {
        printf("Multibyte length: %%zu; character codes: [", mblen);
        for( size_t i = 0; i < mblen; ++i)
            printf(" %%X", (unsigned char)mbstr[i]);
        puts(" ]");

        if( wcptr != NULL)
            printf("Wide characters remaining: \"%%ls\"\n", wcptr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsspn_ex">
			<text>
				<![CDATA[// wcsspn_ex.c : wcsspn() example
// -------------------------------------------------------------

#include <wchar.h>     // size_t wcsspn( const wchar_t *s1,
                       //                const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t wordin[256];
    double val;

    fputws( L"Enter a floating-point number, please: ", stdout );
    wscanf( L"%%ls", wordin );

    int index = wcsspn( wordin, L"+-0123456789eE." );
    if ( index < wcslen( wordin ) )
       wprintf ( L"Sorry, but the character %%lc is not permitted.\n",
                 wordin[index] );
    else
    {
       swscanf( wordin, L"%%lg", &val );
       wprintf( L"You entered the value %%g\n", val );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsstr_ex">
			<text>
				<![CDATA[// wcsstr_ex.c : wcsstr() example
// -------------------------------------------------------------

#include <wchar.h>     // size_t wcsstr( const wchar_t *s1,
                       //                const wchar_t *s2 );
#include <stdlib.h>
#include <stdio.h>

#define MAX_LINE 1024

int main( int argc, char **argv )
{
    FILE *fpIn = NULL;
    wchar_t keyword[MAX_LINE] = { L'\0' };
    wchar_t line[MAX_LINE] = { L'\0' };

    if ( argc != 3 )
    {
        wprintf( L"Syntax: %%s <keyword> <filename>\n", argv[0] );
        return -1;
    }

    if (( fpIn = fopen( argv[2], "r" )) == NULL )
       return -2;
    else
       fwide( fpIn, 1 );

    if ( mbstowcs( keyword, argv[1], MAX_LINE ) == -1 )
       return -3;

    int count = 0;
    while ( fgetws( line, MAX_LINE, fpIn ) != NULL )
       if ( wcsstr( line, keyword ) != NULL )
       {
           ++count;
           fputws( line, stdout );
       }

    if ( !feof( fpIn ))
       return -4;
    else
       return count;
}
]]>
			</text>
		</p>
		<p n="xc_wcstod_ex">
			<text>
				<![CDATA[// wcstod_ex.c : wcstod() example
// -------------------------------------------------------------

#include <wchar.h>     // double wcstod( const wchar_t * restrict wcs,
                       //                wchar_t ** restrict endptr );
                       // float wcstof( const wchar_t * restrict wcs,
                       //               wchar_t ** restrict endptr ); 
                       // long double wcstold( const wchar_t * restrict wcs,
                       //                      wchar_t ** restrict endptr );
#include <stdio.h>

int main()
{
    wchar_t in[1024], *this = in, *next = in;
    double val;

    fputws( L"Enter some floating-point numbers, please:\n", stdout );
    wscanf( L"%%l[^\n]", in );

    fputws( L"Here are the values you entered:\n", stdout );
    while ( 1 )
    {
        val = wcstod( this, &next );
        if ( next == this )           // Means no conversion possible.
            break ;
        this = next;
        wprintf( L"\t%%g\n", val );
    }
    fputws( L"Done.\n", stdout );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstok_ex">
			<text>
				<![CDATA[// wcstok_ex.c : wcstok() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wcstok( wchar_t * restrict s1, 
                       //                  const wchar_t * restrict s2,
                       //                  wchar_t ** restrict ptr );

int main()
{
    wchar_t *mnemonic, *arg1, *arg2, *comment, *ptr;
    wchar_t line[ ] = L" mul eax,[ebp+4] ; Multiply by y\n";

    // First word between spaces or tabs
    mnemonic = wcstok( line, L" \t", &ptr );
    arg1 = wcstok( NULL, L",", &ptr );    // From there to the comma is arg1.
                                          // Trim off any spaces later.
    arg2 = wcstok( NULL, L";\n", &ptr );  // From there to the semicolon is
                                          // arg2.
    // To line or page end is comment:
    comment = wcstok( NULL, L"\n\r\v\f", &ptr );

    wprintf( L"Mnemonic:     %%ls\n"
             L"1st argument: %%ls\n"
             L"2nd argument: %%ls\n"
             L"Comment:      %%ls\n\n",
             mnemonic, arg1, arg2, comment );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstol_ex">
			<text>
				<![CDATA[// wcstol_ex.c : wcstol(), wcstoll() example
// -------------------------------------------------------------

#include <wchar.h>     // long int wcstol( const wchar_t * restrict wcs,
                       //                  wchar_t ** restrict endptr, int base );
                       // long long int wcstoll( const wchar_t * restrict wcs,
                       //                        wchar_t ** restrict endptr, 
                       //                        int base );

int main()
{
    wchar_t date[ ] = L"10/3/2005, 13:44:18 +0100", *more = date;
    long day, mo, yr, hr, min, sec, tzone;

    day = wcstol( more, &more, 10 ); // &more is the address of a
    mo  = wcstol( more+1, &more, 10 ); // pointer
    yr  = wcstol( more+1, &more, 10 );
    hr  = wcstol( more+1, &more, 10 );
    min = wcstol( more+1, &more, 10 );
    sec = wcstol( more+1, &more, 10 );
    tzone = wcstol( more+1, &more, 10 );

    wprintf( L"It's now %%02ld:%%02ld o'clock on %%02ld-%%02ld-%%02ld.\n",
             hr, min, mo, day, yr %% 100 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstombs_ex">
			<text>
				<![CDATA[// wcstombs_ex.c : wcstombs() example
// -------------------------------------------------------------

#include <stdlib.h>   // size_t wcstombs( char * restrict dest, 
                      //                  const wchar_t * restrict src,
                      //                  size_t n );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);

    wchar_t fmt_amount[128] = { L'\0' };
    wchar_t prefix[32]  = L"-";
    wchar_t suffix[32]  = L"€";
    wchar_t number[128] = L"123.456,78";
    char output_amount[256];

    wcscpy( fmt_amount, prefix );
    wcscat( fmt_amount, number );
    wcscat( fmt_amount, suffix );

    if ( -1 != wcstombs( output_amount, fmt_amount, 256 ))
        printf( "Full amount: %%s\n", output_amount );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstoumax_ex">
			<text>
				<![CDATA[// wcstoumax_ex.c : wcstoumax() example
// -------------------------------------------------------------

#include <stddef.h>
#include <inttypes.h>  // uintmax_t wcstoumax( const wchar_t * restrict wcs,
                       //                      wchar_t ** restrict endptr, int base );
#include <wchar.h>

typedef struct {
    uintmax_t packets, bytes;
    wchar_t policy[16];
    wchar_t protocol[6];
    /* ... */
} stats_t ;

int main()
{
    stats_t iface_in = {0};
    wchar_t wcsstat[] =
            L"25183 1633438 ACCEPT tcp -- eth2 * 0.0.0.0/0 tcp dpts:80";
    wchar_t *wcsptr = wcsstat;

    iface_in.packets = wcstoumax( wcsptr, &wcsptr, 10 );
    iface_in.bytes = wcstoumax( ++wcsptr, &wcsptr, 10 );
    /* ... */

    wprintf( L"Packets: %%" PRIuMAX "; bytes: %%" PRIuMAX "; policy: ...\n",
             iface_in.packets, iface_in.bytes );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsxfrm_ex">
			<text>
				<![CDATA[// wcsxfrm_ex.c : wcsxfrm() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcsxfrm( wchar_t * restrict dest, 
                     //                 const wchar_t * restrict src,
                     //                 size_t n );
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

typedef struct stringpair { wchar_t * original;
                            wchar_t * xformed;
                          } Stringpair_t ;

int stringpaircmp( const void *p1, const void *p2 );

int main()
{
    wchar_t *originals[] = { L"Chávez", L"Carron", L"Canoso",
                             L"Cañoso", L"Carteño", L"Corriando",
                             L"Carilo", L"Carillón", };
    wchar_t xformbuffer[1024];

    /* Make an array of structures out of the strings and their
       xformations */

    const int elementcount = sizeof(originals) / sizeof(wchar_t *);
    Stringpair_t stringpairs[elementcount];

    setlocale( LC_ALL, "es_US.UTF-8" );   // Set the locale to US Spanish
    wprintf( L"Sorting order in the locale %%s:\n",
             setlocale( LC_COLLATE, NULL ));

    for ( int i = 0; i < elementcount ; i++ )
    {
        stringpairs[i].original = originals[i];
        stringpairs[i].xformed
                    = malloc( wcsxfrm( xformbuffer, originals[i], 1024 ));
        if ( stringpairs[i].xformed != NULL )
           wcscpy( stringpairs[i].xformed, xformbuffer );
    }

    qsort( stringpairs, elementcount,
           sizeof(Stringpair_t), stringpaircmp );

    for ( int i = 0; i < elementcount ; i++ )
    {
        fputws( stringpairs[i].original, stdout );
        fputwc( L'\n', stdout );
    }
} // end of main()

/* A comparison function for use by qsort. Uses wcscmp() rather
 * that wcscoll(), assuming strings are paired with their wcsxfrm()
 * results in a Stringpair_t structure.
*/
int stringpaircmp( const void *p1, const void *p2 )
{
    const Stringpair_t * sp1 = (Stringpair_t *)p1;
    const Stringpair_t * sp2 = (Stringpair_t *)p2;

    return wcscmp( sp1->xformed, sp2->xformed );
}
]]>
			</text>
		</p>
		<p n="xc_wctomb_ex">
			<text>
				<![CDATA[// wctomb_ex.c : wctomb() example
// -------------------------------------------------------------

#include <stdlib.h>   // int wctomb( char *s, wchar_t wc );
#include <wchar.h>
#include <stdio.h>
#include <limits.h>
#include <locale.h>

int main()
{
    char mbbuffer[MB_LEN_MAX] = { '\0' };
    wchar_t wcs[] = L"Wir stehen auf den Füßen von Riesen";
    int n = 0, i = 0;

    printf( "The current locale is %%s.\n", setlocale( LC_CTYPE, "" ));
    printf( "The locale's multibyte encoding is %%s.\n",
             (wctomb( NULL, L'\0' ) ? "stateful" : "stateless" ));

    do {
        n += wctomb( mbbuffer, wcs[i] );
    } while ( wcs[i++] != L'\0' );

    printf( "The wide string \"%%ls\" \nis %%u wide characters long.\n"
            "Its multibyte representation requires a buffer of %%u bytes.\n",
            wcs, wcslen( wcs ), n );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wctomb_s_ex">
			<text>
				<![CDATA[// wctomb_s_ex.c : wctomb_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1         // For wctomb_s()

#include <stdlib.h>   // errno_t wctomb_s( int * restrict status,
                      //                   char * restrict s,
                      //                   rsize_t smax, 
                      //                   wchar_t wc);
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    setlocale(LC_ALL, "en_US.utf8");

    wchar_t wc = L'\u03B1';       // Greek lowercase alpha α
    char mbStr[MB_CUR_MAX];
    int nBytes = 0;

    // if( (nBytes = wctomb( mbStr, wc )) < 0)
    // is equivalent to
    if( wctomb_s( &nBytes, mbStr, sizeof(mbStr), wc ) != 0)
    { /* error: */ return -1; }

    printf("Wide-character code: %%#06x; character: '%%lc'; "
           "multibyte code:", wc, wc);
    for( int i = 0; i < nBytes; ++i)
        printf(" %%#04x", (unsigned char)mbStr[i]);
    putchar('\n');

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wctype_ex">
			<text>
				<![CDATA[// wctype_ex.c : wctype() example
// -------------------------------------------------------------

#include <wctype.h>   // wctype_t wctype( const char *property );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wctype_t wct_kanji, wct_kata, wct_hira  /* , ... */ ;

    if ( setlocale( LC_CTYPE, "ja_JP.UTF-8" ) == NULL)
        fputws(L"Unable to set the locale.\n", stderr);

    if (( wct_kata = wctype( "jkata" ) ) == 0 )
    {   wprintf( L"The locale doesn't support the wide-character type "
                  "string \"jkata\".\n" ); 
        return -1;
    }
    /* ... */
    wchar_t wc = fgetwc( stdin );
    if ( iswctype( wc, wct_kata ) )          // Mainly 0xFF66 − 0xFF9F.
        wprintf( L"%%lc is a katakana character.\n", wc );
    else
        wprintf( L"%%lc is a not katakana character.\n", wc );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wmemcpy_ex">
			<text>
				<![CDATA[// wmemcpy_ex.c : wmemcpy(), wmemcpy_s() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wmemcpy( wchar_t * restrict dest, 
                       //                   const wchar_t * restrict src,
                       //                   size_t n );
                       // errno_t wmemcpy_s( wchar_t * restrict dest, rsize_t destmax,
                       //                    const wchar_t * restrict src, 
                       //                    rsize_t n);
#include <stdio.h>
#include <stdlib.h>

#define BUFFERSIZE 2048     // Size as a number of wchar_t elements.

wchar_t inputbuffer[BUFFERSIZE] = { L'\0' },
        *writeptr = inputbuffer;

struct block { wchar_t *text;
               struct block *next;
               struct block *prev;
             } firstblock = { NULL },  // The first block is the list head.
               *tmp = NULL;

struct block *newblock( struct block *lastblock );
                                           // Creates a linked-list member.
wchar_t *storetext( struct block *listhead,
                    wchar_t *buffer,
                    size_t bufsize );
                         // Copies input buffer to a new linked-list member.

int main()
{
    while( fgetws( writeptr, BUFFERSIZE - (writeptr - inputbuffer), stdin)
           != NULL )
    {
       // Set writeptr to end of the input string:
       writeptr = wmemchr( inputbuffer, L'\0',
                           sizeof(inputbuffer) / sizeof(wchar_t) );

       if ( BUFFERSIZE - (writeptr - inputbuffer) < 80 )
                                            // If block full, or nearly so:
       {                                    // copy buffer to a data block.
           writeptr = storetext( &firstblock, inputbuffer, BUFFERSIZE );
           if ( writeptr == NULL )          // Out of memory!
              abort();
       }
    }    // Here if fgetws() returns NULL.

    writeptr = storetext( &firstblock, inputbuffer, BUFFERSIZE );
    if ( writeptr == NULL )                 // Out of memory!
       abort();
}

// ----------------------------
wchar_t *storetext(struct block *listhead,
                   wchar_t *buffer, size_t bufsize)
    // Copies input buffer to a new chained-list member;
    // returns pointer to input buffer, or NULL on failure.
{
    struct block *tmp = listhead;     // create new block on end of list ...
    while ( tmp->next != NULL )
       tmp = tmp->next;
    if (( tmp = newblock( tmp )) != NULL )
       wmemcpy( tmp->text, buffer, bufsize );     // ... and copy the text.
    // Or:
    // wmemcpy_s( tmp->text, BUFFERSIZE, buffer, bufsize );
    else            // Out of memory!
       return NULL;

#ifdef DEBUG
    fwprintf( stderr, L"\nStored a block with this text:\n%%ls\n",
              tmp->text );
#endif

    return buffer;     // Return pointer to buffer, now ready for re-use.
}

// ----------------------------
struct block *newblock( struct block *lastblock )
   // Allocates a new block and appends it to the chained list;
   // returns pointer to new block, or NULL on failure.
{
   if (( lastblock->next = malloc( sizeof(struct block) )) != NULL
         && ( lastblock->next->text
                 = malloc( BUFFERSIZE * sizeof(wchar_t) )) != NULL)
   {
      lastblock->next->prev = lastblock;
      lastblock->next->next = NULL;
      return lastblock->next;
   }
   else            // Out of memory!
      return NULL;
}
]]>
			</text>
		</p>
		<p n="xc_wscanf_ex">
			<text>
				<![CDATA[// wscanf_ex.c : wscanf() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>
    // int wscanf( const wchar_t * restrict format, ... );
    // int wscanf_s( const wchar_t * restrict format, ... );

int main()
{
    wchar_t perms[12];
    wchar_t name[256];
    unsigned int ownerid, groupid, links;
    unsigned long size;
    int count;

    count = wscanf( L"%%11l[rwxsStTld-+]%%u%%u%%u%%lu%%*10s%%*5s%%256ls",
                    perms, &links, &ownerid, &groupid, &size, name );

wprintf(L"%%ls %%u %%u %%u %%lu %%ls\n", 
         perms, links, ownerid, groupid, size, name );
    wprintf( L"\nThe file %%ls has a length of %%lu bytes.\n", name, size );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_circle">
			<text>
				<![CDATA[// circle.c: Calculate the areas of circles and
// print them in ncurses mode
// $ gcc -o circle  circle.c -lncurses

#include <curses.h>               // Console control functions
double circularArea( double r );  // Function for the math
void circle();                    // Function for output

int main()        // Starts and stops curses display mode
{

/* Set up the console behavior: */
    (void) initscr();      // Initialize the curses system
    keypad(stdscr, TRUE);  // Enable keyboard mapping
    (void) nonl();         // Disable line-end translation
    (void) cbreak();       // Take single input characters

/* Run the circle routine: */
    circle(); 
    printw( "Press any key to exit." );
    refresh();             // Put the output on the screen

/* Finish: */
    getch();               // Wait for user to press a key
    endwin();              // Shut down curses console
    return 0;
}

// The circle.c program from Example 1.1, but replacing the
// standard library function printf() with printw() from the
// ncurses library.
void circle()
{
  double radius = 1.0, area = 0.0;
  printw("    Areas of Circles\n\n" );
  printw("     Radius          Area\n"
          "-------------------------\n" );
  area = circularArea( radius );
  printw( "%%10.1f     %%10.2f\n", radius, area ); 
  radius = 5.0;
  area = circularArea( radius );
  printw( "%%10.1f     %%10.2f\n", radius, area ); 
}

// Return the area of a circle with radius r
double circularArea( double r )
{
  const double pi = 3.1415926536; // Pi is a constant 
  return  pi * r * r;
}
]]>
			</text>
		</p>
		<p n="xlnx_epoll">
			<text>
				<![CDATA[/***************************************** 

* File Name : epoll.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : https://suchprogramming.com/epoll-in-3-easy-steps/

******************************************/

/**
 *  Purpose:
 *
 */

#define MAX_EVENTS 5
#define READ_SIZE 10
#include <stdio.h>     // for fprintf()
#include <unistd.h>    // for close(), read()
#include <sys/epoll.h> // for epoll_create1(), epoll_ctl(), struct epoll_event
#include <string.h>    // for strncmp

int main()
{
  int running = 1, event_count, i;
  size_t bytes_read;
  char read_buffer[READ_SIZE + 1];
  struct epoll_event event;
  struct epoll_event events[MAX_EVENTS];
  int epoll_fd = epoll_create1(0);

  if(epoll_fd == -1)
  {
    fprintf(stderr, "Failed to create epoll file descriptor\n");
    return 1;
  }

  event.events = EPOLLIN;
  event.data.fd = 0;

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, 0, &event))
  {
    fprintf(stderr, "Failed to add file descriptor to epoll\n");
    close(epoll_fd);
    return 1;
  }

  while(running)
  {
    printf("\nPolling for input...\n");
    event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, 30000);
    printf("%%d ready events\n", event_count);
    for(i = 0; i < event_count; i++)
    {
      printf("Reading file descriptor '%%d' -- ", events[i].data.fd);
      bytes_read = read(events[i].data.fd, read_buffer, READ_SIZE);
      printf("%%zd bytes read.\n", bytes_read);
      read_buffer[bytes_read] = '\0';
      printf("Read '%%s'\n", read_buffer);

      if(!strncmp(read_buffer, "stop\n", 5))
        running = 0;
    }
  }


  if(close(epoll_fd))
  {
    fprintf(stderr, "Failed to close epoll file descriptor\n");
    return 1;
  }
  return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_mmap">
			<text>
				<![CDATA[/***************************************** 

* File Name : mmap.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>

/**
 * ******************************************************
 * 
void * realloc (void *addr, size_t len)
{
        size_t old_size = look_up_mapping_size (addr);
        void *p;

        p = mremap (addr, old_size, len, MREMAP_MAYMOVE);
        if (p == MAP_FAILED)
                return NULL;
        return p;
}
 * ******************************************************
**/


/**
 * ******************************************************
 * #include <sys/mman.h>

int mprotect (const void *addr,
              size_t len,
              int prot);
 * ******************************************************
**/

/**
 * ******************************************************
 * #include <sys/mman.h>

int msync (void *addr, size_t len, int flags);
 * ******************************************************
**/


/**
 * ******************************************************
 * The only unfamiliar system call in this example should be 
 * fstat(), which we will cover in Chapter 8. All you need to
 * know at this point is that fstat() returns information 
 * about a given file. 
 *
 * The S_ISREG() macro can check some 
 * of this information so that we can ensure that the given
 * file is a regular file (as opposed to a device file or a 
 * directory) before we map it. 
 *
 * The behavior of nonregular
 * files when mapped depends on the backing device.
 * Some device files are mmap-able; other nonregular files 
 * are not mmap-able and will set errno to EACCES.
 *
 * The rest of the example should be straightforward. The program is
 * passed a filename as an argument. It opens the file, ensures 
 * it is a regular file, maps it, closes it, prints the file 
 * byte-by-byte to standard out, and then unmaps the file from memory.
 * ******************************************************
**/
int main (int argc, char *argv[])
{
        struct stat sb;
        off_t len;
        char *p;
        int fd;

        if (argc < 2) {
                fprintf (stderr, "usage: %%s <file>\n", argv[0]);
                return 1;
        }

        fd = open (argv[1], O_RDONLY);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        if (fstat (fd, &sb) == -1) {
                perror ("fstat");
                return 1;
        }

        if (!S_ISREG (sb.st_mode)) {
                fprintf (stderr, "%%s is not a file\n", argv[1]);
                return 1;
        }

        p = mmap (0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
        if (p == MAP_FAILED) {
                perror ("mmap");
                return 1;
        }

        if (close (fd) == -1) {
                perror ("close");
                return 1;
        }

        for (len = 0; len < sb.st_size; len++)
                putchar (p[len]);

        if (munmap (p, sb.st_size) == -1) {
                perror ("munmap");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_readv">
			<text>
				<![CDATA[/***************************************** 

* File Name : readv.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/uio.h>

int main ()
{
        char foo[48], bar[51], baz[49];
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        fd = open ("buccaneer.txt", O_RDONLY);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        /* set up our iovec structures */
        iov[0].iov_base = foo;
        iov[0].iov_len = sizeof (foo);
        iov[1].iov_base = bar;
        iov[1].iov_len = sizeof (bar);
        iov[2].iov_base = baz;
        iov[2].iov_len = sizeof (baz);

        /* read into the structures with a single call */
        nr = readv (fd, iov, 3);
        if (nr == -1) {
                perror ("readv");
                return 1;
        }

        for (i = 0; i < 3; i++)
                printf ("%%d: %%s", i, (char *) iov[i].iov_base);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_writev">
			<text>
				<![CDATA[/***************************************** 

* File Name : writev.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/uio.h>

int main ()
{
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        char *buf[] = {
                "The term buccaneer comes from the word boucan.\n",
                "A boucan is a wooden frame used for cooking meat.\n",
                "Buccaneer is the West Indies name for a pirate.\n" };

        fd = open ("buccaneer.txt", O_WRONLY | O_CREAT | O_TRUNC);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        /* fill out three iovec structures */
        for (i = 0; i < 3; i++) {
                iov[i].iov_base = buf[i];
                iov[i].iov_len = strlen(buf[i]) + 1;
        }
        /* with a single call, write them all out */
        nr = writev (fd, iov, 3);
        if (nr == -1) {
                perror ("writev");
                return 1;
        }
        printf ("wrote %%d bytes\n", (int)nr);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_processor_affinity">
			<text>
				<![CDATA[/***************************************** 

* File Name : processor_affinity.c

* Creation Date : 18-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#define _GNU_SOURCE

#include <sched.h>
#include <error.h>
#include <stdio.h>

#if 0
typedef struct cpu_set_t;

size_t CPU_SETSIZE;

void CPU_SET (unsigned long cpu, cpu_set_t *set);
void CPU_CLR (unsigned long cpu, cpu_set_t *set);
int CPU_ISSET (unsigned long cpu, cpu_set_t *set);
void CPU_ZERO (cpu_set_t *set);

int sched_setaffinity (pid_t pid, size_t setsize,
                       const cpu_set_t *set);

int sched_getaffinity (pid_t pid, size_t setsize,
                       cpu_set_t *set);
#endif


/**
 * ******************************************************
 *  Checks if the cpu is set
 * ******************************************************
**/
void check_set_processors() {
    cpu_set_t set;
    int ret, i;

    CPU_ZERO (&set);
    ret = sched_getaffinity (0, sizeof (cpu_set_t), &set);
    if (ret == -1)
            perror ("sched_getaffinity");

    for (i = 0; i < 8 /*nr of cores*/; i++) {
            int cpu;

            cpu = CPU_ISSET (i, &set);
            printf ("cpu=%%i is %%s\n", i,
                    cpu ? "set" : "unset");
    }
}

/**
 * ******************************************************
 *  Set the hard affinity for the process
 * ******************************************************
**/
void set_hard_affinity() {
    cpu_set_t set;
    int ret, i;

    CPU_ZERO (&set);        /* clear all CPUs */
    CPU_SET (0, &set);      /* allow CPU #0 */
    //CPU_CLR (1, &set);      /* disallow CPU #1 */
                              /* clearing is not necessary */
    ret = sched_setaffinity (0, sizeof (cpu_set_t), &set);
    if (ret == -1)
            perror ("sched_setaffinity");

    for (i = 0; i < 8 /*nr of cores*/; i++) {
            int cpu;

            cpu = CPU_ISSET (i, &set);
            printf ("cpu=%%i is %%s\n", i,
                    cpu ? "set" : "unset");
    }
}

int main(int argc, char ** argv) {
    check_set_processors();
    set_hard_affinity();
}
]]>
			</text>
		</p>
		<p n="xlnx_scheduling">
			<text>
				<![CDATA[/***************************************** 

* File Name : scheduling.c

* Creation Date : 18-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <sched.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>



void wrapper_sched_yield() {
    while(1) {
        sched_yield();
    }
}

/**
 * ******************************************************
 *  Sets the processor niceness:
 *  -20 to 19
 * ******************************************************
**/
void wrapper_nice() {
    int ret, val;

    /* get current nice value */
    val = nice (0);

    /* we want a nice value of 10 */
    val = 10 - val;
    errno = 0;
    ret = nice (val);
    if (ret == -1 && errno != 0)
            perror ("nice");
    else
            printf ("nice value is now %%d\n", ret);
}

/**
 * ******************************************************
 *  which: PRIO_PROCESS
 *         PRIO_PGRP
 *         PRIO_USER
 *
 *  who: PID
 *       0 means current process, group or user
 * ******************************************************
**/
void wrapper_getpriority(int which, int who) {
    int ret = getpriority(which, who);
    printf("nice value is %%d\n", ret);
}

void wrapper_setpriority(int which, int who, int prio) {
    int ret = setpriority(which, who, prio);
    if (ret == -1) perror ("setpriority");
}


int main(int argc, char ** argv) {

}
]]>
			</text>
		</p>
		<p n="xlnx_buffered_io">
			<text>
				<![CDATA[/***************************************** 

* File Name : main.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

/* fcloseall() */
#define _GNU_SOURCE

/* open(), creat(), lseek(), ftruncate */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <stdio.h>

/**
 * ******************************************************
 *  Fopen wrapper
 * ******************************************************
**/
void wrapper_fopen() {
    FILE *stream = NULL;

    stream = fopen("/etc/manifest", "r");
    if (!stream) perror("fopen");

    int close = fclose(stream);
    (void)close;
}

void wrapper_fdopen() {
    FILE *stream = NULL;
    int fd, close;

    fd = open("/tmp/test.txt", O_RDONLY);
    if (fd == -1) perror ("open:");

    stream = fdopen(fd, "r");
    if (!stream) perror("fopen");

    close = fclose(stream);
    (void)close;
}

/**
 * ******************************************************
 *  fgetc wrapper
 * ******************************************************
**/
void wrapper_getc() {
    FILE *stream = NULL;
    int c;

    c = fgetc(stream);

    if (c == EOF) perror("getc:");
    else printf("c=%%c'n", (char) c);

    int ret = ungetc(c, stream);
    (void)ret;
}


/**
 * ******************************************************
 *  fgets() wrapper
 * ******************************************************
**/
void wrapper_fgets() {
    int line_max = 100;
    char buf[line_max];
    FILE *stream = NULL;

    if (!fgets (buf, line_max, stream)) {
        perror("fgets:");
    }
}

/**
 * ******************************************************
 *  Reads a line of data. Also stops reading at delimiter 
 *  'd'
 * ******************************************************
**/
void fgets_substitute(int n, char d, char* str, FILE *stream) {
    char *s;
    int c;

    s = str;

    while (--n > 0 && (c = fgetc(stream)) != EOF && (*s++ = c) != d)
        ;

    if (c == d)
        *--s = '\0';
    else
        *s ='\0' ;
}


/**
 * ******************************************************
 *  Fread() wrapper
 * ******************************************************
**/
void wrapper_fread() {
    FILE *stream = NULL;
    size_t size = 100;
    char buf[(int)size];
    size_t  nr = 1;

    stream = fopen("/etc/manifest", "r");
    if (!stream) perror("fopen");

    size_t ret = fread(buf, size, nr, stream);

    if (ret == 0) perror("fread:");

    int close = fclose(stream);
    (void)close;
}


/**
 * ******************************************************
 *  Wrappers for writing
 * ******************************************************
**/
void wrapper_fputc(FILE *stream) {
    if (fputc('p', stream) == EOF) {
    }
}

void wrapper_fputs() {
    FILE *stream;

    stream = fopen("/tmp/test.txt", "a");
    if (!stream) {
        perror("fopen:");
    }

    if (fputs("The ship is made of wood.\n", stream) == EOF) perror("fputs");

    if (fclose(stream) == EOF) perror("fclose:");
}

void wrapper_fwrite(void *buf, size_t size, size_t nr, FILE *stream) {
    size_t ret = fwrite(buf, size, nr, stream);
    (void) ret;
}


#if 0
#include <stdio.h>
int fseek (FILE *stream, long offset, int whence);
#endif

#if 0
#include <stdio.h>
int fsetpos (FILE *stream, fpos_t *pos);
#endif

#if 0
#include <stdio.h>
void rewind (FILE *stream);o

errno = 0;
rewind (stream);
if (errno)
        /* error */
#endif


#if 0
#include <stdio.h>
long ftell (FILE *stream);
#endif

#if 0
#include <stdioh.h>
int fgetpos (FILE *stream, fpos_t *pos);
#endif


#if 0
#include <stdio.h>
int fflush (FILE *stream);
#endif


#if 0
#include <stdio.h>
int ferror (FILE *stream);
#endif

#if 0
#include <stdio.h>

int feof (FILE *stream);
#endif

#if 0
#include <stdio.h>

void clearerr (FILE *stream);
#endif


#if 0
#include <stdio.h>

int fileno (FILE *stream);
#endif

#if 0
#include <stdio.h>

int setvbuf (FILE *stream, char *buf, int mode, size_t size);
#endif


int main (void)
{
        FILE *in, *out;
        struct pirate {
                char            name[100]; /* real name */
                unsigned long   booty;     /* in pounds sterling */
                unsigned int    beard_len; /* in inches */
        } p, blackbeard = { "Edward Teach", 950, 48 };

        out = fopen ("data", "w");
        if (!out) {
                perror ("fopen");
                return 1;
        }

        if (!fwrite (&blackbeard, sizeof (struct pirate), 1, out)) {
                perror ("fwrite");
                return 1;
        }

        if (fclose (out)) {
                perror ("fclose");
                return 1;
        }

        in = fopen ("data", "r");
        if (!in) {
                perror ("fopen");
                return 1;
        }

        if (!fread (&p, sizeof (struct pirate), 1, in)) {
                perror ("fread");
                return 1;
        }

        if (fclose (in)) {
                perror ("fclose");
                return 1;
        }

        printf ("name=\"%%s\" booty=%%lu beard_len=%%u\n",
                p.name, p.booty, p.beard_len);

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_file_stat">
			<text>
				<![CDATA[/***************************************** 

* File Name : file_stat.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <sys/statvfs.h>
#include <stdlib.h>
#include <sys/types.h>
#include <grp.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <dirent.h>
#include <errno.h>
#include <string.h>
#include <sys/sysmacros.h>
#include <time.h>
#include <math.h>
#include <mntent.h>


/*
 * is_on_physical_device - returns a positive
 * integer if 'fd' resides on a physical device,
 * 0 if the file resides on a nonphysical or
 * virtual device (e.g., on an NFS mount), and
 * −1 on error.
 */
int is_on_physical_device (int fd)
{
        struct stat sb;
        int ret;

        ret = fstat (fd, &sb);
        if (ret) {
                perror ("fstat");
                return -1;
        }

        //return gnu_dev_major (sb.st_dev);
        return 0;
}

void wrapper_change_mod() {
    int ret;
    ret = chmod ("./map.png", S_IRUSR | S_IWUSR);

    if (ret) {
        perror("chmod");
    }
}

void wrapper_fchange_mod(int fd) {
    int ret;
    ret = fchmod (fd, S_IRUSR | S_IWUSR);

    if (ret) {
        perror("fchmod");
    }
}

void wrapper_owner() {
    struct group *gr;
    int ret;
    /*
     * getgrnam() returns information on a group
     * given its name.
     */
    gr = getgrnam ("officers");
    if (!gr) {
            /* likely an invalid group */
            perror ("getgrnam");
            return;
    }

    /* set manifest.txt's group to 'officers' */
    ret = chown("manifest.txt", -1, gr->gr_gid);
    if (ret)
            perror ("chown");
}


/*
 * make_root_owner - changes the owner and group of the file
 * given by 'fd' to root. Returns 0 on success and −1 on
 * failure.
 */
int make_root_owner (int fd)
{
        int ret;

        /* 0 is both the gid and the uid for root */
        ret = fchown (fd, 0, 0);
        if (ret)
                perror ("fchown");

        return ret;
}

/*
 * find_file_in_dir - searches the directory 'path' for a
 * file named 'file'.
 *
 * Returns 0 if 'file' exists in 'path' and a nonzero
 * value otherwise.
 */
int find_file_in_dir (const char *path, const char *file)
{
        struct dirent *entry;
        int ret = 1;
        DIR *dir;

        dir = opendir (path);

        errno = 0;
        while ((entry = readdir (dir)) != NULL) {
                if (strcmp(entry->d_name, file) == 0) {
                        ret = 0;
                        break;
                }
        }

        if (errno && !entry)
                perror ("readdir");

        closedir (dir);
        return ret;
}

void process(const char *filename)
{
	FILE *fp;
	struct mntent *fs;

	fp = setmntent(filename, "r");	/* read only */
	if (fp == NULL) {
		fprintf(stderr, "%%s: could not open: %%s\n",
			filename, strerror(errno));
		exit(1);
	}

	while ((fs = getmntent(fp)) != NULL) {
		//do_statvfs(fs);
        printf("MNT_DIR %%s", fs->mnt_dir);
        printf("fsname %%s", fs->mnt_fsname);
    }

	endmntent(fp);
}

int main (int argc, char *argv[])
{
#if 0
        struct stat sb;
        int ret;

        if (argc < 2) {
                fprintf (stderr,
                         "usage: %%s <file>\n", argv[0]);
                return 1;
        }

        ret = stat (argv[1], &sb);
        if (ret) {
                perror ("stat");
                return 1;
        }

        printf ("%%s is %%ld bytes\n",
                argv[1], sb.st_size);


        printf ("File type: ");
        switch (sb.st_mode & S_IFMT) {
        case S_IFBLK:
                printf("block device node\n");
                break;
        case S_IFCHR:
                printf("character device node\n");
                break;
        case S_IFDIR:
                printf("directory\n");
                break;
        case S_IFIFO:
                printf("FIFO\n");
                break;
        case S_IFLNK:
                printf("symbolic link\n");
                break;
        case S_IFREG:
                printf("regular file\n");
                break;
        case S_IFSOCK:
                printf("socket\n");
                break;
        default:
                printf("unknown\n");
                break;
        }

        return 0;
#endif
        struct stat sb;

        if (argc != 2) {
            fprintf(stderr, "Usage: %%s <pathname>\n", argv[0]);
            exit(1);
        }

        if (lstat(argv[1], &sb) == -1) {
            perror("lstat");
            exit(1);
        }

        printf("ID of containing device:  [%%lx,%%lx]\n",
               (long) major(sb.st_dev), (long) minor(sb.st_dev));

        printf("File type:		     ");

        switch (sb.st_mode & S_IFMT) {
            case S_IFBLK:  printf("block device\n");	       break;
            case S_IFCHR:  printf("character device\n");        break;
            case S_IFDIR:  printf("directory\n");	       break;
            case S_IFIFO:  printf("FIFO/pipe\n");	       break;
            case S_IFLNK:  printf("symlink\n");		       break;
            case S_IFREG:  printf("regular file\n");	       break;
            case S_IFSOCK: printf("socket\n");		       break;
            default:	  printf("unknown?\n"); 	       break;
        }

        printf("I-node number:	     %%ld\n", (long) sb.st_ino);

        printf("Mode:		     %%lo (octal)\n",
               (unsigned long) sb.st_mode);

        printf("Link count:		     %%ld\n", (long) sb.st_nlink);
        printf("Ownership:		     UID=%%ld   GID=%%ld\n",
               (long) sb.st_uid, (long) sb.st_gid);

        printf("Preferred I/O block size: %%ld bytes\n",
               (long) sb.st_blksize);
        printf("File size:		     %%lld bytes\n",
               (long long) sb.st_size);
        printf("Blocks allocated:	     %%lld\n",
               (long long) sb.st_blocks);

        printf("Last status change:	     %%s", ctime(&sb.st_ctime));
        printf("Last file access:	     %%s", ctime(&sb.st_atime));
        printf("Last file modification:   %%s", ctime(&sb.st_mtime));

        struct statvfs stat;

        if (statvfs(argv[1], &stat) != 0) {
            // error happens, just quits here
            return -1;
        }

        printf("Total space: %%.3f GB\n",  (stat.f_bsize * stat.f_blocks) / pow(1024, 3));
        printf("Available space: %%.3f GB\n", (stat.f_bsize * stat.f_bavail) / pow(1024, 3));

        process(argv[1]);

        exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_file_io_main">
			<text>
				<![CDATA[/***************************************** 

* File Name : main.c

* Creation Date : 13-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdbool.h>

/* open(), creat(), lseek(), ftruncate */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/* getcwd(), read(), write(), fsync(), close() */
/* lseek(), pread(), pwrite(), ftruncate() */
#include <unistd.h>

/* printf() */
#include <stdio.h>

/* PATH_MAX */
#include <limits.h>

/* str* calls */
#include <string.h>

/* errno */
#include <errno.h>

/* */
#include "multiplexed_io.h"


/**
 * ******************************************************
 * Opens a file. `man open` for all the flags.
 * ******************************************************
**/
int wrapper_open(const char* str, int flags) {
    int fd = 0;

    fd = open (str, flags);
    if (fd == -1) {
        perror("Error opening file:");
        return 1;
    } else {
        printf("Opened: %%s\n", str);
    }

    return fd;
}


/**
 * ******************************************************
 * The combination of O_WRONLY | O_CREAT | O_TRUNC is so 
 * common that a system call exists to provide just that 
 * behavior:
 * ******************************************************
**/
int wrapper_creat() {
    int fd;
    fd = creat ("some_file", 0644);
    if (fd == -1) {      /* error */
    }

    return 0;
}

/**
 * ******************************************************
 * Wrapper for read.
 * read() can have a plethora of results.
 * `man read` for  possible return values.
 * * also check pread()
 * ******************************************************
**/
ssize_t wrapper_blocking_read(int fd, void *buf, size_t len) {

    ssize_t ret, total_ret = 0;

    if (len > SSIZE_MAX) len = SSIZE_MAX;

    while (len != 0 && (ret = read(fd, buf, len)) != 0) {
        if (ret == -1) {
            if (errno == EINTR) continue;
            /* else */
            perror("blocking read");
            break;
        }
        len -= ret;
        buf += ret;
        total_ret += ret;
    }

    return total_ret;
}

ssize_t wrapper_nonblocking_read(int fd, void *buf, size_t len) {
    ssize_t ret = 0;

    if (len > SSIZE_MAX) len = SSIZE_MAX;

start:
    ret = read(fd, buf, len);
    if (ret == -1) {
        if (errno == EINTR) goto start;
        if (errno == EAGAIN) {
            /* Do some usefull stuff */
            /* Resubmit read again later */
        } else {
            /* else error */
            perror("non-blocking read");
        }
    }

    return ret;
}

/**
 * ******************************************************
 * Write wrapper
 * * also check pwrite()
 * ******************************************************
**/
ssize_t wrapper_write(int fd, const void *buf, size_t count) {
    ssize_t nr;
    int ret;
    bool essential_data_only = true;

    nr = write(fd, buf, strlen(buf));
    if (nr == -1) {
        perror("write error");
    } else if (nr != count) {
        /* possible error, but errno is not set*/
    }

    // Alternativley, open with O_SYNC, O_DSYNC, O_RSYNC
    if (essential_data_only ) {
        ret = fdatasync(fd);
        if (ret == -1) perror("fdatasync error:");
    } else {
        ret = fsync(fd);
        if (ret == -1) perror("fsync error:");
    }

    return nr;
}


ssize_t wrapper_socket_write(int fd, const void *buf, size_t len) {
    ssize_t ret, total_ret;

    /* Trying to write more than SSIZE_MAX results in 
     * undefined behaviour */
    if (len > SSIZE_MAX) len = SSIZE_MAX;

    while (len != 0 && (ret = write (fd, buf, len)) != 0) {
        if (ret == -1) {
            if (errno == EINTR) continue; 
            /*else */
            perror ("write");
            break;
        }
#if 0
        // Uncomment this if you want to flush the data to the hdd
        // Alternativley, open with O_SYNC, O_DSYNC, O_RSYNC
        if (essential_data_only ) {
            ret = fdatasync(fd);
            if (ret == -1) perror("fdatasync error:");
        } else {
            ret = fsync(fd);
            if (ret == -1) perror("fsync error:");
        }
#endif

        len -= ret;
        buf += ret;
        total_ret += ret;
    }

    return total_ret;
}

/**
 * ******************************************************
 *  Close wrapper
 * ******************************************************
**/
int wrapper_close(int fd) {
    int ret = 0;
    if ( (ret = close(fd)) == -1) {
        perror ("close");
    }

    return ret;
}

/**
 * ******************************************************
 *  Lseek wrapper. curr + pos
 *
 *   - SEEK_CUR: if pos = 0, sets cursor to curr pos
 *   - SEEK_END: if pos = 0, sets cursor to end
 *   - SEEK_SET: if pos = 0, sets cursor to beginning
 *
 *   * also check pread() and pwrite()
 *
 * ******************************************************
**/
off_t wrapper_lseek(int fd, off_t pos, int origin) {
    off_t ret;

    /* Set the cursor to poistion pos */
    ret = lseek(fd, pos, SEEK_SET);
    if (ret == (off_t) -1) {
        perror("lseek:");
    }

    return ret;
}

/**
 * ******************************************************
 *  Truncate wrapper
 * ******************************************************
**/
int wrapper_truncate(const char* path, off_t len) {
    int ret;
    ret = truncate ("./pirate.txt", 45);
    if (ret == -1) {
        perror ("truncate");
        return -1;
    } 
    return 0;
}

/**
 * ******************************************************
 *  Sscanf wrapper.
 * ******************************************************
**/
void wrapper_sscanf() {
    int nr = 10;
    const char * line = "10 ten(";
    char str[128];
    if (sscanf (line, "%%d %%64[^(]", &nr, str) < 2) {
        fprintf(stderr, "Bad command in wrapper scanf\n");
        printf("%%s\n", str);
    }
    else {
        printf("%%s\n", str);
    }
}

/**
 * ******************************************************
 *  Main
 * ******************************************************
**/
int main(int argc, char ** argv) {
    int fd;
    char cwd[PATH_MAX];
    char abs_path[PATH_MAX + 30];

    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("Current working dir: %%s\n", cwd);
    } else {
        perror("getcwd() error");
        return 1;
    }

    wrapper_sscanf();

    fd = wrapper_open("/home/teach/pearl", O_WRONLY | O_TRUNC);
    
    strcat(abs_path, cwd);
    strcat(abs_path, "/perl");

    fd = wrapper_open((const char*)abs_path, O_WRONLY | O_TRUNC);
    (void)fd;

    wrapper_select();
    wrapper_poll();

    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_file_io_multiplexed">
			<text>
				<![CDATA[/***************************************** 

* File Name : multiplexed_io.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include "multiplexed_io.h"

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <poll.h>

#define TIMEOUT 5
#define BUF_LEN 1024

/**
 * ******************************************************
 * @brief 
 * 1. Tell me when any of these fds become ready for i/o
 * 2. Sleep until one or more fds are ready
 * 3. Woken up! What is ready?
 * 4. Handle all fds ready for i/o without blocking
 * 5. go back to 1.
 * ******************************************************
**/
int wrapper_select() {
    int ret;
    struct timeval tv;
    fd_set readfds;

    /* Wait on stdin for input. */
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);

    /* Wait up to five seconds */
    /* !!!! 
     * This needs to be reinitialized on subsequent calls.
     * pselect() leaves the structure alone. 
     * !!!! */
    tv.tv_sec = TIMEOUT;
    tv.tv_usec = 0;

    /* Now block */
    ret = select(STDIN_FILENO + 1,
                &readfds,
                0,
                0,
                &tv);

    if (ret == -1) {
        perror("select:");
        return 1;
    } else if (!ret) {
        printf("%%d seconds elapsed.\n", TIMEOUT);
        /* The time structure is modified by the select() */
        printf("tv_sec %%d.\n", (int)tv.tv_sec);
        printf("tv_usec %%d.\n", (int)tv.tv_usec);
        return 0;
    }

    /* 
     * Is our fd ready to read?
     * Only one provided, so yes.
     * */
    if (FD_ISSET(STDIN_FILENO, &readfds)) {
        char buf[BUF_LEN + 1];
        int len;

        /* guaranteed to not block */
        len = read (STDIN_FILENO, buf, BUF_LEN);
        if (len == -1) {
            perror("read:");
            return 1;
        }

        if (len) {
            buf[len] = '\0';
            printf("read: %%s.\n", buf);
            /* The time structure is modified by the select() */
            printf("tv_sec %%d.\n", (int)tv.tv_sec);
            printf("tv_usec %%d.\n", (int)tv.tv_usec);
        }

        return 0;
    }

    fprintf(stderr, "This should not happen!\n");
    return 1;
}

/*
 * There are three differences between pselect() and select():
 *  - pselect() uses the timespec structure, not the timeval structure, for its 
 *    timeout parameter. The timespec structure uses seconds and nanoseconds,
 *    not seconds and microseconds, providing theoretically superior timeout 
 *    resolution. In practice, however, neither call reliably provides even
 *    microsecond resolution.
 *  - A call to pselect() does not modify the timeout parameter.
 *    Consequently, this parameter does not need to be
 *    reinitialized on subsequent invocations.
 *  - The select() system call does not have the sigmask parameter.
 *    With respect to signals, when this parameter is set to NULL, pselect()
 *    behaves like select().
 *
 *    The motivation for pselect() are the signals. The app can block indefinetly
 *    if the signall arives between the check for the global signal flag
 *    and the call to select().
 *    sigmask in pselect() blocks signals. Blocked signals are not handled
 *    until they are unblocked. Once pselec() returns, the kernel restors the
 *    old signal mask.
 */



int wrapper_poll() {
    int ret;

    struct pollfd fds[2];
    /* watch stdin for input */
    fds[0].fd = STDIN_FILENO;
    fds[0].events = POLLIN;
    /* watch stdout for ability to write (almost always true) */
    //fds[1].fd = STDOUT_FILENO;
    //fds[1].events = POLLOUT;
    /* All set, block! */
    ret = poll (fds, 1, TIMEOUT * 1000);
    if (ret == -1) {
        perror ("poll");
        return 1;
    }
    if (!ret) {
        printf ("%%d seconds elapsed.\n", TIMEOUT);
        return 0;
    }
    if (fds[0].revents & POLLIN) {
        char buf[BUF_LEN + 1];
        int len;

        /* guaranteed to not block */
        len = read (STDIN_FILENO, buf, BUF_LEN);
        if (len == -1) {
            perror("read:");
            return 1;
        }

        if (len) {
            buf[len] = '\0';
            printf("read: %%s.\n", buf);
        }
        printf ("stdin is readable\n");
    }
    if (fds[1].revents & POLLOUT)
        printf ("stdout is writable\n");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_mmap2">
			<text>
				<![CDATA[/***************************************** 

* File Name : mmap.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

/**
 * ******************************************************
 * As an alternative to standard file I/O, the kernel
 * provides an interface that allows an application to
 * map a file into memory, meaning that there is a 
 * one-to-one correspondence between a memory address 
 * and a word in the file. The programmer can then access
 * the file directly through memory, identically to any
 * other chunk of memory-resident data—it is even possible 
 * to allow writes to the memory region to transparently 
 * map back to the file on disk.
 *
 *  - or -
 *
 *  Perhaps because you want to force the use of a memory 
 *  mapping over the heap for a specific allocation, or 
 *  perhaps because you are writing your own memory allocation 
 *  system, you may want to manually create your own 
 *  anonymous memory mapping—either way, Linux makes it easy. 
 *  Recall from Chapter 4 that the system call mmap()
 *  creates a memory mapping and the system call munmap() 
 *  destroys a mapping:
 * ******************************************************
**/
int main(int argc, char ** argv) {
    void *p;
    int fd;

    /* open /dev/zero for reading and writing */
    fd = open ("/dev/zero", O_RDWR);
    if (fd < 0) {
            perror ("open");
            return −1;
    }

    /* map [0,page size) of /dev/zero */
    p = mmap (NULL,                   /* do not care where */
              getpagesize (),         /* map one page */
              PROT_READ | PROT_WRITE, /* map read/write */
              MAP_PRIVATE,            /* private mapping */
              fd,                     /* map /dev/zero */
              0);                     /* no offset */

    if (p == MAP_FAILED) {
            perror ("mmap");
            if (close (fd))
                    perror ("close");
            return −1;
    }

    /* close /dev/zero, no longer needed */
    if (close (fd))
            perror ("close");

    /* 'p' points at one page of memory, use it... */  
}
]]>
			</text>
		</p>
		<p n="xlnx_daemon">
			<text>
				<![CDATA[/***************************************** 

* File Name : daemon.c

* Creation Date : 17-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/fs.h>

/**
 * ******************************************************
 *  This main() actually is synonymous for:
 *  #include <unistd.h>
 *  int daemon (int nochdir, int noclose)
 * ******************************************************
**/
int main (void)
{
        pid_t pid;
//        int i;

        /* create new process */
        pid = fork ();
        if (pid == -1)
                return -1;
        else if (pid != 0)
                exit (EXIT_SUCCESS);

        /* create new session and process group */
        if (setsid () == -1)
                return -1;

        /* set the working directory to the root directory */
        if (chdir ("/") == -1)
                return -1;

        /* close all open files--NR_OPEN is overkill, but works */
//        for (i = 0; i < NR_OPEN; i++)
//                close (i);

        /* redirect fd's 0,1,2 to /dev/null */
        open ("/dev/null", O_RDWR);     /* stdin */
        dup (0);                        /* stdout */
        dup (0);                        /* stderror */

        /* do its daemon thing... */

        /* Just so you can see it with `ps | grep daemon` */
        while (1) {
            sleep(1);
        }

        return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_exec_prog">
			<text>
				<![CDATA[/***************************************** 

* File Name : exec_prog.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <errno.h>
#include <unistd.h>


int main(int argc, char ** argv) {

    char * const args[] = { "program_name_here", "/hooks.txt", NULL };
    int ret;

    ret = execv ("/usr/bin/vi", args);
    if (ret == -1) perror ("execvp");

    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_fork_call">
			<text>
				<![CDATA[/***************************************** 

* File Name : fork_call.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

void parent_out() {
    printf("parent atexit() succeeded!\n");
}

void child_out() {
    printf("child atexit() succeeded!\n");
}


int main(int argc, char ** argv) {

    pid_t pid;

    pid = fork ();
    if (pid == -1) perror ("fork");
    else if (pid > 0) {
        printf("I am the parent of pid=%%d.\n", pid);
        printf("My pid is =%%d.\n", getpid());

        /* Will call the parent_out function when falling of the 
         * edge. */
        if (atexit(parent_out)) {
            fprintf(stderr, "atexit() failed!\n");
        }

        return 0;
    }
    else if (!pid) {
        /* the child ... */
        printf(" -- I am the the child of pid=%%d.\n", getppid());
        printf(" -- My pid is =%%d.\n", getpid());
        printf(" -- I list files:\n");
        char *const args[] = { "list_child", NULL };
        int ret;

        if (atexit(child_out)) {
            fprintf(stderr, "atexit() failed!\n");
        }
        /* If I uncomment the line below then , the program ends with
         * "atexit() succeeded." Otherwise the execv() flushes all 
         * registered functions with atexit(). */
        //exit(0);

        ret = execv ("/bin/ls", args);
        if (ret == -1) {
                perror ("execv");
                exit (EXIT_FAILURE);
        }

        /* Other things which are lost on exec() family commands:
         *  - Any pending signals are lost.
         *  - Any signals that the process is catching (see Chapter 10)
         *    are returned to their default behavior, as the signal handlers
         *    no longer exist in the process’s address space. 
         *  - Any memory locks (see Chapter 9) are dropped. 
         *  - Most thread attributes are returned to the default values. 
         *  - Most process statistics are reset.  
         *  - Anything related to the process’s memory address space, including any mapped files, 
         *    is cleared. 
         *  - Anything that exists solely in user space, including features of the C library,
         *    such as atexit() behavior, is cleared.  
         *
         * Some properties of the process, 
         * however, do not change. For example, the pid, parent pid, priority, and owning 
         * user and group all remain the same.  Normally, open files are inherited across an exec.
         * This means the newly executed program has full access to all of the files open in the 
         * original process, assuming it knows the file descriptor values. However, this is
         * often not the desired behavior. 
         *
         * The usual practice is to close files before the exec, 
         * although it is also possible to instruct the kernel to 
         * do so automatically via fcntl().  
         */

        return 0;
    }

}
]]>
			</text>
		</p>
		<p n="xlnx_wait_call">
			<text>
				<![CDATA[/***************************************** 

* File Name : wait_call.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdlib.h>
#include <signal.h>


#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>

/**
 * ******************************************************
 *  system(): A short hand function for fork() -> exec()
 * ******************************************************
**/
void wrapper_system() {
    /*
     * During execution of the command, SIGCHLD is blocked, 
     * and SIGINT and SIGQUIT are ignored. Ignoring SIGINT 
     * and SIGQUIT has several implications,
     * particularly if system() is invoked inside a loop. 
     * If calling system() from within a loop, you should 
     * ensure that the program properly checks the exit status of the child.
     * For example:
     */
    do {
        int ret;

        ret = system ("pidof rudderd");
        if (WIFSIGNALED (ret) &&
            (WTERMSIG (ret) == SIGINT ||
             WTERMSIG (ret) == SIGQUIT))
                break; /* or otherwise handle */
    } while (1);
}

/**
 * ******************************************************
 *  The waitid(), more options than waitpid().
 * ******************************************************
**/
void wrapper_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {
    int ret = waitid (idtype, id, infop, options);

    (void)ret;
}

int main(int argc, char ** argv) {
    int status;
    pid_t pid;

    if (!fork ())
            return 1;

    //pid = wait (&status); // Weaksauce

    pid = waitpid(-1, &status, 0); // Better
    /*
     * < −1
     * Wait for any child process whose process group ID 
     * is equal to the absolute value of this value. 
     * For example, passing −500 waits for any process in process group 500.
     *
     * −1
     * Wait for any child process. This is the same behavior as wait().
     *
     * 0
     * Wait for any child process that belongs to the same process 
     * group as the calling process.
     *
     * > 0
     * Wait for any child process whose pid is exactly the value provided.
     * For example, passing 500 waits for the child process with pid 500.
     */

    /*
     * The options parameter is a binary OR of zero or more of the following 
     * options:
     * 
     *  - WNOHANG
     * Do not block, but return immediately if no matching child process has 
     * already terminated (or stopped or continued).
     *  
     *  - WUNTRACED
     * If set, the WIFSTOPPED bit in the returned status parameter is set,
     * even if the calling process is not tracing the child process. 
     * This flag allows for the implementation of more general job control,
     * as in a shell.
     *
     *  - WCONTINUED
     * If set, the WIFCONTINUED bit in the returned status parameter is
     * set even if the calling process is not tracing the child process.
     * As with WUNTRACED, this flag is useful for implementing a shell.
     */
    if (pid == -1)
            perror ("wait");

    printf ("pid=%%d\n", pid);

    if (WIFEXITED (status))
            printf ("Normal termination with exit status=%%d\n",
                    WEXITSTATUS (status));

    if (WIFSIGNALED (status))
            printf ("Killed by signal=%%d%%s\n",
                    WTERMSIG (status),
                    WCOREDUMP (status) ? " (dumped core)" : "");

    if (WIFSTOPPED (status))
            printf ("Stopped by signal=%%d\n",
                    WSTOPSIG (status));

    if (WIFCONTINUED (status))
            printf ("Continued\n");

   return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_signal_handling">
			<text>
				<![CDATA[/***************************************** 

* File Name : signal_handling.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 * https://en.wikipedia.org/wiki/Reentrancy_(computing)
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

/* handler for SIGINT and SIGTERM */
static void signal_handler (int signo)
{
        if (signo == SIGINT)
                printf ("Caught SIGINT!\n");
        else if (signo == SIGTERM)
                printf ("Caught SIGTERM!\n");
        else {
                /* this should never happen */
                fprintf (stderr, "Unexpected signal!\n");
                exit (EXIT_FAILURE);
        }
        exit (EXIT_SUCCESS);
}

int main (void)
{
        /*
         * Register signal_handler as our signal handler
         * for SIGINT.
         */
        if (signal (SIGINT, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGINT!\n");
                exit (EXIT_FAILURE);
        }

        /*
         * Register signal_handler as our signal handler
         * for SIGTERM.
         */
        if (signal (SIGTERM, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGTERM!\n");
                exit (EXIT_FAILURE);
        }

        /* Reset SIGPROF's behavior to the default. */
        if (signal (SIGPROF, SIG_DFL) == SIG_ERR) {
                fprintf (stderr, "Cannot reset SIGPROF!\n");
                exit (EXIT_FAILURE);
        }

        /* Ignore SIGHUP. */
        if (signal (SIGHUP, SIG_IGN) == SIG_ERR) {
                fprintf (stderr, "Cannot ignore SIGHUP!\n");
                exit (EXIT_FAILURE);
        }

        int i = 0;
        while (1) {
            i++;
            printf("Sleeping %%d\n", i);
            sleep(1);
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_threading">
			<text>
				<![CDATA[/***************************************** 

* File Name : threading.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

void * start_thread (void *message)
{
        printf ("%%s\n", (const char *) message);
        return message;
}

int main (void)
{
        pthread_t thing1, thing2;
        const char *message1 = "Thing 1";
        const char *message2 = "Thing 2";

        /* Create two threads, each with a different message. */
        pthread_create (&thing1, NULL, start_thread, (void *) message1);
        pthread_create (&thing2, NULL, start_thread, (void *) message2);

        /*
         * Wait for the threads to exit. If we didn't join here,
         * we'd risk terminating this main thread before the
         * other two threads finished.
         */
        pthread_join (thing1, NULL);
        pthread_join (thing2, NULL);

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_thread_safety_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : thread_saftey.h

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef _THREAD_SAFTEY_H_
#define _THREAD_SAFTEY_H_

/**
 * ******************************************************
 * #include <stdio.h>

void flockfile (FILE *stream);
 * ******************************************************
**/

/**
 * ******************************************************
 * #include <stdio.h>

void funlockfile (FILE *stream);
 * ******************************************************
**/


/**
 * ******************************************************
 *  #include <stdio.h>

int ftrylockfile (FILE *stream);
 * ******************************************************
**/


/**
 * ******************************************************
 * 
flockfile (stream);

fputs ("List of treasure:\n", stream);
fputs ("    (1) 500 gold coins\n", stream);
fputs ("    (2) Wonderfully ornate dishware\n", stream);

funlockfile (stream);
 * ******************************************************
**/


/**
 * ******************************************************
 * 
 * #define _GNU_SOURCE

#include <stdio.h>

int fgetc_unlocked (FILE *stream);
char *fgets_unlocked (char *str, int size, FILE *stream);
size_t fread_unlocked (void *buf, size_t size, size_t nr,
                       FILE *stream);
int fputc_unlocked (int c, FILE *stream);
int fputs_unlocked (const char *str, FILE *stream);
size_t fwrite_unlocked (void *buf, size_t size, size_t nr,
                        FILE *stream);
int fflush_unlocked (FILE *stream);
int feof_unlocked (FILE *stream);
int ferror_unlocked (FILE *stream);
int fileno_unlocked (FILE *stream);
void clearerr_unlocked (FILE *stream);
 * ******************************************************
**/


#endif
]]>
			</text>
		</p>
		<p n="xlnx_multiplexed_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : multiplexed_io.h

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef __MULTIPLEXED_IO_H_
#define __MULTIPLEXED_IO_H_

#include <sys/select.h>
#include <sys/time.h>

/**
 * ******************************************************
 * @brief 
 * 1. Tell me when any of these fds become ready for i/o
 * 2. Sleep until one or more fds are ready
 * 3. Woken up! What is ready?
 * 4. Handle all fds ready for i/o without blocking
 * 5. go back to 1.
 * ******************************************************
**/
int wrapper_select();

int wrapper_poll();

#endif
]]>
			</text>
		</p>
		<p n="xlnx_drv_lddbus">
			<text>
				<![CDATA[/*
 * A virtual bus for LDD sample code devices to plug into.  This
 * code is heavily borrowed from drivers/base/sys.c
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */
/* $Id: lddbus.c,v 1.9 2004/09/26 08:12:27 gregkh Exp $ */

#include <linux/device.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/string.h>
#include "lddbus.h"

MODULE_AUTHOR("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");
static char *Version = "$Revision: 1.9 $";

/*
 * Respond to hotplug events.
 */
static int ldd_hotplug(struct device *dev, char **envp, int num_envp,
		char *buffer, int buffer_size)
{
	envp[0] = buffer;
	if (snprintf(buffer, buffer_size, "LDDBUS_VERSION=%%s",
			    Version) >= buffer_size)
		return -ENOMEM;
	envp[1] = NULL;
	return 0;
}

/*
 * Match LDD devices to drivers.  Just do a simple name test.
 */
static int ldd_match(struct device *dev, struct device_driver *driver)
{
	return !strncmp(dev->bus_id, driver->name, strlen(driver->name));
}


/*
 * The LDD bus device.
 */
static void ldd_bus_release(struct device *dev)
{
	printk(KERN_DEBUG "lddbus release\n");
}
	
struct device ldd_bus = {
	.bus_id   = "ldd0",
	.release  = ldd_bus_release
};


/*
 * And the bus type.
 */
struct bus_type ldd_bus_type = {
	.name = "ldd",
	.match = ldd_match,
	.hotplug  = ldd_hotplug,
};

/*
 * Export a simple attribute.
 */
static ssize_t show_bus_version(struct bus_type *bus, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%%s\n", Version);
}

static BUS_ATTR(version, S_IRUGO, show_bus_version, NULL);



/*
 * LDD devices.
 */

/*
 * For now, no references to LDDbus devices go out which are not
 * tracked via the module reference count, so we use a no-op
 * release function.
 */
static void ldd_dev_release(struct device *dev)
{ }

int register_ldd_device(struct ldd_device *ldddev)
{
	ldddev->dev.bus = &ldd_bus_type;
	ldddev->dev.parent = &ldd_bus;
	ldddev->dev.release = ldd_dev_release;
	strncpy(ldddev->dev.bus_id, ldddev->name, BUS_ID_SIZE);
	return device_register(&ldddev->dev);
}
EXPORT_SYMBOL(register_ldd_device);

void unregister_ldd_device(struct ldd_device *ldddev)
{
	device_unregister(&ldddev->dev);
}
EXPORT_SYMBOL(unregister_ldd_device);

/*
 * Crude driver interface.
 */


static ssize_t show_version(struct device_driver *driver, char *buf)
{
	struct ldd_driver *ldriver = to_ldd_driver(driver);

	sprintf(buf, "%%s\n", ldriver->version);
	return strlen(buf);
}
		

int register_ldd_driver(struct ldd_driver *driver)
{
	int ret;
	
	driver->driver.bus = &ldd_bus_type;
	ret = driver_register(&driver->driver);
	if (ret)
		return ret;
	driver->version_attr.attr.name = "version";
	driver->version_attr.attr.owner = driver->module;
	driver->version_attr.attr.mode = S_IRUGO;
	driver->version_attr.show = show_version;
	driver->version_attr.store = NULL;
	return driver_create_file(&driver->driver, &driver->version_attr);
}

void unregister_ldd_driver(struct ldd_driver *driver)
{
	driver_unregister(&driver->driver);
}
EXPORT_SYMBOL(register_ldd_driver);
EXPORT_SYMBOL(unregister_ldd_driver);



static int __init ldd_bus_init(void)
{
	int ret;

	ret = bus_register(&ldd_bus_type);
	if (ret)
		return ret;
	if (bus_create_file(&ldd_bus_type, &bus_attr_version))
		printk(KERN_NOTICE "Unable to create version attribute\n");
	ret = device_register(&ldd_bus);
	if (ret)
		printk(KERN_NOTICE "Unable to register ldd0\n");
	return ret;
}

static void ldd_bus_exit(void)
{
	device_unregister(&ldd_bus);
	bus_unregister(&ldd_bus_type);
}

module_init(ldd_bus_init);
module_exit(ldd_bus_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_faulty">
			<text>
				<![CDATA[/*
 * complete.c -- the writers awake the readers
 *
 * Copyright (C) 2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: complete.c,v 1.2 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/module.h>
#include <linux/init.h>

#include <linux/sched.h>  /* current and everything */
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>     /* everything... */
#include <linux/types.h>  /* size_t */
#include <linux/completion.h>

MODULE_LICENSE("Dual BSD/GPL");

static int complete_major = 0;

DECLARE_COMPLETION(comp);

ssize_t complete_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) going to sleep\n",
			current->pid, current->comm);
	wait_for_completion(&comp);
	printk(KERN_DEBUG "awoken %%i (%%s)\n", current->pid, current->comm);
	return 0; /* EOF */
}

ssize_t complete_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) awakening the readers...\n",
			current->pid, current->comm);
	complete(&comp);
	return count; /* succeed, to avoid retrial */
}


struct file_operations complete_fops = {
	.owner = THIS_MODULE,
	.read =  complete_read,
	.write = complete_write,
};


int complete_init(void)
{
	int result;

	/*
	 * Register your major, and accept a dynamic number
	 */
	result = register_chrdev(complete_major, "complete", &complete_fops);
	if (result < 0)
		return result;
	if (complete_major == 0)
		complete_major = result; /* dynamic */
	return 0;
}

void complete_cleanup(void)
{
	unregister_chrdev(complete_major, "complete");
}

module_init(complete_init);
module_exit(complete_cleanup);

]]>
			</text>
		</p>
		<p n="xlnx_drv_complete">
			<text>
				<![CDATA[/*
 * complete.c -- the writers awake the readers
 *
 * Copyright (C) 2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: complete.c,v 1.2 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/module.h>
#include <linux/init.h>

#include <linux/sched.h>  /* current and everything */
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>     /* everything... */
#include <linux/types.h>  /* size_t */
#include <linux/completion.h>

MODULE_LICENSE("Dual BSD/GPL");

static int complete_major = 0;

DECLARE_COMPLETION(comp);

ssize_t complete_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) going to sleep\n",
			current->pid, current->comm);
	wait_for_completion(&comp);
	printk(KERN_DEBUG "awoken %%i (%%s)\n", current->pid, current->comm);
	return 0; /* EOF */
}

ssize_t complete_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) awakening the readers...\n",
			current->pid, current->comm);
	complete(&comp);
	return count; /* succeed, to avoid retrial */
}


struct file_operations complete_fops = {
	.owner = THIS_MODULE,
	.read =  complete_read,
	.write = complete_write,
};


int complete_init(void)
{
	int result;

	/*
	 * Register your major, and accept a dynamic number
	 */
	result = register_chrdev(complete_major, "complete", &complete_fops);
	if (result < 0)
		return result;
	if (complete_major == 0)
		complete_major = result; /* dynamic */
	return 0;
}

void complete_cleanup(void)
{
	unregister_chrdev(complete_major, "complete");
}

module_init(complete_init);
module_exit(complete_cleanup);

]]>
			</text>
		</p>
		<p n="xlnx_drv_hello">
			<text>
				<![CDATA[/*                                                     
 * $Id: hello.c,v 1.5 2004/10/26 03:32:21 corbet Exp $ 
 */                                                    
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
	printk(KERN_ALERT "Hello, world\n");
	return 0;
}

static void hello_exit(void)
{
	printk(KERN_ALERT "Goodbye, cruel world\n");
}

module_init(hello_init);
module_exit(hello_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_hellop">
			<text>
				<![CDATA[/*                                                     
 * $Id: hellop.c,v 1.4 2004/09/26 07:02:43 gregkh Exp $ 
 */                                                    
#include <linux/init.h>
#include <linux/module.h>
#include <linux/moduleparam.h>

MODULE_LICENSE("Dual BSD/GPL");

/*                                                        
 * These lines, although not shown in the book,           
 * are needed to make hello.c run properly even when      
 * your kernel has version support enabled                
 */                                                       
                                                          

/*
 * A couple of parameters that can be passed in: how many times we say
 * hello, and to whom.
 */
static char *whom = "world";
static int howmany = 1;
module_param(howmany, int, S_IRUGO);
module_param(whom, charp, S_IRUGO);

static int hello_init(void)
{
	int i;
	for (i = 0; i < howmany; i++)
		printk(KERN_ALERT "(%%d) Hello, %%s\n", i, whom);
	return 0;
}

static void hello_exit(void)
{
	printk(KERN_ALERT "Goodbye, cruel world\n");
}

module_init(hello_init);
module_exit(hello_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_jiq">
			<text>
				<![CDATA[/*
 * jiq.c -- the just-in-queue module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: jiq.c,v 1.7 2004/09/26 07:02:43 gregkh Exp $
 */
 
#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/sched.h>
#include <linux/kernel.h>
#include <linux/fs.h>     /* everything... */
#include <linux/proc_fs.h>
#include <linux/errno.h>  /* error codes */
#include <linux/workqueue.h>
#include <linux/preempt.h>
#include <linux/interrupt.h> /* tasklets */

MODULE_LICENSE("Dual BSD/GPL");

/*
 * The delay for the delayed workqueue timer file.
 */
static long delay = 1;
module_param(delay, long, 0);


/*
 * This module is a silly one: it only embeds short code fragments
 * that show how enqueued tasks `feel' the environment
 */

#define LIMIT	(PAGE_SIZE-128)	/* don't print any more after this size */

/*
 * Print information about the current environment. This is called from
 * within the task queues. If the limit is reched, awake the reading
 * process.
 */
static DECLARE_WAIT_QUEUE_HEAD (jiq_wait);


static struct work_struct jiq_work;



/*
 * Keep track of info we need between task queue runs.
 */
static struct clientdata {
	int len;
	char *buf;
	unsigned long jiffies;
	long delay;
} jiq_data;

#define SCHEDULER_QUEUE ((task_queue *) 1)



static void jiq_print_tasklet(unsigned long);
static DECLARE_TASKLET(jiq_tasklet, jiq_print_tasklet, (unsigned long)&jiq_data);


/*
 * Do the printing; return non-zero if the task should be rescheduled.
 */
static int jiq_print(void *ptr)
{
	struct clientdata *data = ptr;
	int len = data->len;
	char *buf = data->buf;
	unsigned long j = jiffies;

	if (len > LIMIT) { 
		wake_up_interruptible(&jiq_wait);
		return 0;
	}

	if (len == 0)
		len = sprintf(buf,"    time  delta preempt   pid cpu command\n");
	else
		len =0;

  	/* intr_count is only exported since 1.3.5, but 1.99.4 is needed anyways */
	len += sprintf(buf+len, "%%9li  %%4li     %%3i %%5i %%3i %%s\n",
			j, j - data->jiffies,
			preempt_count(), current->pid, smp_processor_id(),
			current->comm);

	data->len += len;
	data->buf += len;
	data->jiffies = j;
	return 1;
}


/*
 * Call jiq_print from a work queue
 */
static void jiq_print_wq(void *ptr)
{
	struct clientdata *data = (struct clientdata *) ptr;
    
	if (! jiq_print (ptr))
		return;
    
	if (data->delay)
		schedule_delayed_work(&jiq_work, data->delay);
	else
		schedule_work(&jiq_work);
}



static int jiq_read_wq(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{
	DEFINE_WAIT(wait);
	
	jiq_data.len = 0;                /* nothing printed, yet */
	jiq_data.buf = buf;              /* print in this place */
	jiq_data.jiffies = jiffies;      /* initial time */
	jiq_data.delay = 0;
    
	prepare_to_wait(&jiq_wait, &wait, TASK_INTERRUPTIBLE);
	schedule_work(&jiq_work);
	schedule();
	finish_wait(&jiq_wait, &wait);

	*eof = 1;
	return jiq_data.len;
}


static int jiq_read_wq_delayed(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{
	DEFINE_WAIT(wait);
	
	jiq_data.len = 0;                /* nothing printed, yet */
	jiq_data.buf = buf;              /* print in this place */
	jiq_data.jiffies = jiffies;      /* initial time */
	jiq_data.delay = delay;
    
	prepare_to_wait(&jiq_wait, &wait, TASK_INTERRUPTIBLE);
	schedule_delayed_work(&jiq_work, delay);
	schedule();
	finish_wait(&jiq_wait, &wait);

	*eof = 1;
	return jiq_data.len;
}




/*
 * Call jiq_print from a tasklet
 */
static void jiq_print_tasklet(unsigned long ptr)
{
	if (jiq_print ((void *) ptr))
		tasklet_schedule (&jiq_tasklet);
}



static int jiq_read_tasklet(char *buf, char **start, off_t offset, int len,
                int *eof, void *data)
{
	jiq_data.len = 0;                /* nothing printed, yet */
	jiq_data.buf = buf;              /* print in this place */
	jiq_data.jiffies = jiffies;      /* initial time */

	tasklet_schedule(&jiq_tasklet);
	interruptible_sleep_on(&jiq_wait);    /* sleep till completion */

	*eof = 1;
	return jiq_data.len;
}




/*
 * This one, instead, tests out the timers.
 */

static struct timer_list jiq_timer;

static void jiq_timedout(unsigned long ptr)
{
	jiq_print((void *)ptr);            /* print a line */
	wake_up_interruptible(&jiq_wait);  /* awake the process */
}


static int jiq_read_run_timer(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{

	jiq_data.len = 0;           /* prepare the argument for jiq_print() */
	jiq_data.buf = buf;
	jiq_data.jiffies = jiffies;

	init_timer(&jiq_timer);              /* init the timer structure */
	jiq_timer.function = jiq_timedout;
	jiq_timer.data = (unsigned long)&jiq_data;
	jiq_timer.expires = jiffies + HZ; /* one second */

	jiq_print(&jiq_data);   /* print and go to sleep */
	add_timer(&jiq_timer);
	interruptible_sleep_on(&jiq_wait);  /* RACE */
	del_timer_sync(&jiq_timer);  /* in case a signal woke us up */
    
	*eof = 1;
	return jiq_data.len;
}



/*
 * the init/clean material
 */

static int jiq_init(void)
{

	/* this line is in jiq_init() */
	INIT_WORK(&jiq_work, jiq_print_wq, &jiq_data);

	create_proc_read_entry("jiqwq", 0, NULL, jiq_read_wq, NULL);
	create_proc_read_entry("jiqwqdelay", 0, NULL, jiq_read_wq_delayed, NULL);
	create_proc_read_entry("jitimer", 0, NULL, jiq_read_run_timer, NULL);
	create_proc_read_entry("jiqtasklet", 0, NULL, jiq_read_tasklet, NULL);

	return 0; /* succeed */
}

static void jiq_cleanup(void)
{
	remove_proc_entry("jiqwq", NULL);
	remove_proc_entry("jiqwqdelay", NULL);
	remove_proc_entry("jitimer", NULL);
	remove_proc_entry("jiqtasklet", NULL);
}


module_init(jiq_init);
module_exit(jiq_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_jit">
			<text>
				<![CDATA[/*
 * jit.c -- the just-in-time module
 *
 * Copyright (C) 2001,2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001,2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: jit.c,v 1.16 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/time.h>
#include <linux/timer.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/types.h>
#include <linux/spinlock.h>
#include <linux/interrupt.h>

#include <asm/hardirq.h>
/*
 * This module is a silly one: it only embeds short code fragments
 * that show how time delays can be handled in the kernel.
 */

int delay = HZ; /* the default delay, expressed in jiffies */

module_param(delay, int, 0);

MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

/* use these as data pointers, to implement four files in one function */
enum jit_files {
	JIT_BUSY,
	JIT_SCHED,
	JIT_QUEUE,
	JIT_SCHEDTO
};

/*
 * This function prints one line of data, after sleeping one second.
 * It can sleep in different ways, according to the data pointer
 */
int jit_fn(char *buf, char **start, off_t offset,
	      int len, int *eof, void *data)
{
	unsigned long j0, j1; /* jiffies */
	wait_queue_head_t wait;

	init_waitqueue_head (&wait);
	j0 = jiffies;
	j1 = j0 + delay;

	switch((long)data) {
		case JIT_BUSY:
			while (time_before(jiffies, j1))
				cpu_relax();
			break;
		case JIT_SCHED:
			while (time_before(jiffies, j1)) {
				schedule();
			}
			break;
		case JIT_QUEUE:
			wait_event_interruptible_timeout(wait, 0, delay);
			break;
		case JIT_SCHEDTO:
			set_current_state(TASK_INTERRUPTIBLE);
			schedule_timeout (delay);
			break;
	}
	j1 = jiffies; /* actual value after we delayed */

	len = sprintf(buf, "%%9li %%9li\n", j0, j1);
	*start = buf;
	return len;
}

/*
 * This file, on the other hand, returns the current time forever
 */
int jit_currentime(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{
	struct timeval tv1;
	struct timespec tv2;
	unsigned long j1;
	u64 j2;

	/* get them four */
	j1 = jiffies;
	j2 = get_jiffies_64();
	do_gettimeofday(&tv1);
	tv2 = current_kernel_time();

	/* print */
	len=0;
	len += sprintf(buf,"0x%%08lx 0x%%016Lx %%10i.%%06i\n"
		       "%%40i.%%09i\n",
		       j1, j2,
		       (int) tv1.tv_sec, (int) tv1.tv_usec,
		       (int) tv2.tv_sec, (int) tv2.tv_nsec);
	*start = buf;
	return len;
}

/*
 * The timer example follows
 */

int tdelay = 10;
module_param(tdelay, int, 0);

/* This data structure used as "data" for the timer and tasklet functions */
struct jit_data {
	struct timer_list timer;
	struct tasklet_struct tlet;
	int hi; /* tasklet or tasklet_hi */
	wait_queue_head_t wait;
	unsigned long prevjiffies;
	unsigned char *buf;
	int loops;
};
#define JIT_ASYNC_LOOPS 5

void jit_timer_fn(unsigned long arg)
{
	struct jit_data *data = (struct jit_data *)arg;
	unsigned long j = jiffies;
	data->buf += sprintf(data->buf, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			     j, j - data->prevjiffies, in_interrupt() ? 1 : 0,
			     current->pid, smp_processor_id(), current->comm);

	if (--data->loops) {
		data->timer.expires += tdelay;
		data->prevjiffies = j;
		add_timer(&data->timer);
	} else {
		wake_up_interruptible(&data->wait);
	}
}

/* the /proc function: allocate everything to allow concurrency */
int jit_timer(char *buf, char **start, off_t offset,
	      int len, int *eof, void *unused_data)
{
	struct jit_data *data;
	char *buf2 = buf;
	unsigned long j = jiffies;

	data = kmalloc(sizeof(*data), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	init_timer(&data->timer);
	init_waitqueue_head (&data->wait);

	/* write the first lines in the buffer */
	buf2 += sprintf(buf2, "   time   delta  inirq    pid   cpu command\n");
	buf2 += sprintf(buf2, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			j, 0L, in_interrupt() ? 1 : 0,
			current->pid, smp_processor_id(), current->comm);

	/* fill the data for our timer function */
	data->prevjiffies = j;
	data->buf = buf2;
	data->loops = JIT_ASYNC_LOOPS;
	
	/* register the timer */
	data->timer.data = (unsigned long)data;
	data->timer.function = jit_timer_fn;
	data->timer.expires = j + tdelay; /* parameter */
	add_timer(&data->timer);

	/* wait for the buffer to fill */
	wait_event_interruptible(data->wait, !data->loops);
	if (signal_pending(current))
		return -ERESTARTSYS;
	buf2 = data->buf;
	kfree(data);
	*eof = 1;
	return buf2 - buf;
}

void jit_tasklet_fn(unsigned long arg)
{
	struct jit_data *data = (struct jit_data *)arg;
	unsigned long j = jiffies;
	data->buf += sprintf(data->buf, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			     j, j - data->prevjiffies, in_interrupt() ? 1 : 0,
			     current->pid, smp_processor_id(), current->comm);

	if (--data->loops) {
		data->prevjiffies = j;
		if (data->hi)
			tasklet_hi_schedule(&data->tlet);
		else
			tasklet_schedule(&data->tlet);
	} else {
		wake_up_interruptible(&data->wait);
	}
}

/* the /proc function: allocate everything to allow concurrency */
int jit_tasklet(char *buf, char **start, off_t offset,
	      int len, int *eof, void *arg)
{
	struct jit_data *data;
	char *buf2 = buf;
	unsigned long j = jiffies;
	long hi = (long)arg;

	data = kmalloc(sizeof(*data), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	init_waitqueue_head (&data->wait);

	/* write the first lines in the buffer */
	buf2 += sprintf(buf2, "   time   delta  inirq    pid   cpu command\n");
	buf2 += sprintf(buf2, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			j, 0L, in_interrupt() ? 1 : 0,
			current->pid, smp_processor_id(), current->comm);

	/* fill the data for our tasklet function */
	data->prevjiffies = j;
	data->buf = buf2;
	data->loops = JIT_ASYNC_LOOPS;
	
	/* register the tasklet */
	tasklet_init(&data->tlet, jit_tasklet_fn, (unsigned long)data);
	data->hi = hi;
	if (hi)
		tasklet_hi_schedule(&data->tlet);
	else
		tasklet_schedule(&data->tlet);

	/* wait for the buffer to fill */
	wait_event_interruptible(data->wait, !data->loops);

	if (signal_pending(current))
		return -ERESTARTSYS;
	buf2 = data->buf;
	kfree(data);
	*eof = 1;
	return buf2 - buf;
}



int __init jit_init(void)
{
	create_proc_read_entry("currentime", 0, NULL, jit_currentime, NULL);
	create_proc_read_entry("jitbusy", 0, NULL, jit_fn, (void *)JIT_BUSY);
	create_proc_read_entry("jitsched",0, NULL, jit_fn, (void *)JIT_SCHED);
	create_proc_read_entry("jitqueue",0, NULL, jit_fn, (void *)JIT_QUEUE);
	create_proc_read_entry("jitschedto", 0, NULL, jit_fn, (void *)JIT_SCHEDTO);

	create_proc_read_entry("jitimer", 0, NULL, jit_timer, NULL);
	create_proc_read_entry("jitasklet", 0, NULL, jit_tasklet, NULL);
	create_proc_read_entry("jitasklethi", 0, NULL, jit_tasklet, (void *)1);

	return 0; /* success */
}

void __exit jit_cleanup(void)
{
	remove_proc_entry("currentime", NULL);
	remove_proc_entry("jitbusy", NULL);
	remove_proc_entry("jitsched", NULL);
	remove_proc_entry("jitqueue", NULL);
	remove_proc_entry("jitschedto", NULL);

	remove_proc_entry("jitimer", NULL);
	remove_proc_entry("jitasklet", NULL);
	remove_proc_entry("jitasklethi", NULL);
}

module_init(jit_init);
module_exit(jit_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_kdataalign">
			<text>
				<![CDATA[/*
 * kdatasize.c -- print the size of common data items from kernel space
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/utsname.h>
#include <linux/errno.h>

/*
 * Define several data structures, all of them start with a lone char
 * in order to present an unaligned offset for the next field
 */
struct c   {char c;  char      t;} c;
struct s   {char c;  short     t;} s;
struct i   {char c;  int       t;} i;
struct l   {char c;  long      t;} l;
struct ll  {char c;  long long t;} ll;
struct p   {char c;  void *    t;} p;
struct u1b {char c;  __u8      t;} u1b;
struct u2b {char c;  __u16     t;} u2b;
struct u4b {char c;  __u32     t;} u4b;
struct u8b {char c;  __u64     t;} u8b;

static void data_cleanup(void)
{
	/* never called */
}

static int data_init(void)
{
	/* print information and return an error */
	printk("arch  Align:  char  short  int  long   ptr long-long "
		" u8 u16 u32 u64\n");
	printk("%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
		"%%3i %%3i %%3i %%3i\n",
		system_utsname.machine,
		/* note that gcc can subtract void * values, but it's not ansi */
		(int)((void *)(&c.t)   - (void *)&c),
		(int)((void *)(&s.t)   - (void *)&s),
		(int)((void *)(&i.t)   - (void *)&i),
		(int)((void *)(&l.t)   - (void *)&l),
		(int)((void *)(&p.t)   - (void *)&p),
		(int)((void *)(&ll.t)  - (void *)&ll),
		(int)((void *)(&u1b.t) - (void *)&u1b),
		(int)((void *)(&u2b.t) - (void *)&u2b),
		(int)((void *)(&u4b.t) - (void *)&u4b),
		(int)((void *)(&u8b.t) - (void *)&u8b));
	return -ENODEV;
}

module_init(data_init);
module_exit(data_cleanup);

MODULE_LICENSE("Dual BSD/GPL");
]]>
			</text>
		</p>
		<p n="xlnx_drv_kdatasize">
			<text>
				<![CDATA[/*
 * kdatasize.c -- print the size of common data items from kernel space
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/utsname.h>
#include <linux/errno.h>

static void data_cleanup(void)
{
	/* never called */
}

int data_init(void)
{
	/* print information and return an error */
	printk("arch   Size:  char  short  int  long   ptr long-long "
		" u8 u16 u32 u64\n");
	printk("%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
		"%%3i %%3i %%3i %%3i\n",
		system_utsname.machine,
		(int)sizeof(char), (int)sizeof(short), (int)sizeof(int),
		(int)sizeof(long),
		(int)sizeof(void *), (int)sizeof(long long), (int)sizeof(__u8),
		(int)sizeof(__u16), (int)sizeof(__u32), (int)sizeof(__u64));
	return -ENODEV;
}

module_init(data_init);
module_exit(data_cleanup);

MODULE_LICENSE("Dual BSD/GPL");
]]>
			</text>
		</p>
		<p n="xlnx_drv_seq">
			<text>
				<![CDATA[/*
 * Simple demonstration of the seq_file interface.
 *
 * $Id: seq.c,v 1.3 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/fs.h>
#include <linux/seq_file.h>
#include <linux/slab.h>


MODULE_AUTHOR("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");



/*
 * The sequence iterator functions.  The position as seen by the
 * filesystem is just the count that we return.
 */
static void *ct_seq_start(struct seq_file *s, loff_t *pos)
{
	loff_t *spos = kmalloc(sizeof(loff_t), GFP_KERNEL);
	if (!spos)
		return NULL;
	*spos = *pos;
	return spos;
}

static void *ct_seq_next(struct seq_file *s, void *v, loff_t *pos)
{
	loff_t *spos = (loff_t *) v;
	*pos = ++(*spos);
	return spos;
}

static void ct_seq_stop(struct seq_file *s, void *v)
{
	kfree (v);
}

/*
 * The show function.
 */
static int ct_seq_show(struct seq_file *s, void *v)
{
	loff_t *spos = (loff_t *) v;
	seq_printf(s, "%%Ld\n", *spos);
	return 0;
}

/*
 * Tie them all together into a set of seq_operations.
 */
static struct seq_operations ct_seq_ops = {
	.start = ct_seq_start,
	.next  = ct_seq_next,
	.stop  = ct_seq_stop,
	.show  = ct_seq_show
};


/*
 * Time to set up the file operations for our /proc file.  In this case,
 * all we need is an open function which sets up the sequence ops.
 */

static int ct_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ct_seq_ops);
};

/*
 * The file operations structure contains our open function along with
 * set of the canned seq_ ops.
 */
static struct file_operations ct_file_ops = {
	.owner   = THIS_MODULE,
	.open    = ct_open,
	.read    = seq_read,
	.llseek  = seq_lseek,
	.release = seq_release
};
	
	
/*
 * Module setup and teardown.
 */

static int ct_init(void)
{
	struct proc_dir_entry *entry;

	entry = create_proc_entry("sequence", 0, NULL);
	if (entry)
		entry->proc_fops = &ct_file_ops;
	return 0;
}

static void ct_exit(void)
{
	remove_proc_entry("sequence", NULL);
}

module_init(ct_init);
module_exit(ct_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_silly">
			<text>
				<![CDATA[/*
 * silly.c -- Simple Tool for Unloading and Printing ISA Data
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: silly.c,v 1.3 2004/09/26 07:02:43 gregkh Exp $
 */

/* =========================> BIG FAT WARNING:
 * This will only work on architectures with an ISA memory range.
 * It won't work on other computers.
 */

#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>
#include <linux/version.h>

#include <linux/sched.h>
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>	  /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/ioport.h>
#include <linux/poll.h>

#include <asm/io.h>
#include <asm/uaccess.h>

int silly_major = 0;
module_param(silly_major, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

/*
 * The devices access the 640k-1M memory.
 * minor 0 uses ioread8/iowrite8
 * minor 1 uses ioread16/iowrite16
 * minor 2 uses ioread32/iowrite32
 * minor 3 uses memcpy_fromio()/memcpy_toio()
 */

/*
 * Here's our address range, and a place to store the ioremap'd base.
 */
#define ISA_BASE	0xA0000
#define ISA_MAX		0x100000  /* for general memory access */

#define VIDEO_MAX	0xC0000  /* for vga access */
#define VGA_BASE	0xb8000
static void __iomem *io_base;



int silly_open(struct inode *inode, struct file *filp)
{
	return 0;
}

int silly_release(struct inode *inode, struct file *filp)
{
	return 0;
}

enum silly_modes {M_8=0, M_16, M_32, M_memcpy};

ssize_t silly_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	int retval;
	int mode = iminor(filp->f_dentry->d_inode);
	void __iomem *add;
	unsigned long isa_addr = ISA_BASE + *f_pos;
	unsigned char *kbuf, *ptr;

	if (isa_addr + count > ISA_MAX) /* range: 0xA0000-0x100000 */
		count = ISA_MAX - isa_addr;

	/*
	 * too big an f_pos (caused by a malicious lseek())
	 * would result in a negative count
	 */
	if (count < 0)
		return 0;

	kbuf = kmalloc(count, GFP_KERNEL);
	if (!kbuf)
		return -ENOMEM;
	ptr = kbuf;
	retval = count;
	/*
	 * Convert our address into our remapped area.
	 */
	add = (void __iomem *)(io_base + (isa_addr - ISA_BASE));
	/*
	 * kbuf is aligned, but the reads might not. In order not to
	 * drive me mad with unaligned leading and trailing bytes,
	 * I downgrade the `mode' if unaligned xfers are requested.
	 */

	if (mode == M_32 && ((isa_addr | count) & 3))
		mode = M_16;
	if (mode == M_16 && ((isa_addr | count) & 1))
		mode = M_8;

	switch(mode) {
	  case M_32: 
		while (count >= 4) {
			*(u32 *)ptr = ioread32(add);
			add += 4;
			count -= 4;
			ptr += 4;
		}
		break;
	    
	  case M_16: 
		while (count >= 2) {
			*(u16 *)ptr = ioread16(add);
			add+=2;
			count-=2;
			ptr+=2;
		}
		break;
	    
	  case M_8: 
		while (count) {
			*ptr = ioread8(add);
			add++;
			count--;
			ptr++;
		}
		break;

	  case M_memcpy:
		memcpy_fromio(ptr, add, count);
		break;

	    default:
		return -EINVAL;
	}
	if ((retval > 0) && copy_to_user(buf, kbuf, retval))
		retval = -EFAULT;
	kfree(kbuf);
	*f_pos += retval;
	return retval;
}


ssize_t silly_write(struct file *filp, const char __user *buf, size_t count,
		    loff_t *f_pos)
{
	int retval;
	int mode = iminor(filp->f_dentry->d_inode);
	unsigned long isa_addr = ISA_BASE + *f_pos;
	unsigned char *kbuf, *ptr;
	void __iomem *add;

	/*
	 * Writing is dangerous.
	 * Allow root-only, independently of device permissions
	 */
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

	if (isa_addr + count > ISA_MAX) /* range: 0xA0000-0x100000 */
		count = ISA_MAX - isa_addr;

	/*
	 * too big an f_pos (caused by a malicious lseek())
	 * results in a negative count
	 */
	if (count < 0)
		return 0;

	kbuf = kmalloc(count, GFP_KERNEL);
	if (!kbuf)
		return -ENOMEM;
	ptr = kbuf;
	retval=count;

	/*
	 * kbuf is aligned, but the writes might not. In order not to
	 * drive me mad with unaligned leading and trailing bytes,
	 * I downgrade the `mode' if unaligned xfers are requested.
	 */

	if (mode == M_32 && ((isa_addr | count) & 3))
		mode = M_16;
	if (mode == M_16 && ((isa_addr | count) & 1))
		mode = M_8;

	if (copy_from_user(kbuf, buf, count)) {
		kfree(kbuf);
		return -EFAULT;
	}
	ptr = kbuf;

	/*
	 * Switch over to our remapped address space.
	 */
	add = (void __iomem *)(io_base + (isa_addr - ISA_BASE));

	switch(mode) {
	  case M_32: 
		while (count >= 4) {
			iowrite8(*(u32 *)ptr, add);
			add += 4;
			count -= 4;
			ptr += 4;
		}
		break;
	    
	  case M_16: 
		while (count >= 2) {
			iowrite8(*(u16 *)ptr, add);
			add += 2;
			count -= 2;
			ptr += 2;
		}
		break;
	    
	  case M_8: 
		while (count) {
			iowrite8(*ptr, add);
			add++;
			count--;
			ptr++;
		}
		break;

	  case M_memcpy:
		memcpy_toio(add, ptr, count);
		break;

	  default:
		return -EINVAL;
	}
	*f_pos += retval;
	kfree(kbuf);
	return retval;
}


unsigned int silly_poll(struct file *filp, poll_table *wait)
{
    return POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
}


struct file_operations silly_fops = {
	.read =	    silly_read,
	.write =    silly_write,
	.poll =	    silly_poll,
	.open =	    silly_open,
	.release =  silly_release,
	.owner =    THIS_MODULE
};

int silly_init(void)
{
	int result = register_chrdev(silly_major, "silly", &silly_fops);
	if (result < 0) {
		printk(KERN_INFO "silly: can't get major number\n");
		return result;
	}
	if (silly_major == 0)
		silly_major = result; /* dynamic */
	/*
	 * Set up our I/O range.
	 */

	/* this line appears in silly_init */
	io_base = ioremap(ISA_BASE, ISA_MAX - ISA_BASE);
	return 0;
}

void silly_cleanup(void)
{
	iounmap(io_base);
	unregister_chrdev(silly_major, "silly");
}


module_init(silly_init);
module_exit(silly_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_sleepy">
			<text>
				<![CDATA[/*
 * sleepy.c -- the writers awake the readers
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: sleepy.c,v 1.7 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/module.h>
#include <linux/init.h>

#include <linux/sched.h>  /* current and everything */
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>     /* everything... */
#include <linux/types.h>  /* size_t */
#include <linux/wait.h>

MODULE_LICENSE("Dual BSD/GPL");

static int sleepy_major = 0;

static DECLARE_WAIT_QUEUE_HEAD(wq);
static int flag = 0;

ssize_t sleepy_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) going to sleep\n",
			current->pid, current->comm);
	wait_event_interruptible(wq, flag != 0);
	flag = 0;
	printk(KERN_DEBUG "awoken %%i (%%s)\n", current->pid, current->comm);
	return 0; /* EOF */
}

ssize_t sleepy_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) awakening the readers...\n",
			current->pid, current->comm);
	flag = 1;
	wake_up_interruptible(&wq);
	return count; /* succeed, to avoid retrial */
}


struct file_operations sleepy_fops = {
	.owner = THIS_MODULE,
	.read =  sleepy_read,
	.write = sleepy_write,
};


int sleepy_init(void)
{
	int result;

	/*
	 * Register your major, and accept a dynamic number
	 */
	result = register_chrdev(sleepy_major, "sleepy", &sleepy_fops);
	if (result < 0)
		return result;
	if (sleepy_major == 0)
		sleepy_major = result; /* dynamic */
	return 0;
}

void sleepy_cleanup(void)
{
	unregister_chrdev(sleepy_major, "sleepy");
}

module_init(sleepy_init);
module_exit(sleepy_cleanup);

]]>
			</text>
		</p>
		<p n="xlnx_drv_asynctest">
			<text>
				<![CDATA[/*
 * asynctest.c: use async notification to read stdin
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>

int gotdata=0;
void sighandler(int signo)
{
    if (signo==SIGIO)
        gotdata++;
    return;
}

char buffer[4096];

int main(int argc, char **argv)
{
    int count;
    struct sigaction action;

    memset(&action, 0, sizeof(action));
    action.sa_handler = sighandler;
    action.sa_flags = 0;

    sigaction(SIGIO, &action, NULL);

    fcntl(STDIN_FILENO, F_SETOWN, getpid());
    fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL) | FASYNC);

    while(1) {
        /* this only returns if a signal arrives */
        sleep(86400); /* one day */
        if (!gotdata)
            continue;
        count=read(0, buffer, 4096);
        /* buggy: if avail data is more than 4kbytes... */
        write(1,buffer,count);
        gotdata=0;
    }
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_dataalign">
			<text>
				<![CDATA[/*
 * dataalign.c -- show alignment needs
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 */
#include <stdio.h>
#include <sys/utsname.h>
#include <linux/types.h>

/*
 * Define several data structures, all of them start with a lone char
 * in order to present an unaligned offset for the next field
 */
struct c   {char c;  char      t;} c;
struct s   {char c;  short     t;} s;
struct i   {char c;  int       t;} i;
struct l   {char c;  long      t;} l;
struct ll  {char c;  long long t;} ll;
struct p   {char c;  void *    t;} p;
struct u1b {char c;  __u8      t;} u1b;
struct u2b {char c;  __u16     t;} u2b;
struct u4b {char c;  __u32     t;} u4b;
struct u8b {char c;  __u64     t;} u8b;

int main(int argc, char **argv)
{
    struct utsname name;

    uname(&name); /* never fails :) */
    printf("arch  Align:  char  short  int  long   ptr long-long "
	   " u8 u16 u32 u64\n");
    printf(       "%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
	   "%%3i %%3i %%3i %%3i\n",
	   name.machine,
	   /* note that gcc can subtract void * values, but it's not ansi */
	   (int)((void *)(&c.t)   - (void *)&c),
	   (int)((void *)(&s.t)   - (void *)&s),
	   (int)((void *)(&i.t)   - (void *)&i),
	   (int)((void *)(&l.t)   - (void *)&l),
	   (int)((void *)(&p.t)   - (void *)&p),
	   (int)((void *)(&ll.t)  - (void *)&ll),
	   (int)((void *)(&u1b.t) - (void *)&u1b),
	   (int)((void *)(&u2b.t) - (void *)&u2b),
	   (int)((void *)(&u4b.t) - (void *)&u4b),
	   (int)((void *)(&u8b.t) - (void *)&u8b));
    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_datasize">
			<text>
				<![CDATA[/*
 * datasize.c -- print the size of common data items
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */
#include <stdio.h>
#include <sys/utsname.h>
#include <linux/types.h>

int main(int argc, char **argv)
{
    struct utsname name;

    uname(&name); /* never fails :) */
    printf("arch   Size:  char  short  int  long   ptr long-long "
	   " u8 u16 u32 u64\n");
    printf(       "%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
	   "%%3i %%3i %%3i %%3i\n",
	   name.machine,
	   (int)sizeof(char), (int)sizeof(short), (int)sizeof(int),
	   (int)sizeof(long),
	   (int)sizeof(void *), (int)sizeof(long long), (int)sizeof(__u8),
	   (int)sizeof(__u16), (int)sizeof(__u32), (int)sizeof(__u64));
    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_inp">
			<text>
				<![CDATA[/* 
 * inp.c -- read all the ports specified in hex on the command line.
 *     The program uses the faster ioperm/iopl calls on x86, /dev/port
 *     on other platforms. The program acts as inb/inw/inl according
 *     to its own name
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <asm/io.h> /* linux-specific */

#ifdef __GLIBC__
#  include <sys/perm.h>
#endif

#define PORT_FILE "/dev/port"

char *prgname;

#ifdef __i386__
static int read_and_print_one(unsigned int port,int size)
{
    static int iopldone = 0;

    if (port > 1024) {
	if (!iopldone && iopl(3)) {
	    fprintf(stderr, "%%s: iopl(): %%s\n", prgname, strerror(errno));
	    return 1;
	}
	iopldone++;
    } else if (ioperm(port,size,1)) {
	fprintf(stderr, "%%s: ioperm(%%x): %%s\n", prgname,
		port, strerror(errno));
	return 1;
    }

    if (size == 4)
	printf("%%04x: %%08x\n", port, inl(port));
    else if (size == 2)
	printf("%%04x: %%04x\n", port, inw(port));
    else
	printf("%%04x: %%02x\n", port, inb(port));
    return 0;
}
#else /* not i386 */

static int read_and_print_one(unsigned int port,int size)
{
    static int fd = -1;
    unsigned char b; unsigned short w; unsigned int l;

    if (fd < 0)
	fd = open(PORT_FILE, O_RDONLY);
    if (fd < 0) {
	fprintf(stderr, "%%s: %%s: %%s\n", prgname, PORT_FILE, strerror(errno));
	return 1;
    }
    lseek(fd, port, SEEK_SET);
    
    if (size == 4) {
	read(fd, &l, 4);
	printf("%%04x: 0x%%08x\n", port, l);
    } else if (size == 2) {
	read(fd, &w, 2);
	printf("%%04x: 0x%%04x\n", port, w & 0xffff);
    } else {
	read(fd, &b, 1);
	printf("%%04x: 0x%%02x\n", port, b & 0xff);
    }
    return 0;
}

#endif /* i386 */


int main(int argc, char **argv)
{
    unsigned int i, n, port, size, error = 0;
    
    prgname = argv[0];
    /* find the data size */
    switch (prgname[strlen(prgname)-1]) {
        case 'w': size = 2; break;
        case 'l': size = 4; break;
        case 'b': case 'p': default:
	    size = 1;
    }

    setuid(0); /* if we're setuid, force it on */
    for (i = 1; i < argc; i++) {
        if ( sscanf(argv[i], "%%x%%n", &port, &n) < 1
	      || n != strlen(argv[i]) ) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not a hex number\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
	if (port & (size-1)) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not properly aligned\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
	error += read_and_print_one(port, size);
    }
    exit (error ? 1 : 0);
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_load50">
			<text>
				<![CDATA[/*
 * load50.c -- a simple busy-looping tool. 
 * Obviously, this runs with any kernel and any Unix
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */ 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv)
{
	int i, load=50;

	if (argc==2) {
		load=atoi(argv[1]);
	}
	printf("Bringing load to %%i\n",load);
  
	for (i=0; i<load; i++)
		if (fork()==0)
			break;

	while(1)
		;
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_mapcmp">
			<text>
				<![CDATA[/*
 * Simple program to compare two mmap'd areas.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: mapcmp.c,v 1.2 2004/03/05 17:35:41 corbet Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/errno.h>
#include <fcntl.h>

static char *mapdev (const char *, unsigned long, unsigned long);
#define PAGE_SIZE 4096

/*
 * memcmp dev1 dev2 offset pages
 */
int main (int argc, char **argv)
{
	unsigned long offset, size, i;
	char *addr1, *addr2;
/*
 * Sanity check.
 */
	if (argc != 5)
	{
		fprintf (stderr, "Usage: mapcmp dev1 dev2 offset pages\n");
		exit (1);
	}
/*
 * Map the two devices.
 */
	offset = strtoul (argv[3], NULL, 16);
	size = atoi (argv[4])*PAGE_SIZE;
	printf ("Offset is 0x%%lx\n", offset);
	addr1 = mapdev (argv[1], offset, size);
	addr2 = mapdev (argv[2], offset, size);
/*
 * Do the comparison.
 */
	printf ("Comparing...");
	fflush (stdout);
	for (i = 0; i < size; i++)
		if (*addr1++ != *addr2++)
		{
			printf ("areas differ at byte %%ld\n", i);
			exit (0);
		}
	printf ("areas are identical.\n");
	exit (0);
}



static char *mapdev (const char *dev, unsigned long offset,
		unsigned long size)
{
	char *addr;
	int fd = open (dev, O_RDONLY);

	if (fd < 0)
	{
		perror (dev);
		exit (1);
	}
	addr = mmap (0, size, PROT_READ, MAP_PRIVATE, fd, offset);
	if (addr == MAP_FAILED)
	{
		perror (dev);
		exit (1);
	}
	printf ("Mapped %%s (%%lu @ %%lx) at %%p\n", dev, size, offset, addr);
	return (addr);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_mapper">
			<text>
				<![CDATA[/*
 * mapper.c -- simple file that mmap()s a file region and prints it
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>
#include <limits.h>

int main(int argc, char **argv)
{
    char *fname;
    FILE *f;
    unsigned long offset, len;
    void *address;

    if (argc !=4
       || sscanf(argv[2],"%%li", &offset) != 1
       || sscanf(argv[3],"%%li", &len) != 1) {
        fprintf(stderr, "%%s: Usage \"%%s <file> <offset> <len>\"\n", argv[0],
                argv[0]);
        exit(1);
    }
    /* the offset might be big (e.g., PCI devices), but conversion trims it */
    if (offset == INT_MAX) {
	if (argv[2][1]=='x')
            sscanf(argv[2]+2, "%%lx", &offset);
        else
            sscanf(argv[2], "%%lu", &offset);
    }

    fname=argv[1];

    if (!(f=fopen(fname,"r"))) {
        fprintf(stderr, "%%s: %%s: %%s\n", argv[0], fname, strerror(errno));
        exit(1);
    }

    address=mmap(0, len, PROT_READ, MAP_FILE | MAP_PRIVATE, fileno(f), offset);

    if (address == (void *)-1) {
        fprintf(stderr,"%%s: mmap(): %%s\n",argv[0],strerror(errno));
        exit(1);
    }
    fclose(f);
    fprintf(stderr, "mapped \"%%s\" from %%lu (0x%%08lx) to %%lu (0x%%08lx)\n",
            fname, offset, offset, offset+len, offset+len);

    fwrite(address, 1, len, stdout);
    return 0;
}
        
]]>
			</text>
		</p>
		<p n="xlnx_drv_nbtest">
			<text>
				<![CDATA[/*
 * nbtest.c: read and write in non-blocking mode
 * This should run with any Unix
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>

char buffer[4096];

int main(int argc, char **argv)
{
	int delay = 1, n, m = 0;

	if (argc > 1)
		delay=atoi(argv[1]);
	fcntl(0, F_SETFL, fcntl(0,F_GETFL) | O_NONBLOCK); /* stdin */
	fcntl(1, F_SETFL, fcntl(1,F_GETFL) | O_NONBLOCK); /* stdout */

	while (1) {
		n = read(0, buffer, 4096);
		if (n >= 0)
			m = write(1, buffer, n);
		if ((n < 0 || m < 0) && (errno != EAGAIN))
			break;
		sleep(delay);
	}
	perror(n < 0 ? "stdin" : "stdout");
	exit(1);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_netifdebug">
			<text>
				<![CDATA[/*
 * netifdebug.c -- change the IFF_DEBUG flag of an interface
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/in.h>

int main(int argc, char **argv)
{
    int action = -1, sock;
    struct ifreq req;
    char *actname;

    if (argc < 2) {
        fprintf(stderr,"%%s: usage is \"%%s <ifname> [<on|off|tell>]\"\n",
                argv[0],argv[0]);
        exit(1);
    }
    if (argc==2)
        actname="tell";
    else
        actname=argv[2];

    /* a silly raw socket just for ioctl()ling it */
    sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (sock < 0) {
        fprintf(stderr, "%%s: socket(): %%s\n", argv[0],strerror(errno));
        exit(1);
    }

    /* retrieve flags */
    strcpy(req.ifr_name, argv[1]);
    if ( ioctl(sock, SIOCGIFFLAGS, &req) < 0) {
        fprintf(stderr, " %%s: ioctl(SIOCGIFFLAGS): %%s\n",
                argv[0],strerror(errno));
        exit(1);
    }

    if (!strcmp(actname,"on")
        || !strcmp(actname,"+")
        || !strcmp(actname,"1"))
        action = IFF_DEBUG;

    if (!strcmp(actname,"off")
        || !strcmp(actname,"-")
        || !strcmp(actname,"0"))
        action = 0;

    if (!strcmp(actname,"tell")
        || actname[0]=='t') {
        printf("%%s: debug is %%s\n", argv[1],
               req.ifr_flags & IFF_DEBUG ? "on" : "off");
        exit(0);
    }

    req.ifr_flags &= ~IFF_DEBUG;
    req.ifr_flags |= action;

    if ( ioctl(sock, SIOCSIFFLAGS, &req) < 0) {
        fprintf(stderr, " %%s: ioctl(SIOCSIFFLAGS): %%s\n",
                argv[0],strerror(errno));
        exit(1);
    }
    exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_outp">
			<text>
				<![CDATA[/* 
 * outp.c -- write all the ports specified in hex on the command line.
 *     The program uses the faster ioperm/iopl calls on x86, /dev/port
 *     on other platforms. The program acts as outb/outw/outl according
 *     to its own name
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <asm/io.h> /* linux-specific */

#ifdef __GLIBC__
#  include <sys/perm.h>
#endif

#define PORT_FILE "/dev/port"

char *prgname;

#ifdef __i386__
static int write_one(unsigned int port, unsigned int val, int size)
{
    static int iopldone = 0;

    if (port > 1024) {
	if (!iopldone && iopl(3)) {
	    fprintf(stderr, "%%s: iopl(): %%s\n", prgname, strerror(errno));
	    return 1;
	}
	iopldone++;
    } else if (ioperm(port,size,1)) {
	fprintf(stderr, "%%s: ioperm(%%x): %%s\n", prgname,
		port, strerror(errno));
	return 1;
    }

    if (size == 4)
	outl(val, port);
    else if (size == 2)
	outw(val&0xffff, port);
    else
	outb(val&0xff, port);
    return 0;
}
#else /* not i386 */

static int write_one(unsigned int port, unsigned int val, int size)
{
    static int fd = -1;
    unsigned char b; unsigned short w;

    if (fd < 0)
	fd = open(PORT_FILE, O_WRONLY);
    if (fd < 0) {
	fprintf(stderr, "%%s: %%s: %%s\n", prgname, PORT_FILE, strerror(errno));
	return 1;
    }
    lseek(fd, port, SEEK_SET);
    
    if (size == 4) {
	write(fd, &val, 4);
    } else if (size == 2) {
	w = val;
	write(fd, &w, 2);
    } else {
	b = val;
	write(fd, &b, 1);
    }
    return 0;
}

#endif /* i386 */

int main(int argc, char **argv)
{
    unsigned int i, n, port, val, size, error = 0;
    
    prgname = argv[0];
    /* find the data size */
    switch (prgname[strlen(prgname)-1]) {
        case 'w': size = 2; break;
        case 'l': size = 4; break;
        case 'b': case 'p': default:
	    size = 1;
    }
    setuid(0); /* if we're setuid, force it on */
    for (i=1;i<argc-1;i++) {
        if ( sscanf(argv[i], "%%x%%n", &port, &n) < 1
	      || n != strlen(argv[i]) ) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not a hex number\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
	if (port & (size-1)) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not properly aligned\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
        if ( sscanf(argv[i+1], "%%x%%n", &val, &n) < 1
	      || n != strlen(argv[i+1]) ) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not a hex number\n",
		    argv[0], argv[i+1]);
	    error++; continue;
	}
	if (size < 4 && val > (size == 1 ? 0xff : 0xffff)) {
	    fprintf(stderr, "%%s: argument \"%%s\" out of range\n",
		    argv[0], argv[i+1]);
	    error++; continue;
	}
	error += write_one(port, val, size);
    }
    exit (error ? 1 : 0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_polltest">
			<text>
				<![CDATA[/*
 * Test out reading with poll()
 * This should run with any Unix
 *
 * Copyright (C) 2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: polltest.c,v 1.1 2003/02/07 18:01:38 corbet Exp $
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/poll.h>
#include <fcntl.h>

char buffer[4096];

int main(int argc, char **argv)
{
    struct pollfd pfd;
    int n;

    fcntl(0, F_SETFL, fcntl(0,F_GETFL) | O_NONBLOCK); /* stdin */
    pfd.fd = 0;  /* stdin */
    pfd.events = POLLIN;

    while (1) {
        n=read(0, buffer, 4096);
        if (n >= 0)
            write(1, buffer, n);
	n = poll(&pfd, 1, -1);
	if (n < 0)
	    break;
    }
    perror( n<0 ? "stdin" : "stdout");
    exit(1);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_setconsole">
			<text>
				<![CDATA[/*
 * setconsole.c -- choose a console to receive kernel messages
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/ioctl.h>

int main(int argc, char **argv)
{
    char bytes[2] = {11,0}; /* 11 is the TIOCLINUX cmd number */

    if (argc==2) bytes[1] = atoi(argv[1]); /* the chosen console */
    else {
        fprintf(stderr, "%%s: need a single arg\n",argv[0]); exit(1);
    }
    if (ioctl(STDIN_FILENO, TIOCLINUX, bytes)<0) {    /* use stdin */
        fprintf(stderr,"%%s: ioctl(stdin, TIOCLINUX): %%s\n",
                argv[0], strerror(errno));
        exit(1);
    }
    exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_setlevel">
			<text>
				<![CDATA[/*
 * setlevel.c -- choose a console_loglevel for the kernel
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
/* #include <unistd.h> */ /* conflicting on the alpha */
#define __LIBRARY__ /* _syscall3 and friends are only available through this */
#include <linux/unistd.h>

/* define the system call, to override the library function */
_syscall3(int, syslog, int, type, char *, bufp, int, len);

int main(int argc, char **argv)
{
    int level;

    if (argc==2) {
	level = atoi(argv[1]); /* the chosen console */
    } else {
        fprintf(stderr, "%%s: need a single arg\n",argv[0]); exit(1);
    }
    if (syslog(8,NULL,level) < 0) {  
        fprintf(stderr,"%%s: syslog(setlevel): %%s\n",
                argv[0],strerror(errno));
        exit(1);
    }
    exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_pci_skel">
			<text>
				<![CDATA[#include <linux/config.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/pci.h>
#include <linux/init.h>


static struct pci_device_id ids[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801AA_3), },
	{ 0, }
};
MODULE_DEVICE_TABLE(pci, ids);

static unsigned char skel_get_revision(struct pci_dev *dev)
{
	u8 revision;

	pci_read_config_byte(dev, PCI_REVISION_ID, &revision);
	return revision;
}

static int probe(struct pci_dev *dev, const struct pci_device_id *id)
{
	/* Do probing type stuff here.  
	 * Like calling request_region();
	 */
	pci_enable_device(dev);
	
	if (skel_get_revision(dev) == 0x42)
		return -ENODEV;


	return 0;
}

static void remove(struct pci_dev *dev)
{
	/* clean up any allocated resources and stuff here.
	 * like call release_region();
	 */
}

static struct pci_driver pci_driver = {
	.name = "pci_skel",
	.id_table = ids,
	.probe = probe,
	.remove = remove,
};

static int __init pci_skel_init(void)
{
	return pci_register_driver(&pci_driver);
}

static void __exit pci_skel_exit(void)
{
	pci_unregister_driver(&pci_driver);
}

MODULE_LICENSE("GPL");

module_init(pci_skel_init);
module_exit(pci_skel_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_sbull">
			<text>
				<![CDATA[/*
 * Sample disk driver, from the beginning.
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/sched.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/timer.h>
#include <linux/types.h>	/* size_t */
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/hdreg.h>	/* HDIO_GETGEO */
#include <linux/kdev_t.h>
#include <linux/vmalloc.h>
#include <linux/genhd.h>
#include <linux/blkdev.h>
#include <linux/buffer_head.h>	/* invalidate_bdev */
#include <linux/bio.h>

MODULE_LICENSE("Dual BSD/GPL");

static int sbull_major = 0;
module_param(sbull_major, int, 0);
static int hardsect_size = 512;
module_param(hardsect_size, int, 0);
static int nsectors = 1024;	/* How big the drive is */
module_param(nsectors, int, 0);
static int ndevices = 4;
module_param(ndevices, int, 0);

/*
 * The different "request modes" we can use.
 */
enum {
	RM_SIMPLE  = 0,	/* The extra-simple request function */
	RM_FULL    = 1,	/* The full-blown version */
	RM_NOQUEUE = 2,	/* Use make_request */
};
static int request_mode = RM_SIMPLE;
module_param(request_mode, int, 0);

/*
 * Minor number and partition management.
 */
#define SBULL_MINORS	16
#define MINOR_SHIFT	4
#define DEVNUM(kdevnum)	(MINOR(kdev_t_to_nr(kdevnum)) >> MINOR_SHIFT

/*
 * We can tweak our hardware sector size, but the kernel talks to us
 * in terms of small sectors, always.
 */
#define KERNEL_SECTOR_SIZE	512

/*
 * After this much idle time, the driver will simulate a media change.
 */
#define INVALIDATE_DELAY	30*HZ

/*
 * The internal representation of our device.
 */
struct sbull_dev {
        int size;                       /* Device size in sectors */
        u8 *data;                       /* The data array */
        short users;                    /* How many users */
        short media_change;             /* Flag a media change? */
        spinlock_t lock;                /* For mutual exclusion */
        struct request_queue *queue;    /* The device request queue */
        struct gendisk *gd;             /* The gendisk structure */
        struct timer_list timer;        /* For simulated media changes */
};

static struct sbull_dev *Devices = NULL;

/*
 * Handle an I/O request.
 */
static void sbull_transfer(struct sbull_dev *dev, unsigned long sector,
		unsigned long nsect, char *buffer, int write)
{
	unsigned long offset = sector*KERNEL_SECTOR_SIZE;
	unsigned long nbytes = nsect*KERNEL_SECTOR_SIZE;

	if ((offset + nbytes) > dev->size) {
		printk (KERN_NOTICE "Beyond-end write (%%ld %%ld)\n", offset, nbytes);
		return;
	}
	if (write)
		memcpy(dev->data + offset, buffer, nbytes);
	else
		memcpy(buffer, dev->data + offset, nbytes);
}

/*
 * The simple form of the request function.
 */
static void sbull_request(request_queue_t *q)
{
	struct request *req;

	while ((req = elv_next_request(q)) != NULL) {
		struct sbull_dev *dev = req->rq_disk->private_data;
		if (! blk_fs_request(req)) {
			printk (KERN_NOTICE "Skip non-fs request\n");
			end_request(req, 0);
			continue;
		}
    //    	printk (KERN_NOTICE "Req dev %%d dir %%ld sec %%ld, nr %%d f %%lx\n",
    //    			dev - Devices, rq_data_dir(req),
    //    			req->sector, req->current_nr_sectors,
    //    			req->flags);
		sbull_transfer(dev, req->sector, req->current_nr_sectors,
				req->buffer, rq_data_dir(req));
		end_request(req, 1);
	}
}


/*
 * Transfer a single BIO.
 */
static int sbull_xfer_bio(struct sbull_dev *dev, struct bio *bio)
{
	int i;
	struct bio_vec *bvec;
	sector_t sector = bio->bi_sector;

	/* Do each segment independently. */
	bio_for_each_segment(bvec, bio, i) {
		char *buffer = __bio_kmap_atomic(bio, i, KM_USER0);
		sbull_transfer(dev, sector, bio_cur_sectors(bio),
				buffer, bio_data_dir(bio) == WRITE);
		sector += bio_cur_sectors(bio);
		__bio_kunmap_atomic(bio, KM_USER0);
	}
	return 0; /* Always "succeed" */
}

/*
 * Transfer a full request.
 */
static int sbull_xfer_request(struct sbull_dev *dev, struct request *req)
{
	struct bio *bio;
	int nsect = 0;
    
	rq_for_each_bio(bio, req) {
		sbull_xfer_bio(dev, bio);
		nsect += bio->bi_size/KERNEL_SECTOR_SIZE;
	}
	return nsect;
}



/*
 * Smarter request function that "handles clustering".
 */
static void sbull_full_request(request_queue_t *q)
{
	struct request *req;
	int sectors_xferred;
	struct sbull_dev *dev = q->queuedata;

	while ((req = elv_next_request(q)) != NULL) {
		if (! blk_fs_request(req)) {
			printk (KERN_NOTICE "Skip non-fs request\n");
			end_request(req, 0);
			continue;
		}
		sectors_xferred = sbull_xfer_request(dev, req);
		if (! end_that_request_first(req, 1, sectors_xferred)) {
			blkdev_dequeue_request(req);
			end_that_request_last(req);
		}
	}
}



/*
 * The direct make request version.
 */
static int sbull_make_request(request_queue_t *q, struct bio *bio)
{
	struct sbull_dev *dev = q->queuedata;
	int status;

	status = sbull_xfer_bio(dev, bio);
	bio_endio(bio, bio->bi_size, status);
	return 0;
}


/*
 * Open and close.
 */

static int sbull_open(struct inode *inode, struct file *filp)
{
	struct sbull_dev *dev = inode->i_bdev->bd_disk->private_data;

	del_timer_sync(&dev->timer);
	filp->private_data = dev;
	spin_lock(&dev->lock);
	if (! dev->users) 
		check_disk_change(inode->i_bdev);
	dev->users++;
	spin_unlock(&dev->lock);
	return 0;
}

static int sbull_release(struct inode *inode, struct file *filp)
{
	struct sbull_dev *dev = inode->i_bdev->bd_disk->private_data;

	spin_lock(&dev->lock);
	dev->users--;

	if (!dev->users) {
		dev->timer.expires = jiffies + INVALIDATE_DELAY;
		add_timer(&dev->timer);
	}
	spin_unlock(&dev->lock);

	return 0;
}

/*
 * Look for a (simulated) media change.
 */
int sbull_media_changed(struct gendisk *gd)
{
	struct sbull_dev *dev = gd->private_data;
	
	return dev->media_change;
}

/*
 * Revalidate.  WE DO NOT TAKE THE LOCK HERE, for fear of deadlocking
 * with open.  That needs to be reevaluated.
 */
int sbull_revalidate(struct gendisk *gd)
{
	struct sbull_dev *dev = gd->private_data;
	
	if (dev->media_change) {
		dev->media_change = 0;
		memset (dev->data, 0, dev->size);
	}
	return 0;
}

/*
 * The "invalidate" function runs out of the device timer; it sets
 * a flag to simulate the removal of the media.
 */
void sbull_invalidate(unsigned long ldev)
{
	struct sbull_dev *dev = (struct sbull_dev *) ldev;

	spin_lock(&dev->lock);
	if (dev->users || !dev->data) 
		printk (KERN_WARNING "sbull: timer sanity check failed\n");
	else
		dev->media_change = 1;
	spin_unlock(&dev->lock);
}

/*
 * The ioctl() implementation
 */

int sbull_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{
	long size;
	struct hd_geometry geo;
	struct sbull_dev *dev = filp->private_data;

	switch(cmd) {
	    case HDIO_GETGEO:
        	/*
		 * Get geometry: since we are a virtual device, we have to make
		 * up something plausible.  So we claim 16 sectors, four heads,
		 * and calculate the corresponding number of cylinders.  We set the
		 * start of data at sector four.
		 */
		size = dev->size*(hardsect_size/KERNEL_SECTOR_SIZE);
		geo.cylinders = (size & ~0x3f) >> 6;
		geo.heads = 4;
		geo.sectors = 16;
		geo.start = 4;
		if (copy_to_user((void __user *) arg, &geo, sizeof(geo)))
			return -EFAULT;
		return 0;
	}

	return -ENOTTY; /* unknown command */
}



/*
 * The device operations structure.
 */
static struct block_device_operations sbull_ops = {
	.owner           = THIS_MODULE,
	.open 	         = sbull_open,
	.release 	 = sbull_release,
	.media_changed   = sbull_media_changed,
	.revalidate_disk = sbull_revalidate,
	.ioctl	         = sbull_ioctl
};


/*
 * Set up our internal device.
 */
static void setup_device(struct sbull_dev *dev, int which)
{
	/*
	 * Get some memory.
	 */
	memset (dev, 0, sizeof (struct sbull_dev));
	dev->size = nsectors*hardsect_size;
	dev->data = vmalloc(dev->size);
	if (dev->data == NULL) {
		printk (KERN_NOTICE "vmalloc failure.\n");
		return;
	}
	spin_lock_init(&dev->lock);
	
	/*
	 * The timer which "invalidates" the device.
	 */
	init_timer(&dev->timer);
	dev->timer.data = (unsigned long) dev;
	dev->timer.function = sbull_invalidate;
	
	/*
	 * The I/O queue, depending on whether we are using our own
	 * make_request function or not.
	 */
	switch (request_mode) {
	    case RM_NOQUEUE:
		dev->queue = blk_alloc_queue(GFP_KERNEL);
		if (dev->queue == NULL)
			goto out_vfree;
		blk_queue_make_request(dev->queue, sbull_make_request);
		break;

	    case RM_FULL:
		dev->queue = blk_init_queue(sbull_full_request, &dev->lock);
		if (dev->queue == NULL)
			goto out_vfree;
		break;

	    default:
		printk(KERN_NOTICE "Bad request mode %%d, using simple\n", request_mode);
        	/* fall into.. */
	
	    case RM_SIMPLE:
		dev->queue = blk_init_queue(sbull_request, &dev->lock);
		if (dev->queue == NULL)
			goto out_vfree;
		break;
	}
	blk_queue_hardsect_size(dev->queue, hardsect_size);
	dev->queue->queuedata = dev;
	/*
	 * And the gendisk structure.
	 */
	dev->gd = alloc_disk(SBULL_MINORS);
	if (! dev->gd) {
		printk (KERN_NOTICE "alloc_disk failure\n");
		goto out_vfree;
	}
	dev->gd->major = sbull_major;
	dev->gd->first_minor = which*SBULL_MINORS;
	dev->gd->fops = &sbull_ops;
	dev->gd->queue = dev->queue;
	dev->gd->private_data = dev;
	snprintf (dev->gd->disk_name, 32, "sbull%%c", which + 'a');
	set_capacity(dev->gd, nsectors*(hardsect_size/KERNEL_SECTOR_SIZE));
	add_disk(dev->gd);
	return;

  out_vfree:
	if (dev->data)
		vfree(dev->data);
}



static int __init sbull_init(void)
{
	int i;
	/*
	 * Get registered.
	 */
	sbull_major = register_blkdev(sbull_major, "sbull");
	if (sbull_major <= 0) {
		printk(KERN_WARNING "sbull: unable to get major number\n");
		return -EBUSY;
	}
	/*
	 * Allocate the device array, and initialize each one.
	 */
	Devices = kmalloc(ndevices*sizeof (struct sbull_dev), GFP_KERNEL);
	if (Devices == NULL)
		goto out_unregister;
	for (i = 0; i < ndevices; i++) 
		setup_device(Devices + i, i);
    
	return 0;

  out_unregister:
	unregister_blkdev(sbull_major, "sbd");
	return -ENOMEM;
}

static void sbull_exit(void)
{
	int i;

	for (i = 0; i < ndevices; i++) {
		struct sbull_dev *dev = Devices + i;

		del_timer_sync(&dev->timer);
		if (dev->gd) {
			del_gendisk(dev->gd);
			put_disk(dev->gd);
		}
		if (dev->queue) {
			if (request_mode == RM_NOQUEUE)
				blk_put_queue(dev->queue);
			else
				blk_cleanup_queue(dev->queue);
		}
		if (dev->data)
			vfree(dev->data);
	}
	unregister_blkdev(sbull_major, "sbull");
	kfree(Devices);
}
	
module_init(sbull_init);
module_exit(sbull_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_access">
			<text>
				<![CDATA[/*
 * access.c -- the files with access control on open
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: access.c,v 1.17 2004/09/26 07:29:56 gregkh Exp $
 */

/* FIXME: cloned devices as a use for kobjects? */
 
#include <linux/kernel.h> /* printk() */
#include <linux/module.h>
#include <linux/slab.h>   /* kmalloc() */
#include <linux/fs.h>     /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/types.h>  /* size_t */
#include <linux/fcntl.h>
#include <linux/cdev.h>
#include <linux/tty.h>
#include <asm/atomic.h>
#include <linux/list.h>

#include "scull.h"        /* local definitions */

static dev_t scull_a_firstdev;  /* Where our range begins */

/*
 * These devices fall back on the main scull operations. They only
 * differ in the implementation of open() and close()
 */



/************************************************************************
 *
 * The first device is the single-open one,
 *  it has an hw structure and an open count
 */

static struct scull_dev scull_s_device;
static atomic_t scull_s_available = ATOMIC_INIT(1);

static int scull_s_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_s_device; /* device information */

	if (! atomic_dec_and_test (&scull_s_available)) {
		atomic_inc(&scull_s_available);
		return -EBUSY; /* already open */
	}

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_s_release(struct inode *inode, struct file *filp)
{
	atomic_inc(&scull_s_available); /* release the device */
	return 0;
}


/*
 * The other operations for the single-open device come from the bare device
 */
struct file_operations scull_sngl_fops = {
	.owner =	THIS_MODULE,
	.llseek =     	scull_llseek,
	.read =       	scull_read,
	.write =      	scull_write,
	.ioctl =      	scull_ioctl,
	.open =       	scull_s_open,
	.release =    	scull_s_release,
};


/************************************************************************
 *
 * Next, the "uid" device. It can be opened multiple times by the
 * same user, but access is denied to other users if the device is open
 */

static struct scull_dev scull_u_device;
static int scull_u_count;	/* initialized to 0 by default */
static uid_t scull_u_owner;	/* initialized to 0 by default */
static spinlock_t scull_u_lock = SPIN_LOCK_UNLOCKED;

static int scull_u_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_u_device; /* device information */

	spin_lock(&scull_u_lock);
	if (scull_u_count && 
			(scull_u_owner != current->uid) &&  /* allow user */
			(scull_u_owner != current->euid) && /* allow whoever did su */
			!capable(CAP_DAC_OVERRIDE)) { /* still allow root */
		spin_unlock(&scull_u_lock);
		return -EBUSY;   /* -EPERM would confuse the user */
	}

	if (scull_u_count == 0)
		scull_u_owner = current->uid; /* grab it */

	scull_u_count++;
	spin_unlock(&scull_u_lock);

/* then, everything else is copied from the bare scull device */

	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_u_release(struct inode *inode, struct file *filp)
{
	spin_lock(&scull_u_lock);
	scull_u_count--; /* nothing else */
	spin_unlock(&scull_u_lock);
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_user_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_u_open,
	.release =    scull_u_release,
};


/************************************************************************
 *
 * Next, the device with blocking-open based on uid
 */

static struct scull_dev scull_w_device;
static int scull_w_count;	/* initialized to 0 by default */
static uid_t scull_w_owner;	/* initialized to 0 by default */
static DECLARE_WAIT_QUEUE_HEAD(scull_w_wait);
static spinlock_t scull_w_lock = SPIN_LOCK_UNLOCKED;

static inline int scull_w_available(void)
{
	return scull_w_count == 0 ||
		scull_w_owner == current->uid ||
		scull_w_owner == current->euid ||
		capable(CAP_DAC_OVERRIDE);
}


static int scull_w_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_w_device; /* device information */

	spin_lock(&scull_w_lock);
	while (! scull_w_available()) {
		spin_unlock(&scull_w_lock);
		if (filp->f_flags & O_NONBLOCK) return -EAGAIN;
		if (wait_event_interruptible (scull_w_wait, scull_w_available()))
			return -ERESTARTSYS; /* tell the fs layer to handle it */
		spin_lock(&scull_w_lock);
	}
	if (scull_w_count == 0)
		scull_w_owner = current->uid; /* grab it */
	scull_w_count++;
	spin_unlock(&scull_w_lock);

	/* then, everything else is copied from the bare scull device */
	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_w_release(struct inode *inode, struct file *filp)
{
	int temp;

	spin_lock(&scull_w_lock);
	scull_w_count--;
	temp = scull_w_count;
	spin_unlock(&scull_w_lock);

	if (temp == 0)
		wake_up_interruptible_sync(&scull_w_wait); /* awake other uid's */
	return 0;
}


/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_wusr_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_w_open,
	.release =    scull_w_release,
};

/************************************************************************
 *
 * Finally the `cloned' private device. This is trickier because it
 * involves list management, and dynamic allocation.
 */

/* The clone-specific data structure includes a key field */

struct scull_listitem {
	struct scull_dev device;
	dev_t key;
	struct list_head list;
    
};

/* The list of devices, and a lock to protect it */
static LIST_HEAD(scull_c_list);
static spinlock_t scull_c_lock = SPIN_LOCK_UNLOCKED;

/* A placeholder scull_dev which really just holds the cdev stuff. */
static struct scull_dev scull_c_device;   

/* Look for a device or create one if missing */
static struct scull_dev *scull_c_lookfor_device(dev_t key)
{
	struct scull_listitem *lptr;

	list_for_each_entry(lptr, &scull_c_list, list) {
		if (lptr->key == key)
			return &(lptr->device);
	}

	/* not found */
	lptr = kmalloc(sizeof(struct scull_listitem), GFP_KERNEL);
	if (!lptr)
		return NULL;

	/* initialize the device */
	memset(lptr, 0, sizeof(struct scull_listitem));
	lptr->key = key;
	scull_trim(&(lptr->device)); /* initialize it */
	init_MUTEX(&(lptr->device.sem));

	/* place it in the list */
	list_add(&lptr->list, &scull_c_list);

	return &(lptr->device);
}

static int scull_c_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev;
	dev_t key;
 
	if (!current->signal->tty) { 
		PDEBUG("Process \"%%s\" has no ctl tty\n", current->comm);
		return -EINVAL;
	}
	key = tty_devnum(current->signal->tty);

	/* look for a scullc device in the list */
	spin_lock(&scull_c_lock);
	dev = scull_c_lookfor_device(key);
	spin_unlock(&scull_c_lock);

	if (!dev)
		return -ENOMEM;

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_c_release(struct inode *inode, struct file *filp)
{
	/*
	 * Nothing to do, because the device is persistent.
	 * A `real' cloned device should be freed on last close
	 */
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_priv_fops = {
	.owner =    THIS_MODULE,
	.llseek =   scull_llseek,
	.read =     scull_read,
	.write =    scull_write,
	.ioctl =    scull_ioctl,
	.open =     scull_c_open,
	.release =  scull_c_release,
};

/************************************************************************
 *
 * And the init and cleanup functions come last
 */

static struct scull_adev_info {
	char *name;
	struct scull_dev *sculldev;
	struct file_operations *fops;
} scull_access_devs[] = {
	{ "scullsingle", &scull_s_device, &scull_sngl_fops },
	{ "sculluid", &scull_u_device, &scull_user_fops },
	{ "scullwuid", &scull_w_device, &scull_wusr_fops },
	{ "sullpriv", &scull_c_device, &scull_priv_fops }
};
#define SCULL_N_ADEVS 4

/*
 * Set up a single device.
 */
static void scull_access_setup (dev_t devno, struct scull_adev_info *devinfo)
{
	struct scull_dev *dev = devinfo->sculldev;
	int err;

	/* Initialize the device structure */
	dev->quantum = scull_quantum;
	dev->qset = scull_qset;
	init_MUTEX(&dev->sem);

	/* Do the cdev stuff. */
	cdev_init(&dev->cdev, devinfo->fops);
	kobject_set_name(&dev->cdev.kobj, devinfo->name);
	dev->cdev.owner = THIS_MODULE;
	err = cdev_add (&dev->cdev, devno, 1);
        /* Fail gracefully if need be */
	if (err) {
		printk(KERN_NOTICE "Error %%d adding %%s\n", err, devinfo->name);
		kobject_put(&dev->cdev.kobj);
	} else
		printk(KERN_NOTICE "%%s registered at %%x\n", devinfo->name, devno);
}


int scull_access_init(dev_t firstdev)
{
	int result, i;

	/* Get our number space */
	result = register_chrdev_region (firstdev, SCULL_N_ADEVS, "sculla");
	if (result < 0) {
		printk(KERN_WARNING "sculla: device number registration failed\n");
		return 0;
	}
	scull_a_firstdev = firstdev;

	/* Set up each device. */
	for (i = 0; i < SCULL_N_ADEVS; i++)
		scull_access_setup (firstdev + i, scull_access_devs + i);
	return SCULL_N_ADEVS;
}

/*
 * This is called by cleanup_module or on failure.
 * It is required to never fail, even if nothing was initialized first
 */
void scull_access_cleanup(void)
{
	struct scull_listitem *lptr, *next;
	int i;

	/* Clean up the static devs */
	for (i = 0; i < SCULL_N_ADEVS; i++) {
		struct scull_dev *dev = scull_access_devs[i].sculldev;
		cdev_del(&dev->cdev);
		scull_trim(scull_access_devs[i].sculldev);
	}

    	/* And all the cloned devices */
	list_for_each_entry_safe(lptr, next, &scull_c_list, list) {
		list_del(&lptr->list);
		scull_trim(&(lptr->device));
		kfree(lptr);
	}

	/* Free up our number space */
	unregister_chrdev_region(scull_a_firstdev, SCULL_N_ADEVS);
	return;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_main">
			<text>
				<![CDATA[/*
 * main.c -- the bare scull char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/seq_file.h>
#include <linux/cdev.h>

#include <asm/system.h>		/* cli(), *_flags */
#include <asm/uaccess.h>	/* copy_*_user */

#include "scull.h"		/* local definitions */

/*
 * Our parameters which can be set at load time.
 */

int scull_major =   SCULL_MAJOR;
int scull_minor =   0;
int scull_nr_devs = SCULL_NR_DEVS;	/* number of bare scull devices */
int scull_quantum = SCULL_QUANTUM;
int scull_qset =    SCULL_QSET;

module_param(scull_major, int, S_IRUGO);
module_param(scull_minor, int, S_IRUGO);
module_param(scull_nr_devs, int, S_IRUGO);
module_param(scull_quantum, int, S_IRUGO);
module_param(scull_qset, int, S_IRUGO);

MODULE_AUTHOR("Alessandro Rubini, Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");

struct scull_dev *scull_devices;	/* allocated in scull_init_module */


/*
 * Empty out the scull device; must be called with the device
 * semaphore held.
 */
int scull_trim(struct scull_dev *dev)
{
	struct scull_qset *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	for (dptr = dev->data; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			for (i = 0; i < qset; i++)
				kfree(dptr->data[i]);
			kfree(dptr->data);
			dptr->data = NULL;
		}
		next = dptr->next;
		kfree(dptr);
	}
	dev->size = 0;
	dev->quantum = scull_quantum;
	dev->qset = scull_qset;
	dev->data = NULL;
	return 0;
}
#ifdef SCULL_DEBUG /* use proc only if debugging */
/*
 * The proc filesystem: function to read and entry
 */

int scull_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, len = 0;
	int limit = count - 80; /* Don't print more than this */

	for (i = 0; i < scull_nr_devs && len <= limit; i++) {
		struct scull_dev *d = &scull_devices[i];
		struct scull_qset *qs = d->data;
		if (down_interruptible(&d->sem))
			return -ERESTARTSYS;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, q %%i, sz %%li\n",
				i, d->qset, d->quantum, d->size);
		for (; qs && len <= limit; qs = qs->next) { /* scan the list */
			len += sprintf(buf + len, "  item at %%p, qset at %%p\n",
					qs, qs->data);
			if (qs->data && !qs->next) /* dump only the last item */
				for (j = 0; j < d->qset; j++) {
					if (qs->data[j])
						len += sprintf(buf + len,
								"    %% 4i: %%8p\n",
								j, qs->data[j]);
				}
		}
		up(&scull_devices[i].sem);
	}
	*eof = 1;
	return len;
}


/*
 * For now, the seq_file implementation will exist in parallel.  The
 * older read_procmem function should maybe go away, though.
 */

/*
 * Here are our sequence iteration methods.  Our "position" is
 * simply the device number.
 */
static void *scull_seq_start(struct seq_file *s, loff_t *pos)
{
	if (*pos >= scull_nr_devs)
		return NULL;   /* No more to read */
	return scull_devices + *pos;
}

static void *scull_seq_next(struct seq_file *s, void *v, loff_t *pos)
{
	(*pos)++;
	if (*pos >= scull_nr_devs)
		return NULL;
	return scull_devices + *pos;
}

static void scull_seq_stop(struct seq_file *s, void *v)
{
	/* Actually, there's nothing to do here */
}

static int scull_seq_show(struct seq_file *s, void *v)
{
	struct scull_dev *dev = (struct scull_dev *) v;
	struct scull_qset *d;
	int i;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;
	seq_printf(s, "\nDevice %%i: qset %%i, q %%i, sz %%li\n",
			(int) (dev - scull_devices), dev->qset,
			dev->quantum, dev->size);
	for (d = dev->data; d; d = d->next) { /* scan the list */
		seq_printf(s, "  item at %%p, qset at %%p\n", d, d->data);
		if (d->data && !d->next) /* dump only the last item */
			for (i = 0; i < dev->qset; i++) {
				if (d->data[i])
					seq_printf(s, "    %% 4i: %%8p\n",
							i, d->data[i]);
			}
	}
	up(&dev->sem);
	return 0;
}
	
/*
 * Tie the sequence operators up.
 */
static struct seq_operations scull_seq_ops = {
	.start = scull_seq_start,
	.next  = scull_seq_next,
	.stop  = scull_seq_stop,
	.show  = scull_seq_show
};

/*
 * Now to implement the /proc file we need only make an open
 * method which sets up the sequence operators.
 */
static int scull_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &scull_seq_ops);
}

/*
 * Create a set of file operations for our proc file.
 */
static struct file_operations scull_proc_ops = {
	.owner   = THIS_MODULE,
	.open    = scull_proc_open,
	.read    = seq_read,
	.llseek  = seq_lseek,
	.release = seq_release
};
	

/*
 * Actually create (and remove) the /proc file(s).
 */

static void scull_create_proc(void)
{
	struct proc_dir_entry *entry;
	create_proc_read_entry("scullmem", 0 /* default mode */,
			NULL /* parent dir */, scull_read_procmem,
			NULL /* client data */);
	entry = create_proc_entry("scullseq", 0, NULL);
	if (entry)
		entry->proc_fops = &scull_proc_ops;
}

static void scull_remove_proc(void)
{
	/* no problem if it was not registered */
	remove_proc_entry("scullmem", NULL /* parent dir */);
	remove_proc_entry("scullseq", NULL);
}


#endif /* SCULL_DEBUG */





/*
 * Open and close
 */

int scull_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev; /* device information */

	dev = container_of(inode->i_cdev, struct scull_dev, cdev);
	filp->private_data = dev; /* for other methods */

	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible(&dev->sem))
			return -ERESTARTSYS;
		scull_trim(dev); /* ignore errors */
		up(&dev->sem);
	}
	return 0;          /* success */
}

int scull_release(struct inode *inode, struct file *filp)
{
	return 0;
}
/*
 * Follow the list
 */
struct scull_qset *scull_follow(struct scull_dev *dev, int n)
{
	struct scull_qset *qs = dev->data;

        /* Allocate first qset explicitly if need be */
	if (! qs) {
		qs = dev->data = kmalloc(sizeof(struct scull_qset), GFP_KERNEL);
		if (qs == NULL)
			return NULL;  /* Never mind */
		memset(qs, 0, sizeof(struct scull_qset));
	}

	/* Then follow the list */
	while (n--) {
		if (!qs->next) {
			qs->next = kmalloc(sizeof(struct scull_qset), GFP_KERNEL);
			if (qs->next == NULL)
				return NULL;  /* Never mind */
			memset(qs->next, 0, sizeof(struct scull_qset));
		}
		qs = qs->next;
		continue;
	}
	return qs;
}

/*
 * Data management: read and write
 */

ssize_t scull_read(struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_dev *dev = filp->private_data; 
	struct scull_qset *dptr;	/* the first listitem */
	int quantum = dev->quantum, qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos >= dev->size)
		goto out;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;

	/* find listitem, qset index, and offset in the quantum */
	item = (long)*f_pos / itemsize;
	rest = (long)*f_pos %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position (defined elsewhere) */
	dptr = scull_follow(dev, item);

	if (dptr == NULL || !dptr->data || ! dptr->data[s_pos])
		goto out; /* don't fill holes */

	/* read only up to the end of this quantum */
	if (count > quantum - q_pos)
		count = quantum - q_pos;

	if (copy_to_user(buf, dptr->data[s_pos] + q_pos, count)) {
		retval = -EFAULT;
		goto out;
	}
	*f_pos += count;
	retval = count;

  out:
	up(&dev->sem);
	return retval;
}

ssize_t scull_write(struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_dev *dev = filp->private_data;
	struct scull_qset *dptr;
	int quantum = dev->quantum, qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* value used in "goto out" statements */

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = (long)*f_pos / itemsize;
	rest = (long)*f_pos %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scull_follow(dev, item);
	if (dptr == NULL)
		goto out;
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(char *), GFP_KERNEL);
		if (!dptr->data)
			goto out;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] = kmalloc(quantum, GFP_KERNEL);
		if (!dptr->data[s_pos])
			goto out;
	}
	/* write only up to the end of this quantum */
	if (count > quantum - q_pos)
		count = quantum - q_pos;

	if (copy_from_user(dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto out;
	}
	*f_pos += count;
	retval = count;

        /* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;

  out:
	up(&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scull_ioctl(struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, tmp;
	int retval = 0;
    
	/*
	 * extract the type and number bitfields, and don't decode
	 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
	 */
	if (_IOC_TYPE(cmd) != SCULL_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULL_IOC_MAXNR) return -ENOTTY;

	/*
	 * the direction is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. `Type' is user-oriented, while
	 * access_ok is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err) return -EFAULT;

	switch(cmd) {

	  case SCULL_IOCRESET:
		scull_quantum = SCULL_QUANTUM;
		scull_qset = SCULL_QSET;
		break;
        
	  case SCULL_IOCSQUANTUM: /* Set: arg points to the value */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		retval = __get_user(scull_quantum, (int __user *)arg);
		break;

	  case SCULL_IOCTQUANTUM: /* Tell: arg is the value */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		scull_quantum = arg;
		break;

	  case SCULL_IOCGQUANTUM: /* Get: arg is pointer to result */
		retval = __put_user(scull_quantum, (int __user *)arg);
		break;

	  case SCULL_IOCQQUANTUM: /* Query: return it (it's positive) */
		return scull_quantum;

	  case SCULL_IOCXQUANTUM: /* eXchange: use arg as pointer */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_quantum;
		retval = __get_user(scull_quantum, (int __user *)arg);
		if (retval == 0)
			retval = __put_user(tmp, (int __user *)arg);
		break;

	  case SCULL_IOCHQUANTUM: /* sHift: like Tell + Query */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_quantum;
		scull_quantum = arg;
		return tmp;
        
	  case SCULL_IOCSQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		retval = __get_user(scull_qset, (int __user *)arg);
		break;

	  case SCULL_IOCTQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		scull_qset = arg;
		break;

	  case SCULL_IOCGQSET:
		retval = __put_user(scull_qset, (int __user *)arg);
		break;

	  case SCULL_IOCQQSET:
		return scull_qset;

	  case SCULL_IOCXQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_qset;
		retval = __get_user(scull_qset, (int __user *)arg);
		if (retval == 0)
			retval = put_user(tmp, (int __user *)arg);
		break;

	  case SCULL_IOCHQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_qset;
		scull_qset = arg;
		return tmp;

        /*
         * The following two change the buffer size for scullpipe.
         * The scullpipe device uses this same ioctl method, just to
         * write less code. Actually, it's the same driver, isn't it?
         */

	  case SCULL_P_IOCTSIZE:
		scull_p_buffer = arg;
		break;

	  case SCULL_P_IOCQSIZE:
		return scull_p_buffer;


	  default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}
	return retval;

}



/*
 * The "extended" operations -- only seek
 */

loff_t scull_llseek(struct file *filp, loff_t off, int whence)
{
	struct scull_dev *dev = filp->private_data;
	loff_t newpos;

	switch(whence) {
	  case 0: /* SEEK_SET */
		newpos = off;
		break;

	  case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	  case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	  default: /* can't happen */
		return -EINVAL;
	}
	if (newpos < 0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}



struct file_operations scull_fops = {
	.owner =    THIS_MODULE,
	.llseek =   scull_llseek,
	.read =     scull_read,
	.write =    scull_write,
	.ioctl =    scull_ioctl,
	.open =     scull_open,
	.release =  scull_release,
};

/*
 * Finally, the module stuff
 */

/*
 * The cleanup function is used to handle initialization failures as well.
 * Thefore, it must be careful to work correctly even if some of the items
 * have not been initialized
 */
void scull_cleanup_module(void)
{
	int i;
	dev_t devno = MKDEV(scull_major, scull_minor);

	/* Get rid of our char dev entries */
	if (scull_devices) {
		for (i = 0; i < scull_nr_devs; i++) {
			scull_trim(scull_devices + i);
			cdev_del(&scull_devices[i].cdev);
		}
		kfree(scull_devices);
	}

#ifdef SCULL_DEBUG /* use proc only if debugging */
	scull_remove_proc();
#endif

	/* cleanup_module is never called if registering failed */
	unregister_chrdev_region(devno, scull_nr_devs);

	/* and call the cleanup functions for friend devices */
	scull_p_cleanup();
	scull_access_cleanup();

}


/*
 * Set up the char_dev structure for this device.
 */
static void scull_setup_cdev(struct scull_dev *dev, int index)
{
	int err, devno = MKDEV(scull_major, scull_minor + index);
    
	cdev_init(&dev->cdev, &scull_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scull_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}


int scull_init_module(void)
{
	int result, i;
	dev_t dev = 0;

/*
 * Get a range of minor numbers to work with, asking for a dynamic
 * major unless directed otherwise at load time.
 */
	if (scull_major) {
		dev = MKDEV(scull_major, scull_minor);
		result = register_chrdev_region(dev, scull_nr_devs, "scull");
	} else {
		result = alloc_chrdev_region(&dev, scull_minor, scull_nr_devs,
				"scull");
		scull_major = MAJOR(dev);
	}
	if (result < 0) {
		printk(KERN_WARNING "scull: can't get major %%d\n", scull_major);
		return result;
	}

        /* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scull_devices = kmalloc(scull_nr_devs * sizeof(struct scull_dev), GFP_KERNEL);
	if (!scull_devices) {
		result = -ENOMEM;
		goto fail;  /* Make this more graceful */
	}
	memset(scull_devices, 0, scull_nr_devs * sizeof(struct scull_dev));

        /* Initialize each device. */
	for (i = 0; i < scull_nr_devs; i++) {
		scull_devices[i].quantum = scull_quantum;
		scull_devices[i].qset = scull_qset;
		init_MUTEX(&scull_devices[i].sem);
		scull_setup_cdev(&scull_devices[i], i);
	}

        /* At this point call the init function for any friend device */
	dev = MKDEV(scull_major, scull_minor + scull_nr_devs);
	dev += scull_p_init(dev);
	dev += scull_access_init(dev);

#ifdef SCULL_DEBUG /* only when debugging */
	scull_create_proc();
#endif

	return 0; /* succeed */

  fail:
	scull_cleanup_module();
	return result;
}

module_init(scull_init_module);
module_exit(scull_cleanup_module);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_access">
			<text>
				<![CDATA[/*
 * access.c -- the files with access control on open
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: access.c,v 1.17 2004/09/26 07:29:56 gregkh Exp $
 */

/* FIXME: cloned devices as a use for kobjects? */
 
#include <linux/kernel.h> /* printk() */
#include <linux/module.h>
#include <linux/slab.h>   /* kmalloc() */
#include <linux/fs.h>     /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/types.h>  /* size_t */
#include <linux/fcntl.h>
#include <linux/cdev.h>
#include <linux/tty.h>
#include <asm/atomic.h>
#include <linux/list.h>

#include "scull.h"        /* local definitions */

static dev_t scull_a_firstdev;  /* Where our range begins */

/*
 * These devices fall back on the main scull operations. They only
 * differ in the implementation of open() and close()
 */



/************************************************************************
 *
 * The first device is the single-open one,
 *  it has an hw structure and an open count
 */

static struct scull_dev scull_s_device;
static atomic_t scull_s_available = ATOMIC_INIT(1);

static int scull_s_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_s_device; /* device information */

	if (! atomic_dec_and_test (&scull_s_available)) {
		atomic_inc(&scull_s_available);
		return -EBUSY; /* already open */
	}

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_s_release(struct inode *inode, struct file *filp)
{
	atomic_inc(&scull_s_available); /* release the device */
	return 0;
}


/*
 * The other operations for the single-open device come from the bare device
 */
struct file_operations scull_sngl_fops = {
	.owner =	THIS_MODULE,
	.llseek =     	scull_llseek,
	.read =       	scull_read,
	.write =      	scull_write,
	.ioctl =      	scull_ioctl,
	.open =       	scull_s_open,
	.release =    	scull_s_release,
};


/************************************************************************
 *
 * Next, the "uid" device. It can be opened multiple times by the
 * same user, but access is denied to other users if the device is open
 */

static struct scull_dev scull_u_device;
static int scull_u_count;	/* initialized to 0 by default */
static uid_t scull_u_owner;	/* initialized to 0 by default */
static spinlock_t scull_u_lock = SPIN_LOCK_UNLOCKED;

static int scull_u_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_u_device; /* device information */

	spin_lock(&scull_u_lock);
	if (scull_u_count && 
			(scull_u_owner != current->uid) &&  /* allow user */
			(scull_u_owner != current->euid) && /* allow whoever did su */
			!capable(CAP_DAC_OVERRIDE)) { /* still allow root */
		spin_unlock(&scull_u_lock);
		return -EBUSY;   /* -EPERM would confuse the user */
	}

	if (scull_u_count == 0)
		scull_u_owner = current->uid; /* grab it */

	scull_u_count++;
	spin_unlock(&scull_u_lock);

/* then, everything else is copied from the bare scull device */

	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_u_release(struct inode *inode, struct file *filp)
{
	spin_lock(&scull_u_lock);
	scull_u_count--; /* nothing else */
	spin_unlock(&scull_u_lock);
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_user_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_u_open,
	.release =    scull_u_release,
};


/************************************************************************
 *
 * Next, the device with blocking-open based on uid
 */

static struct scull_dev scull_w_device;
static int scull_w_count;	/* initialized to 0 by default */
static uid_t scull_w_owner;	/* initialized to 0 by default */
static DECLARE_WAIT_QUEUE_HEAD(scull_w_wait);
static spinlock_t scull_w_lock = SPIN_LOCK_UNLOCKED;

static inline int scull_w_available(void)
{
	return scull_w_count == 0 ||
		scull_w_owner == current->uid ||
		scull_w_owner == current->euid ||
		capable(CAP_DAC_OVERRIDE);
}


static int scull_w_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_w_device; /* device information */

	spin_lock(&scull_w_lock);
	while (! scull_w_available()) {
		spin_unlock(&scull_w_lock);
		if (filp->f_flags & O_NONBLOCK) return -EAGAIN;
		if (wait_event_interruptible (scull_w_wait, scull_w_available()))
			return -ERESTARTSYS; /* tell the fs layer to handle it */
		spin_lock(&scull_w_lock);
	}
	if (scull_w_count == 0)
		scull_w_owner = current->uid; /* grab it */
	scull_w_count++;
	spin_unlock(&scull_w_lock);

	/* then, everything else is copied from the bare scull device */
	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_w_release(struct inode *inode, struct file *filp)
{
	int temp;

	spin_lock(&scull_w_lock);
	scull_w_count--;
	temp = scull_w_count;
	spin_unlock(&scull_w_lock);

	if (temp == 0)
		wake_up_interruptible_sync(&scull_w_wait); /* awake other uid's */
	return 0;
}


/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_wusr_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_w_open,
	.release =    scull_w_release,
};

/************************************************************************
 *
 * Finally the `cloned' private device. This is trickier because it
 * involves list management, and dynamic allocation.
 */

/* The clone-specific data structure includes a key field */

struct scull_listitem {
	struct scull_dev device;
	dev_t key;
	struct list_head list;
    
};

/* The list of devices, and a lock to protect it */
static LIST_HEAD(scull_c_list);
static spinlock_t scull_c_lock = SPIN_LOCK_UNLOCKED;

/* A placeholder scull_dev which really just holds the cdev stuff. */
static struct scull_dev scull_c_device;   

/* Look for a device or create one if missing */
static struct scull_dev *scull_c_lookfor_device(dev_t key)
{
	struct scull_listitem *lptr;

	list_for_each_entry(lptr, &scull_c_list, list) {
		if (lptr->key == key)
			return &(lptr->device);
	}

	/* not found */
	lptr = kmalloc(sizeof(struct scull_listitem), GFP_KERNEL);
	if (!lptr)
		return NULL;

	/* initialize the device */
	memset(lptr, 0, sizeof(struct scull_listitem));
	lptr->key = key;
	scull_trim(&(lptr->device)); /* initialize it */
	init_MUTEX(&(lptr->device.sem));

	/* place it in the list */
	list_add(&lptr->list, &scull_c_list);

	return &(lptr->device);
}

static int scull_c_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev;
	dev_t key;
 
	if (!current->signal->tty) { 
		PDEBUG("Process \"%%s\" has no ctl tty\n", current->comm);
		return -EINVAL;
	}
	key = tty_devnum(current->signal->tty);

	/* look for a scullc device in the list */
	spin_lock(&scull_c_lock);
	dev = scull_c_lookfor_device(key);
	spin_unlock(&scull_c_lock);

	if (!dev)
		return -ENOMEM;

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_c_release(struct inode *inode, struct file *filp)
{
	/*
	 * Nothing to do, because the device is persistent.
	 * A `real' cloned device should be freed on last close
	 */
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_priv_fops = {
	.owner =    THIS_MODULE,
	.llseek =   scull_llseek,
	.read =     scull_read,
	.write =    scull_write,
	.ioctl =    scull_ioctl,
	.open =     scull_c_open,
	.release =  scull_c_release,
};

/************************************************************************
 *
 * And the init and cleanup functions come last
 */

static struct scull_adev_info {
	char *name;
	struct scull_dev *sculldev;
	struct file_operations *fops;
} scull_access_devs[] = {
	{ "scullsingle", &scull_s_device, &scull_sngl_fops },
	{ "sculluid", &scull_u_device, &scull_user_fops },
	{ "scullwuid", &scull_w_device, &scull_wusr_fops },
	{ "sullpriv", &scull_c_device, &scull_priv_fops }
};
#define SCULL_N_ADEVS 4

/*
 * Set up a single device.
 */
static void scull_access_setup (dev_t devno, struct scull_adev_info *devinfo)
{
	struct scull_dev *dev = devinfo->sculldev;
	int err;

	/* Initialize the device structure */
	dev->quantum = scull_quantum;
	dev->qset = scull_qset;
	init_MUTEX(&dev->sem);

	/* Do the cdev stuff. */
	cdev_init(&dev->cdev, devinfo->fops);
	kobject_set_name(&dev->cdev.kobj, devinfo->name);
	dev->cdev.owner = THIS_MODULE;
	err = cdev_add (&dev->cdev, devno, 1);
        /* Fail gracefully if need be */
	if (err) {
		printk(KERN_NOTICE "Error %%d adding %%s\n", err, devinfo->name);
		kobject_put(&dev->cdev.kobj);
	} else
		printk(KERN_NOTICE "%%s registered at %%x\n", devinfo->name, devno);
}


int scull_access_init(dev_t firstdev)
{
	int result, i;

	/* Get our number space */
	result = register_chrdev_region (firstdev, SCULL_N_ADEVS, "sculla");
	if (result < 0) {
		printk(KERN_WARNING "sculla: device number registration failed\n");
		return 0;
	}
	scull_a_firstdev = firstdev;

	/* Set up each device. */
	for (i = 0; i < SCULL_N_ADEVS; i++)
		scull_access_setup (firstdev + i, scull_access_devs + i);
	return SCULL_N_ADEVS;
}

/*
 * This is called by cleanup_module or on failure.
 * It is required to never fail, even if nothing was initialized first
 */
void scull_access_cleanup(void)
{
	struct scull_listitem *lptr, *next;
	int i;

	/* Clean up the static devs */
	for (i = 0; i < SCULL_N_ADEVS; i++) {
		struct scull_dev *dev = scull_access_devs[i].sculldev;
		cdev_del(&dev->cdev);
		scull_trim(scull_access_devs[i].sculldev);
	}

    	/* And all the cloned devices */
	list_for_each_entry_safe(lptr, next, &scull_c_list, list) {
		list_del(&lptr->list);
		scull_trim(&(lptr->device));
		kfree(lptr);
	}

	/* Free up our number space */
	unregister_chrdev_region(scull_a_firstdev, SCULL_N_ADEVS);
	return;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_pipe">
			<text>
				<![CDATA[/*
 * pipe.c -- fifo driver for scull
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */
 
#include <linux/module.h>
#include <linux/moduleparam.h>

#include <linux/kernel.h>	/* printk(), min() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/proc_fs.h>
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/fcntl.h>
#include <linux/poll.h>
#include <linux/cdev.h>
#include <asm/uaccess.h>

#include "scull.h"		/* local definitions */

struct scull_pipe {
        wait_queue_head_t inq, outq;       /* read and write queues */
        char *buffer, *end;                /* begin of buf, end of buf */
        int buffersize;                    /* used in pointer arithmetic */
        char *rp, *wp;                     /* where to read, where to write */
        int nreaders, nwriters;            /* number of openings for r/w */
        struct fasync_struct *async_queue; /* asynchronous readers */
        struct semaphore sem;              /* mutual exclusion semaphore */
        struct cdev cdev;                  /* Char device structure */
};

/* parameters */
static int scull_p_nr_devs = SCULL_P_NR_DEVS;	/* number of pipe devices */
int scull_p_buffer =  SCULL_P_BUFFER;	/* buffer size */
dev_t scull_p_devno;			/* Our first device number */

module_param(scull_p_nr_devs, int, 0);	/* FIXME check perms */
module_param(scull_p_buffer, int, 0);

static struct scull_pipe *scull_p_devices;

static int scull_p_fasync(int fd, struct file *filp, int mode);
static int spacefree(struct scull_pipe *dev);
/*
 * Open and close
 */


static int scull_p_open(struct inode *inode, struct file *filp)
{
	struct scull_pipe *dev;

	dev = container_of(inode->i_cdev, struct scull_pipe, cdev);
	filp->private_data = dev;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;
	if (!dev->buffer) {
		/* allocate the buffer */
		dev->buffer = kmalloc(scull_p_buffer, GFP_KERNEL);
		if (!dev->buffer) {
			up(&dev->sem);
			return -ENOMEM;
		}
	}
	dev->buffersize = scull_p_buffer;
	dev->end = dev->buffer + dev->buffersize;
	dev->rp = dev->wp = dev->buffer; /* rd and wr from the beginning */

	/* use f_mode,not  f_flags: it's cleaner (fs/open.c tells why) */
	if (filp->f_mode & FMODE_READ)
		dev->nreaders++;
	if (filp->f_mode & FMODE_WRITE)
		dev->nwriters++;
	up(&dev->sem);

	return nonseekable_open(inode, filp);
}



static int scull_p_release(struct inode *inode, struct file *filp)
{
	struct scull_pipe *dev = filp->private_data;

	/* remove this filp from the asynchronously notified filp's */
	scull_p_fasync(-1, filp, 0);
	down(&dev->sem);
	if (filp->f_mode & FMODE_READ)
		dev->nreaders--;
	if (filp->f_mode & FMODE_WRITE)
		dev->nwriters--;
	if (dev->nreaders + dev->nwriters == 0) {
		kfree(dev->buffer);
		dev->buffer = NULL; /* the other fields are not checked on open */
	}
	up(&dev->sem);
	return 0;
}


/*
 * Data management: read and write
 */

static ssize_t scull_p_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_pipe *dev = filp->private_data;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;

	while (dev->rp == dev->wp) { /* nothing to read */
		up(&dev->sem); /* release the lock */
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		PDEBUG("\"%%s\" reading: going to sleep\n", current->comm);
		if (wait_event_interruptible(dev->inq, (dev->rp != dev->wp)))
			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
		/* otherwise loop, but first reacquire the lock */
		if (down_interruptible(&dev->sem))
			return -ERESTARTSYS;
	}
	/* ok, data is there, return something */
	if (dev->wp > dev->rp)
		count = min(count, (size_t)(dev->wp - dev->rp));
	else /* the write pointer has wrapped, return data up to dev->end */
		count = min(count, (size_t)(dev->end - dev->rp));
	if (copy_to_user(buf, dev->rp, count)) {
		up (&dev->sem);
		return -EFAULT;
	}
	dev->rp += count;
	if (dev->rp == dev->end)
		dev->rp = dev->buffer; /* wrapped */
	up (&dev->sem);

	/* finally, awake any writers and return */
	wake_up_interruptible(&dev->outq);
	PDEBUG("\"%%s\" did read %%li bytes\n",current->comm, (long)count);
	return count;
}

/* Wait for space for writing; caller must hold device semaphore.  On
 * error the semaphore will be released before returning. */
static int scull_getwritespace(struct scull_pipe *dev, struct file *filp)
{
	while (spacefree(dev) == 0) { /* full */
		DEFINE_WAIT(wait);
		
		up(&dev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		PDEBUG("\"%%s\" writing: going to sleep\n",current->comm);
		prepare_to_wait(&dev->outq, &wait, TASK_INTERRUPTIBLE);
		if (spacefree(dev) == 0)
			schedule();
		finish_wait(&dev->outq, &wait);
		if (signal_pending(current))
			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
		if (down_interruptible(&dev->sem))
			return -ERESTARTSYS;
	}
	return 0;
}	

/* How much space is free? */
static int spacefree(struct scull_pipe *dev)
{
	if (dev->rp == dev->wp)
		return dev->buffersize - 1;
	return ((dev->rp + dev->buffersize - dev->wp) %% dev->buffersize) - 1;
}

static ssize_t scull_p_write(struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_pipe *dev = filp->private_data;
	int result;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;

	/* Make sure there's space to write */
	result = scull_getwritespace(dev, filp);
	if (result)
		return result; /* scull_getwritespace called up(&dev->sem) */

	/* ok, space is there, accept something */
	count = min(count, (size_t)spacefree(dev));
	if (dev->wp >= dev->rp)
		count = min(count, (size_t)(dev->end - dev->wp)); /* to end-of-buf */
	else /* the write pointer has wrapped, fill up to rp-1 */
		count = min(count, (size_t)(dev->rp - dev->wp - 1));
	PDEBUG("Going to accept %%li bytes to %%p from %%p\n", (long)count, dev->wp, buf);
	if (copy_from_user(dev->wp, buf, count)) {
		up (&dev->sem);
		return -EFAULT;
	}
	dev->wp += count;
	if (dev->wp == dev->end)
		dev->wp = dev->buffer; /* wrapped */
	up(&dev->sem);

	/* finally, awake any reader */
	wake_up_interruptible(&dev->inq);  /* blocked in read() and select() */

	/* and signal asynchronous readers, explained late in chapter 5 */
	if (dev->async_queue)
		kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	PDEBUG("\"%%s\" did write %%li bytes\n",current->comm, (long)count);
	return count;
}

static unsigned int scull_p_poll(struct file *filp, poll_table *wait)
{
	struct scull_pipe *dev = filp->private_data;
	unsigned int mask = 0;

	/*
	 * The buffer is circular; it is considered full
	 * if "wp" is right behind "rp" and empty if the
	 * two are equal.
	 */
	down(&dev->sem);
	poll_wait(filp, &dev->inq,  wait);
	poll_wait(filp, &dev->outq, wait);
	if (dev->rp != dev->wp)
		mask |= POLLIN | POLLRDNORM;	/* readable */
	if (spacefree(dev))
		mask |= POLLOUT | POLLWRNORM;	/* writable */
	up(&dev->sem);
	return mask;
}





static int scull_p_fasync(int fd, struct file *filp, int mode)
{
	struct scull_pipe *dev = filp->private_data;

	return fasync_helper(fd, filp, mode, &dev->async_queue);
}



/* FIXME this should use seq_file */
#ifdef SCULL_DEBUG
static void scullp_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {	/* Not there yet */
		*offset -= *len;
		*len = 0;
	}
	else {			/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}


static int scull_read_p_mem(char *buf, char **start, off_t offset, int count,
		int *eof, void *data)
{
	int i, len;
	struct scull_pipe *p;

#define LIMIT (PAGE_SIZE-200)	/* don't print any more after this size */
	*start = buf;
	len = sprintf(buf, "Default buffersize is %%i\n", scull_p_buffer);
	for(i = 0; i<scull_p_nr_devs && len <= LIMIT; i++) {
		p = &scull_p_devices[i];
		if (down_interruptible(&p->sem))
			return -ERESTARTSYS;
		len += sprintf(buf+len, "\nDevice %%i: %%p\n", i, p);
/*		len += sprintf(buf+len, "   Queues: %%p %%p\n", p->inq, p->outq);*/
		len += sprintf(buf+len, "   Buffer: %%p to %%p (%%i bytes)\n", p->buffer, p->end, p->buffersize);
		len += sprintf(buf+len, "   rp %%p   wp %%p\n", p->rp, p->wp);
		len += sprintf(buf+len, "   readers %%i   writers %%i\n", p->nreaders, p->nwriters);
		up(&p->sem);
		scullp_proc_offset(buf, start, &offset, &len);
	}
	*eof = (len <= LIMIT);
	return len;
}


#endif



/*
 * The file operations for the pipe device
 * (some are overlayed with bare scull)
 */
struct file_operations scull_pipe_fops = {
	.owner =	THIS_MODULE,
	.llseek =	no_llseek,
	.read =		scull_p_read,
	.write =	scull_p_write,
	.poll =		scull_p_poll,
	.ioctl =	scull_ioctl,
	.open =		scull_p_open,
	.release =	scull_p_release,
	.fasync =	scull_p_fasync,
};


/*
 * Set up a cdev entry.
 */
static void scull_p_setup_cdev(struct scull_pipe *dev, int index)
{
	int err, devno = scull_p_devno + index;
    
	cdev_init(&dev->cdev, &scull_pipe_fops);
	dev->cdev.owner = THIS_MODULE;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scullpipe%%d", err, index);
}

 

/*
 * Initialize the pipe devs; return how many we did.
 */
int scull_p_init(dev_t firstdev)
{
	int i, result;

	result = register_chrdev_region(firstdev, scull_p_nr_devs, "scullp");
	if (result < 0) {
		printk(KERN_NOTICE "Unable to get scullp region, error %%d\n", result);
		return 0;
	}
	scull_p_devno = firstdev;
	scull_p_devices = kmalloc(scull_p_nr_devs * sizeof(struct scull_pipe), GFP_KERNEL);
	if (scull_p_devices == NULL) {
		unregister_chrdev_region(firstdev, scull_p_nr_devs);
		return 0;
	}
	memset(scull_p_devices, 0, scull_p_nr_devs * sizeof(struct scull_pipe));
	for (i = 0; i < scull_p_nr_devs; i++) {
		init_waitqueue_head(&(scull_p_devices[i].inq));
		init_waitqueue_head(&(scull_p_devices[i].outq));
		init_MUTEX(&scull_p_devices[i].sem);
		scull_p_setup_cdev(scull_p_devices + i, i);
	}
#ifdef SCULL_DEBUG
	create_proc_read_entry("scullpipe", 0, NULL, scull_read_p_mem, NULL);
#endif
	return scull_p_nr_devs;
}

/*
 * This is called by cleanup_module or on failure.
 * It is required to never fail, even if nothing was initialized first
 */
void scull_p_cleanup(void)
{
	int i;

#ifdef SCULL_DEBUG
	remove_proc_entry("scullpipe", NULL);
#endif

	if (!scull_p_devices)
		return; /* nothing else to release */

	for (i = 0; i < scull_p_nr_devs; i++) {
		cdev_del(&scull_p_devices[i].cdev);
		kfree(scull_p_devices[i].buffer);
	}
	kfree(scull_p_devices);
	unregister_chrdev_region(scull_p_devno, scull_p_nr_devs);
	scull_p_devices = NULL; /* pedantic */
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullc_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare scullc char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include "scullc.h"		/* local definitions */


int scullc_major =   SCULLC_MAJOR;
int scullc_devs =    SCULLC_DEVS;	/* number of bare scullc devices */
int scullc_qset =    SCULLC_QSET;
int scullc_quantum = SCULLC_QUANTUM;

module_param(scullc_major, int, 0);
module_param(scullc_devs, int, 0);
module_param(scullc_qset, int, 0);
module_param(scullc_quantum, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct scullc_dev *scullc_devices; /* allocated in scullc_init */

int scullc_trim(struct scullc_dev *dev);
void scullc_cleanup(void);

/* declare one cache pointer: use it for all devices */
kmem_cache_t *scullc_cache;





#ifdef SCULLC_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void scullc_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int scullc_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, quantum, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct scullc_dev *d;

	*start = buf;
	for(i = 0; i < scullc_devs; i++) {
		d = &scullc_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		quantum=d->quantum;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, quantum %%i, sz %%li\n",
				i, qset, quantum, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			scullc_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					scullc_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&scullc_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLC_USE_PROC */

/*
 * Open and close
 */

int scullc_open (struct inode *inode, struct file *filp)
{
	struct scullc_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct scullc_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		scullc_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int scullc_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct scullc_dev *scullc_follow(struct scullc_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct scullc_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct scullc_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t scullc_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullc_dev *dev = filp->private_data; /* the first listitem */
	struct scullc_dev *dptr;
	int quantum = dev->quantum;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = scullc_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t scullc_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullc_dev *dev = filp->private_data;
	struct scullc_dev *dptr;
	int quantum = dev->quantum;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scullc_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Allocate a quantum using the memory cache */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] = kmem_cache_alloc(scullc_cache, GFP_KERNEL);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, scullc_quantum);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scullc_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLC_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLC_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLC_IOCRESET:
		scullc_qset = SCULLC_QSET;
		scullc_quantum = SCULLC_QUANTUM;
		break;

	case SCULLC_IOCSQUANTUM: /* Set: arg points to the value */
		ret = __get_user(scullc_quantum, (int __user *) arg);
		break;

	case SCULLC_IOCTQUANTUM: /* Tell: arg is the value */
		scullc_quantum = arg;
		break;

	case SCULLC_IOCGQUANTUM: /* Get: arg is pointer to result */
		ret = __put_user (scullc_quantum, (int __user *) arg);
		break;

	case SCULLC_IOCQQUANTUM: /* Query: return it (it's positive) */
		return scullc_quantum;

	case SCULLC_IOCXQUANTUM: /* eXchange: use arg as pointer */
		tmp = scullc_quantum;
		ret = __get_user(scullc_quantum, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLC_IOCHQUANTUM: /* sHift: like Tell + Query */
		tmp = scullc_quantum;
		scullc_quantum = arg;
		return tmp;

	case SCULLC_IOCSQSET:
		ret = __get_user(scullc_qset, (int __user *) arg);
		break;

	case SCULLC_IOCTQSET:
		scullc_qset = arg;
		break;

	case SCULLC_IOCGQSET:
		ret = __put_user(scullc_qset, (int __user *)arg);
		break;

	case SCULLC_IOCQQSET:
		return scullc_qset;

	case SCULLC_IOCXQSET:
		tmp = scullc_qset;
		ret = __get_user(scullc_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLC_IOCHQSET:
		tmp = scullc_qset;
		scullc_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t scullc_llseek (struct file *filp, loff_t off, int whence)
{
	struct scullc_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void scullc_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int scullc_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = scullc_write(iocb->ki_filp, buf, count, &pos);
	else
		result = scullc_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, scullc_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t scullc_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return scullc_defer_op(0, iocb, buf, count, pos);
}

static ssize_t scullc_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return scullc_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 

/*
 * The fops
 */

struct file_operations scullc_fops = {
	.owner =     THIS_MODULE,
	.llseek =    scullc_llseek,
	.read =	     scullc_read,
	.write =     scullc_write,
	.ioctl =     scullc_ioctl,
	.open =	     scullc_open,
	.release =   scullc_release,
	.aio_read =  scullc_aio_read,
	.aio_write = scullc_aio_write,
};

int scullc_trim(struct scullc_dev *dev)
{
	struct scullc_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					kmem_cache_free(scullc_cache, dptr->data[i]);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = scullc_qset;
	dev->quantum = scullc_quantum;
	dev->next = NULL;
	return 0;
}


static void scullc_setup_cdev(struct scullc_dev *dev, int index)
{
	int err, devno = MKDEV(scullc_major, index);
    
	cdev_init(&dev->cdev, &scullc_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scullc_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}



/*
 * Finally, the module stuff
 */

int scullc_init(void)
{
	int result, i;
	dev_t dev = MKDEV(scullc_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (scullc_major)
		result = register_chrdev_region(dev, scullc_devs, "scullc");
	else {
		result = alloc_chrdev_region(&dev, 0, scullc_devs, "scullc");
		scullc_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scullc_devices = kmalloc(scullc_devs*sizeof (struct scullc_dev), GFP_KERNEL);
	if (!scullc_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(scullc_devices, 0, scullc_devs*sizeof (struct scullc_dev));
	for (i = 0; i < scullc_devs; i++) {
		scullc_devices[i].quantum = scullc_quantum;
		scullc_devices[i].qset = scullc_qset;
		sema_init (&scullc_devices[i].sem, 1);
		scullc_setup_cdev(scullc_devices + i, i);
	}

	scullc_cache = kmem_cache_create("scullc", scullc_quantum,
			0, SLAB_HWCACHE_ALIGN, NULL, NULL); /* no ctor/dtor */
	if (!scullc_cache) {
		scullc_cleanup();
		return -ENOMEM;
	}

#ifdef SCULLC_USE_PROC /* only when available */
	create_proc_read_entry("scullcmem", 0, NULL, scullc_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, scullc_devs);
	return result;
}



void scullc_cleanup(void)
{
	int i;

#ifdef SCULLC_USE_PROC
	remove_proc_entry("scullcmem", NULL);
#endif

	for (i = 0; i < scullc_devs; i++) {
		cdev_del(&scullc_devices[i].cdev);
		scullc_trim(scullc_devices + i);
	}
	kfree(scullc_devices);

	if (scullc_cache)
		kmem_cache_destroy(scullc_cache);
	unregister_chrdev_region(MKDEV (scullc_major, 0), scullc_devs);
}


module_init(scullc_init);
module_exit(scullc_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullc_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the scullc char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "scullc.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void scullc_vma_open(struct vm_area_struct *vma)
{
	struct scullc_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void scullc_vma_close(struct vm_area_struct *vma)
{
	struct scullc_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the scullc device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *scullc_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct scullc_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the scullc device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct scullc_vm_ops = {
	.open =     scullc_vma_open,
	.close =    scullc_vma_close,
	.nopage =   scullc_vma_nopage,
};


int scullc_mmap(struct file *filp, struct vm_area_struct *vma)
{
	struct inode *inode = filp->f_dentry->d_inode;

	/* refuse to map if order is not 0 */
	if (scullc_devices[iminor(inode)].order)
		return -ENODEV;

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &scullc_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	scullc_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_sculld_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare sculld char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include "sculld.h"		/* local definitions */


int sculld_major =   SCULLD_MAJOR;
int sculld_devs =    SCULLD_DEVS;	/* number of bare sculld devices */
int sculld_qset =    SCULLD_QSET;
int sculld_order =   SCULLD_ORDER;

module_param(sculld_major, int, 0);
module_param(sculld_devs, int, 0);
module_param(sculld_qset, int, 0);
module_param(sculld_order, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct sculld_dev *sculld_devices; /* allocated in sculld_init */

int sculld_trim(struct sculld_dev *dev);
void sculld_cleanup(void);



/* Device model stuff */

static struct ldd_driver sculld_driver = {
	.version = "$Revision: 1.21 $",
	.module = THIS_MODULE,
	.driver = {
		.name = "sculld",
	},
};



#ifdef SCULLD_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void sculld_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int sculld_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, order, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct sculld_dev *d;

	*start = buf;
	for(i = 0; i < sculld_devs; i++) {
		d = &sculld_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		order = d->order;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, order %%i, sz %%li\n",
				i, qset, order, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			sculld_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					sculld_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&sculld_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLD_USE_PROC */

/*
 * Open and close
 */

int sculld_open (struct inode *inode, struct file *filp)
{
	struct sculld_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct sculld_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		sculld_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int sculld_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct sculld_dev *sculld_follow(struct sculld_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct sculld_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct sculld_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t sculld_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct sculld_dev *dev = filp->private_data; /* the first listitem */
	struct sculld_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = sculld_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t sculld_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct sculld_dev *dev = filp->private_data;
	struct sculld_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = sculld_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Here's the allocation of a single quantum */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] =
			(void *)__get_free_pages(GFP_KERNEL, dptr->order);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, PAGE_SIZE << dptr->order);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int sculld_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLD_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLD_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLD_IOCRESET:
		sculld_qset = SCULLD_QSET;
		sculld_order = SCULLD_ORDER;
		break;

	case SCULLD_IOCSORDER: /* Set: arg points to the value */
		ret = __get_user(sculld_order, (int __user *) arg);
		break;

	case SCULLD_IOCTORDER: /* Tell: arg is the value */
		sculld_order = arg;
		break;

	case SCULLD_IOCGORDER: /* Get: arg is pointer to result */
		ret = __put_user (sculld_order, (int __user *) arg);
		break;

	case SCULLD_IOCQORDER: /* Query: return it (it's positive) */
		return sculld_order;

	case SCULLD_IOCXORDER: /* eXchange: use arg as pointer */
		tmp = sculld_order;
		ret = __get_user(sculld_order, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLD_IOCHORDER: /* sHift: like Tell + Query */
		tmp = sculld_order;
		sculld_order = arg;
		return tmp;

	case SCULLD_IOCSQSET:
		ret = __get_user(sculld_qset, (int __user *) arg);
		break;

	case SCULLD_IOCTQSET:
		sculld_qset = arg;
		break;

	case SCULLD_IOCGQSET:
		ret = __put_user(sculld_qset, (int __user *)arg);
		break;

	case SCULLD_IOCQQSET:
		return sculld_qset;

	case SCULLD_IOCXQSET:
		tmp = sculld_qset;
		ret = __get_user(sculld_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLD_IOCHQSET:
		tmp = sculld_qset;
		sculld_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t sculld_llseek (struct file *filp, loff_t off, int whence)
{
	struct sculld_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void sculld_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int sculld_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = sculld_write(iocb->ki_filp, buf, count, &pos);
	else
		result = sculld_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, sculld_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t sculld_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return sculld_defer_op(0, iocb, buf, count, pos);
}

static ssize_t sculld_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return sculld_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 
/*
 * Mmap *is* available, but confined in a different file
 */
extern int sculld_mmap(struct file *filp, struct vm_area_struct *vma);


/*
 * The fops
 */

struct file_operations sculld_fops = {
	.owner =     THIS_MODULE,
	.llseek =    sculld_llseek,
	.read =	     sculld_read,
	.write =     sculld_write,
	.ioctl =     sculld_ioctl,
	.mmap =	     sculld_mmap,
	.open =	     sculld_open,
	.release =   sculld_release,
	.aio_read =  sculld_aio_read,
	.aio_write = sculld_aio_write,
};

int sculld_trim(struct sculld_dev *dev)
{
	struct sculld_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			/* This code frees a whole quantum-set */
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					free_pages((unsigned long)(dptr->data[i]),
							dptr->order);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = sculld_qset;
	dev->order = sculld_order;
	dev->next = NULL;
	return 0;
}


static void sculld_setup_cdev(struct sculld_dev *dev, int index)
{
	int err, devno = MKDEV(sculld_major, index);
    
	cdev_init(&dev->cdev, &sculld_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &sculld_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}

static ssize_t sculld_show_dev(struct device *ddev, char *buf)
{
	struct sculld_dev *dev = ddev->driver_data;

	return print_dev_t(buf, dev->cdev.dev);
}

static DEVICE_ATTR(dev, S_IRUGO, sculld_show_dev, NULL);

static void sculld_register_dev(struct sculld_dev *dev, int index)
{
	sprintf(dev->devname, "sculld%%d", index);
	dev->ldev.name = dev->devname;
	dev->ldev.driver = &sculld_driver;
	dev->ldev.dev.driver_data = dev;
	register_ldd_device(&dev->ldev);
	device_create_file(&dev->ldev.dev, &dev_attr_dev);
}


/*
 * Finally, the module stuff
 */

int sculld_init(void)
{
	int result, i;
	dev_t dev = MKDEV(sculld_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (sculld_major)
		result = register_chrdev_region(dev, sculld_devs, "sculld");
	else {
		result = alloc_chrdev_region(&dev, 0, sculld_devs, "sculld");
		sculld_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	/*
	 * Register with the driver core.
	 */
	register_ldd_driver(&sculld_driver);
	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	sculld_devices = kmalloc(sculld_devs*sizeof (struct sculld_dev), GFP_KERNEL);
	if (!sculld_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(sculld_devices, 0, sculld_devs*sizeof (struct sculld_dev));
	for (i = 0; i < sculld_devs; i++) {
		sculld_devices[i].order = sculld_order;
		sculld_devices[i].qset = sculld_qset;
		sema_init (&sculld_devices[i].sem, 1);
		sculld_setup_cdev(sculld_devices + i, i);
		sculld_register_dev(sculld_devices + i, i);
	}


#ifdef SCULLD_USE_PROC /* only when available */
	create_proc_read_entry("sculldmem", 0, NULL, sculld_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, sculld_devs);
	return result;
}



void sculld_cleanup(void)
{
	int i;

#ifdef SCULLD_USE_PROC
	remove_proc_entry("sculldmem", NULL);
#endif

	for (i = 0; i < sculld_devs; i++) {
		unregister_ldd_device(&sculld_devices[i].ldev);
		cdev_del(&sculld_devices[i].cdev);
		sculld_trim(sculld_devices + i);
	}
	kfree(sculld_devices);
	unregister_ldd_driver(&sculld_driver);
	unregister_chrdev_region(MKDEV (sculld_major, 0), sculld_devs);
}


module_init(sculld_init);
module_exit(sculld_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_sculld_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the sculld char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "sculld.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void sculld_vma_open(struct vm_area_struct *vma)
{
	struct sculld_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void sculld_vma_close(struct vm_area_struct *vma)
{
	struct sculld_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the sculld device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *sculld_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct sculld_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the sculld device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct sculld_vm_ops = {
	.open =     sculld_vma_open,
	.close =    sculld_vma_close,
	.nopage =   sculld_vma_nopage,
};


int sculld_mmap(struct file *filp, struct vm_area_struct *vma)
{
	struct inode *inode = filp->f_dentry->d_inode;

	/* refuse to map if order is not 0 */
	if (sculld_devices[iminor(inode)].order)
		return -ENODEV;

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &sculld_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	sculld_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_scullp_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare scullp char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include "scullp.h"		/* local definitions */


int scullp_major =   SCULLP_MAJOR;
int scullp_devs =    SCULLP_DEVS;	/* number of bare scullp devices */
int scullp_qset =    SCULLP_QSET;
int scullp_order =   SCULLP_ORDER;

module_param(scullp_major, int, 0);
module_param(scullp_devs, int, 0);
module_param(scullp_qset, int, 0);
module_param(scullp_order, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct scullp_dev *scullp_devices; /* allocated in scullp_init */

int scullp_trim(struct scullp_dev *dev);
void scullp_cleanup(void);






#ifdef SCULLP_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void scullp_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int scullp_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, order, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct scullp_dev *d;

	*start = buf;
	for(i = 0; i < scullp_devs; i++) {
		d = &scullp_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		order = d->order;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, order %%i, sz %%li\n",
				i, qset, order, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			scullp_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					scullp_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&scullp_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLP_USE_PROC */

/*
 * Open and close
 */

int scullp_open (struct inode *inode, struct file *filp)
{
	struct scullp_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct scullp_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		scullp_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int scullp_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct scullp_dev *scullp_follow(struct scullp_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct scullp_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct scullp_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t scullp_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullp_dev *dev = filp->private_data; /* the first listitem */
	struct scullp_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = scullp_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t scullp_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullp_dev *dev = filp->private_data;
	struct scullp_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scullp_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Here's the allocation of a single quantum */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] =
			(void *)__get_free_pages(GFP_KERNEL, dptr->order);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, PAGE_SIZE << dptr->order);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scullp_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLP_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLP_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLP_IOCRESET:
		scullp_qset = SCULLP_QSET;
		scullp_order = SCULLP_ORDER;
		break;

	case SCULLP_IOCSORDER: /* Set: arg points to the value */
		ret = __get_user(scullp_order, (int __user *) arg);
		break;

	case SCULLP_IOCTORDER: /* Tell: arg is the value */
		scullp_order = arg;
		break;

	case SCULLP_IOCGORDER: /* Get: arg is pointer to result */
		ret = __put_user (scullp_order, (int __user *) arg);
		break;

	case SCULLP_IOCQORDER: /* Query: return it (it's positive) */
		return scullp_order;

	case SCULLP_IOCXORDER: /* eXchange: use arg as pointer */
		tmp = scullp_order;
		ret = __get_user(scullp_order, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLP_IOCHORDER: /* sHift: like Tell + Query */
		tmp = scullp_order;
		scullp_order = arg;
		return tmp;

	case SCULLP_IOCSQSET:
		ret = __get_user(scullp_qset, (int __user *) arg);
		break;

	case SCULLP_IOCTQSET:
		scullp_qset = arg;
		break;

	case SCULLP_IOCGQSET:
		ret = __put_user(scullp_qset, (int __user *)arg);
		break;

	case SCULLP_IOCQQSET:
		return scullp_qset;

	case SCULLP_IOCXQSET:
		tmp = scullp_qset;
		ret = __get_user(scullp_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLP_IOCHQSET:
		tmp = scullp_qset;
		scullp_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t scullp_llseek (struct file *filp, loff_t off, int whence)
{
	struct scullp_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void scullp_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int scullp_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = scullp_write(iocb->ki_filp, buf, count, &pos);
	else
		result = scullp_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, scullp_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t scullp_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return scullp_defer_op(0, iocb, buf, count, pos);
}

static ssize_t scullp_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return scullp_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 
/*
 * Mmap *is* available, but confined in a different file
 */
extern int scullp_mmap(struct file *filp, struct vm_area_struct *vma);


/*
 * The fops
 */

struct file_operations scullp_fops = {
	.owner =     THIS_MODULE,
	.llseek =    scullp_llseek,
	.read =	     scullp_read,
	.write =     scullp_write,
	.ioctl =     scullp_ioctl,
	.mmap =	     scullp_mmap,
	.open =	     scullp_open,
	.release =   scullp_release,
	.aio_read =  scullp_aio_read,
	.aio_write = scullp_aio_write,
};

int scullp_trim(struct scullp_dev *dev)
{
	struct scullp_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			/* This code frees a whole quantum-set */
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					free_pages((unsigned long)(dptr->data[i]),
							dptr->order);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = scullp_qset;
	dev->order = scullp_order;
	dev->next = NULL;
	return 0;
}


static void scullp_setup_cdev(struct scullp_dev *dev, int index)
{
	int err, devno = MKDEV(scullp_major, index);
    
	cdev_init(&dev->cdev, &scullp_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scullp_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}



/*
 * Finally, the module stuff
 */

int scullp_init(void)
{
	int result, i;
	dev_t dev = MKDEV(scullp_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (scullp_major)
		result = register_chrdev_region(dev, scullp_devs, "scullp");
	else {
		result = alloc_chrdev_region(&dev, 0, scullp_devs, "scullp");
		scullp_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scullp_devices = kmalloc(scullp_devs*sizeof (struct scullp_dev), GFP_KERNEL);
	if (!scullp_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(scullp_devices, 0, scullp_devs*sizeof (struct scullp_dev));
	for (i = 0; i < scullp_devs; i++) {
		scullp_devices[i].order = scullp_order;
		scullp_devices[i].qset = scullp_qset;
		sema_init (&scullp_devices[i].sem, 1);
		scullp_setup_cdev(scullp_devices + i, i);
	}


#ifdef SCULLP_USE_PROC /* only when available */
	create_proc_read_entry("scullpmem", 0, NULL, scullp_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, scullp_devs);
	return result;
}



void scullp_cleanup(void)
{
	int i;

#ifdef SCULLP_USE_PROC
	remove_proc_entry("scullpmem", NULL);
#endif

	for (i = 0; i < scullp_devs; i++) {
		cdev_del(&scullp_devices[i].cdev);
		scullp_trim(scullp_devices + i);
	}
	kfree(scullp_devices);
	unregister_chrdev_region(MKDEV (scullp_major, 0), scullp_devs);
}


module_init(scullp_init);
module_exit(scullp_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullp_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the scullp char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "scullp.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void scullp_vma_open(struct vm_area_struct *vma)
{
	struct scullp_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void scullp_vma_close(struct vm_area_struct *vma)
{
	struct scullp_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the scullp device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *scullp_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct scullp_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the scullp device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */
	page = virt_to_page(pageptr);

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct scullp_vm_ops = {
	.open =     scullp_vma_open,
	.close =    scullp_vma_close,
	.nopage =   scullp_vma_nopage,
};


int scullp_mmap(struct file *filp, struct vm_area_struct *vma)
{
	struct inode *inode = filp->f_dentry->d_inode;

	/* refuse to map if order is not 0 */
	if (scullp_devices[iminor(inode)].order)
		return -ENODEV;

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &scullp_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	scullp_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_scullv_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare scullv char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include <linux/vmalloc.h>
#include "scullv.h"		/* local definitions */


int scullv_major =   SCULLV_MAJOR;
int scullv_devs =    SCULLV_DEVS;	/* number of bare scullv devices */
int scullv_qset =    SCULLV_QSET;
int scullv_order =   SCULLV_ORDER;

module_param(scullv_major, int, 0);
module_param(scullv_devs, int, 0);
module_param(scullv_qset, int, 0);
module_param(scullv_order, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct scullv_dev *scullv_devices; /* allocated in scullv_init */

int scullv_trim(struct scullv_dev *dev);
void scullv_cleanup(void);






#ifdef SCULLV_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void scullv_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int scullv_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, order, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct scullv_dev *d;

	*start = buf;
	for(i = 0; i < scullv_devs; i++) {
		d = &scullv_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		order = d->order;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, order %%i, sz %%li\n",
				i, qset, order, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			scullv_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					scullv_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&scullv_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLV_USE_PROC */

/*
 * Open and close
 */

int scullv_open (struct inode *inode, struct file *filp)
{
	struct scullv_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct scullv_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		scullv_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int scullv_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct scullv_dev *scullv_follow(struct scullv_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct scullv_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct scullv_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t scullv_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullv_dev *dev = filp->private_data; /* the first listitem */
	struct scullv_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = scullv_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t scullv_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullv_dev *dev = filp->private_data;
	struct scullv_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scullv_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Allocate a quantum using virtual addresses */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] = (void *)vmalloc(PAGE_SIZE << dptr->order);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, PAGE_SIZE << dptr->order);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scullv_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLV_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLV_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLV_IOCRESET:
		scullv_qset = SCULLV_QSET;
		scullv_order = SCULLV_ORDER;
		break;

	case SCULLV_IOCSORDER: /* Set: arg points to the value */
		ret = __get_user(scullv_order, (int __user *) arg);
		break;

	case SCULLV_IOCTORDER: /* Tell: arg is the value */
		scullv_order = arg;
		break;

	case SCULLV_IOCGORDER: /* Get: arg is pointer to result */
		ret = __put_user (scullv_order, (int __user *) arg);
		break;

	case SCULLV_IOCQORDER: /* Query: return it (it's positive) */
		return scullv_order;

	case SCULLV_IOCXORDER: /* eXchange: use arg as pointer */
		tmp = scullv_order;
		ret = __get_user(scullv_order, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLV_IOCHORDER: /* sHift: like Tell + Query */
		tmp = scullv_order;
		scullv_order = arg;
		return tmp;

	case SCULLV_IOCSQSET:
		ret = __get_user(scullv_qset, (int __user *) arg);
		break;

	case SCULLV_IOCTQSET:
		scullv_qset = arg;
		break;

	case SCULLV_IOCGQSET:
		ret = __put_user(scullv_qset, (int __user *)arg);
		break;

	case SCULLV_IOCQQSET:
		return scullv_qset;

	case SCULLV_IOCXQSET:
		tmp = scullv_qset;
		ret = __get_user(scullv_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLV_IOCHQSET:
		tmp = scullv_qset;
		scullv_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t scullv_llseek (struct file *filp, loff_t off, int whence)
{
	struct scullv_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void scullv_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int scullv_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = scullv_write(iocb->ki_filp, buf, count, &pos);
	else
		result = scullv_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, scullv_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t scullv_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return scullv_defer_op(0, iocb, buf, count, pos);
}

static ssize_t scullv_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return scullv_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 
/*
 * Mmap *is* available, but confined in a different file
 */
extern int scullv_mmap(struct file *filp, struct vm_area_struct *vma);


/*
 * The fops
 */

struct file_operations scullv_fops = {
	.owner =     THIS_MODULE,
	.llseek =    scullv_llseek,
	.read =	     scullv_read,
	.write =     scullv_write,
	.ioctl =     scullv_ioctl,
	.mmap =	     scullv_mmap,
	.open =	     scullv_open,
	.release =   scullv_release,
	.aio_read =  scullv_aio_read,
	.aio_write = scullv_aio_write,
};

int scullv_trim(struct scullv_dev *dev)
{
	struct scullv_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			/* Release the quantum-set */
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					vfree(dptr->data[i]);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = scullv_qset;
	dev->order = scullv_order;
	dev->next = NULL;
	return 0;
}


static void scullv_setup_cdev(struct scullv_dev *dev, int index)
{
	int err, devno = MKDEV(scullv_major, index);
    
	cdev_init(&dev->cdev, &scullv_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scullv_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}



/*
 * Finally, the module stuff
 */

int scullv_init(void)
{
	int result, i;
	dev_t dev = MKDEV(scullv_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (scullv_major)
		result = register_chrdev_region(dev, scullv_devs, "scullv");
	else {
		result = alloc_chrdev_region(&dev, 0, scullv_devs, "scullv");
		scullv_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scullv_devices = kmalloc(scullv_devs*sizeof (struct scullv_dev), GFP_KERNEL);
	if (!scullv_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(scullv_devices, 0, scullv_devs*sizeof (struct scullv_dev));
	for (i = 0; i < scullv_devs; i++) {
		scullv_devices[i].order = scullv_order;
		scullv_devices[i].qset = scullv_qset;
		sema_init (&scullv_devices[i].sem, 1);
		scullv_setup_cdev(scullv_devices + i, i);
	}


#ifdef SCULLV_USE_PROC /* only when available */
	create_proc_read_entry("scullvmem", 0, NULL, scullv_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, scullv_devs);
	return result;
}



void scullv_cleanup(void)
{
	int i;

#ifdef SCULLV_USE_PROC
	remove_proc_entry("scullvmem", NULL);
#endif

	for (i = 0; i < scullv_devs; i++) {
		cdev_del(&scullv_devices[i].cdev);
		scullv_trim(scullv_devices + i);
	}
	kfree(scullv_devices);
	unregister_chrdev_region(MKDEV (scullv_major, 0), scullv_devs);
}


module_init(scullv_init);
module_exit(scullv_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullv_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the scullv char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "scullv.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void scullv_vma_open(struct vm_area_struct *vma)
{
	struct scullv_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void scullv_vma_close(struct vm_area_struct *vma)
{
	struct scullv_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the scullv device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *scullv_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct scullv_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the scullv device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */

	/*
	 * After scullv lookup, "page" is now the address of the page
	 * needed by the current process. Since it's a vmalloc address,
	 * turn it into a struct page.
	 */
	page = vmalloc_to_page(pageptr);

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct scullv_vm_ops = {
	.open =     scullv_vma_open,
	.close =    scullv_vma_close,
	.nopage =   scullv_vma_nopage,
};


int scullv_mmap(struct file *filp, struct vm_area_struct *vma)
{

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &scullv_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	scullv_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_short">
			<text>
				<![CDATA[/*
 * short.c -- Simple Hardware Operations and Raw Tests
 * short.c -- also a brief example of interrupt handling ("short int")
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: short.c,v 1.16 2004/10/29 16:45:40 corbet Exp $
 */

/*
 * FIXME: this driver is not safe with concurrent readers or
 * writers.
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/sched.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/delay.h>	/* udelay */
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/ioport.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/poll.h>
#include <linux/wait.h>

#include <asm/io.h>

#define SHORT_NR_PORTS	8	/* use 8 ports by default */

/*
 * all of the parameters have no "short_" prefix, to save typing when
 * specifying them at load time
 */
static int major = 0;	/* dynamic by default */
module_param(major, int, 0);

static int use_mem = 0;	/* default is I/O-mapped */
module_param(use_mem, int, 0);

/* default is the first printer port on PC's. "short_base" is there too
   because it's what we want to use in the code */
static unsigned long base = 0x378;
unsigned long short_base = 0;
module_param(base, long, 0);

/* The interrupt line is undefined by default. "short_irq" is as above */
static int irq = -1;
volatile int short_irq = -1;
module_param(irq, int, 0);

static int probe = 0;	/* select at load time how to probe irq line */
module_param(probe, int, 0);

static int wq = 0;	/* select at load time whether a workqueue is used */
module_param(wq, int, 0);

static int tasklet = 0;	/* select whether a tasklet is used */
module_param(tasklet, int, 0);

static int share = 0;	/* select at load time whether install a shared irq */
module_param(share, int, 0);

MODULE_AUTHOR ("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");


unsigned long short_buffer = 0;
unsigned long volatile short_head;
volatile unsigned long short_tail;
DECLARE_WAIT_QUEUE_HEAD(short_queue);

/* Set up our tasklet if we're doing that. */
void short_do_tasklet(unsigned long);
DECLARE_TASKLET(short_tasklet, short_do_tasklet, 0);

/*
 * Atomicly increment an index into short_buffer
 */
static inline void short_incr_bp(volatile unsigned long *index, int delta)
{
	unsigned long new = *index + delta;
	barrier();  /* Don't optimize these two together */
	*index = (new >= (short_buffer + PAGE_SIZE)) ? short_buffer : new;
}


/*
 * The devices with low minor numbers write/read burst of data to/from
 * specific I/O ports (by default the parallel ones).
 * 
 * The device with 128 as minor number returns ascii strings telling
 * when interrupts have been received. Writing to the device toggles
 * 00/FF on the parallel data lines. If there is a loopback wire, this
 * generates interrupts.  
 */

int short_open (struct inode *inode, struct file *filp)
{
	extern struct file_operations short_i_fops;

	if (iminor (inode) & 0x80)
		filp->f_op = &short_i_fops; /* the interrupt-driven node */
	return 0;
}


int short_release (struct inode *inode, struct file *filp)
{
	return 0;
}


/* first, the port-oriented device */

enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};

ssize_t do_short_read (struct inode *inode, struct file *filp, char __user *buf,
		size_t count, loff_t *f_pos)
{
	int retval = count, minor = iminor (inode);
	unsigned long port = short_base + (minor&0x0f);
	void *address = (void *) short_base + (minor&0x0f);
	int mode = (minor&0x70) >> 4;
	unsigned char *kbuf = kmalloc(count, GFP_KERNEL), *ptr;
    
	if (!kbuf)
		return -ENOMEM;
	ptr = kbuf;

	if (use_mem)
		mode = SHORT_MEMORY;
	
	switch(mode) {
	    case SHORT_STRING:
		insb(port, ptr, count);
		rmb();
		break;

	    case SHORT_DEFAULT:
		while (count--) {
			*(ptr++) = inb(port);
			rmb();
		}
		break;

	    case SHORT_MEMORY:
		while (count--) {
			*ptr++ = ioread8(address);
			rmb();
		}
		break;
	    case SHORT_PAUSE:
		while (count--) {
			*(ptr++) = inb_p(port);
			rmb();
		}
		break;

	    default: /* no more modes defined by now */
		retval = -EINVAL;
		break;
	}
	if ((retval > 0) && copy_to_user(buf, kbuf, retval))
		retval = -EFAULT;
	kfree(kbuf);
	return retval;
}


/*
 * Version-specific methods for the fops structure.  FIXME don't need anymore.
 */
ssize_t short_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	return do_short_read(filp->f_dentry->d_inode, filp, buf, count, f_pos);
}



ssize_t do_short_write (struct inode *inode, struct file *filp, const char __user *buf,
		size_t count, loff_t *f_pos)
{
	int retval = count, minor = iminor(inode);
	unsigned long port = short_base + (minor&0x0f);
	void *address = (void *) short_base + (minor&0x0f);
	int mode = (minor&0x70) >> 4;
	unsigned char *kbuf = kmalloc(count, GFP_KERNEL), *ptr;

	if (!kbuf)
		return -ENOMEM;
	if (copy_from_user(kbuf, buf, count))
		return -EFAULT;
	ptr = kbuf;

	if (use_mem)
		mode = SHORT_MEMORY;

	switch(mode) {
	case SHORT_PAUSE:
		while (count--) {
			outb_p(*(ptr++), port);
			wmb();
		}
		break;

	case SHORT_STRING:
		outsb(port, ptr, count);
		wmb();
		break;

	case SHORT_DEFAULT:
		while (count--) {
			outb(*(ptr++), port);
			wmb();
		}
		break;

	case SHORT_MEMORY:
		while (count--) {
			iowrite8(*ptr++, address);
			wmb();
		}
		break;

	default: /* no more modes defined by now */
		retval = -EINVAL;
		break;
	}
	kfree(kbuf);
	return retval;
}


ssize_t short_write(struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	return do_short_write(filp->f_dentry->d_inode, filp, buf, count, f_pos);
}




unsigned int short_poll(struct file *filp, poll_table *wait)
{
	return POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
}






struct file_operations short_fops = {
	.owner	 = THIS_MODULE,
	.read	 = short_read,
	.write	 = short_write,
	.poll	 = short_poll,
	.open	 = short_open,
	.release = short_release,
};

/* then,  the interrupt-related device */

ssize_t short_i_read (struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	int count0;
	DEFINE_WAIT(wait);

	while (short_head == short_tail) {
		prepare_to_wait(&short_queue, &wait, TASK_INTERRUPTIBLE);
		if (short_head == short_tail)
			schedule();
		finish_wait(&short_queue, &wait);
		if (signal_pending (current))  /* a signal arrived */
			return -ERESTARTSYS; /* tell the fs layer to handle it */
	} 
	/* count0 is the number of readable data bytes */
	count0 = short_head - short_tail;
	if (count0 < 0) /* wrapped */
		count0 = short_buffer + PAGE_SIZE - short_tail;
	if (count0 < count) count = count0;

	if (copy_to_user(buf, (char *)short_tail, count))
		return -EFAULT;
	short_incr_bp (&short_tail, count);
	return count;
}

ssize_t short_i_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	int written = 0, odd = *f_pos & 1;
	unsigned long port = short_base; /* output to the parallel data latch */
	void *address = (void *) short_base;

	if (use_mem) {
		while (written < count)
			iowrite8(0xff * ((++written + odd) & 1), address);
	} else {
		while (written < count)
			outb(0xff * ((++written + odd) & 1), port);
	}

	*f_pos += count;
	return written;
}




struct file_operations short_i_fops = {
	.owner	 = THIS_MODULE,
	.read	 = short_i_read,
	.write	 = short_i_write,
	.open	 = short_open,
	.release = short_release,
};

irqreturn_t short_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	struct timeval tv;
	int written;

	do_gettimeofday(&tv);

	    /* Write a 16 byte record. Assume PAGE_SIZE is a multiple of 16 */
	written = sprintf((char *)short_head,"%%08u.%%06u\n",
			(int)(tv.tv_sec %% 100000000), (int)(tv.tv_usec));
	BUG_ON(written != 16);
	short_incr_bp(&short_head, written);
	wake_up_interruptible(&short_queue); /* awake any reading process */
	return IRQ_HANDLED;
}

/*
 * The following two functions are equivalent to the previous one,
 * but split in top and bottom half. First, a few needed variables
 */

#define NR_TIMEVAL 512 /* length of the array of time values */

struct timeval tv_data[NR_TIMEVAL]; /* too lazy to allocate it */
volatile struct timeval *tv_head=tv_data;
volatile struct timeval *tv_tail=tv_data;

static struct work_struct short_wq;


int short_wq_count = 0;

/*
 * Increment a circular buffer pointer in a way that nobody sees
 * an intermediate value.
 */
static inline void short_incr_tv(volatile struct timeval **tvp)
{
	if (*tvp == (tv_data + NR_TIMEVAL - 1))
		*tvp = tv_data;	 /* Wrap */
	else
		(*tvp)++;
}



void short_do_tasklet (unsigned long unused)
{
	int savecount = short_wq_count, written;
	short_wq_count = 0; /* we have already been removed from the queue */
	/*
	 * The bottom half reads the tv array, filled by the top half,
	 * and prints it to the circular text buffer, which is then consumed
	 * by reading processes
	 */

	/* First write the number of interrupts that occurred before this bh */
	written = sprintf((char *)short_head,"bh after %%6i\n",savecount);
	short_incr_bp(&short_head, written);

	/*
	 * Then, write the time values. Write exactly 16 bytes at a time,
	 * so it aligns with PAGE_SIZE
	 */

	do {
		written = sprintf((char *)short_head,"%%08u.%%06u\n",
				(int)(tv_tail->tv_sec %% 100000000),
				(int)(tv_tail->tv_usec));
		short_incr_bp(&short_head, written);
		short_incr_tv(&tv_tail);
	} while (tv_tail != tv_head);

	wake_up_interruptible(&short_queue); /* awake any reading process */
}


irqreturn_t short_wq_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	/* Grab the current time information. */
	do_gettimeofday((struct timeval *) tv_head);
	short_incr_tv(&tv_head);

	/* Queue the bh. Don't worry about multiple enqueueing */
	schedule_work(&short_wq);

	short_wq_count++; /* record that an interrupt arrived */
	return IRQ_HANDLED;
}


/*
 * Tasklet top half
 */

irqreturn_t short_tl_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	do_gettimeofday((struct timeval *) tv_head); /* cast to stop 'volatile' warning */
	short_incr_tv(&tv_head);
	tasklet_schedule(&short_tasklet);
	short_wq_count++; /* record that an interrupt arrived */
	return IRQ_HANDLED;
}




irqreturn_t short_sh_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	int value, written;
	struct timeval tv;

	/* If it wasn't short, return immediately */
	value = inb(short_base);
	if (!(value & 0x80))
		return IRQ_NONE;
	
	/* clear the interrupting bit */
	outb(value & 0x7F, short_base);

	/* the rest is unchanged */

	do_gettimeofday(&tv);
	written = sprintf((char *)short_head,"%%08u.%%06u\n",
			(int)(tv.tv_sec %% 100000000), (int)(tv.tv_usec));
	short_incr_bp(&short_head, written);
	wake_up_interruptible(&short_queue); /* awake any reading process */
	return IRQ_HANDLED;
}

void short_kernelprobe(void)
{
	int count = 0;
	do {
		unsigned long mask;

		mask = probe_irq_on();
		outb_p(0x10,short_base+2); /* enable reporting */
		outb_p(0x00,short_base);   /* clear the bit */
		outb_p(0xFF,short_base);   /* set the bit: interrupt! */
		outb_p(0x00,short_base+2); /* disable reporting */
		udelay(5);  /* give it some time */
		short_irq = probe_irq_off(mask);

		if (short_irq == 0) { /* none of them? */
			printk(KERN_INFO "short: no irq reported by probe\n");
			short_irq = -1;
		}
		/*
		 * if more than one line has been activated, the result is
		 * negative. We should service the interrupt (no need for lpt port)
		 * and loop over again. Loop at most five times, then give up
		 */
	} while (short_irq < 0 && count++ < 5);
	if (short_irq < 0)
		printk("short: probe failed %%i times, giving up\n", count);
}

irqreturn_t short_probing(int irq, void *dev_id, struct pt_regs *regs)
{
	if (short_irq == 0) short_irq = irq;	/* found */
	if (short_irq != irq) short_irq = -irq; /* ambiguous */
	return IRQ_HANDLED;
}

void short_selfprobe(void)
{
	int trials[] = {3, 5, 7, 9, 0};
	int tried[]  = {0, 0, 0, 0, 0};
	int i, count = 0;

	/*
	 * install the probing handler for all possible lines. Remember
	 * the result (0 for success, or -EBUSY) in order to only free
	 * what has been acquired
      */
	for (i = 0; trials[i]; i++)
		tried[i] = request_irq(trials[i], short_probing,
				SA_INTERRUPT, "short probe", NULL);

	do {
		short_irq = 0; /* none got, yet */
		outb_p(0x10,short_base+2); /* enable */
		outb_p(0x00,short_base);
		outb_p(0xFF,short_base); /* toggle the bit */
		outb_p(0x00,short_base+2); /* disable */
		udelay(5);  /* give it some time */

		/* the value has been set by the handler */
		if (short_irq == 0) { /* none of them? */
			printk(KERN_INFO "short: no irq reported by probe\n");
		}
		/*
		 * If more than one line has been activated, the result is
		 * negative. We should service the interrupt (but the lpt port
		 * doesn't need it) and loop over again. Do it at most 5 times
		 */
	} while (short_irq <=0 && count++ < 5);

	/* end of loop, uninstall the handler */
	for (i = 0; trials[i]; i++)
		if (tried[i] == 0)
			free_irq(trials[i], NULL);

	if (short_irq < 0)
		printk("short: probe failed %%i times, giving up\n", count);
}



/* Finally, init and cleanup */

int short_init(void)
{
	int result;

	/*
	 * first, sort out the base/short_base ambiguity: we'd better
	 * use short_base in the code, for clarity, but allow setting
	 * just "base" at load time. Same for "irq".
	 */
	short_base = base;
	short_irq = irq;

	/* Get our needed resources. */
	if (!use_mem) {
		if (! request_region(short_base, SHORT_NR_PORTS, "short")) {
			printk(KERN_INFO "short: can't get I/O port address 0x%%lx\n",
					short_base);
			return -ENODEV;
		}

	} else {
		if (! request_mem_region(short_base, SHORT_NR_PORTS, "short")) {
			printk(KERN_INFO "short: can't get I/O mem address 0x%%lx\n",
					short_base);
			return -ENODEV;
		}

		/* also, ioremap it */
		short_base = (unsigned long) ioremap(short_base, SHORT_NR_PORTS);
		/* Hmm... we should check the return value */
	}
	/* Here we register our device - should not fail thereafter */
	result = register_chrdev(major, "short", &short_fops);
	if (result < 0) {
		printk(KERN_INFO "short: can't get major number\n");
		release_region(short_base,SHORT_NR_PORTS);  /* FIXME - use-mem case? */
		return result;
	}
	if (major == 0) major = result; /* dynamic */

	short_buffer = __get_free_pages(GFP_KERNEL,0); /* never fails */  /* FIXME */
	short_head = short_tail = short_buffer;

	/*
	 * Fill the workqueue structure, used for the bottom half handler.
	 * The cast is there to prevent warnings about the type of the
	 * (unused) argument.
	 */
	/* this line is in short_init() */
	INIT_WORK(&short_wq, (void (*)(void *)) short_do_tasklet, NULL);

	/*
	 * Now we deal with the interrupt: either kernel-based
	 * autodetection, DIY detection or default number
	 */

	if (short_irq < 0 && probe == 1)
		short_kernelprobe();

	if (short_irq < 0 && probe == 2)
		short_selfprobe();

	if (short_irq < 0) /* not yet specified: force the default on */
		switch(short_base) {
		    case 0x378: short_irq = 7; break;
		    case 0x278: short_irq = 2; break;
		    case 0x3bc: short_irq = 5; break;
		}

	/*
	 * If shared has been specified, installed the shared handler
	 * instead of the normal one. Do it first, before a -EBUSY will
	 * force short_irq to -1.
	 */
	if (short_irq >= 0 && share > 0) {
		result = request_irq(short_irq, short_sh_interrupt,
				SA_SHIRQ | SA_INTERRUPT,"short",
				short_sh_interrupt);
		if (result) {
			printk(KERN_INFO "short: can't get assigned irq %%i\n", short_irq);
			short_irq = -1;
		}
		else { /* actually enable it -- assume this *is* a parallel port */
			outb(0x10, short_base+2);
		}
		return 0; /* the rest of the function only installs handlers */
	}

	if (short_irq >= 0) {
		result = request_irq(short_irq, short_interrupt,
				SA_INTERRUPT, "short", NULL);
		if (result) {
			printk(KERN_INFO "short: can't get assigned irq %%i\n",
					short_irq);
			short_irq = -1;
		}
		else { /* actually enable it -- assume this *is* a parallel port */
			outb(0x10,short_base+2);
		}
	}

	/*
	 * Ok, now change the interrupt handler if using top/bottom halves
	 * has been requested
	 */
	if (short_irq >= 0 && (wq + tasklet) > 0) {
		free_irq(short_irq,NULL);
		result = request_irq(short_irq,
				tasklet ? short_tl_interrupt :
				short_wq_interrupt,
				SA_INTERRUPT,"short-bh", NULL);
		if (result) {
			printk(KERN_INFO "short-bh: can't get assigned irq %%i\n",
					short_irq);
			short_irq = -1;
		}
	}

	return 0;
}

void short_cleanup(void)
{
	if (short_irq >= 0) {
		outb(0x0, short_base + 2);   /* disable the interrupt */
		if (!share) free_irq(short_irq, NULL);
		else free_irq(short_irq, short_sh_interrupt);
	}
	/* Make sure we don't leave work queue/tasklet functions running */
	if (tasklet)
		tasklet_disable(&short_tasklet);
	else
		flush_scheduled_work();
	unregister_chrdev(major, "short");
	if (use_mem) {
		iounmap((void __iomem *)short_base);
		release_mem_region(short_base, SHORT_NR_PORTS);
	} else {
		release_region(short_base,SHORT_NR_PORTS);
	}
	if (short_buffer) free_page(short_buffer);
}

module_init(short_init);
module_exit(short_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_shortprint">
			<text>
				<![CDATA[/*
 * A version of the "short" driver which drives a parallel printer directly,
 * with a lot of simplifying assumptions.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: shortprint.c,v 1.4 2004/09/26 08:01:04 gregkh Exp $
 */
#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>

#include <linux/sched.h>
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>	  /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/delay.h>  /* udelay */
#include <linux/slab.h>
#include <linux/ioport.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/timer.h>
#include <linux/poll.h>

#include <asm/io.h>
#include <asm/semaphore.h>
#include <asm/atomic.h>

#include "shortprint.h"

#define SHORTP_NR_PORTS 3

/*
 * all of the parameters have no "shortp_" prefix, to save typing when
 * specifying them at load time
 */
static int major = 0; /* dynamic by default */
module_param(major, int, 0);

/* default is the first printer port on PC's. "shortp_base" is there too
   because it's what we want to use in the code */
static unsigned long base = 0x378;
unsigned long shortp_base = 0;
module_param(base, long, 0);

/* The interrupt line is undefined by default. "shortp_irq" is as above */
static int irq = -1;
static int shortp_irq = -1;
module_param(irq, int, 0);

/* Microsecond delay around strobe. */
static int delay = 0;
static int shortp_delay;
module_param(delay, int, 0);

MODULE_AUTHOR ("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");

/*
 * Forwards.
 */
static void shortp_cleanup(void);
static void shortp_timeout(unsigned long unused);

/*
 * Input is managed through a simple circular buffer which, among other things,
 * is allowed to overrun if the reader isn't fast enough.  That makes life simple
 * on the "read" interrupt side, where we don't want to block.
 */
static unsigned long shortp_in_buffer = 0;
static unsigned long volatile shortp_in_head;
static volatile unsigned long shortp_in_tail;
DECLARE_WAIT_QUEUE_HEAD(shortp_in_queue);
static struct timeval shortp_tv;  /* When the interrupt happened. */

/*
 * Atomicly increment an index into shortp_in_buffer
 */
static inline void shortp_incr_bp(volatile unsigned long *index, int delta)
{
	unsigned long new = *index + delta;
	barrier ();  /* Don't optimize these two together */
	*index = (new >= (shortp_in_buffer + PAGE_SIZE)) ? shortp_in_buffer : new;
}


/*
 * On the write side we have to be more careful, since we don't want to drop
 * data.  The semaphore is used to serialize write-side access to the buffer;
 * there is only one consumer, so read-side access is unregulated.  The
 * wait queue will be awakened when space becomes available in the buffer.
 */
static unsigned char *shortp_out_buffer = NULL;
static volatile unsigned char *shortp_out_head, *shortp_out_tail;
static struct semaphore shortp_out_sem;
static DECLARE_WAIT_QUEUE_HEAD(shortp_out_queue);

/*
 * Feeding the output queue to the device is handled by way of a
 * workqueue.
 */
static void shortp_do_work(void *);
static DECLARE_WORK(shortp_work, shortp_do_work, NULL);
static struct workqueue_struct *shortp_workqueue;

/*
 * Available space in the output buffer; should be called with the semaphore
 * held.  Returns contiguous space, so caller need not worry about wraps.
 */
static inline int shortp_out_space(void)
{
	if (shortp_out_head >= shortp_out_tail) {
		int space = PAGE_SIZE - (shortp_out_head - shortp_out_buffer);
		return (shortp_out_tail == shortp_out_buffer) ? space - 1 : space;
	} else
		return (shortp_out_tail - shortp_out_head) - 1;
}

static inline void shortp_incr_out_bp(volatile unsigned char **bp, int incr)
{
	unsigned char *new = (unsigned char *) *bp + incr;
	if (new >= (shortp_out_buffer + PAGE_SIZE))
		new -= PAGE_SIZE;
	*bp = new;
}

/*
 * The output "process" is controlled by a spin lock; decisions on
 * shortp_output_active or manipulation of shortp_out_tail require
 * that this lock be held.
 */
static spinlock_t shortp_out_lock;
volatile static int shortp_output_active;
DECLARE_WAIT_QUEUE_HEAD(shortp_empty_queue); /* waked when queue empties */

/*
 * When output is active, the timer is too, in case we miss interrupts.	 Hold
 * shortp_out_lock if you mess with the timer.
 */
static struct timer_list shortp_timer;
#define TIMEOUT 5*HZ  /* Wait a long time */


/*
 * Open the device.
 */
static int shortp_open(struct inode *inode, struct file *filp)
{
	return 0;
}


static int shortp_release(struct inode *inode, struct file *filp)
{
	/* Wait for any pending output to complete */
	wait_event_interruptible(shortp_empty_queue, shortp_output_active==0);

	return 0;
}



static unsigned int shortp_poll(struct file *filp, poll_table *wait)
{
    return POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
}



/*
 * The read routine, which doesn't return data from the device; instead, it
 * returns timing information just like the "short" device.
 */
static ssize_t shortp_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	int count0;
	DEFINE_WAIT(wait);

	while (shortp_in_head == shortp_in_tail) {
		prepare_to_wait(&shortp_in_queue, &wait, TASK_INTERRUPTIBLE);
		if (shortp_in_head == shortp_in_tail)
			schedule();
		finish_wait(&shortp_in_queue, &wait);
		if (signal_pending (current))  /* a signal arrived */
			return -ERESTARTSYS; /* tell the fs layer to handle it */
	}

	/* count0 is the number of readable data bytes */
	count0 = shortp_in_head - shortp_in_tail;
	if (count0 < 0) /* wrapped */
		count0 = shortp_in_buffer + PAGE_SIZE - shortp_in_tail;
	if (count0 < count)
		count = count0;

	if (copy_to_user(buf, (char *)shortp_in_tail, count))
		return -EFAULT;
	shortp_incr_bp(&shortp_in_tail, count);
	return count;
}


/*
 * Wait for the printer to be ready; this can sleep.
 */
static void shortp_wait(void)
{
	if ((inb(shortp_base + SP_STATUS) & SP_SR_BUSY) == 0) {
		printk(KERN_INFO "shortprint: waiting for printer busy\n");
		printk(KERN_INFO "Status is 0x%%x\n", inb(shortp_base + SP_STATUS));
		while ((inb(shortp_base + SP_STATUS) & SP_SR_BUSY) == 0) {
			set_current_state(TASK_INTERRUPTIBLE);
			schedule_timeout(10*HZ); 
		}
	}
}


/*
 * Write the next character from the buffer.  There should *be* a next
 * character...	 The spinlock should be held when this routine is called.
 */
static void shortp_do_write(void)
{
	unsigned char cr = inb(shortp_base + SP_CONTROL);

	/* Something happened; reset the timer */
	mod_timer(&shortp_timer, jiffies + TIMEOUT);

	/* Strobe a byte out to the device */
	outb_p(*shortp_out_tail, shortp_base+SP_DATA);
	shortp_incr_out_bp(&shortp_out_tail, 1);
	if (shortp_delay)
		udelay(shortp_delay);
	outb_p(cr | SP_CR_STROBE, shortp_base+SP_CONTROL);
	if (shortp_delay)
		udelay(shortp_delay);
	outb_p(cr & ~SP_CR_STROBE, shortp_base+SP_CONTROL);
}


/*
 * Start output; call under lock.
 */
static void shortp_start_output(void)
{
	if (shortp_output_active) /* Should never happen */
		return;

	/* Set up our 'missed interrupt' timer */
	shortp_output_active = 1;
	shortp_timer.expires = jiffies + TIMEOUT;
	add_timer(&shortp_timer);

	/*  And get the process going. */
	queue_work(shortp_workqueue, &shortp_work);
}


/*
 * Write to the device.
 */
static ssize_t shortp_write(struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	int space, written = 0;
	unsigned long flags;
	/*
	 * Take and hold the semaphore for the entire duration of the operation.  The
	 * consumer side ignores it, and it will keep other data from interleaving
	 * with ours.
	 */
	if (down_interruptible(&shortp_out_sem))
		return -ERESTARTSYS;
	/*
	 * Out with the data.
	 */
	while (written < count) {
		/* Hang out until some buffer space is available. */
		space = shortp_out_space();
		if (space <= 0) {
			if (wait_event_interruptible(shortp_out_queue,
					    (space = shortp_out_space()) > 0))
				goto out;
		}

		/* Move data into the buffer. */
		if ((space + written) > count)
			space = count - written;
		if (copy_from_user((char *) shortp_out_head, buf, space)) {
			up(&shortp_out_sem);
			return -EFAULT;
		}
		shortp_incr_out_bp(&shortp_out_head, space);
		buf += space;
		written += space;

		/* If no output is active, make it active. */
		spin_lock_irqsave(&shortp_out_lock, flags);
		if (! shortp_output_active)
			shortp_start_output();
		spin_unlock_irqrestore(&shortp_out_lock, flags);
	}

out:
	*f_pos += written;
	up(&shortp_out_sem);
	return written;
}


/*
 * The bottom-half handler.
 */


static void shortp_do_work(void *unused)
{
	int written;
	unsigned long flags;

	/* Wait until the device is ready */
	shortp_wait();
	
	spin_lock_irqsave(&shortp_out_lock, flags);

	/* Have we written everything? */
	if (shortp_out_head == shortp_out_tail) { /* empty */
		shortp_output_active = 0;
		wake_up_interruptible(&shortp_empty_queue);
		del_timer(&shortp_timer);  
	}
	/* Nope, write another byte */
	else
		shortp_do_write();

	/* If somebody's waiting, maybe wake them up. */
	if (((PAGE_SIZE + shortp_out_tail - shortp_out_head) %% PAGE_SIZE) > SP_MIN_SPACE) {
		wake_up_interruptible(&shortp_out_queue);
	}
	spin_unlock_irqrestore(&shortp_out_lock, flags);

	/* Handle the "read" side operation */
	written = sprintf((char *)shortp_in_head, "%%08u.%%06u\n",
			(int)(shortp_tv.tv_sec %% 100000000),
			(int)(shortp_tv.tv_usec));
	shortp_incr_bp(&shortp_in_head, written);
	wake_up_interruptible(&shortp_in_queue); /* awake any reading process */
}


/*
 * The top-half interrupt handler.
 */
static irqreturn_t shortp_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	if (! shortp_output_active) 
		return IRQ_NONE;

	/* Remember the time, and farm off the rest to the workqueue function */ 
	do_gettimeofday(&shortp_tv);
	queue_work(shortp_workqueue, &shortp_work);
	return IRQ_HANDLED;
}

/*
 * Interrupt timeouts.	Just because we got a timeout doesn't mean that
 * things have gone wrong, however; printers can spend an awful long time
 * just thinking about things.
 */
static void shortp_timeout(unsigned long unused)
{
	unsigned long flags;
	unsigned char status;
   
	if (! shortp_output_active)
		return;
	spin_lock_irqsave(&shortp_out_lock, flags);
	status = inb(shortp_base + SP_STATUS);

	/* If the printer is still busy we just reset the timer */
	if ((status & SP_SR_BUSY) == 0 || (status & SP_SR_ACK)) {
		shortp_timer.expires = jiffies + TIMEOUT;
		add_timer(&shortp_timer);
		spin_unlock_irqrestore(&shortp_out_lock, flags);
		return;
	}

	/* Otherwise we must have dropped an interrupt. */
	spin_unlock_irqrestore(&shortp_out_lock, flags);
	shortp_interrupt(shortp_irq, NULL, NULL);
}
    




static struct file_operations shortp_fops = {
	.read =	   shortp_read,
	.write =   shortp_write,
	.open =	   shortp_open,
	.release = shortp_release,
	.poll =	   shortp_poll,
	.owner	 = THIS_MODULE
};




/*
 * Module initialization
 */

static int shortp_init(void)
{
	int result;

	/*
	 * first, sort out the base/shortp_base ambiguity: we'd better
	 * use shortp_base in the code, for clarity, but allow setting
	 * just "base" at load time. Same for "irq".
	 */
	shortp_base = base;
	shortp_irq = irq;
	shortp_delay = delay;

	/* Get our needed resources. */
	if (! request_region(shortp_base, SHORTP_NR_PORTS, "shortprint")) {
		printk(KERN_INFO "shortprint: can't get I/O port address 0x%%lx\n",
				shortp_base);
		return -ENODEV;
	}	

	/* Register the device */
	result = register_chrdev(major, "shortprint", &shortp_fops);
	if (result < 0) {
		printk(KERN_INFO "shortp: can't get major number\n");
		release_region(shortp_base, SHORTP_NR_PORTS);
		return result;
	}
	if (major == 0)
		major = result; /* dynamic */

	/* Initialize the input buffer. */
	shortp_in_buffer = __get_free_pages(GFP_KERNEL, 0); /* never fails */
	shortp_in_head = shortp_in_tail = shortp_in_buffer;

	/* And the output buffer. */
	shortp_out_buffer = (unsigned char *) __get_free_pages(GFP_KERNEL, 0);
	shortp_out_head = shortp_out_tail = shortp_out_buffer;
	sema_init(&shortp_out_sem, 1);
    
	/* And the output info */
	shortp_output_active = 0;
	spin_lock_init(&shortp_out_lock);
	init_timer(&shortp_timer);
	shortp_timer.function = shortp_timeout;
	shortp_timer.data = 0;
    
	/* Set up our workqueue. */
	shortp_workqueue = create_singlethread_workqueue("shortprint");

	/* If no IRQ was explicitly requested, pick a default */
	if (shortp_irq < 0)
		switch(shortp_base) {
		    case 0x378: shortp_irq = 7; break;
		    case 0x278: shortp_irq = 2; break;
		    case 0x3bc: shortp_irq = 5; break;
		}

	/* Request the IRQ */
	result = request_irq(shortp_irq, shortp_interrupt, 0, "shortprint", NULL);
	if (result) {
		printk(KERN_INFO "shortprint: can't get assigned irq %%i\n",
				shortp_irq);
		shortp_irq = -1;
		shortp_cleanup ();
		return result;
	}

	/* Initialize the control register, turning on interrupts. */
	outb(SP_CR_IRQ | SP_CR_SELECT | SP_CR_INIT, shortp_base + SP_CONTROL);

	return 0;
}

static void shortp_cleanup(void)
{
	/* Return the IRQ if we have one */
	if (shortp_irq >= 0) {
		outb(0x0, shortp_base + SP_CONTROL);   /* disable the interrupt */
		free_irq(shortp_irq, NULL);
	}

	/* All done with the device */
	unregister_chrdev(major, "shortprint");
	release_region(shortp_base,SHORTP_NR_PORTS);

	/* Don't leave any timers floating around.  Note that any active output
	   is effectively stopped by turning off the interrupt */
	if (shortp_output_active)
		del_timer_sync (&shortp_timer);
	flush_workqueue(shortp_workqueue);
	destroy_workqueue(shortp_workqueue);

	if (shortp_in_buffer)
		free_page(shortp_in_buffer);
	if (shortp_out_buffer)
		free_page((unsigned long) shortp_out_buffer);
}

module_init(shortp_init);
module_exit(shortp_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_simple">
			<text>
				<![CDATA[/*
 * Simple - REALLY simple memory mapping demonstration.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: simple.c,v 1.12 2005/01/31 16:15:31 rubini Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/kernel.h>   /* printk() */
#include <linux/slab.h>   /* kmalloc() */
#include <linux/fs.h>       /* everything... */
#include <linux/errno.h>    /* error codes */
#include <linux/types.h>    /* size_t */
#include <linux/mm.h>
#include <linux/kdev_t.h>
#include <asm/page.h>
#include <linux/cdev.h>

#include <linux/device.h>

static int simple_major = 0;
module_param(simple_major, int, 0);
MODULE_AUTHOR("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");

/*
 * Open the device; in fact, there's nothing to do here.
 */
static int simple_open (struct inode *inode, struct file *filp)
{
	return 0;
}


/*
 * Closing is just as simpler.
 */
static int simple_release(struct inode *inode, struct file *filp)
{
	return 0;
}



/*
 * Common VMA ops.
 */

void simple_vma_open(struct vm_area_struct *vma)
{
	printk(KERN_NOTICE "Simple VMA open, virt %%lx, phys %%lx\n",
			vma->vm_start, vma->vm_pgoff << PAGE_SHIFT);
}

void simple_vma_close(struct vm_area_struct *vma)
{
	printk(KERN_NOTICE "Simple VMA close.\n");
}


/*
 * The remap_pfn_range version of mmap.  This one is heavily borrowed
 * from drivers/char/mem.c.
 */

static struct vm_operations_struct simple_remap_vm_ops = {
	.open =  simple_vma_open,
	.close = simple_vma_close,
};

static int simple_remap_mmap(struct file *filp, struct vm_area_struct *vma)
{
	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
			    vma->vm_end - vma->vm_start,
			    vma->vm_page_prot))
		return -EAGAIN;

	vma->vm_ops = &simple_remap_vm_ops;
	simple_vma_open(vma);
	return 0;
}



/*
 * The nopage version.
 */
struct page *simple_vma_nopage(struct vm_area_struct *vma,
                unsigned long address, int *type)
{
	struct page *pageptr;
	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
	unsigned long physaddr = address - vma->vm_start + offset;
	unsigned long pageframe = physaddr >> PAGE_SHIFT;

// Eventually remove these printks
	printk (KERN_NOTICE "---- Nopage, off %%lx phys %%lx\n", offset, physaddr);
	printk (KERN_NOTICE "VA is %%p\n", __va (physaddr));
	printk (KERN_NOTICE "Page at %%p\n", virt_to_page (__va (physaddr)));
	if (!pfn_valid(pageframe))
		return NOPAGE_SIGBUS;
	pageptr = pfn_to_page(pageframe);
	printk (KERN_NOTICE "page->index = %%ld mapping %%p\n", pageptr->index, pageptr->mapping);
	printk (KERN_NOTICE "Page frame %%ld\n", pageframe);
	get_page(pageptr);
	if (type)
		*type = VM_FAULT_MINOR;
	return pageptr;
}

static struct vm_operations_struct simple_nopage_vm_ops = {
	.open =   simple_vma_open,
	.close =  simple_vma_close,
	.nopage = simple_vma_nopage,
};

static int simple_nopage_mmap(struct file *filp, struct vm_area_struct *vma)
{
	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;

	if (offset >= __pa(high_memory) || (filp->f_flags & O_SYNC))
		vma->vm_flags |= VM_IO;
	vma->vm_flags |= VM_RESERVED;

	vma->vm_ops = &simple_nopage_vm_ops;
	simple_vma_open(vma);
	return 0;
}


/*
 * Set up the cdev structure for a device.
 */
static void simple_setup_cdev(struct cdev *dev, int minor,
		struct file_operations *fops)
{
	int err, devno = MKDEV(simple_major, minor);
    
	cdev_init(dev, fops);
	dev->owner = THIS_MODULE;
	dev->ops = fops;
	err = cdev_add (dev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk (KERN_NOTICE "Error %%d adding simple%%d", err, minor);
}


/*
 * Our various sub-devices.
 */
/* Device 0 uses remap_pfn_range */
static struct file_operations simple_remap_ops = {
	.owner   = THIS_MODULE,
	.open    = simple_open,
	.release = simple_release,
	.mmap    = simple_remap_mmap,
};

/* Device 1 uses nopage */
static struct file_operations simple_nopage_ops = {
	.owner   = THIS_MODULE,
	.open    = simple_open,
	.release = simple_release,
	.mmap    = simple_nopage_mmap,
};

#define MAX_SIMPLE_DEV 2

#if 0
static struct file_operations *simple_fops[MAX_SIMPLE_DEV] = {
	&simple_remap_ops,
	&simple_nopage_ops,
};
#endif

/*
 * We export two simple devices.  There's no need for us to maintain any
 * special housekeeping info, so we just deal with raw cdevs.
 */
static struct cdev SimpleDevs[MAX_SIMPLE_DEV];

/*
 * Module housekeeping.
 */
static int simple_init(void)
{
	int result;
	dev_t dev = MKDEV(simple_major, 0);

	/* Figure out our device number. */
	if (simple_major)
		result = register_chrdev_region(dev, 2, "simple");
	else {
		result = alloc_chrdev_region(&dev, 0, 2, "simple");
		simple_major = MAJOR(dev);
	}
	if (result < 0) {
		printk(KERN_WARNING "simple: unable to get major %%d\n", simple_major);
		return result;
	}
	if (simple_major == 0)
		simple_major = result;

	/* Now set up two cdevs. */
	simple_setup_cdev(SimpleDevs, 0, &simple_remap_ops);
	simple_setup_cdev(SimpleDevs + 1, 1, &simple_nopage_ops);
	return 0;
}


static void simple_cleanup(void)
{
	cdev_del(SimpleDevs);
	cdev_del(SimpleDevs + 1);
	unregister_chrdev_region(MKDEV(simple_major, 0), 2);
}


module_init(simple_init);
module_exit(simple_cleanup);
]]>
			</text>
		</p>
		<p n="xln_drv_skull_clean">
			<text>
				<![CDATA[#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>

#include <linux/ioport.h>

void skull_release(unsigned int port, unsigned int range)
{
    release_region(port,range);
}

void skull_cleanup(void)
{
    /* should put real values here ... */
    /* skull_release(0,0); */
}

module_exit(skull_cleanup);




]]>
			</text>
		</p>
		<p n="xlnx_drv_skull_init">
			<text>
				<![CDATA[/*
 * skull.c -- sample typeless module.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * BUGS:
 *   -it only runs on intel platforms.
 *   -readb() should be used (see short.c): skull doesn't work with 2.1
 *
 */

/* jc: cleaned up, but not yet run for anything */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>

#include <linux/kernel.h> /* printk */
#include <linux/ioport.h>
#include <linux/errno.h>
#include <asm/system.h> /* cli(), *_flags */
#include <linux/mm.h> /* vremap (2.0) */
#include <asm/io.h> /* ioremap */

/* The region we look at. */
#define ISA_REGION_BEGIN 0xA0000
#define ISA_REGION_END   0x100000
#define STEP 2048

/* have three symbols to export */
       void skull_fn1(void){}
static void skull_fn2(void){}
       int  skull_variable;

EXPORT_SYMBOL (skull_fn1);
EXPORT_SYMBOL (skull_fn2);
EXPORT_SYMBOL (skull_variable);


/* perform hardware autodetection */
int skull_probe_hw(unsigned int port, unsigned int range)
{
   /* do smart probing here */
   return -1; /* not found  :-) */
}

/* perform hardware initalizazion */
int skull_init_board(unsigned int port)
{
  /* do smart initalization here */
  return 0; /* done :-) */
}

/* detect the the device if the region is still free */
static int skull_detect(unsigned int port, unsigned int range)
{
    int err;

    if ((err = check_region(port,range)) < 0) return err; /* busy */
    if (skull_probe_hw(port,range) != 0) return -ENODEV;  /* not found */
    request_region(port,range,"skull");                   /* "Can't fail" */
    return 0;
}

/*
 * port ranges: the device can reside between
 * 0x280 and 0x300, in step of 0x10. It uses 0x10 ports.
 */
#define SKULL_PORT_FLOOR 0x280
#define SKULL_PORT_CEIL  0x300
#define SKULL_PORT_RANGE  0x010

/*
 * the following function performs autodetection, unless a specific
 * value was assigned by insmod to "skull_port_base"
 */

static int skull_port_base=0; /* 0 forces autodetection */
module_param(skull_port_base, int, 0);

static int skull_find_hw(void) /* returns the # of devices */
{
    /* base is either the load-time value or the first trial */
    int base = skull_port_base ? skull_port_base 
                             : SKULL_PORT_FLOOR; 
    int result = 0;

    /* loop one time if value assigned, try them all if autodetecting */
    do {
	if (skull_detect(base, SKULL_PORT_RANGE) == 0) {
	    skull_init_board(base);
	    result++;
	}
	base += SKULL_PORT_RANGE; /* prepare for next trial */
    }
    while (skull_port_base == 0 && base < SKULL_PORT_CEIL);

    return result;
}


int skull_init(void)
{
    /*
     * Print the isa region map, in blocks of 2K bytes.
     * This is not the best code, as it prints too many lines,
     * but it deserves to remain short to be included in the book.
     * Note also that read() should be used instead of pointers.
     */
    unsigned char oldval, newval; /* values read from memory   */
    unsigned long flags;          /* used to hold system flags */
    unsigned long add, i;
    void *base;
    
    /* Use ioremap to get a handle on our region */
    base = ioremap(ISA_REGION_BEGIN, ISA_REGION_END - ISA_REGION_BEGIN);
    base -= ISA_REGION_BEGIN;  /* Do the offset once */
    
    /* probe all the memory hole in 2KB steps */
    for (add = ISA_REGION_BEGIN; add < ISA_REGION_END; add += STEP) {
	/*
	 * Check for an already allocated region.
	 */
	if (check_mem_region (add, 2048)) {
		printk(KERN_INFO "%%lx: Allocated\n", add);
		continue;
	}
	/*
	 * Read and write the beginning of the region and see what happens.
	 */
	save_flags(flags); 
	cli();
	oldval = readb (base + add);  /* Read a byte */
	writeb (oldval^0xff, base + add);
	mb();
	newval = readb (base + add);
	writeb (oldval, base + add);
	restore_flags(flags);

	if ((oldval^newval) == 0xff) {  /* we re-read our change: it's ram */
	    printk(KERN_INFO "%%lx: RAM\n", add);
	    continue;
	}
	if ((oldval^newval) != 0) {  /* random bits changed: it's empty */
	    printk(KERN_INFO "%%lx: empty\n", add);
	    continue;
	}
	
	/*
	 * Expansion rom (executed at boot time by the bios)
	 * has a signature where the first byt is 0x55, the second 0xaa,
	 * and the third byte indicates the size of such rom
	 */
	if ( (oldval == 0x55) && (readb (base + add + 1) == 0xaa)) {
	    int size = 512 * readb (base + add + 2);
	    printk(KERN_INFO "%%lx: Expansion ROM, %%i bytes\n",
                   add, size);
	    add += (size & ~2048) - 2048; /* skip it */
	    continue;
	}
	
	/*
	 * If the tests above failed, we still don't know if it is ROM or
	 * empty. Since empty memory can appear as 0x00, 0xff, or the low
	 * address byte, we must probe multiple bytes: if at least one of
	 * them is different from these three values, then this is rom
	 * (though not boot rom).
	 */
	printk(KERN_INFO "%%lx: ", add);
	for (i=0; i<5; i++) {
	    unsigned long radd = add + 57*(i+1);  /* a "random" value */
	    unsigned char val = readb (base + radd);
	    if (val && val != 0xFF && val != ((unsigned long) radd&0xFF))
		break;
	}    
	printk("%%s\n", i==5 ? "empty" : "ROM");
    }

    /*
     * Find you hardware 
     */
    skull_find_hw();

    /*
     * Always fail to load (or suceed).
     */
    return 0;
}

module_init(skull_init);
]]>
			</text>
		</p>
		<p n="xlnx_drv_snull">
			<text>
				<![CDATA[/*
 * snull.c --  the Simple Network Utility
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: snull.c,v 1.21 2004/11/05 02:36:03 rubini Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>

#include <linux/sched.h>
#include <linux/kernel.h> /* printk() */
#include <linux/slab.h> /* kmalloc() */
#include <linux/errno.h>  /* error codes */
#include <linux/types.h>  /* size_t */
#include <linux/interrupt.h> /* mark_bh */

#include <linux/in.h>
#include <linux/netdevice.h>   /* struct device, and other headers */
#include <linux/etherdevice.h> /* eth_type_trans */
#include <linux/ip.h>          /* struct iphdr */
#include <linux/tcp.h>         /* struct tcphdr */
#include <linux/skbuff.h>

#include "snull.h"

#include <linux/in6.h>
#include <asm/checksum.h>

MODULE_AUTHOR("Alessandro Rubini, Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");


/*
 * Transmitter lockup simulation, normally disabled.
 */
static int lockup = 0;
module_param(lockup, int, 0);

static int timeout = SNULL_TIMEOUT;
module_param(timeout, int, 0);

/*
 * Do we run in NAPI mode?
 */
static int use_napi = 0;
module_param(use_napi, int, 0);


/*
 * A structure representing an in-flight packet.
 */
struct snull_packet {
	struct snull_packet *next;
	struct net_device *dev;
	int	datalen;
	u8 data[ETH_DATA_LEN];
};

int pool_size = 8;
module_param(pool_size, int, 0);

/*
 * This structure is private to each device. It is used to pass
 * packets in and out, so there is place for a packet
 */

struct snull_priv {
	struct net_device_stats stats;
	int status;
	struct snull_packet *ppool;
	struct snull_packet *rx_queue;  /* List of incoming packets */
	int rx_int_enabled;
	int tx_packetlen;
	u8 *tx_packetdata;
	struct sk_buff *skb;
	spinlock_t lock;
};

static void snull_tx_timeout(struct net_device *dev);
static void (*snull_interrupt)(int, void *, struct pt_regs *);

/*
 * Set up a device's packet pool.
 */
void snull_setup_pool(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	int i;
	struct snull_packet *pkt;

	priv->ppool = NULL;
	for (i = 0; i < pool_size; i++) {
		pkt = kmalloc (sizeof (struct snull_packet), GFP_KERNEL);
		if (pkt == NULL) {
			printk (KERN_NOTICE "Ran out of memory allocating packet pool\n");
			return;
		}
		pkt->dev = dev;
		pkt->next = priv->ppool;
		priv->ppool = pkt;
	}
}

void snull_teardown_pool(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	struct snull_packet *pkt;
    
	while ((pkt = priv->ppool)) {
		priv->ppool = pkt->next;
		kfree (pkt);
		/* FIXME - in-flight packets ? */
	}
}    

/*
 * Buffer/pool management.
 */
struct snull_packet *snull_get_tx_buffer(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	unsigned long flags;
	struct snull_packet *pkt;
    
	spin_lock_irqsave(&priv->lock, flags);
	pkt = priv->ppool;
	priv->ppool = pkt->next;
	if (priv->ppool == NULL) {
		printk (KERN_INFO "Pool empty\n");
		netif_stop_queue(dev);
	}
	spin_unlock_irqrestore(&priv->lock, flags);
	return pkt;
}


void snull_release_buffer(struct snull_packet *pkt)
{
	unsigned long flags;
	struct snull_priv *priv = netdev_priv(pkt->dev);
	
	spin_lock_irqsave(&priv->lock, flags);
	pkt->next = priv->ppool;
	priv->ppool = pkt;
	spin_unlock_irqrestore(&priv->lock, flags);
	if (netif_queue_stopped(pkt->dev) && pkt->next == NULL)
		netif_wake_queue(pkt->dev);
}

void snull_enqueue_buf(struct net_device *dev, struct snull_packet *pkt)
{
	unsigned long flags;
	struct snull_priv *priv = netdev_priv(dev);

	spin_lock_irqsave(&priv->lock, flags);
	pkt->next = priv->rx_queue;  /* FIXME - misorders packets */
	priv->rx_queue = pkt;
	spin_unlock_irqrestore(&priv->lock, flags);
}

struct snull_packet *snull_dequeue_buf(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	struct snull_packet *pkt;
	unsigned long flags;

	spin_lock_irqsave(&priv->lock, flags);
	pkt = priv->rx_queue;
	if (pkt != NULL)
		priv->rx_queue = pkt->next;
	spin_unlock_irqrestore(&priv->lock, flags);
	return pkt;
}

/*
 * Enable and disable receive interrupts.
 */
static void snull_rx_ints(struct net_device *dev, int enable)
{
	struct snull_priv *priv = netdev_priv(dev);
	priv->rx_int_enabled = enable;
}

    
/*
 * Open and close
 */

int snull_open(struct net_device *dev)
{
	/* request_region(), request_irq(), ....  (like fops->open) */

	/* 
	 * Assign the hardware address of the board: use "\0SNULx", where
	 * x is 0 or 1. The first byte is '\0' to avoid being a multicast
	 * address (the first byte of multicast addrs is odd).
	 */
	memcpy(dev->dev_addr, "\0SNUL0", ETH_ALEN);
	if (dev == snull_devs[1])
		dev->dev_addr[ETH_ALEN-1]++; /* \0SNUL1 */
	netif_start_queue(dev);
	return 0;
}

int snull_release(struct net_device *dev)
{
    /* release ports, irq and such -- like fops->close */

	netif_stop_queue(dev); /* can't transmit any more */
	return 0;
}

/*
 * Configuration changes (passed on by ifconfig)
 */
int snull_config(struct net_device *dev, struct ifmap *map)
{
	if (dev->flags & IFF_UP) /* can't act on a running interface */
		return -EBUSY;

	/* Don't allow changing the I/O address */
	if (map->base_addr != dev->base_addr) {
		printk(KERN_WARNING "snull: Can't change I/O address\n");
		return -EOPNOTSUPP;
	}

	/* Allow changing the IRQ */
	if (map->irq != dev->irq) {
		dev->irq = map->irq;
        	/* request_irq() is delayed to open-time */
	}

	/* ignore other fields */
	return 0;
}

/*
 * Receive a packet: retrieve, encapsulate and pass over to upper levels
 */
void snull_rx(struct net_device *dev, struct snull_packet *pkt)
{
	struct sk_buff *skb;
	struct snull_priv *priv = netdev_priv(dev);

	/*
	 * The packet has been retrieved from the transmission
	 * medium. Build an skb around it, so upper layers can handle it
	 */
	skb = dev_alloc_skb(pkt->datalen + 2);
	if (!skb) {
		if (printk_ratelimit())
			printk(KERN_NOTICE "snull rx: low on mem - packet dropped\n");
		priv->stats.rx_dropped++;
		goto out;
	}
	skb_reserve(skb, 2); /* align IP on 16B boundary */  
	memcpy(skb_put(skb, pkt->datalen), pkt->data, pkt->datalen);

	/* Write metadata, and then pass to the receive level */
	skb->dev = dev;
	skb->protocol = eth_type_trans(skb, dev);
	skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
	priv->stats.rx_packets++;
	priv->stats.rx_bytes += pkt->datalen;
	netif_rx(skb);
  out:
	return;
}
    

/*
 * The poll implementation.
 */
static int snull_poll(struct net_device *dev, int *budget)
{
	int npackets = 0, quota = min(dev->quota, *budget);
	struct sk_buff *skb;
	struct snull_priv *priv = netdev_priv(dev);
	struct snull_packet *pkt;
    
	while (npackets < quota && priv->rx_queue) {
		pkt = snull_dequeue_buf(dev);
		skb = dev_alloc_skb(pkt->datalen + 2);
		if (! skb) {
			if (printk_ratelimit())
				printk(KERN_NOTICE "snull: packet dropped\n");
			priv->stats.rx_dropped++;
			snull_release_buffer(pkt);
			continue;
		}
		skb_reserve(skb, 2); /* align IP on 16B boundary */  
		memcpy(skb_put(skb, pkt->datalen), pkt->data, pkt->datalen);
		skb->dev = dev;
		skb->protocol = eth_type_trans(skb, dev);
		skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
		netif_receive_skb(skb);
		
        	/* Maintain stats */
		npackets++;
		priv->stats.rx_packets++;
		priv->stats.rx_bytes += pkt->datalen;
		snull_release_buffer(pkt);
	}
	/* If we processed all packets, we're done; tell the kernel and reenable ints */
	*budget -= npackets;
	dev->quota -= npackets;
	if (! priv->rx_queue) {
		netif_rx_complete(dev);
		snull_rx_ints(dev, 1);
		return 0;
	}
	/* We couldn't process everything. */
	return 1;
}
	    
        
/*
 * The typical interrupt entry point
 */
static void snull_regular_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	int statusword;
	struct snull_priv *priv;
	struct snull_packet *pkt = NULL;
	/*
	 * As usual, check the "device" pointer to be sure it is
	 * really interrupting.
	 * Then assign "struct device *dev"
	 */
	struct net_device *dev = (struct net_device *)dev_id;
	/* ... and check with hw if it's really ours */

	/* paranoid */
	if (!dev)
		return;

	/* Lock the device */
	priv = netdev_priv(dev);
	spin_lock(&priv->lock);

	/* retrieve statusword: real netdevices use I/O instructions */
	statusword = priv->status;
	priv->status = 0;
	if (statusword & SNULL_RX_INTR) {
		/* send it to snull_rx for handling */
		pkt = priv->rx_queue;
		if (pkt) {
			priv->rx_queue = pkt->next;
			snull_rx(dev, pkt);
		}
	}
	if (statusword & SNULL_TX_INTR) {
		/* a transmission is over: free the skb */
		priv->stats.tx_packets++;
		priv->stats.tx_bytes += priv->tx_packetlen;
		dev_kfree_skb(priv->skb);
	}

	/* Unlock the device and we are done */
	spin_unlock(&priv->lock);
	if (pkt) snull_release_buffer(pkt); /* Do this outside the lock! */
	return;
}

/*
 * A NAPI interrupt handler.
 */
static void snull_napi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	int statusword;
	struct snull_priv *priv;

	/*
	 * As usual, check the "device" pointer for shared handlers.
	 * Then assign "struct device *dev"
	 */
	struct net_device *dev = (struct net_device *)dev_id;
	/* ... and check with hw if it's really ours */

	/* paranoid */
	if (!dev)
		return;

	/* Lock the device */
	priv = netdev_priv(dev);
	spin_lock(&priv->lock);

	/* retrieve statusword: real netdevices use I/O instructions */
	statusword = priv->status;
	priv->status = 0;
	if (statusword & SNULL_RX_INTR) {
		snull_rx_ints(dev, 0);  /* Disable further interrupts */
		netif_rx_schedule(dev);
	}
	if (statusword & SNULL_TX_INTR) {
        	/* a transmission is over: free the skb */
		priv->stats.tx_packets++;
		priv->stats.tx_bytes += priv->tx_packetlen;
		dev_kfree_skb(priv->skb);
	}

	/* Unlock the device and we are done */
	spin_unlock(&priv->lock);
	return;
}



/*
 * Transmit a packet (low level interface)
 */
static void snull_hw_tx(char *buf, int len, struct net_device *dev)
{
	/*
	 * This function deals with hw details. This interface loops
	 * back the packet to the other snull interface (if any).
	 * In other words, this function implements the snull behaviour,
	 * while all other procedures are rather device-independent
	 */
	struct iphdr *ih;
	struct net_device *dest;
	struct snull_priv *priv;
	u32 *saddr, *daddr;
	struct snull_packet *tx_buffer;
    
	/* I am paranoid. Ain't I? */
	if (len < sizeof(struct ethhdr) + sizeof(struct iphdr)) {
		printk("snull: Hmm... packet too short (%%i octets)\n",
				len);
		return;
	}

	if (0) { /* enable this conditional to look at the data */
		int i;
		PDEBUG("len is %%i\n" KERN_DEBUG "data:",len);
		for (i=14 ; i<len; i++)
			printk(" %%02x",buf[i]&0xff);
		printk("\n");
	}
	/*
	 * Ethhdr is 14 bytes, but the kernel arranges for iphdr
	 * to be aligned (i.e., ethhdr is unaligned)
	 */
	ih = (struct iphdr *)(buf+sizeof(struct ethhdr));
	saddr = &ih->saddr;
	daddr = &ih->daddr;

	((u8 *)saddr)[2] ^= 1; /* change the third octet (class C) */
	((u8 *)daddr)[2] ^= 1;

	ih->check = 0;         /* and rebuild the checksum (ip needs it) */
	ih->check = ip_fast_csum((unsigned char *)ih,ih->ihl);

	if (dev == snull_devs[0])
		PDEBUGG("%%08x:%%05i --> %%08x:%%05i\n",
				ntohl(ih->saddr),ntohs(((struct tcphdr *)(ih+1))->source),
				ntohl(ih->daddr),ntohs(((struct tcphdr *)(ih+1))->dest));
	else
		PDEBUGG("%%08x:%%05i <-- %%08x:%%05i\n",
				ntohl(ih->daddr),ntohs(((struct tcphdr *)(ih+1))->dest),
				ntohl(ih->saddr),ntohs(((struct tcphdr *)(ih+1))->source));

	/*
	 * Ok, now the packet is ready for transmission: first simulate a
	 * receive interrupt on the twin device, then  a
	 * transmission-done on the transmitting device
	 */
	dest = snull_devs[dev == snull_devs[0] ? 1 : 0];
	priv = netdev_priv(dest);
	tx_buffer = snull_get_tx_buffer(dev);
	tx_buffer->datalen = len;
	memcpy(tx_buffer->data, buf, len);
	snull_enqueue_buf(dest, tx_buffer);
	if (priv->rx_int_enabled) {
		priv->status |= SNULL_RX_INTR;
		snull_interrupt(0, dest, NULL);
	}

	priv = netdev_priv(dev);
	priv->tx_packetlen = len;
	priv->tx_packetdata = buf;
	priv->status |= SNULL_TX_INTR;
	if (lockup && ((priv->stats.tx_packets + 1) %% lockup) == 0) {
        	/* Simulate a dropped transmit interrupt */
		netif_stop_queue(dev);
		PDEBUG("Simulate lockup at %%ld, txp %%ld\n", jiffies,
				(unsigned long) priv->stats.tx_packets);
	}
	else
		snull_interrupt(0, dev, NULL);
}

/*
 * Transmit a packet (called by the kernel)
 */
int snull_tx(struct sk_buff *skb, struct net_device *dev)
{
	int len;
	char *data, shortpkt[ETH_ZLEN];
	struct snull_priv *priv = netdev_priv(dev);
	
	data = skb->data;
	len = skb->len;
	if (len < ETH_ZLEN) {
		memset(shortpkt, 0, ETH_ZLEN);
		memcpy(shortpkt, skb->data, skb->len);
		len = ETH_ZLEN;
		data = shortpkt;
	}
	dev->trans_start = jiffies; /* save the timestamp */

	/* Remember the skb, so we can free it at interrupt time */
	priv->skb = skb;

	/* actual deliver of data is device-specific, and not shown here */
	snull_hw_tx(data, len, dev);

	return 0; /* Our simple device can not fail */
}

/*
 * Deal with a transmit timeout.
 */
void snull_tx_timeout (struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);

	PDEBUG("Transmit timeout at %%ld, latency %%ld\n", jiffies,
			jiffies - dev->trans_start);
        /* Simulate a transmission interrupt to get things moving */
	priv->status = SNULL_TX_INTR;
	snull_interrupt(0, dev, NULL);
	priv->stats.tx_errors++;
	netif_wake_queue(dev);
	return;
}



/*
 * Ioctl commands 
 */
int snull_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	PDEBUG("ioctl\n");
	return 0;
}

/*
 * Return statistics to the caller
 */
struct net_device_stats *snull_stats(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	return &priv->stats;
}

/*
 * This function is called to fill up an eth header, since arp is not
 * available on the interface
 */
int snull_rebuild_header(struct sk_buff *skb)
{
	struct ethhdr *eth = (struct ethhdr *) skb->data;
	struct net_device *dev = skb->dev;
    
	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
	memcpy(eth->h_dest, dev->dev_addr, dev->addr_len);
	eth->h_dest[ETH_ALEN-1]   ^= 0x01;   /* dest is us xor 1 */
	return 0;
}


int snull_header(struct sk_buff *skb, struct net_device *dev,
                unsigned short type, void *daddr, void *saddr,
                unsigned int len)
{
	struct ethhdr *eth = (struct ethhdr *)skb_push(skb,ETH_HLEN);

	eth->h_proto = htons(type);
	memcpy(eth->h_source, saddr ? saddr : dev->dev_addr, dev->addr_len);
	memcpy(eth->h_dest,   daddr ? daddr : dev->dev_addr, dev->addr_len);
	eth->h_dest[ETH_ALEN-1]   ^= 0x01;   /* dest is us xor 1 */
	return (dev->hard_header_len);
}





/*
 * The "change_mtu" method is usually not needed.
 * If you need it, it must be like this.
 */
int snull_change_mtu(struct net_device *dev, int new_mtu)
{
	unsigned long flags;
	struct snull_priv *priv = netdev_priv(dev);
	spinlock_t *lock = &priv->lock;
    
	/* check ranges */
	if ((new_mtu < 68) || (new_mtu > 1500))
		return -EINVAL;
	/*
	 * Do anything you need, and the accept the value
	 */
	spin_lock_irqsave(lock, flags);
	dev->mtu = new_mtu;
	spin_unlock_irqrestore(lock, flags);
	return 0; /* success */
}

/*
 * The init function (sometimes called probe).
 * It is invoked by register_netdev()
 */
void snull_init(struct net_device *dev)
{
	struct snull_priv *priv;
#if 0
    	/*
	 * Make the usual checks: check_region(), probe irq, ...  -ENODEV
	 * should be returned if no device found.  No resource should be
	 * grabbed: this is done on open(). 
	 */
#endif

    	/* 
	 * Then, assign other fields in dev, using ether_setup() and some
	 * hand assignments
	 */
	ether_setup(dev); /* assign some of the fields */

	dev->open            = snull_open;
	dev->stop            = snull_release;
	dev->set_config      = snull_config;
	dev->hard_start_xmit = snull_tx;
	dev->do_ioctl        = snull_ioctl;
	dev->get_stats       = snull_stats;
	dev->change_mtu      = snull_change_mtu;  
	dev->rebuild_header  = snull_rebuild_header;
	dev->hard_header     = snull_header;
	dev->tx_timeout      = snull_tx_timeout;
	dev->watchdog_timeo = timeout;
	if (use_napi) {
		dev->poll        = snull_poll;
		dev->weight      = 2;
	}
	/* keep the default flags, just add NOARP */
	dev->flags           |= IFF_NOARP;
	dev->features        |= NETIF_F_NO_CSUM;
	dev->hard_header_cache = NULL;      /* Disable caching */

	/*
	 * Then, initialize the priv field. This encloses the statistics
	 * and a few private fields.
	 */
	priv = netdev_priv(dev);
	memset(priv, 0, sizeof(struct snull_priv));
	spin_lock_init(&priv->lock);
	snull_rx_ints(dev, 1);		/* enable receive interrupts */
	snull_setup_pool(dev);
}

/*
 * The devices
 */

struct net_device *snull_devs[2];



/*
 * Finally, the module stuff
 */

void snull_cleanup(void)
{
	int i;
    
	for (i = 0; i < 2;  i++) {
		if (snull_devs[i]) {
			unregister_netdev(snull_devs[i]);
			snull_teardown_pool(snull_devs[i]);
			free_netdev(snull_devs[i]);
		}
	}
	return;
}




int snull_init_module(void)
{
	int result, i, ret = -ENOMEM;

	snull_interrupt = use_napi ? snull_napi_interrupt : snull_regular_interrupt;

	/* Allocate the devices */
	snull_devs[0] = alloc_netdev(sizeof(struct snull_priv), "sn%%d",
			snull_init);
	snull_devs[1] = alloc_netdev(sizeof(struct snull_priv), "sn%%d",
			snull_init);
	if (snull_devs[0] == NULL || snull_devs[1] == NULL)
		goto out;

	ret = -ENODEV;
	for (i = 0; i < 2;  i++)
		if ((result = register_netdev(snull_devs[i])))
			printk("snull: error %%i registering device \"%%s\"\n",
					result, snull_devs[i]->name);
		else
			ret = 0;
   out:
	if (ret) 
		snull_cleanup();
	return ret;
}


module_init(snull_init_module);
module_exit(snull_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_tiny_serial">
			<text>
				<![CDATA[/*
 * Tiny Serial driver
 *
 * Copyright (C) 2002-2004 Greg Kroah-Hartman (greg@kroah.com)
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, version 2 of the License.
 *
 * This driver shows how to create a minimal serial driver.  It does not rely on
 * any backing hardware, but creates a timer that emulates data being received
 * from some kind of hardware.
 */

#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/serial.h>
#include <linux/serial_core.h>
#include <linux/module.h>


#define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>"
#define DRIVER_DESC "Tiny serial driver"

/* Module information */
MODULE_AUTHOR( DRIVER_AUTHOR );
MODULE_DESCRIPTION( DRIVER_DESC );
MODULE_LICENSE("GPL");

#define DELAY_TIME		HZ * 2	/* 2 seconds per character */
#define TINY_DATA_CHARACTER	't'

#define TINY_SERIAL_MAJOR	240	/* experimental range */
#define TINY_SERIAL_MINORS	1	/* only have one minor */
#define UART_NR			1	/* only use one port */

#define TINY_SERIAL_NAME	"ttytiny"

#define MY_NAME			TINY_SERIAL_NAME

static struct timer_list *timer;

static void tiny_stop_tx(struct uart_port *port, unsigned int tty_stop)
{
}

static void tiny_stop_rx(struct uart_port *port)
{
}

static void tiny_enable_ms(struct uart_port *port)
{
}

static void tiny_tx_chars(struct uart_port *port)
{
	struct circ_buf *xmit = &port->info->xmit;
	int count;

	if (port->x_char) {
		pr_debug("wrote %%2x", port->x_char);
		port->icount.tx++;
		port->x_char = 0;
		return;
	}
	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
		tiny_stop_tx(port, 0);
		return;
	}

	count = port->fifosize >> 1;
	do {
		pr_debug("wrote %%2x", xmit->buf[xmit->tail]);
		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
		port->icount.tx++;
		if (uart_circ_empty(xmit))
			break;
	} while (--count > 0);

	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
		uart_write_wakeup(port);

	if (uart_circ_empty(xmit))
		tiny_stop_tx(port, 0);
}

static void tiny_start_tx(struct uart_port *port, unsigned int tty_start)
{
}

static void tiny_timer(unsigned long data)
{
	struct uart_port *port;
	struct tty_struct *tty;


	port = (struct uart_port *)data;
	if (!port)
		return;
	if (!port->info)
		return;
	tty = port->info->tty;
	if (!tty)
		return;

	/* add one character to the tty port */
	/* this doesn't actually push the data through unless tty->low_latency is set */
	tty_insert_flip_char(tty, TINY_DATA_CHARACTER, 0);

	tty_flip_buffer_push(tty);

	/* resubmit the timer again */
	timer->expires = jiffies + DELAY_TIME;
	add_timer(timer);

	/* see if we have any data to transmit */
	tiny_tx_chars(port);
}

static unsigned int tiny_tx_empty(struct uart_port *port)
{
	return 0;
}

static unsigned int tiny_get_mctrl(struct uart_port *port)
{
	return 0;
}

static void tiny_set_mctrl(struct uart_port *port, unsigned int mctrl)
{
}

static void tiny_break_ctl(struct uart_port *port, int break_state)
{
}

static void tiny_set_termios(struct uart_port *port,
			     struct termios *new, struct termios *old)
{
	int baud, quot, cflag = new->c_cflag;
	/* get the byte size */
	switch (cflag & CSIZE) {
	case CS5:
		printk(KERN_DEBUG " - data bits = 5\n");
		break;
	case CS6:
		printk(KERN_DEBUG " - data bits = 6\n");
		break;
	case CS7:
		printk(KERN_DEBUG " - data bits = 7\n");
		break;
	default: // CS8
		printk(KERN_DEBUG " - data bits = 8\n");
		break;
	}

	/* determine the parity */
	if (cflag & PARENB)
		if (cflag & PARODD)
			pr_debug(" - parity = odd\n");
		else
			pr_debug(" - parity = even\n");
	else
		pr_debug(" - parity = none\n");

	/* figure out the stop bits requested */
	if (cflag & CSTOPB)
		pr_debug(" - stop bits = 2\n");
	else
		pr_debug(" - stop bits = 1\n");

	/* figure out the flow control settings */
	if (cflag & CRTSCTS)
		pr_debug(" - RTS/CTS is enabled\n");
	else
		pr_debug(" - RTS/CTS is disabled\n");

	/* Set baud rate */
        baud = uart_get_baud_rate(port, new, old, 0, port->uartclk/16);
        quot = uart_get_divisor(port, baud);
	
	//UART_PUT_DIV_LO(port, (quot & 0xff));
	//UART_PUT_DIV_HI(port, ((quot & 0xf00) >> 8));
}

static int tiny_startup(struct uart_port *port)
{
	/* this is the first time this port is opened */
	/* do any hardware initialization needed here */

	/* create our timer and submit it */
	if (!timer) {
		timer = kmalloc(sizeof(*timer), GFP_KERNEL);
		if (!timer)
			return -ENOMEM;
	}
	timer->data = (unsigned long)port;
	timer->expires = jiffies + DELAY_TIME;
	timer->function = tiny_timer;
	add_timer(timer);
	return 0;
}

static void tiny_shutdown(struct uart_port *port)
{
	/* The port is being closed by the last user. */
	/* Do any hardware specific stuff here */

	/* shut down our timer */
	del_timer(timer);
}

static const char *tiny_type(struct uart_port *port)
{
	return "tinytty";
}

static void tiny_release_port(struct uart_port *port)
{

}

static int tiny_request_port(struct uart_port *port)
{
	return 0;
}

static void tiny_config_port(struct uart_port *port, int flags)
{
}

static int tiny_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return 0;
}

static struct uart_ops tiny_ops = {
	.tx_empty	= tiny_tx_empty,
	.set_mctrl	= tiny_set_mctrl,
	.get_mctrl	= tiny_get_mctrl,
	.stop_tx	= tiny_stop_tx,
	.start_tx	= tiny_start_tx,
	.stop_rx	= tiny_stop_rx,
	.enable_ms	= tiny_enable_ms,
	.break_ctl	= tiny_break_ctl,
	.startup	= tiny_startup,
	.shutdown	= tiny_shutdown,
	.set_termios	= tiny_set_termios,
	.type		= tiny_type,
	.release_port	= tiny_release_port,
	.request_port	= tiny_request_port,
	.config_port	= tiny_config_port,
	.verify_port	= tiny_verify_port,
};

static struct uart_port tiny_port = {
	.ops		= &tiny_ops,
};

static struct uart_driver tiny_reg = {
	.owner		= THIS_MODULE,
	.driver_name	= TINY_SERIAL_NAME,
	.dev_name	= TINY_SERIAL_NAME,
	.major		= TINY_SERIAL_MAJOR,
	.minor		= TINY_SERIAL_MINORS,
	.nr		= UART_NR,
};

static int __init tiny_init(void)
{
	int result;

	printk(KERN_INFO "Tiny serial driver loaded\n");

	result = uart_register_driver(&tiny_reg);
	if (result)
		return result;

	result = uart_add_one_port(&tiny_reg, &tiny_port);
	if (result)
		uart_unregister_driver(&tiny_reg);

	return result;
}

module_init(tiny_init);
]]>
			</text>
		</p>
		<p n="xlnx_drv_tiny_tty">
			<text>
				<![CDATA[/*
 * Tiny TTY driver
 *
 * Copyright (C) 2002-2004 Greg Kroah-Hartman (greg@kroah.com)
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, version 2 of the License.
 *
 * This driver shows how to create a minimal tty driver.  It does not rely on
 * any backing hardware, but creates a timer that emulates data being received
 * from some kind of hardware.
 */

#include <linux/config.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/wait.h>
#include <linux/tty.h>
#include <linux/tty_driver.h>
#include <linux/tty_flip.h>
#include <linux/serial.h>
#include <asm/uaccess.h>


#define DRIVER_VERSION "v2.0"
#define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>"
#define DRIVER_DESC "Tiny TTY driver"

/* Module information */
MODULE_AUTHOR( DRIVER_AUTHOR );
MODULE_DESCRIPTION( DRIVER_DESC );
MODULE_LICENSE("GPL");

#define DELAY_TIME		HZ * 2	/* 2 seconds per character */
#define TINY_DATA_CHARACTER	't'

#define TINY_TTY_MAJOR		240	/* experimental range */
#define TINY_TTY_MINORS		4	/* only have 4 devices */

struct tiny_serial {
	struct tty_struct	*tty;		/* pointer to the tty for this device */
	int			open_count;	/* number of times this port has been opened */
	struct semaphore	sem;		/* locks this structure */
	struct timer_list	*timer;

	/* for tiocmget and tiocmset functions */
	int			msr;		/* MSR shadow */
	int			mcr;		/* MCR shadow */

	/* for ioctl fun */
	struct serial_struct	serial;
	wait_queue_head_t	wait;
	struct async_icount	icount;
};

static struct tiny_serial *tiny_table[TINY_TTY_MINORS];	/* initially all NULL */


static void tiny_timer(unsigned long timer_data)
{
	struct tiny_serial *tiny = (struct tiny_serial *)timer_data;
	struct tty_struct *tty;
	int i;
	char data[1] = {TINY_DATA_CHARACTER};
	int data_size = 1;

	if (!tiny)
		return;

	tty = tiny->tty;

	/* send the data to the tty layer for users to read.  This doesn't
	 * actually push the data through unless tty->low_latency is set */
	for (i = 0; i < data_size; ++i) {
		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
			tty_flip_buffer_push(tty);
		tty_insert_flip_char(tty, data[i], TTY_NORMAL);
	}
	tty_flip_buffer_push(tty);

	/* resubmit the timer again */
	tiny->timer->expires = jiffies + DELAY_TIME;
	add_timer(tiny->timer);
}

static int tiny_open(struct tty_struct *tty, struct file *file)
{
	struct tiny_serial *tiny;
	struct timer_list *timer;
	int index;

	/* initialize the pointer in case something fails */
	tty->driver_data = NULL;

	/* get the serial object associated with this tty pointer */
	index = tty->index;
	tiny = tiny_table[index];
	if (tiny == NULL) {
		/* first time accessing this device, let's create it */
		tiny = kmalloc(sizeof(*tiny), GFP_KERNEL);
		if (!tiny)
			return -ENOMEM;

		init_MUTEX(&tiny->sem);
		tiny->open_count = 0;
		tiny->timer = NULL;

		tiny_table[index] = tiny;
	}

	down(&tiny->sem);

	/* save our structure within the tty structure */
	tty->driver_data = tiny;
	tiny->tty = tty;

	++tiny->open_count;
	if (tiny->open_count == 1) {
		/* this is the first time this port is opened */
		/* do any hardware initialization needed here */

		/* create our timer and submit it */
		if (!tiny->timer) {
			timer = kmalloc(sizeof(*timer), GFP_KERNEL);
			if (!timer) {
				up(&tiny->sem);
				return -ENOMEM;
			}
			tiny->timer = timer;
		}
		tiny->timer->data = (unsigned long )tiny;
		tiny->timer->expires = jiffies + DELAY_TIME;
		tiny->timer->function = tiny_timer;
		add_timer(tiny->timer);
	}

	up(&tiny->sem);
	return 0;
}

static void do_close(struct tiny_serial *tiny)
{
	down(&tiny->sem);

	if (!tiny->open_count) {
		/* port was never opened */
		goto exit;
	}

	--tiny->open_count;
	if (tiny->open_count <= 0) {
		/* The port is being closed by the last user. */
		/* Do any hardware specific stuff here */

		/* shut down our timer */
		del_timer(tiny->timer);
	}
exit:
	up(&tiny->sem);
}

static void tiny_close(struct tty_struct *tty, struct file *file)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (tiny)
		do_close(tiny);
}	

static int tiny_write(struct tty_struct *tty, 
		      const unsigned char *buffer, int count)
{
	struct tiny_serial *tiny = tty->driver_data;
	int i;
	int retval = -EINVAL;

	if (!tiny)
		return -ENODEV;

	down(&tiny->sem);

	if (!tiny->open_count)
		/* port was not opened */
		goto exit;

	/* fake sending the data out a hardware port by
	 * writing it to the kernel debug log.
	 */
	printk(KERN_DEBUG "%%s - ", __FUNCTION__);
	for (i = 0; i < count; ++i)
		printk("%%02x ", buffer[i]);
	printk("\n");
		
exit:
	up(&tiny->sem);
	return retval;
}

static int tiny_write_room(struct tty_struct *tty) 
{
	struct tiny_serial *tiny = tty->driver_data;
	int room = -EINVAL;

	if (!tiny)
		return -ENODEV;

	down(&tiny->sem);
	
	if (!tiny->open_count) {
		/* port was not opened */
		goto exit;
	}

	/* calculate how much room is left in the device */
	room = 255;

exit:
	up(&tiny->sem);
	return room;
}

#define RELEVANT_IFLAG(iflag) ((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))

static void tiny_set_termios(struct tty_struct *tty, struct termios *old_termios)
{
	unsigned int cflag;

	cflag = tty->termios->c_cflag;

	/* check that they really want us to change something */
	if (old_termios) {
		if ((cflag == old_termios->c_cflag) &&
		    (RELEVANT_IFLAG(tty->termios->c_iflag) == 
		     RELEVANT_IFLAG(old_termios->c_iflag))) {
			printk(KERN_DEBUG " - nothing to change...\n");
			return;
		}
	}

	/* get the byte size */
	switch (cflag & CSIZE) {
		case CS5:
			printk(KERN_DEBUG " - data bits = 5\n");
			break;
		case CS6:
			printk(KERN_DEBUG " - data bits = 6\n");
			break;
		case CS7:
			printk(KERN_DEBUG " - data bits = 7\n");
			break;
		default:
		case CS8:
			printk(KERN_DEBUG " - data bits = 8\n");
			break;
	}
	
	/* determine the parity */
	if (cflag & PARENB)
		if (cflag & PARODD)
			printk(KERN_DEBUG " - parity = odd\n");
		else
			printk(KERN_DEBUG " - parity = even\n");
	else
		printk(KERN_DEBUG " - parity = none\n");

	/* figure out the stop bits requested */
	if (cflag & CSTOPB)
		printk(KERN_DEBUG " - stop bits = 2\n");
	else
		printk(KERN_DEBUG " - stop bits = 1\n");

	/* figure out the hardware flow control settings */
	if (cflag & CRTSCTS)
		printk(KERN_DEBUG " - RTS/CTS is enabled\n");
	else
		printk(KERN_DEBUG " - RTS/CTS is disabled\n");
	
	/* determine software flow control */
	/* if we are implementing XON/XOFF, set the start and 
	 * stop character in the device */
	if (I_IXOFF(tty) || I_IXON(tty)) {
		unsigned char stop_char  = STOP_CHAR(tty);
		unsigned char start_char = START_CHAR(tty);

		/* if we are implementing INBOUND XON/XOFF */
		if (I_IXOFF(tty))
			printk(KERN_DEBUG " - INBOUND XON/XOFF is enabled, "
				"XON = %%2x, XOFF = %%2x", start_char, stop_char);
		else
			printk(KERN_DEBUG" - INBOUND XON/XOFF is disabled");

		/* if we are implementing OUTBOUND XON/XOFF */
		if (I_IXON(tty))
			printk(KERN_DEBUG" - OUTBOUND XON/XOFF is enabled, "
				"XON = %%2x, XOFF = %%2x", start_char, stop_char);
		else
			printk(KERN_DEBUG" - OUTBOUND XON/XOFF is disabled");
	}

	/* get the baud rate wanted */
	printk(KERN_DEBUG " - baud rate = %%d", tty_get_baud_rate(tty));
}

/* Our fake UART values */
#define MCR_DTR		0x01
#define MCR_RTS		0x02
#define MCR_LOOP	0x04
#define MSR_CTS		0x08
#define MSR_CD		0x10
#define MSR_RI		0x20
#define MSR_DSR		0x40

static int tiny_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct tiny_serial *tiny = tty->driver_data;

	unsigned int result = 0;
	unsigned int msr = tiny->msr;
	unsigned int mcr = tiny->mcr;

	result = ((mcr & MCR_DTR)  ? TIOCM_DTR  : 0) |	/* DTR is set */
             ((mcr & MCR_RTS)  ? TIOCM_RTS  : 0) |	/* RTS is set */
             ((mcr & MCR_LOOP) ? TIOCM_LOOP : 0) |	/* LOOP is set */
             ((msr & MSR_CTS)  ? TIOCM_CTS  : 0) |	/* CTS is set */
             ((msr & MSR_CD)   ? TIOCM_CAR  : 0) |	/* Carrier detect is set*/
             ((msr & MSR_RI)   ? TIOCM_RI   : 0) |	/* Ring Indicator is set */
             ((msr & MSR_DSR)  ? TIOCM_DSR  : 0);	/* DSR is set */

	return result;
}

static int tiny_tiocmset(struct tty_struct *tty, struct file *file,
                         unsigned int set, unsigned int clear)
{
	struct tiny_serial *tiny = tty->driver_data;
	unsigned int mcr = tiny->mcr;

	if (set & TIOCM_RTS)
		mcr |= MCR_RTS;
	if (set & TIOCM_DTR)
		mcr |= MCR_RTS;

	if (clear & TIOCM_RTS)
		mcr &= ~MCR_RTS;
	if (clear & TIOCM_DTR)
		mcr &= ~MCR_RTS;

	/* set the new MCR value in the device */
	tiny->mcr = mcr;
	return 0;
}

static int tiny_read_proc(char *page, char **start, off_t off, int count,
                          int *eof, void *data)
{
	struct tiny_serial *tiny;
	off_t begin = 0;
	int length = 0;
	int i;

	length += sprintf(page, "tinyserinfo:1.0 driver:%%s\n", DRIVER_VERSION);
	for (i = 0; i < TINY_TTY_MINORS && length < PAGE_SIZE; ++i) {
		tiny = tiny_table[i];
		if (tiny == NULL)
			continue;

		length += sprintf(page+length, "%%d\n", i);
		if ((length + begin) > (off + count))
			goto done;
		if ((length + begin) < off) {
			begin += length;
			length = 0;
		}
	}
	*eof = 1;
done:
	if (off >= (length + begin))
		return 0;
	*start = page + (off-begin);
	return (count < begin+length-off) ? count : begin + length-off;
}

#define tiny_ioctl tiny_ioctl_tiocgserial
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (cmd == TIOCGSERIAL) {
		struct serial_struct tmp;

		if (!arg)
			return -EFAULT;

		memset(&tmp, 0, sizeof(tmp));

		tmp.type		= tiny->serial.type;
		tmp.line		= tiny->serial.line;
		tmp.port		= tiny->serial.port;
		tmp.irq			= tiny->serial.irq;
		tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
		tmp.xmit_fifo_size	= tiny->serial.xmit_fifo_size;
		tmp.baud_base		= tiny->serial.baud_base;
		tmp.close_delay		= 5*HZ;
		tmp.closing_wait	= 30*HZ;
		tmp.custom_divisor	= tiny->serial.custom_divisor;
		tmp.hub6		= tiny->serial.hub6;
		tmp.io_type		= tiny->serial.io_type;

		if (copy_to_user((void __user *)arg, &tmp, sizeof(struct serial_struct)))
			return -EFAULT;
		return 0;
	}
	return -ENOIOCTLCMD;
}
#undef tiny_ioctl

#define tiny_ioctl tiny_ioctl_tiocmiwait
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (cmd == TIOCMIWAIT) {
		DECLARE_WAITQUEUE(wait, current);
		struct async_icount cnow;
		struct async_icount cprev;

		cprev = tiny->icount;
		while (1) {
			add_wait_queue(&tiny->wait, &wait);
			set_current_state(TASK_INTERRUPTIBLE);
			schedule();
			remove_wait_queue(&tiny->wait, &wait);

			/* see if a signal woke us up */
			if (signal_pending(current))
				return -ERESTARTSYS;

			cnow = tiny->icount;
			if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
			    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
				return -EIO; /* no change => error */
			if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
			    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
			    ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {
				return 0;
			}
			cprev = cnow;
		}

	}
	return -ENOIOCTLCMD;
}
#undef tiny_ioctl

#define tiny_ioctl tiny_ioctl_tiocgicount
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (cmd == TIOCGICOUNT) {
		struct async_icount cnow = tiny->icount;
		struct serial_icounter_struct icount;

		icount.cts	= cnow.cts;
		icount.dsr	= cnow.dsr;
		icount.rng	= cnow.rng;
		icount.dcd	= cnow.dcd;
		icount.rx	= cnow.rx;
		icount.tx	= cnow.tx;
		icount.frame	= cnow.frame;
		icount.overrun	= cnow.overrun;
		icount.parity	= cnow.parity;
		icount.brk	= cnow.brk;
		icount.buf_overrun = cnow.buf_overrun;

		if (copy_to_user((void __user *)arg, &icount, sizeof(icount)))
			return -EFAULT;
		return 0;
	}
	return -ENOIOCTLCMD;
}
#undef tiny_ioctl

/* the real tiny_ioctl function.  The above is done to get the small functions in the book */
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
	case TIOCGSERIAL:
		return tiny_ioctl_tiocgserial(tty, file, cmd, arg);
	case TIOCMIWAIT:
		return tiny_ioctl_tiocmiwait(tty, file, cmd, arg);
	case TIOCGICOUNT:
		return tiny_ioctl_tiocgicount(tty, file, cmd, arg);
	}

	return -ENOIOCTLCMD;
}

static struct tty_operations serial_ops = {
	.open = tiny_open,
	.close = tiny_close,
	.write = tiny_write,
	.write_room = tiny_write_room,
	.set_termios = tiny_set_termios,
};

static struct tty_driver *tiny_tty_driver;

static int __init tiny_init(void)
{
	int retval;
	int i;

	/* allocate the tty driver */
	tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);
	if (!tiny_tty_driver)
		return -ENOMEM;

	/* initialize the tty driver */
	tiny_tty_driver->owner = THIS_MODULE;
	tiny_tty_driver->driver_name = "tiny_tty";
	tiny_tty_driver->name = "ttty";
	tiny_tty_driver->devfs_name = "tts/ttty%%d";
	tiny_tty_driver->major = TINY_TTY_MAJOR,
	tiny_tty_driver->type = TTY_DRIVER_TYPE_SERIAL,
	tiny_tty_driver->subtype = SERIAL_TYPE_NORMAL,
	tiny_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
	tiny_tty_driver->init_termios = tty_std_termios;
	tiny_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
	tty_set_operations(tiny_tty_driver, &serial_ops);

	/* hack to make the book purty, yet still use these functions in the
	 * real driver.  They really should be set up in the serial_ops
	 * structure above... */
	tiny_tty_driver->read_proc = tiny_read_proc;
	tiny_tty_driver->tiocmget = tiny_tiocmget;
	tiny_tty_driver->tiocmset = tiny_tiocmset;
	tiny_tty_driver->ioctl = tiny_ioctl;

	/* register the tty driver */
	retval = tty_register_driver(tiny_tty_driver);
	if (retval) {
		printk(KERN_ERR "failed to register tiny tty driver");
		put_tty_driver(tiny_tty_driver);
		return retval;
	}

	for (i = 0; i < TINY_TTY_MINORS; ++i)
		tty_register_device(tiny_tty_driver, i, NULL);

	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION);
	return retval;
}

static void __exit tiny_exit(void)
{
	struct tiny_serial *tiny;
	int i;

	for (i = 0; i < TINY_TTY_MINORS; ++i)
		tty_unregister_device(tiny_tty_driver, i);
	tty_unregister_driver(tiny_tty_driver);

	/* shut down all of the timers and free the memory */
	for (i = 0; i < TINY_TTY_MINORS; ++i) {
		tiny = tiny_table[i];
		if (tiny) {
			/* close the port */
			while (tiny->open_count)
				do_close(tiny);

			/* shut down our timer and free the memory */
			del_timer(tiny->timer);
			kfree(tiny->timer);
			kfree(tiny);
			tiny_table[i] = NULL;
		}
	}
}

module_init(tiny_init);
module_exit(tiny_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_usb_skeleton">
			<text>
				<![CDATA[/*
 * USB Skeleton driver - 2.0
 *
 * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License as
 *	published by the Free Software Foundation, version 2.
 *
 * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c 
 * but has been rewritten to be easy to read and use, as no locks are now
 * needed anymore.
 *
 */

#include <linux/config.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/kref.h>
#include <linux/smp_lock.h>
#include <linux/usb.h>
#include <asm/uaccess.h>


/* Define these values to match your devices */
#define USB_SKEL_VENDOR_ID	0xfff0
#define USB_SKEL_PRODUCT_ID	0xfff0

/* table of devices that work with this driver */
static struct usb_device_id skel_table [] = {
	{ USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
	{ }					/* Terminating entry */
};
MODULE_DEVICE_TABLE (usb, skel_table);


/* Get a minor range for your devices from the usb maintainer */
#define USB_SKEL_MINOR_BASE	192

/* Structure to hold all of our device specific stuff */
struct usb_skel {
	struct usb_device *	udev;			/* the usb device for this device */
	struct usb_interface *	interface;		/* the interface for this device */
	unsigned char *		bulk_in_buffer;		/* the buffer to receive data */
	size_t			bulk_in_size;		/* the size of the receive buffer */
	__u8			bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
	__u8			bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
	struct kref		kref;
};
#define to_skel_dev(d) container_of(d, struct usb_skel, kref)

static struct usb_driver skel_driver;

static void skel_delete(struct kref *kref)
{	
	struct usb_skel *dev = to_skel_dev(kref);

	usb_put_dev(dev->udev);
	kfree (dev->bulk_in_buffer);
	kfree (dev);
}

static int skel_open(struct inode *inode, struct file *file)
{
	struct usb_skel *dev;
	struct usb_interface *interface;
	int subminor;
	int retval = 0;

	subminor = iminor(inode);

	interface = usb_find_interface(&skel_driver, subminor);
	if (!interface) {
		err ("%%s - error, can't find device for minor %%d",
		     __FUNCTION__, subminor);
		retval = -ENODEV;
		goto exit;
	}

	dev = usb_get_intfdata(interface);
	if (!dev) {
		retval = -ENODEV;
		goto exit;
	}
	
	/* increment our usage count for the device */
	kref_get(&dev->kref);

	/* save our object in the file's private structure */
	file->private_data = dev;

exit:
	return retval;
}

static int skel_release(struct inode *inode, struct file *file)
{
	struct usb_skel *dev;

	dev = (struct usb_skel *)file->private_data;
	if (dev == NULL)
		return -ENODEV;

	/* decrement the count on our device */
	kref_put(&dev->kref, skel_delete);
	return 0;
}

static ssize_t skel_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
{
	struct usb_skel *dev;
	int retval = 0;

	dev = (struct usb_skel *)file->private_data;
	
	/* do a blocking bulk read to get data from the device */
	retval = usb_bulk_msg(dev->udev,
			      usb_rcvbulkpipe(dev->udev, dev->bulk_in_endpointAddr),
			      dev->bulk_in_buffer,
			      min(dev->bulk_in_size, count),
			      &count, HZ*10);

	/* if the read was successful, copy the data to userspace */
	if (!retval) {
		if (copy_to_user(buffer, dev->bulk_in_buffer, count))
			retval = -EFAULT;
		else
			retval = count;
	}

	return retval;
}

static void skel_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
{
	/* sync/async unlink faults aren't errors */
	if (urb->status && 
	    !(urb->status == -ENOENT || 
	      urb->status == -ECONNRESET ||
	      urb->status == -ESHUTDOWN)) {
		dbg("%%s - nonzero write bulk status received: %%d",
		    __FUNCTION__, urb->status);
	}

	/* free up our allocated buffer */
	usb_buffer_free(urb->dev, urb->transfer_buffer_length, 
			urb->transfer_buffer, urb->transfer_dma);
}

static ssize_t skel_write(struct file *file, const char __user *user_buffer, size_t count, loff_t *ppos)
{
	struct usb_skel *dev;
	int retval = 0;
	struct urb *urb = NULL;
	char *buf = NULL;

	dev = (struct usb_skel *)file->private_data;

	/* verify that we actually have some data to write */
	if (count == 0)
		goto exit;

	/* create a urb, and a buffer for it, and copy the data to the urb */
	urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!urb) {
		retval = -ENOMEM;
		goto error;
	}

	buf = usb_buffer_alloc(dev->udev, count, GFP_KERNEL, &urb->transfer_dma);
	if (!buf) {
		retval = -ENOMEM;
		goto error;
	}
	if (copy_from_user(buf, user_buffer, count)) {
		retval = -EFAULT;
		goto error;
	}

	/* initialize the urb properly */
	usb_fill_bulk_urb(urb, dev->udev,
			  usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
			  buf, count, skel_write_bulk_callback, dev);
	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;

	/* send the data out the bulk port */
	retval = usb_submit_urb(urb, GFP_KERNEL);
	if (retval) {
		err("%%s - failed submitting write urb, error %%d", __FUNCTION__, retval);
		goto error;
	}

	/* release our reference to this urb, the USB core will eventually free it entirely */
	usb_free_urb(urb);

exit:
	return count;

error:
	usb_buffer_free(dev->udev, count, buf, urb->transfer_dma);
	usb_free_urb(urb);
	kfree(buf);
	return retval;
}

static struct file_operations skel_fops = {
	.owner =	THIS_MODULE,
	.read =		skel_read,
	.write =	skel_write,
	.open =		skel_open,
	.release =	skel_release,
};

/* 
 * usb class driver info in order to get a minor number from the usb core,
 * and to have the device registered with devfs and the driver core
 */
static struct usb_class_driver skel_class = {
	.name = "usb/skel%%d",
	.fops = &skel_fops,
	.mode = S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH,
	.minor_base = USB_SKEL_MINOR_BASE,
};

static int skel_probe(struct usb_interface *interface, const struct usb_device_id *id)
{
	struct usb_skel *dev = NULL;
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor *endpoint;
	size_t buffer_size;
	int i;
	int retval = -ENOMEM;

	/* allocate memory for our device state and initialize it */
	dev = kmalloc(sizeof(struct usb_skel), GFP_KERNEL);
	if (dev == NULL) {
		err("Out of memory");
		goto error;
	}
	memset(dev, 0x00, sizeof (*dev));
	kref_init(&dev->kref);

	dev->udev = usb_get_dev(interface_to_usbdev(interface));
	dev->interface = interface;

	/* set up the endpoint information */
	/* use only the first bulk-in and bulk-out endpoints */
	iface_desc = interface->cur_altsetting;
	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;

		if (!dev->bulk_in_endpointAddr &&
		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
					== USB_ENDPOINT_XFER_BULK)) {
			/* we found a bulk in endpoint */
			buffer_size = endpoint->wMaxPacketSize;
			dev->bulk_in_size = buffer_size;
			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
			if (!dev->bulk_in_buffer) {
				err("Could not allocate bulk_in_buffer");
				goto error;
			}
		}

		if (!dev->bulk_out_endpointAddr &&
		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
					== USB_ENDPOINT_XFER_BULK)) {
			/* we found a bulk out endpoint */
			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
		}
	}
	if (!(dev->bulk_in_endpointAddr && dev->bulk_out_endpointAddr)) {
		err("Could not find both bulk-in and bulk-out endpoints");
		goto error;
	}

	/* save our data pointer in this interface device */
	usb_set_intfdata(interface, dev);

	/* we can register the device now, as it is ready */
	retval = usb_register_dev(interface, &skel_class);
	if (retval) {
		/* something prevented us from registering this driver */
		err("Not able to get a minor for this device.");
		usb_set_intfdata(interface, NULL);
		goto error;
	}

	/* let the user know what node this device is now attached to */
	info("USB Skeleton device now attached to USBSkel-%%d", interface->minor);
	return 0;

error:
	if (dev)
		kref_put(&dev->kref, skel_delete);
	return retval;
}

static void skel_disconnect(struct usb_interface *interface)
{
	struct usb_skel *dev;
	int minor = interface->minor;

	/* prevent skel_open() from racing skel_disconnect() */
	lock_kernel();

	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);

	/* give back our minor */
	usb_deregister_dev(interface, &skel_class);

	unlock_kernel();

	/* decrement our usage count */
	kref_put(&dev->kref, skel_delete);

	info("USB Skeleton #%%d now disconnected", minor);
}

static struct usb_driver skel_driver = {
	.owner = THIS_MODULE,
	.name = "skeleton",
	.id_table = skel_table,
	.probe = skel_probe,
	.disconnect = skel_disconnect,
};

static int __init usb_skel_init(void)
{
	int result;

	/* register this driver with the USB subsystem */
	result = usb_register(&skel_driver);
	if (result)
		err("usb_register failed. Error number %%d", result);

	return result;
}

static void __exit usb_skel_exit(void)
{
	/* deregister this driver with the USB subsystem */
	usb_deregister(&skel_driver);
}

module_init (usb_skel_init);
module_exit (usb_skel_exit);

MODULE_LICENSE("GPL");
]]>
			</text>
		</p>
		<p n="xlnx_drv_ldbus_H">
			<text>/*
 * Definitions for the virtual LDD bus.
 *
 * $Id: lddbus.h,v 1.4 2004/08/20 18:49:44 corbet Exp $
 */

//extern struct device ldd_bus;
extern struct bus_type ldd_bus_type;


/*
 * The LDD driver type.
 */

struct ldd_driver {
	char *version;
	struct module *module;
	struct device_driver driver;
	struct driver_attribute version_attr;
};

#define to_ldd_driver(drv) container_of(drv, struct ldd_driver, driver);

/*
 * A device type for things "plugged" into the LDD bus.
 */

struct ldd_device {
	char *name;
	struct ldd_driver *driver;
	struct device dev;
};

#define to_ldd_device(dev) container_of(dev, struct ldd_device, dev);

extern int register_ldd_device(struct ldd_device *);
extern void unregister_ldd_device(struct ldd_device *);
extern int register_ldd_driver(struct ldd_driver *);
extern void unregister_ldd_driver(struct ldd_driver *);
			</text>
		</p>
		<p n="xlnx_drv_sbull_H">
			<text>
				<![CDATA[
/*
 * sbull.h -- definitions for the char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */


#include <linux/ioctl.h>

/* Multiqueue only works on 2.4 */
#ifdef SBULL_MULTIQUEUE
#    warning "Multiqueue only works on 2.4 kernels"
#endif

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SBULL_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "sbull: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */


#define SBULL_MAJOR 0       /* dynamic major by default */
#define SBULL_DEVS 2        /* two disks */
#define SBULL_RAHEAD 2      /* two sectors */
#define SBULL_SIZE 2048     /* two megs each */
#define SBULL_BLKSIZE 1024  /* 1k blocks */
#define SBULL_HARDSECT 512  /* 2.2 and 2.4 can used different values */

#define SBULLR_MAJOR 0      /* Dynamic major for raw device */
/*
 * The sbull device is removable: if it is left closed for more than
 * half a minute, it is removed. Thus use a usage count and a
 * kernel timer
 */

typedef struct Sbull_Dev {
   int size;
   int usage;
   struct timer_list timer;
   spinlock_t lock;
   u8 *data;
#ifdef SBULL_MULTIQUEUE
   request_queue_t *queue;
   int busy;
#endif
}              Sbull_Dev;
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_H">
			<text>
				<![CDATA[/*
 * scull.h -- definitions for the char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: scull.h,v 1.15 2004/11/04 17:51:18 rubini Exp $
 */

#ifndef _SCULL_H_
#define _SCULL_H_

#include <linux/ioctl.h> /* needed for the _IOW etc stuff used later */

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULL_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scull: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#ifndef SCULL_MAJOR
#define SCULL_MAJOR 0   /* dynamic major by default */
#endif

#ifndef SCULL_NR_DEVS
#define SCULL_NR_DEVS 4    /* scull0 through scull3 */
#endif

#ifndef SCULL_P_NR_DEVS
#define SCULL_P_NR_DEVS 4  /* scullpipe0 through scullpipe3 */
#endif

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scull_dev->data" points to an array of pointers, each
 * pointer refers to a memory area of SCULL_QUANTUM bytes.
 *
 * The array (quantum-set) is SCULL_QSET long.
 */
#ifndef SCULL_QUANTUM
#define SCULL_QUANTUM 4000
#endif

#ifndef SCULL_QSET
#define SCULL_QSET    1000
#endif

/*
 * The pipe device is a simple circular buffer. Here its default size
 */
#ifndef SCULL_P_BUFFER
#define SCULL_P_BUFFER 4000
#endif

/*
 * Representation of scull quantum sets.
 */
struct scull_qset {
	void **data;
	struct scull_qset *next;
};

struct scull_dev {
	struct scull_qset *data;  /* Pointer to first quantum set */
	int quantum;              /* the current quantum size */
	int qset;                 /* the current array size */
	unsigned long size;       /* amount of data stored here */
	unsigned int access_key;  /* used by sculluid and scullpriv */
	struct semaphore sem;     /* mutual exclusion semaphore     */
	struct cdev cdev;	  /* Char device structure		*/
};

/*
 * Split minors in two parts
 */
#define TYPE(minor)	(((minor) >> 4) & 0xf)	/* high nibble */
#define NUM(minor)	((minor) & 0xf)		/* low  nibble */


/*
 * The different configurable parameters
 */
extern int scull_major;     /* main.c */
extern int scull_nr_devs;
extern int scull_quantum;
extern int scull_qset;

extern int scull_p_buffer;	/* pipe.c */


/*
 * Prototypes for shared functions
 */

int     scull_p_init(dev_t dev);
void    scull_p_cleanup(void);
int     scull_access_init(dev_t dev);
void    scull_access_cleanup(void);

int     scull_trim(struct scull_dev *dev);

ssize_t scull_read(struct file *filp, char __user *buf, size_t count,
                   loff_t *f_pos);
ssize_t scull_write(struct file *filp, const char __user *buf, size_t count,
                    loff_t *f_pos);
loff_t  scull_llseek(struct file *filp, loff_t off, int whence);
int     scull_ioctl(struct inode *inode, struct file *filp,
                    unsigned int cmd, unsigned long arg);


/*
 * Ioctl definitions
 */

/* Use 'k' as magic number */
#define SCULL_IOC_MAGIC  'k'
/* Please use a different 8-bit number in your code */

#define SCULL_IOCRESET    _IO(SCULL_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly with the argument value
 * G means "Get": reply by setting through a pointer
 * Q means "Query": response is on the return value
 * X means "eXchange": switch G and S atomically
 * H means "sHift": switch T and Q atomically
 */
#define SCULL_IOCSQUANTUM _IOW(SCULL_IOC_MAGIC,  1, int)
#define SCULL_IOCSQSET    _IOW(SCULL_IOC_MAGIC,  2, int)
#define SCULL_IOCTQUANTUM _IO(SCULL_IOC_MAGIC,   3)
#define SCULL_IOCTQSET    _IO(SCULL_IOC_MAGIC,   4)
#define SCULL_IOCGQUANTUM _IOR(SCULL_IOC_MAGIC,  5, int)
#define SCULL_IOCGQSET    _IOR(SCULL_IOC_MAGIC,  6, int)
#define SCULL_IOCQQUANTUM _IO(SCULL_IOC_MAGIC,   7)
#define SCULL_IOCQQSET    _IO(SCULL_IOC_MAGIC,   8)
#define SCULL_IOCXQUANTUM _IOWR(SCULL_IOC_MAGIC, 9, int)
#define SCULL_IOCXQSET    _IOWR(SCULL_IOC_MAGIC,10, int)
#define SCULL_IOCHQUANTUM _IO(SCULL_IOC_MAGIC,  11)
#define SCULL_IOCHQSET    _IO(SCULL_IOC_MAGIC,  12)

/*
 * The other entities only have "Tell" and "Query", because they're
 * not printed in the book, and there's no need to have all six.
 * (The previous stuff was only there to show different ways to do it.
 */
#define SCULL_P_IOCTSIZE _IO(SCULL_IOC_MAGIC,   13)
#define SCULL_P_IOCQSIZE _IO(SCULL_IOC_MAGIC,   14)
/* ... more to come */

#define SCULL_IOC_MAXNR 14

#endif /* _SCULL_H_ */
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullc_H">
			<text>
				<![CDATA[/* -*- C -*-
 * scullc.h -- definitions for the scullc char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLC_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scullc: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLC_MAJOR 0   /* dynamic major by default */

#define SCULLC_DEVS 4    /* scullc0 through scullc3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scullc_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLC_QSET long.
 */
#define SCULLC_QUANTUM  4000 /* use a quantum size like scull */
#define SCULLC_QSET     500

struct scullc_dev {
	void **data;
	struct scullc_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int quantum;              /* the current allocation size */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
};

extern struct scullc_dev *scullc_devices;

extern struct file_operations scullc_fops;

/*
 * The different configurable parameters
 */
extern int scullc_major;     /* main.c */
extern int scullc_devs;
extern int scullc_order;
extern int scullc_qset;

/*
 * Prototypes for shared functions
 */
int scullc_trim(struct scullc_dev *dev);
struct scullc_dev *scullc_follow(struct scullc_dev *dev, int n);


#ifdef SCULLC_DEBUG
#  define SCULLC_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLC_IOC_MAGIC  'K'

#define SCULLC_IOCRESET    _IO(SCULLC_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLC_IOCSQUANTUM _IOW(SCULLC_IOC_MAGIC,  1, int)
#define SCULLC_IOCTQUANTUM _IO(SCULLC_IOC_MAGIC,   2)
#define SCULLC_IOCGQUANTUM _IOR(SCULLC_IOC_MAGIC,  3, int)
#define SCULLC_IOCQQUANTUM _IO(SCULLC_IOC_MAGIC,   4)
#define SCULLC_IOCXQUANTUM _IOWR(SCULLC_IOC_MAGIC, 5, int)
#define SCULLC_IOCHQUANTUM _IO(SCULLC_IOC_MAGIC,   6)
#define SCULLC_IOCSQSET    _IOW(SCULLC_IOC_MAGIC,  7, int)
#define SCULLC_IOCTQSET    _IO(SCULLC_IOC_MAGIC,   8)
#define SCULLC_IOCGQSET    _IOR(SCULLC_IOC_MAGIC,  9, int)
#define SCULLC_IOCQQSET    _IO(SCULLC_IOC_MAGIC,  10)
#define SCULLC_IOCXQSET    _IOWR(SCULLC_IOC_MAGIC,11, int)
#define SCULLC_IOCHQSET    _IO(SCULLC_IOC_MAGIC,  12)

#define SCULLC_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_sculld_H">
			<text>
				<![CDATA[/* -*- C -*-
 * sculld.h -- definitions for the sculld char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include "../include/lddbus.h"

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLD_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "sculld: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLD_MAJOR 0   /* dynamic major by default */

#define SCULLD_DEVS 4    /* sculld0 through sculld3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "sculld_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLD_QSET long.
 */
#define SCULLD_ORDER    0 /* one page at a time */
#define SCULLD_QSET     500

struct sculld_dev {
	void **data;
	struct sculld_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int order;                /* the current allocation order */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
	char devname[20];
	struct ldd_device ldev;
};

extern struct sculld_dev *sculld_devices;

extern struct file_operations sculld_fops;

/*
 * The different configurable parameters
 */
extern int sculld_major;     /* main.c */
extern int sculld_devs;
extern int sculld_order;
extern int sculld_qset;

/*
 * Prototypes for shared functions
 */
int sculld_trim(struct sculld_dev *dev);
struct sculld_dev *sculld_follow(struct sculld_dev *dev, int n);


#ifdef SCULLD_DEBUG
#  define SCULLD_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLD_IOC_MAGIC  'K'

#define SCULLD_IOCRESET    _IO(SCULLD_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLD_IOCSORDER   _IOW(SCULLD_IOC_MAGIC,  1, int)
#define SCULLD_IOCTORDER   _IO(SCULLD_IOC_MAGIC,   2)
#define SCULLD_IOCGORDER   _IOR(SCULLD_IOC_MAGIC,  3, int)
#define SCULLD_IOCQORDER   _IO(SCULLD_IOC_MAGIC,   4)
#define SCULLD_IOCXORDER   _IOWR(SCULLD_IOC_MAGIC, 5, int)
#define SCULLD_IOCHORDER   _IO(SCULLD_IOC_MAGIC,   6)
#define SCULLD_IOCSQSET    _IOW(SCULLD_IOC_MAGIC,  7, int)
#define SCULLD_IOCTQSET    _IO(SCULLD_IOC_MAGIC,   8)
#define SCULLD_IOCGQSET    _IOR(SCULLD_IOC_MAGIC,  9, int)
#define SCULLD_IOCQQSET    _IO(SCULLD_IOC_MAGIC,  10)
#define SCULLD_IOCXQSET    _IOWR(SCULLD_IOC_MAGIC,11, int)
#define SCULLD_IOCHQSET    _IO(SCULLD_IOC_MAGIC,  12)

#define SCULLD_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_scullp_H">
			<text>
				<![CDATA[/* -*- C -*-
 * scullp.h -- definitions for the scullp char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLP_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scullp: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLP_MAJOR 0   /* dynamic major by default */

#define SCULLP_DEVS 4    /* scullp0 through scullp3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scullp_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLP_QSET long.
 */
#define SCULLP_ORDER    0 /* one page at a time */
#define SCULLP_QSET     500

struct scullp_dev {
	void **data;
	struct scullp_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int order;                /* the current allocation order */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
};

extern struct scullp_dev *scullp_devices;

extern struct file_operations scullp_fops;

/*
 * The different configurable parameters
 */
extern int scullp_major;     /* main.c */
extern int scullp_devs;
extern int scullp_order;
extern int scullp_qset;

/*
 * Prototypes for shared functions
 */
int scullp_trim(struct scullp_dev *dev);
struct scullp_dev *scullp_follow(struct scullp_dev *dev, int n);


#ifdef SCULLP_DEBUG
#  define SCULLP_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLP_IOC_MAGIC  'K'

#define SCULLP_IOCRESET    _IO(SCULLP_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLP_IOCSORDER   _IOW(SCULLP_IOC_MAGIC,  1, int)
#define SCULLP_IOCTORDER   _IO(SCULLP_IOC_MAGIC,   2)
#define SCULLP_IOCGORDER   _IOR(SCULLP_IOC_MAGIC,  3, int)
#define SCULLP_IOCQORDER   _IO(SCULLP_IOC_MAGIC,   4)
#define SCULLP_IOCXORDER   _IOWR(SCULLP_IOC_MAGIC, 5, int)
#define SCULLP_IOCHORDER   _IO(SCULLP_IOC_MAGIC,   6)
#define SCULLP_IOCSQSET    _IOW(SCULLP_IOC_MAGIC,  7, int)
#define SCULLP_IOCTQSET    _IO(SCULLP_IOC_MAGIC,   8)
#define SCULLP_IOCGQSET    _IOR(SCULLP_IOC_MAGIC,  9, int)
#define SCULLP_IOCQQSET    _IO(SCULLP_IOC_MAGIC,  10)
#define SCULLP_IOCXQSET    _IOWR(SCULLP_IOC_MAGIC,11, int)
#define SCULLP_IOCHQSET    _IO(SCULLP_IOC_MAGIC,  12)

#define SCULLP_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_scullv_H">
			<text>
				<![CDATA[/* -*- C -*-
 * scullv.h -- definitions for the scullv char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLV_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scullv: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLV_MAJOR 0   /* dynamic major by default */

#define SCULLV_DEVS 4    /* scullv0 through scullv3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scullv_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLV_QSET long.
 */
#define SCULLV_ORDER    4 /* 16 pages at a time */
#define SCULLV_QSET     500

struct scullv_dev {
	void **data;
	struct scullv_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int order;                /* the current allocation order */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
};

extern struct scullv_dev *scullv_devices;

extern struct file_operations scullv_fops;

/*
 * The different configurable parameters
 */
extern int scullv_major;     /* main.c */
extern int scullv_devs;
extern int scullv_order;
extern int scullv_qset;

/*
 * Prototypes for shared functions
 */
int scullv_trim(struct scullv_dev *dev);
struct scullv_dev *scullv_follow(struct scullv_dev *dev, int n);


#ifdef SCULLV_DEBUG
#  define SCULLV_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLV_IOC_MAGIC  'K'

#define SCULLV_IOCRESET    _IO(SCULLV_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLV_IOCSORDER   _IOW(SCULLV_IOC_MAGIC,  1, int)
#define SCULLV_IOCTORDER   _IO(SCULLV_IOC_MAGIC,   2)
#define SCULLV_IOCGORDER   _IOR(SCULLV_IOC_MAGIC,  3, int)
#define SCULLV_IOCQORDER   _IO(SCULLV_IOC_MAGIC,   4)
#define SCULLV_IOCXORDER   _IOWR(SCULLV_IOC_MAGIC, 5, int)
#define SCULLV_IOCHORDER   _IO(SCULLV_IOC_MAGIC,   6)
#define SCULLV_IOCSQSET    _IOW(SCULLV_IOC_MAGIC,  7, int)
#define SCULLV_IOCTQSET    _IO(SCULLV_IOC_MAGIC,   8)
#define SCULLV_IOCGQSET    _IOR(SCULLV_IOC_MAGIC,  9, int)
#define SCULLV_IOCQQSET    _IO(SCULLV_IOC_MAGIC,  10)
#define SCULLV_IOCXQSET    _IOWR(SCULLV_IOC_MAGIC,11, int)
#define SCULLV_IOCHQSET    _IO(SCULLV_IOC_MAGIC,  12)

#define SCULLV_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_shortprint_H">
			<text>
				<![CDATA[/*
 * Useful info describing the parallel port device.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */

/*
 * Register offsets
 */
#define SP_DATA    0x00
#define SP_STATUS  0x01
#define SP_CONTROL 0x02
#define SP_NPORTS     3

/*
 * Status register bits.
 */
#define SP_SR_BUSY 	0x80
#define SP_SR_ACK	0x40
#define SP_SR_PAPER	0x20
#define SP_SR_ONLINE	0x10
#define SP_SR_ERR	0x08

/*
 * Control register.
 */
#define SP_CR_IRQ	0x10
#define SP_CR_SELECT	0x08
#define SP_CR_INIT	0x04
#define SP_CR_AUTOLF	0x02
#define SP_CR_STROBE	0x01

/*
 * Minimum space before waking up a writer.
 */
#define SP_MIN_SPACE	PAGE_SIZE/2
]]>
			</text>
		</p>
		<p n="xlnx_drv_snull_H">
			<text>
				<![CDATA[
/*
 * snull.h -- definitions for the network module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SNULL_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "snull: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */


/* These are the flags in the statusword */
#define SNULL_RX_INTR 0x0001
#define SNULL_TX_INTR 0x0002

/* Default timeout period */
#define SNULL_TIMEOUT 5   /* In jiffies */

extern struct net_device *snull_devs[];




]]>
			</text>
		</p>
		<p n="xlnx_drv_attribute_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : attribute.h

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef _PRETTY_ATTRIBUTE_H_
#define _PRETTY_ATTRIBUTE_H_

/**
 * ******************************************************
 * @brief 
 * ******************************************************
**/
#if __GNUC_  _ >= 3
# undef  inline
# define inline         inline __attribute_  _ ((always_inline))
# define __noinline     __attribute__ ((noinline))
# define __pure         __attribute__ ((pure))
# define __const        __attribute__ ((const))
# define __noreturn     __attribute__ ((noreturn))
# define __malloc       __attribute__ ((malloc))
# define __must_check   __attribute__ ((warn_unused_result))
# define __deprecated   __attribute__ ((deprecated))
# define __used         __attribute__ ((used))
# define __unused       __attribute__ ((unused))
# define __packed       __attribute__ ((packed))
# define __align(x)     __attribute__ ((aligned (x)))
# define __align_max    __attribute__ ((aligned))
# define likely(x)      __builtin_expect (!!(x), 1)
# define unlikely(x)    __builtin_expect (!!(x), 0)
#else
# define __noinline     /* no noinline */
# define __pure         /* no pure */
# define __const        /* no const */
# define __noreturn     /* no noreturn */
# define __malloc       /* no malloc */
# define __must_check   /* no warn_unused_result */
# define __deprecated   /* no deprecated */
# define __used         /* no used */
# define __unused       /* no unused */
# define __packed       /* no packed */
# define __align(x)     /* no aligned */
# define __align_max    /* no align_max */
# define likely(x)      (x)
# define unlikely(x)    (x)
#endif

#endif
]]>
			</text>
		</p>
	</language.aliases>
</options>
