<options>
	<misc.options n="misc.options" version="1">
		<app_theme v="Dark"/>
		<search_flags v="0x1"/>
	</misc.options>
	<misc.tag_file_list n="misc.tag_file_list" version="1" configs="win">
		<p n="cs" v='%SLICKEDITCONFIGVERSION%tagfiles\unity.vtg;"C:\Users\User\Documents\My SlickEdit Config\24.0.2\tagfiles\dotnet.vtg"'/>
		<p n="bas" v='"C:\Users\User\Documents\My SlickEdit Config\24.0.2\tagfiles\dotnet.vtg"'/>
		<p n="c" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="e" v="%SLICKEDITCONFIGVERSION%tagfiles\slickc.vtg"/>
	</misc.tag_file_list>
	<misc.def_vars n="misc.def_vars" version="1">
		<p n="def_color_scheme" v="Slate"/>
		<p n="def_refactor_active_config" v="Visual Studio 2008"/>
		<p n="def_toolbar_tree_pic_size" v="12"/>
		<p n="def_toolbartab" configs="win unix">
			<array>
				<class._TOOLBAR>
					<FormName v="_tbstandard_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbproject_tools_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x1"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbtools_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbedit_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbseldisp_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbxml_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x800"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbhtml_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x0"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbtagging_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x4"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbcontext_form"/>
					<tbflags v="0x8"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x400"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbdebugbb_form"/>
					<tbflags v="0x49"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x2"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbdebug_sessions_form"/>
					<tbflags v="0x48"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x2"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbvc_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x8"/>
				</class._TOOLBAR>
				<class._TOOLBAR>
					<FormName v="_tbandroid_form"/>
					<tbflags v="0x9"/>
					<restore_docked v="0"/>
					<show_x v="0"/>
					<show_y v="0"/>
					<show_width v="0"/>
					<show_height v="0"/>
					<docked_area v="0"/>
					<docked_row v="0"/>
					<docked_x v="0"/>
					<docked_y v="0"/>
					<docked_width v="0"/>
					<docked_height v="0"/>
					<tabgroup v="0"/>
					<tabOrder v="0"/>
					<auto_width v="0"/>
					<auto_height v="0"/>
					<rflags v="0x1"/>
				</class._TOOLBAR>
			</array>
		</p>
		<p n="def_symbol_color_profile" v="All symbols - Dark background"/>
		<p n="def_mozilla_modified" v="1"/>
		<p n="def_eao_file_date2" v="20200401124714000"/>
		<p n="def_lldb_debug_server" v=""/>
		<p n="def_workspace_info" configs="win">
			<array>
				<class.WORKSPACE_LIST>
					<isFolder v="1"/>
					<filename/>
					<caption v="Sample Workspaces"/>
					<u>
						<array>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\clang\clang.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\csharp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\vcpp_csharp.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\csharp\vcpp_csharp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\DevStudio\2013\VS2013.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\DevStudio\2015\VS2015.sln"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\java\java.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
							<class.WORKSPACE_LIST>
								<isFolder v="0"/>
								<filename v="%SLICKEDITCONFIGVERSION%SampleProjects\ucpp\cpp.vpw"/>
								<caption v=""/>
								<u/>
								<projectname v=""/>
							</class.WORKSPACE_LIST>
						</array>
					</u>
					<projectname/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\workspace\testse\testse.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\workspace\testse\testse.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\workspace\netEx.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\workspace\netEx.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\NetEx\NetEx.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\NetEx\NetEx.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\crypto\wolfssl\wolfsslLEARN\wolfssl.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\crypto\wolfssl\wolfsslLEARN\wolfssl.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\crypto\openssl\opensslLEARN\openssltest\openssltest.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\crypto\openssl\opensslLEARN\openssltest\openssltest.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\usb4java\testjavausb.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\usb4java\testjavausb.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Japan\Repo\TestJP\TestJP.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Japan\Repo\TestJP\TestJP\TestJP.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswing.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswing.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswing2\testswing2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswing2\testswing2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testawtapplet\testawtapplet.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testawtapplet\testawtapplet.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testswtapp\testswtapp.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testswtapp\testswtapp.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testjfcapplet\testjfcapplet.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testjfcapplet\testjfcapplet.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\java\repo\myjava\testjfcapplication\testjfcapplication.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\java\repo\myjava\testjfcapplication\testjfcapplication.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\CH4.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\CH4.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testCross.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testCross.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testc.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testc.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testalg\testalg.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testalg\testalg\testalg.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\Algorithm\repo\myalg\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\Algorithm\repo\myalg\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testalg2\testalg2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testalg2\testalg2.sln"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testalg2\testalg2\testalg2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\testCordinateECC\testCordinateECC\testECCCordinate\vsporj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\testCordinateECC\testCordinateECC\testECCCordinate\vsporj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\se\se.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\se\se.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch02\se_proj\se_proj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch02\se_proj\se_proj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch03\seprj\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch03\seprj\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch07\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch07\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="C:\W\learningjava-master\examples\ch08\seprj.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="C:\W\learningjava-master\examples\ch08\seprj.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vc_string\stringhandle\test2\test2.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vc_string\stringhandle\test2\test2.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vcplusplus\lisbox\lisbox\testlistbox.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vcplusplus\lisbox\lisbox\testlistbox.vpj"/>
				</class.WORKSPACE_LIST>
				<class.WORKSPACE_LIST>
					<isFolder v="0"/>
					<filename v="D:\vcplusplus\vcplusplus\lisbox\lisbox\testlistbox.vpw"/>
					<caption v=""/>
					<u/>
					<projectname v="D:\vcplusplus\vcplusplus\lisbox\lisbox\testlistbox.vpj"/>
				</class.WORKSPACE_LIST>
			</array>
		</p>
		<p n="def_open_style" v="0"/>
		<p n="def_jdk_install_dir" v="C:\Program Files\Java\jdk-14.0.1\" configs="win"/>
		<p n="def_java_live_errors_jdk_6_dir" v="C:\Program Files\Java\jdk-14.0.1\" configs="win"/>
		<p n="def_java_live_errors_jvm_lib" v="C:\Program Files\Java\jdk-14.0.1\bin\server\jvm.dll"/>
		<p n="def_encoding" v="+futf8s"/>
		<p n="def_git_browser_url_list">
			<array>
				<p v="C:\W\java\repo\myjava\"/>
			</array>
		</p>
		<p n="def_debug_number_formats">
			<dict>
				<p n="char">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="double">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="float">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="int">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="long">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="short">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
				<p n="unsigned">
					<class.DebugNumberFormat>
						<base/>
					</class.DebugNumberFormat>
				</p>
			</dict>
		</p>
		<p n="def_project_auto_build" v="1"/>
		<p n="def_keys" v="eclipse-keys" configs="win unix"/>
		<p n="def_deselect_copy" v="0"/>
		<p n="def_vcpp_word" v="1"/>
		<p n="def_subword_nav" v="1"/>
		<p n="def_re_search_flags" v="0x4004000"/>
		<p n="def_vcproj_debug_prefs" v="2"/>
		<p n="def_mfsearch_init_flags" v="0xA"/>
		<p n="def_active_java_config" v="JDK 14.0.1"/>
	</misc.def_vars>
	<misc.tag_file_list_all n="misc.tag_file_list_all" version="1" configs="win">
		<p n="cs" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg;%SLICKEDITCONFIGVERSION%tagfiles\unity.vtg"/>
		<p n="c" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="bas" v="%SLICKEDITCONFIGVERSION%tagfiles\dotnet.vtg"/>
		<p n="e" v="%SLICKEDITCONFIGVERSION%tagfiles\slickc.vtg"/>
	</misc.tag_file_list_all>
	<misc.fonts n="misc.fonts" version="1">
		<sbcs_dbcs_source_window font_name="Fixedsys" sizex10="120" flags="0x0" configs="win"/>
		<unicode_source_window font_name="Fixedsys" sizex10="120" flags="0x0" configs="win"/>
	</misc.fonts>
	<language n="language.dll" version="1">
		<p n="mode_name" v="dll"/>
	</language>
	<misc.file_extensions n="misc.file_extensions" version="1">
		<p n="encoding-def" v=""/>
		<p n="encoding-cs" v=""/>
		<p n="encoding-rb" v=""/>
		<p n="encoding-mp3" v=""/>
		<p n="encoding-7zip" v=""/>
		<p n="encoding-f90" v=""/>
		<p n="encoding-cfm" v=""/>
		<p n="encoding-f" v=""/>
		<p n="encoding-cpio" v=""/>
		<p n="encoding-coffee" v=""/>
		<p n="encoding-p4gl" v=""/>
		<p n="encoding-xhtml" v=""/>
		<p n="encoding-tagdoc" v=""/>
		<p n="encoding-cghlsl" v=""/>
		<p n="encoding-properties" v=""/>
		<p n="encoding-vtg" v=""/>
		<p n="encoding-exp" v=""/>
		<p n="encoding-plist" v=""/>
		<p n="encoding-c" v=""/>
		<p n="encoding-verilog" v=""/>
		<p n="encoding-bin" v=""/>
		<p n="encoding-adb" v=""/>
		<p n="encoding-vcproj" v=""/>
		<p n="encoding-docx" v=""/>
		<p n="encoding-w" v=""/>
		<p n="encoding-txt" v=""/>
		<p n="encoding-py" v=""/>
		<p n="encoding-ada" v=""/>
		<p n="encoding-aspx" v=""/>
		<p n="encoding-cob" v=""/>
		<p n="encoding-rpm" v=""/>
		<p n="encoding-build" v=""/>
		<p n="encoding-pas" v=""/>
		<p n="encoding-less" v=""/>
		<p n="encoding-ttcn" v=""/>
		<p n="encoding-cbl" v=""/>
		<p n="encoding-antlr" v=""/>
		<p n="encoding-svh" v=""/>
		<p n="encoding-sqlserver" v=""/>
		<p n="encoding-h" v=""/>
		<p n="encoding-fs" v=""/>
		<p n="encoding-plsql" v=""/>
		<p n="encoding-h++" v=""/>
		<p n="encoding-mk" v=""/>
		<p n="encoding-asax" v=""/>
		<p n="encoding-bat" v=""/>
		<p n="encoding-dll" v=""/>
		<p n="encoding-pm" v=""/>
		<p n="encoding-plm" v=""/>
		<p n="encoding-fsx" v=""/>
		<p n="encoding-php3" v=""/>
		<p n="encoding-pdf" v=""/>
		<p n="encoding-vsm" v=""/>
		<p n="encoding-inc" v=""/>
		<p n="encoding-xaml" v=""/>
		<p n="encoding-png" v=""/>
		<p n="encoding-asm390" v=""/>
		<p n="encoding-plx" v=""/>
		<p n="encoding-m" v=""/>
		<p n="encoding-db2" v=""/>
		<p n="encoding-htm" v=""/>
		<p n="encoding-i" v=""/>
		<p n="encoding-gsh" v=""/>
		<p n="encoding-exe" v=""/>
		<p n="encoding-dpr" v=""/>
		<p n="encoding-rs" v=""/>
		<p n="encoding-rul" v=""/>
		<p n="encoding-masm" v=""/>
		<p n="encoding-dtd" v=""/>
		<p n="encoding-docbook" v=""/>
		<p n="encoding-xpm" v=""/>
		<p n="encoding-xml" v=""/>
		<p n="encoding-rexx" v=""/>
		<p n="encoding-mpeg" v=""/>
		<p n="encoding-suo" v=""/>
		<p n="encoding-cpy" v=""/>
		<p n="encoding-tld" v=""/>
		<p n="encoding-winmd" v=""/>
		<p n="encoding-pl" v=""/>
		<p n="encoding-ascx" v=""/>
		<p n="encoding-class" v=""/>
		<p n="encoding-pro" v=""/>
		<p n="encoding-gl" v=""/>
		<p n="encoding-cob85" v=""/>
		<p n="encoding-vlx" v=""/>
		<p n="encoding-editorconfig" v=""/>
		<p n="encoding-perl" v=""/>
		<p n="encoding-cfscript" v=""/>
		<p n="encoding-vhdl" v=""/>
		<p n="encoding-hlsl" v=""/>
		<p n="encoding-rmd" v=""/>
		<p n="encoding-rhtml" v=""/>
		<p n="encoding-phpscript" v=""/>
		<p n="encoding-tiff" v=""/>
		<p n="encoding-l" v=""/>
		<p n="encoding-sdef" v=""/>
		<p n="encoding-for" v=""/>
		<p n="encoding-ruby" v=""/>
		<p n="encoding-qml" v=""/>
		<p n="encoding-psm1" v=""/>
		<p n="encoding-vsdelta" v=""/>
		<p n="encoding-cginc" v=""/>
		<p n="encoding-mak" v=""/>
		<p n="encoding-groovy" v=""/>
		<p n="encoding-g" v=""/>
		<p n="encoding-chf" v=""/>
		<p n="encoding-yaml" v=""/>
		<p n="encoding-pp" v=""/>
		<p n="encoding-mdown" v=""/>
		<p n="encoding-inl" v=""/>
		<p n="encoding-m4" v=""/>
		<p n="encoding-applescript" v=""/>
		<p n="encoding-tex" v=""/>
		<p n="encoding-gz" v=""/>
		<p n="encoding-p" v=""/>
		<p n="encoding-ansic" v=""/>
		<p n="encoding-v2k" v=""/>
		<p n="encoding-hp" v=""/>
		<p n="encoding-g4" v=""/>
		<p n="encoding-bbc" v=""/>
		<p n="encoding-rc" v=""/>
		<p n="encoding-scala" v=""/>
		<p n="encoding-frm" v=""/>
		<p n="encoding-prg" v=""/>
		<p n="encoding-vri" v=""/>
		<p n="encoding-ps1" v=""/>
		<p n="encoding-svgz" v=""/>
		<p n="encoding-ds" v=""/>
		<p n="encoding-asp" v=""/>
		<p n="encoding-slk" v=""/>
		<p n="encoding-csh" v=""/>
		<p n="encoding-cfml" v=""/>
		<p n="encoding-qth" v=""/>
		<p n="encoding-ps" v=""/>
		<p n="encoding-patch" v=""/>
		<p n="encoding-js" v=""/>
		<p n="encoding-jpeg" v=""/>
		<p n="encoding-awk" v=""/>
		<p n="encoding-ocb" v=""/>
		<p n="encoding-cpp" v=""/>
		<p n="encoding-xmldoc" v=""/>
		<p n="encoding-tcl" v=""/>
		<p n="encoding-r" v=""/>
		<p n="encoding-bas" v=""/>
		<p n="encoding-ansisql" v=""/>
		<p n="encoding-projitems" v=""/>
		<p n="encoding-zip" v=""/>
		<p n="encoding-hxx" v=""/>
		<p n="encoding-lex" v=""/>
		<p n="encoding-vcxproj" v=""/>
		<p n="encoding-shader" v=""/>
		<p n="encoding-erl" v=""/>
		<p n="encoding-ads" v=""/>
		<p n="encoding-tsv" v=""/>
		<p n="encoding-wxi" v=""/>
		<p n="encoding-d" v=""/>
		<p n="encoding-xslt" v=""/>
		<p n="encoding-mm" v=""/>
		<p n="encoding-cc" v=""/>
		<p n="encoding-cics" v=""/>
		<p n="encoding-npasm" v=""/>
		<p n="encoding-cfc" v=""/>
		<p n="encoding-ini" v=""/>
		<p n="encoding-master" v=""/>
		<p n="encoding-yacc" v=""/>
		<p n="encoding-pli" v=""/>
		<p n="encoding-java" v=""/>
		<p n="encoding-seq" v=""/>
		<p n="encoding-lib" v=""/>
		<p n="encoding-vb" v=""/>
		<p n="encoding-html" v=""/>
		<p n="encoding-a" v=""/>
		<p n="encoding-di" v=""/>
		<p n="encoding-sh" v=""/>
		<p n="encoding-asm" v=""/>
		<p n="encoding-proto" v=""/>
		<p n="encoding-err" v=""/>
		<p n="encoding-csv" v=""/>
		<p n="encoding-asc" v=""/>
		<p n="encoding-log" v=""/>
		<p n="encoding-vr" v=""/>
		<p n="encoding-sv" v=""/>
		<p n="encoding-hpp" v=""/>
		<p n="encoding-gvy" v=""/>
		<p n="encoding-itk" v=""/>
		<p n="encoding-if" v=""/>
		<p n="encoding-sql" v=""/>
		<p n="encoding-so" v=""/>
		<p n="encoding-obj" v=""/>
		<p n="encoding-mod" v=""/>
		<p n="encoding-bib" v=""/>
		<p n="encoding-cp" v=""/>
		<p n="encoding-hh" v=""/>
		<p n="encoding-sybase" v=""/>
		<p n="encoding-jar" v=""/>
		<p n="encoding-lua" v=""/>
		<p n="encoding-css" v=""/>
		<p n="encoding-md" v=""/>
		<p n="encoding-y" v=""/>
		<p n="encoding-ninja" v=""/>
		<p n="encoding-kt" v=""/>
		<p n="encoding-scriptterminology" v=""/>
		<p n="encoding-wxl" v=""/>
		<p n="encoding-vbproj" v=""/>
		<p n="encoding-cpgz" v=""/>
		<p n="encoding-wxs" v=""/>
		<p n="encoding-ch" v=""/>
		<p n="encoding-avi" v=""/>
		<p n="encoding-bourneshell" v=""/>
		<p n="encoding-pl1" v=""/>
		<p n="encoding-cljs" v=""/>
		<p n="encoding-jsfl" v=""/>
		<p n="encoding-ico" v=""/>
		<p n="encoding-cgfx" v=""/>
		<p n="encoding-bmp" v=""/>
		<p n="encoding-vpt" v=""/>
		<p n="encoding-cg" v=""/>
		<p n="encoding-matlab" v=""/>
		<p n="encoding-vsdelta2" v=""/>
		<p n="encoding-vpw" v=""/>
		<p n="encoding-swift" v=""/>
		<p n="encoding-eventhandlers" v=""/>
		<p n="encoding-itcl" v=""/>
		<p n="encoding-cmd" v=""/>
		<p n="encoding-imakefile" v=""/>
		<p n="encoding-cmake" v=""/>
		<p n="encoding-gradle" v=""/>
		<p n="encoding-xslx" v=""/>
		<p n="encoding-pdb" v=""/>
		<p n="encoding-sl" v=""/>
		<p n="encoding-xsl" v=""/>
		<p n="encoding-vhd" v=""/>
		<p n="encoding-tlib" v=""/>
		<p n="encoding-hrl" v=""/>
		<p n="encoding-diff" v=""/>
		<p n="encoding-cljc" v=""/>
		<p n="encoding-e" v=""/>
		<p n="encoding-clj" v=""/>
		<p n="encoding-bash" v=""/>
		<p n="encoding-svg" v=""/>
		<p n="encoding-php" v=""/>
		<p n="encoding-scriptsuite" v=""/>
		<p n="encoding-tsx" v=""/>
		<p n="encoding-vpj" v=""/>
		<p n="encoding-war" v=""/>
		<p n="encoding-vbs" v=""/>
		<p n="encoding-tar" v=""/>
		<p n="encoding-jpg" v=""/>
		<p n="encoding-as" v=""/>
		<p n="encoding-s" v=""/>
		<p n="encoding-z" v=""/>
		<p n="encoding-diffpatch" v=""/>
		<p n="encoding-vrh" v=""/>
		<p n="encoding-sca" v=""/>
		<p n="encoding-xz" v=""/>
		<p n="encoding-v" v=""/>
		<p n="encoding-ts" v=""/>
		<p n="encoding-7z" v=""/>
		<p n="encoding-hs" v=""/>
		<p n="encoding-setemplate" v=""/>
		<p n="encoding-mathml" v=""/>
		<p n="encoding-jsp" v=""/>
		<p n="encoding-csproj" v=""/>
		<p n="encoding-sta" v=""/>
		<p n="encoding-idl" v=""/>
		<p n="encoding-4gl" v=""/>
		<p n="encoding-rar" v=""/>
		<p n="encoding-tif" v=""/>
		<p n="encoding-conf" v=""/>
		<p n="encoding-tgz" v=""/>
		<p n="encoding-jsl" v=""/>
		<p n="encoding-xsd" v=""/>
		<p n="encoding-vpe" v=""/>
		<p n="encoding-unixasm" v=""/>
		<p n="encoding-tcc" v=""/>
		<p n="encoding-cxx" v=""/>
		<p n="encoding-go" v=""/>
		<p n="encoding-kts" v=""/>
		<p n="encoding-o" v=""/>
		<p n="encoding-msi" v=""/>
		<p n="encoding-vbscript" v=""/>
		<p n="encoding-yml" v=""/>
		<p n="encoding-c++" v=""/>
		<p n="encoding-chm" v=""/>
		<p n="encoding-xlsx" v=""/>
		<p n="encoding-cls" v=""/>
		<p n="encoding-shtml" v=""/>
		<p n="encoding-svi" v=""/>
		<p n="encoding-resx" v=""/>
		<p n="encoding-gy" v=""/>
		<p n="encoding-bz2" v=""/>
		<p n="encoding-gif" v=""/>
		<p n="encoding-markdown" v=""/>
		<p n="encoding-cljx" v=""/>
		<p n="encoding-wmv" v=""/>
		<p n="encoding-ex" v=""/>
		<p n="encoding-rby" v=""/>
		<p n="encoding-jcl" v=""/>
		<p n="encoding-json" v=""/>
		<p n="encoding-cf" v=""/>
		<p n="encoding-f95" v=""/>
		<p n="encoding-sas" v=""/>
		<p n="encoding-chs" v=""/>
		<p n="encoding-model204" v=""/>
		<p n="encoding-1" v=""/>
		<p n="encoding-backup" v=""/>
		<p n="encoding-0" v=""/>
		<p n="encoding-bak2" v=""/>
		<p n="encoding-4" v=""/>
		<p n="encoding-orig" v=""/>
		<p n="encoding-2" v=""/>
		<p n="encoding-working" v=""/>
		<p n="encoding-bak" v=""/>
		<p n="encoding-copy" v=""/>
		<p n="encoding-bak3" v=""/>
		<p n="encoding-mine" v=""/>
		<p n="encoding-3" v=""/>
		<p n="encoding-bak1" v=""/>
		<p n="encoding-save" v=""/>
	</misc.file_extensions>
	<language n="language.*ALL_LANGUAGES*" version="1">
		<line_numbers_flags v="0x3"/>
		<indent_with_tabs v="1"/>
	</language>
	<language.ada.beautifier_profiles n="language.ada.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.ada.beautifier_profiles>
	<language.android.beautifier_profiles n="language.android.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.android.beautifier_profiles>
	<language.ant.beautifier_profiles n="language.ant.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.ant.beautifier_profiles>
	<language.as.beautifier_profiles n="language.as.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.as.beautifier_profiles>
	<language.bas.beautifier_profiles n="language.bas.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.bas.beautifier_profiles>
	<language.c.beautifier_profiles n="language.c.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.c.beautifier_profiles>
	<language.cfml.beautifier_profiles n="language.cfml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.cfml.beautifier_profiles>
	<language.cs.beautifier_profiles n="language.cs.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.cs.beautifier_profiles>
	<language.docbook.beautifier_profiles n="language.docbook.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.docbook.beautifier_profiles>
	<language.groovy.beautifier_profiles n="language.groovy.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.groovy.beautifier_profiles>
	<language.html.beautifier_profiles n="language.html.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.html.beautifier_profiles>
	<language.java.beautifier_profiles n="language.java.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.java.beautifier_profiles>
	<language.js.beautifier_profiles n="language.js.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.js.beautifier_profiles>
	<language.json.beautifier_profiles n="language.json.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.json.beautifier_profiles>
	<language.m.beautifier_profiles n="language.m.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.m.beautifier_profiles>
	<language n="language.ninja" version="1">
		<indent_with_tabs v="1"/>
	</language>
	<language.phpscript.beautifier_profiles n="language.phpscript.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.phpscript.beautifier_profiles>
	<language.scala.beautifier_profiles n="language.scala.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.scala.beautifier_profiles>
	<language.systemverilog.beautifier_profiles n="language.systemverilog.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.systemverilog.beautifier_profiles>
	<language.tld.beautifier_profiles n="language.tld.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.tld.beautifier_profiles>
	<language.vbs.beautifier_profiles n="language.vbs.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.vbs.beautifier_profiles>
	<language.verilog.beautifier_profiles n="language.verilog.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.verilog.beautifier_profiles>
	<language.vpj.beautifier_profiles n="language.vpj.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.vpj.beautifier_profiles>
	<language.xhtml.beautifier_profiles n="language.xhtml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xhtml.beautifier_profiles>
	<language.xml.beautifier_profiles n="language.xml.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xml.beautifier_profiles>
	<language.xsd.beautifier_profiles n="language.xsd.beautifier_profiles.Default" version="1">
		<indent_with_tabs v="1"/>
	</language.xsd.beautifier_profiles>
	<language n="language.clojure" version="1">
		<tabs v="+4"/>
	</language>
	<language n="language.protocolbuf" version="1">
		<tabs v="+4"/>
	</language>
	<language n="language.c" version="1">
		<smart_paste v="0"/>
	</language>
	<language.aliases n="language.c.aliases" version="1">
		<p n="xc_printf">
			<text>
				<![CDATA[#include <stdio.h>
#include <limits.h>     // Contains the macros CHAR_MIN, INT_MIN, etc.


  printf("Storage sizes and value ranges of the types char and int\n\n");

  printf("The type char is %s.\n\n", CHAR_MIN < 0 ? "signed" :"unsigned");

  printf(" Type   Size (in bytes)   Minimum         Maximum\n"
         "---------------------------------------------------\n");
  printf(" char %8zu %20d %15d\n", sizeof(char), CHAR_MIN, CHAR_MAX );
  printf(" int  %8zu %20d %15d\n", sizeof(int), INT_MIN, INT_MAX );

%\l]]>
			</text>
		</p>
		<p n="xc_printf2">
			<text>
				<![CDATA[#include <stdio.h>
#include <float.h>

printf("Storage size: %d bytes\n"
          "Smallest positive value: %E\n"
          "Greatest positive value: %E\n"
          "Precision: %d decimal digits\n",
          sizeof(float), FLT_MIN, FLT_MAX, FLT_DIG);

   puts("\nAn example of float precision:\n");
   double d_var = 12345.6;          // A variable of type double.
   float f_var = (float)d_var;      // Initializes the float
                                    // variable with the value of d_var.
   printf("The floating-point number    "
          "%18.10f\n", d_var);
   printf("has been stored in a variable\n"
          "of type float as the value   "
          "%18.10f\n", f_var);
   printf("The rounding error is        "
          "%18.10f\n", d_var - f_var);
%\l]]>
			</text>
		</p>
		<p n="xc_rand">
			<text>
				<![CDATA[#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int i,                              // Obtain some storage space.
       *pNumbers = malloc(ARR_LEN * sizeof(int));

   if ( pNumbers == NULL )
   {
      fprintf(stderr, "Insufficient memory.\n");
      exit(1);
   }

   srand( (unsigned)time(NULL) );      // Initialize the
                                       // random number generator.

   for ( i=0; i < ARR_LEN; ++i )
      pNumbers[i] = rand() % 10000;    // Store some random numbers.

   printf("\n%d random numbers between 0 and 9999:\n", ARR_LEN );
   for ( i=0; i < ARR_LEN; ++i )       // Output loop:
   {
     printf("%6d", pNumbers[i]);       // Print one number per loop %\S
     if ( i % 10 == 9 ) putchar('\n'); // iteration and a newline after
                                       // every 10 numbers.
   }
   free( pNumbers );                   // Release the storage space.
%\l]]>
			</text>
		</p>
		<p n="xc_qsort">
			<text>
				<![CDATA[#include <stdlib.h>
#define ARR_LEN 20
#include <stdio.h>
#include <time.h>

float *pNumbers = malloc( ARR_LEN * sizeof(float) );

   /* ... Handle errors, initialize array elements ... */
   if( pNumbers == NULL)
   {
       fprintf(stderr, "Insufficient memory.\n");
       exit(1);
   }
   srand( (unsigned)time(NULL));
   for( int i=0; i < ARR_LEN; ++i)              // random numbers
       pNumbers[i] = (rand() - RAND_MAX/2) * (100.0F /RAND_MAX);

   /* Sort the array: */
   qsort( pNumbers, ARR_LEN, sizeof(float), floatcmp );

   /* ... Work with the sorted array ... */
   for( int i=0; i < ARR_LEN; ++i)              // The sorted array
       printf("%8.2f", pNumbers[i]);]]>
			</text>
		</p>
		<p n="xc_mv_element">
			<text>
				<![CDATA[#include <stdio.h>


  double dArr[5] = { 0.0, 1.1, 2.2, 3.3, 4.4 },  // Initialize an array and
  *dPtr = dArr;                                  // a pointer to its first
                                                 // element.
  int i = 0;                         // An index variable.
  dPtr = dPtr + 1;                   // Advance dPtr to the second element.
  dPtr = 2 + dPtr;                   // Addends can be in either order.
                                     // dPtr now points to dArr[3].

  printf( "%.1f\n", *dPtr );         // Print the element referenced by dPtr.
  printf( "%.1f\n", *(dPtr -1) );    // Print the element before that, without
                                     // modifying the pointer dPtr.
  i = dPtr - dArr;                   // Result: the index of the
                                     // array element that dPtr points to.
  printf( "%.d\n", i );              // Print the index (3).

%\l]]>
			</text>
		</p>
		<p n="xc_setbit">
			<text>
				<![CDATA[#include <limits.h>

unsigned int setBit( unsigned int mask, unsigned int p )
{
   if ( p >= CHAR_BIT * sizeof(int) )
      return mask;
   else
      return mask | (1 << p);
}]]>
			</text>
		</p>
		<p n="xc_strcpy_">
			<text>char *strcpy_( char* restrict s1, const char* restrict s2 )
{
   int i = 0;
   do
      s1[i] = s2[i];           // The loop body: copy each character
   while ( s2[i++] != '\0' );  // End the loop if we just copied a '\0'.
   return s1;
}</text>
		</p>
		<p n="xc_menu">
			<text>int menu( void )               // Prints the menu and returns
{                              // a character that the user types.
   static char menuStr[] =
   "\n               A = Action 1"
   "\n               B = Action 2"
   "\n               Q = Quit the program"
   "\n Your choice:  ";

   fputs( menuStr,stdout);

   int choice = 0;
   do %\S
     if( (choice = getchar()) == EOF)
         choice = 'Q'; %\S
   while( isspace(choice) );

   return choice;
}</text>
		</p>
		<p n="xc_bubblesort">
			<text>
				<![CDATA[void bubbleSort( float arr[], int len )   // The array arr and
{                                         // its length len.
   int isSorted = 0;
   do
   {
      float temp;             // Holder for values being swapped.
      isSorted = 1;
      --len;
      for ( int i = 0; i < len; ++i )
        if ( arr[i] > arr[i+1] )
        {
           isSorted = 0;      // Not finished yet.
           temp = arr[i];     // Swap adjacent values.
           arr[i] = arr[i+1];
           arr[i+1] = temp;
        }
   } while ( !isSorted );
}]]>
			</text>
		</p>
		<p n="xc_str_reverse">
			<text>
				<![CDATA[#include <string.h>

void strReverse( char* str)
{
   char ch;
   for ( size_t i = 0, j = strlen(str)-1; i < j; ++i, --j )
       ch = str[i], str[i] = str[j], str[j] = ch;
}]]>
			</text>
		</p>
		<p n="xc_selectionsort">
			<text>
				<![CDATA[// With gcc use the option -O  
// GCC does not inline any functions when not optimizing

// The function swapf() exchanges the values of two float variables.
// Arguments:    Two pointers to float.
// Return value: None.

inline void swapf( float *p1, float *p2 )      // An inline function.
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;
}

// The function selection_sortf() uses the selection-sort
// algorithm to sort an array of float elements.
// Arguments:    An array of float, and its length.
// Return value: None.

void selection_sortf( float a[], int n )   // Sort an array a of length n.
{
   register int i, j, mini;                // Three index variables.
   for ( i = 0; i < n - 1; ++i )
   {
      mini = i;             // Search for the minimum starting at index i.
      for ( j = i+1; j < n; ++j )
         if ( a[j] < a[mini] )
           mini = j;
      swapf( a+i, a+mini); // Swap the minimum with the element at index i.
   }
}]]>
			</text>
		</p>
		<p n="xc_factorial">
			<text>
				<![CDATA[// factorial() calculates n!, the factorial of a non-negative number n.
// For n > 0, n! is the product of all integers from 1 to n inclusive.
// 0! equals 1.
// Argument: A whole number, with type unsigned int.
// Return value: The factorial of the argument, with type long double.

long double factorial( register unsigned int n )
{
   long double f = 1;
   while ( n > 1 )
     f *= n--;
   return f;
}
%\l]]>
			</text>
		</p>
		<p n="xc_max">
			<text>
				<![CDATA[// The function maximum() obtains the greatest value in a
// two-dimensional matrix of double values.
// Arguments:    The number of rows, the number of columns, and the matrix.
// Return value: The value of the greatest element.

double maximum( int nrows, int ncols, double matrix[nrows][ncols] )
{
   double max = matrix[0][0];
   for ( int r = 0; r < nrows; ++r )
      for ( int c = 0; c < ncols; ++c )
         if ( max < matrix[r][c] )
            max = matrix[r][c];
   return max;
}]]>
			</text>
		</p>
		<p n="xc_swapf">
			<text>// With gcc use the option -O  
// GCC does not inline any functions when not optimizing

// The function swapf() exchanges the values of two float variables.
// Arguments:    Two pointers to float.
// Return value: None.

inline void swapf( float *p1, float *p2 )      // An inline function.
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;
}</text>
		</p>
		<p n="xc_binarysearch">
			<text>
				<![CDATA[// The binarySearch() function searches a sorted array.
// Arguments:    The value of the element to find;
//               the array of long to search; the array length.
// Return value: A pointer to the element found,
//               or NULL if the element is not present in the array.

long *binarySearch( long val, long array[ ], int n )
{
   int m = n/2;
   if ( n <= 0 )          return NULL;
   if ( val == array[m] ) return array + m;
   if ( val < array[m] )  return binarySearch( val, array, m );
   else                   return binarySearch( val, array+m+1, n-m-1 );
}

int main()
{
  long lArr[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
  int len = sizeof(lArr)/sizeof(*lArr);

  for ( int i = 0; i < len; ++i )
     printf("%6ld", lArr[i]);
  putchar('\n');

  long value = 0;
  printf( "\nEnter a whole number: ");
  scanf( "%ld", &value );

  long *ptr = binarySearch( value, lArr, len);

  if( ptr == NULL)
    printf("%ld is not an element of the array.\n", value);
  else
  { %\S
    int n = ptr+1 - lArr;
    printf("%ld is the %dth element in the arry.\n", value, n );
  }
  return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_strcat_">
			<text>char *strcat_( char * restrict s1, const char * restrict s2 )
{
   char *rtnPtr = s1;
   while ( *s1 != '\0' )               // Find the end of string s1.
      ++s1;
   while (( *s1++ = *s2++ ) != '\0' )  // The first character from s2
     ;                                 // replaces the terminator of s1.
   return rtnPtr;
}</text>
		</p>
		<p n="xc_printMatrix">
			<text>
				<![CDATA[#define NCOLS 10                    // The number of columns.
typedef float ROW_t[NCOLS];         // A type for the "row"

// Print one "row" array.
void printRow( const ROW_t pRow )
{
   for( int c = 0; c < NCOLS; ++c )
      printf( "%6.2f", pRow[c] );
   putchar( '\n' );
}

// Print the whole matrix.
void printMatrix( ROW_t *pMat, int nRows )
{
   for( int r = 0; r < nRows; ++r )
      printRow( pMat[r] );           // Print each row.
}]]>
			</text>
		</p>
		<p n="xc_selection_sort_ptr">
			<text>
				<![CDATA[inline void swapf( float *p1, float *p2 )
{
   float tmp = *p1; *p1 = *p2; *p2 = tmp;      // Swap *p1 and *p2.
}

// The function selection_sortf() uses the selection-sort
// algorithm to sort an array of float elements.
// Arguments: An array of float, and its length.

void selection_sortf( float a[], int n )       // Sort an array a of
{                                              // n float elements.
   if ( n <= 1 ) return;               // Nothing to sort.

   register float *last = a + n-1,     // A pointer to the last element.
                  *p,                  // A pointer to a selected element.
                  *minPtr;             // A pointer to the current minimum.

   for ( ; a < last; ++a )             // Walk pointer a through the array.
   {
      minPtr = a;                      // Find the smallest element
      for ( p = a+1; p <= last; ++p )  // between a and the last element.
         if ( *p < *minPtr )
           minPtr = p;
      swapf( a, minPtr );              // Swap the smallest element
   }                                   // with the element at a.
}]]>
			</text>
		</p>
		<p n="xc_sorttext">
			<text>
				<![CDATA[// Example 9-4. A simple program to sort lines of text
// sorttext.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *getLine(void);                // Reads a line of text
int str_compare(const void *, const void *);

#define NLINES_MAX 1000             // Maximum number of text lines.
char *linePtr[NLINES_MAX];          // Array of pointers to char.

int main()
{
   // Read lines:
   int n = 0;                       // Number of lines read.
   for ( ; n < NLINES_MAX && (linePtr[n] = getLine()) != NULL; ++n )
     ;

   if ( !feof(stdin) )              // Handle errors.
   {
      if ( n == NLINES_MAX )
         fputs( "sorttext: too many lines.\n", stderr );
      else
         fputs( "sorttext: error reading from stdin.\n", stderr );
   }
   else                             // Sort and print.
   {
      qsort( linePtr, n, sizeof(char*), str_compare );   // Sort.
      for ( char **p = linePtr; p < linePtr+n; ++p )     // Print.
         puts(*p);
   }
   return 0;
}

// Reads a line of text from stdin; drops the terminating
// newline character.
// Return value: A pointer to the string read, or
//               NULL at end-of-file, or if an error occurred.

#define LEN_MAX 512                 // Maximum length of a line.

char *getLine()
{
   char buffer[LEN_MAX], *linePtr = NULL;

   if ( fgets( buffer, LEN_MAX, stdin ) != NULL )
   {
      size_t len = strlen( buffer );

      if ( buffer[len-1] == '\n' )   // Trim the newline character.
         buffer[len-1] = '\0';
      else
         ++len;

      if ( (linePtr = malloc( len )) != NULL )   // Get memory for the line.
         strcpy( linePtr, buffer );  // Copy the line to the allocated block.
   }
   return linePtr;
}

// Comparison function for use by qsort().
// Arguments: Pointers to two elements in the array being sorted:
//            here, two pointers to pointers to char (char **).

int str_compare( const void *p1, const void *p2 )
{
   return strcmp( *(char **)p1, *(char **)p2 );
}
%\l]]>
			</text>
		</p>
		<p n="xc_func_ptr">
			<text>double Add( double x, double y ) { return x + y; }
double Sub( double x, double y ) { return x - y; }
double Mul( double x, double y ) { return x * y; }
double Div( double x, double y ) { return x / y; }

// Array of 5 pointers to functions that take two double parameters
// and return a double:

// double (*funcTable[5])(double, double)
//          = { Add, Sub, Mul, Div, pow };       // Initializer list.

typedef double func_t( double, double );    // The functions' type is
                                            // now named func_t.
func_t *funcTable[5] = { Add, Sub, Mul, Div, pow };

// An array of pointers to strings for output:
char *msgTable[5] = {"Sum", "Difference", "Product", "Quotient", "Power"};</text>
		</p>
		<p n="xc_BSTree_c">
			<text>
				<![CDATA[// A binary search tree (BST)
// BSTree.c

#include <string.h>          // memcpy()
#include <stdlib.h>          // malloc(), free()
#include "BSTree.h"

typedef struct Node { struct Node *left,    // Pointers to the left and
                                  *right;   // right child nodes.
                      size_t size;          // Size of the data payload.
                      char data[];          // The data itself.
                    } Node_t;

const void *defaultGetKey( const void *pData) { return pData; }

// -----------------------------------------------------------------------------
// The function newBST() creates a new binary search tree. The pointer to BST_t
// returned by newBST() is the first argument to all the other binary-tree functions.

BST_t *newBST( CmpFunc_t *cmp, GetKeyFunc_t *getKey)
{
   BST_t *pBST = NULL;
   if( cmp != NULL )
       pBST = malloc( sizeof( BST_t));
   if( pBST != NULL)
   {
       pBST->pRoot = NULL;
       pBST->cmp = cmp;
       pBST->getKey = (getKey != NULL) ? getKey : defaultGetKey;
   }
   return pBST;
}

// -----------------------------------------------------------------------------
// The function BST_insert() copies a data item to a new leaf node in the tree.
// The function inserts the new leaf at a position that is consistent with the
// binary tree sorting condition.
// BST_insert() returns true if it succeeds in inserting the new data; %\S
// otherwise, false.

static _Bool insert( BST_t *pBST, Node_t **ppNode, const void *pData, size_t size);

_Bool BST_insert( BST_t *pBST, const void *pData, size_t size)
{
    if( pBST == NULL || pData == NULL || size == 0)
       return false;
    return insert( pBST, &(pBST->pRoot), pData, size);
}

// The recursive helper function insert():
static _Bool insert( BST_t *pBST, Node_t **ppNode, const void *pData, size_t size )
{
   Node_t *pNode = *ppNode;                 // Pointer to the root node of the
                                            // subtree to insert the new node in.
   if ( pNode == NULL )
   {                                        // There's a place for a new leaf here.
     pNode = malloc( sizeof(Node_t) + size );
     if ( pNode != NULL )
     {
       pNode->left = pNode->right = NULL;   // Initialize the new node's
                                            // members.
       memcpy( pNode->data, pData, size );
       *ppNode = pNode;                     // Insert the new node.
       return true;
     }
     else
       return false;
   }
   else                                     // Continue looking for a place ...
   {
     const void *key1 = pBST->getKey( pData ),
                *key2 = pBST->getKey( pNode->data );
     if ( pBST->cmp( key1, key2 ) < 0 )     // ... in the left subtree,
       return insert( pBST, &(pNode->left), pData, size );
     else                                   // or in the right subtree.
       return insert( pBST, &(pNode->right), pData, size );
   }
}

// -------------------------------------------------------------------------------
// The function BST_search() uses the binary search algorithm to find a data item
// that matches a given key. The return value is a pointer to the data item
// of the first node that matches the key, or a null pointer if no match was found.

static const void *search( BST_t *pBST, const Node_t *pNode, const void *pKey);

const void *BST_search( BST_t *pBST, const void *pKey )
{
    if( pBST == NULL || pKey == NULL ) %\S
      return NULL;
    return search( pBST, pBST->pRoot, pKey);    // Start at the root of the tree.
}

// The recursive helper function search():
static const void *search( BST_t *pBST, const Node_t *pNode, const void *pKey )
{
    if ( pNode == NULL )
      return NULL;                                    // No subtree to search;
                                                      // no match found.
    else
    {                                                 // Compare data:
       int cmp_res = pBST->cmp( pKey, pBST->getKey(pNode->data) );
       if( cmp_res == 0 )                             // Found a match.
          return pNode->data;
       else if( cmp_res < 0 )                         // Continue the search
          return search( pBST, pNode->left, pKey );   // in the left subtree,
       else
          return search( pBST, pNode->right, pKey );  // or in the right subtree.
    }
}

// -------------------------------------------------------------------------------
// The BST_erase() function searches for a node that matches the specified key, and
// deletes it if found. The function returns false if it fails to find a matching %\S
// node to delete, or true if successful.

// The removal algorithm uses the recursive helper function detachMin() that plucks
// the minimum node from a specified subtree, and returns a pointer to the node:

static Node_t *detachMin( Node_t **ppNode )
{
    Node_t *pNode = *ppNode;                  // A pointer to the current node.
    if ( pNode == NULL )
      return NULL;                            // pNode is an empty subtree.
    else if ( pNode->left != NULL )
      return detachMin( &(pNode->left) );     // The minimum is in the left subtree.
    else
    {                                         // pNode points to the minimum node.
      *ppNode = pNode->right;                 // Attach the right child to the parent.
      return pNode;
    }
}

static _Bool erase(BST_t *pBST, Node_t **ppNode, const void *pKey);

_Bool BST_erase(BST_t *pBST, const void *pKey)
{
    if( pBST == NULL || pKey == NULL) %\S
      return false;
    return erase( pBST, &(pBST->pRoot), pKey);      // Start at the root of the tree.
}

// The recursive helper function erase():
static _Bool erase( BST_t *pBST, Node_t **ppNode, const void *pKey )
{
   Node_t *pNode = *ppNode;            // Pointer to the current node.
   if ( pNode == NULL )
      return false;                    // No match found.
                                       // Compare data:
   int cmp_res = pBST->cmp( pKey, pBST->getKey(pNode->data) );

   if ( cmp_res < 0 )                            // Continue the search
     return erase( pBST, &(pNode->left), pKey);  // in the left subtree,
   else if ( cmp_res > 0 )
     return erase( pBST, &(pNode->right), pKey); // or in the right subtree.
   else
   {                                   // Found the node to be deleted.
     if ( pNode->left == NULL )        // If no more than one child,
       *ppNode = pNode->right;         // attach the child to the parent.
     else if ( pNode->right == NULL )
       *ppNode = pNode->left;
     else                              // Two children: replace the node with
     {                                 // the minimum from the right subtree.
       Node_t *pMin = detachMin( &(pNode->right) );
       *ppNode = pMin;            // Graft it onto the deleted node's parent.
       pMin->left = pNode->left;       // Graft the deleted node's children.
       pMin->right = pNode->right;
     }
     free( pNode );                    // Release the deleted node's storage.
     return true;
   }
}

// -------------------------------------------------------------------------------
// The BST_clear() function deletes all the nodes of a tree.

static void clear( Node_t *pNode );
void BST_clear( BST_t *pBST )
{
    if ( pBST != NULL)
    {
       clear( pBST->pRoot );
       pBST->pRoot = NULL;
    }
}

// The recursive helper function clear():
static void clear( Node_t *pNode )
{
    if ( pNode != NULL )
    {
       clear( pNode->left );
       clear( pNode->right );
       free( pNode );
    }
}

// -------------------------------------------------------------------------------
// Each of the following traversal functions takes as its second argument a pointer
// to an ction?function that it calls for each node visited. %\S
// The return value is the number of times the action was performed successfully.

static int inorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_inorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return inorder( pBST->pRoot, action);
}

// The recursive helper function inorder():
static int inorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = inorder( pNode->left, action );        // L: Traverse the left
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.
    count += inorder( pNode->right, action );      // R: Traverse the right
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int rev_inorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_rev_inorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return rev_inorder( pBST->pRoot, action);
}

// The recursive helper function rev_inorder():
static int rev_inorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = rev_inorder( pNode->right, action );   // R: Traverse the right
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.
    count += rev_inorder( pNode->left, action );   // L: Traverse the left
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int preorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_preorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return preorder( pBST->pRoot, action);
}

// The recursive helper function preorder():
static int preorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    if ( action( pNode->data ))                    // N: The current node.
      ++count;
    count += preorder( pNode->left, action );      // L: Traverse the left
                                                   // subtree.
    count += preorder( pNode->right, action );     // R: Traverse the right
                                                   // subtree.
    return count;
}

// -------------------------------------------------------------------------------
static int postorder( Node_t *pNode, _Bool (*action)(void *pData));

int BST_postorder( BST_t *pBST, _Bool (*action)(void *pData))
{
    if( pBST == NULL || action == NULL)
        return 0;
    else
        return postorder( pBST->pRoot, action);
}

// The recursive helper function postorder():
static int postorder( Node_t *pNode, _Bool (*action)(void *pData))
{
    int count = 0;
    if( pNode == NULL)
        return 0;

    count = postorder( pNode->left, action );      // L: Traverse the left
                                                   // subtree.
    count += postorder( pNode->right, action );    // R: Traverse the right
                                                   // subtree.
    if ( action( pNode->data ))                    // N: Visit the current
      ++count;                                     // node itself.

    return count;
}
%\l]]>
			</text>
		</p>
		<p n="xc_BSTree_h">
			<text>
				<![CDATA[// A binary search tree (BST)
// BSTree.h

#include <stdbool.h>

typedef int CmpFunc_t( const void *pKey1, const void *pKey2);
typedef const void *GetKeyFunc_t( const void *pData);

typedef struct { struct Node  *pRoot;       // Pointer to the root.
                 CmpFunc_t    *cmp;         // Compares two keys.
                 GetKeyFunc_t *getKey;      // Converts data into a key value
               } BST_t;

BST_t *     newBST( CmpFunc_t *cmp, GetKeyFunc_t *getKey);
_Bool       BST_insert( BST_t *pBST, const void *pData, size_t size);
const void *BST_search( BST_t *pBST, const void *pKey);
_Bool       BST_erase( BST_t *pBST, const void *pKey);
void        BST_clear( BST_t *pBST);

// Each of the folowing functions traverses the tree in a certain order, and %\S
// calls the function referenced by action for each node. If the action modifies %\S
// the node's data, then at least the key value must remain unchanged to preserve %\S
// the tree's sorting order.
int BST_inorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_rev_inorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_preorder( BST_t *pBST, _Bool (*action)(void *pData));
int BST_postorder( BST_t *pBST, _Bool (*action)(void *pData));
%\l]]>
			</text>
		</p>
		<p n="xc_sortline">
			<text>
				<![CDATA[// Example 12-3. The sortlines program
// sortlines.c

// This program reads each line of text into a node of a binary tree,
// and then prints the text in sorted order.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "BSTree.h"               // Prototypes of the BST functions.

#define LEN_MAX 1000              // Maximum length of a line.
char buffer[LEN_MAX];

// Action to perform for each line:
_Bool printStr( void *str ) { return printf( "%s", str ) >= 0; }

int main()
{
    BST_t *pStrTree = newBST( (CmpFunc_t*)strcmp, NULL );
    int n;

    while ( fgets( buffer, LEN_MAX, stdin ) != NULL )   // Read each line.
    {
       size_t len = strlen( buffer );                   // Length incl.
                                                        // newline character.
       if ( !BST_insert( pStrTree, buffer, len+1 ))     // Insert the line in
          break;                                        // the tree.
    }
    if ( !feof(stdin) )
    {                                     // If unable to read the entire text:
       fprintf( stderr, "sortlines: "
                "Error reading or storing text input.\n" );
       exit( EXIT_FAILURE );
    }

    n = BST_inorder( pStrTree, printStr );     // Print each line, in sorted order.

    fprintf( stderr, "\nsortlines: Printed %d lines.\n", n );

    BST_clear( pStrTree );                     // Discard all nodes.
    return 0;
}]]>
			</text>
		</p>
		<p n="xc_getline">
			<text>
				<![CDATA[// Read a line of text from stdin into a dynamically allocated buffer.
// Replace the newline character with a string terminator.
// Arguments:    The maximum line length to read.
// Return value: A pointer to the string read, or
//               NULL if end-of-file was read or if an error occurred.

char *getLine( unsigned int len_max )
{
   char *linePtr = malloc( len_max+1 );  // Reserve storage for "worst case."
   if ( linePtr != NULL )
   {
     // Read a line of text and replace the newline characters with
     // a string terminator:
     int c = EOF;
     unsigned int i = 0;
     while ( i < len_max && ( c = getchar() ) != '\n' && c != EOF )
       linePtr[i++] = (char)c;
     linePtr[i] = '\0';

     if ( c == EOF && i == 0 )          // If end-of-file before any
     {                                  // characters were read,
        free( linePtr );                // release the whole buffer.
        linePtr = NULL;
     }
     else                               // Otherwise, release the unused portion.
        linePtr = realloc( linePtr, i+1 );           // i is the string length.
   }
   return linePtr;
}]]>
			</text>
		</p>
		<p n="xc_createDataFile">
			<text>
				<![CDATA[#include <stdio.h>
#include "record.h"

char dataFile[ ] = "records.dat";                  // Filename.

int main()// Creates a file records.dat (inFile) with some test data.
{
    FILE *fp;
    Record_t records[] = { { 1789L, "George" },
                           { 1797L, "John" }, %\S
                           {    0L, "Harry" },
                           { 1801L, "Thomas"},
                           { 1809L, "James"},
                           { 1825L, "Quincy" }
                         };
    size_t n = sizeof(records) / sizeof(*records); %\S
 %\S
    if( (fp = fopen( dataFile, "wb")) == NULL)
    {
        fprintf( stderr, "Error on opening output file \"%s\".\n", dataFile);
        return 1;
    }
    if( fwrite( records, sizeof(Record_t), n, fp) < n)
    {
        fprintf( stderr, "Error on writing to output file \"%s\".\n", dataFile);
        return 1;
    }
    printf( "%d records written.\n", n);
    return 0;
}]]>
			</text>
		</p>
		<p n="xc_isReadWriteable">
			<text>_Bool isReadWriteable( const char *filename )
{
    FILE *fp = fopen( filename, "r+" );    // Open a file to read and write.

    if ( fp != NULL )                      // Did fopen() succeed?
    {
        fclose(fp);                        // Yes: close the file; no error handling.
        return true;
    }
    else                                   // No.
        return false;
}</text>
		</p>
		<p n="xc_searchFile">
			<text>int searchFile( FILE *fpIn, const char *keyword )
{
   #define MAX_LINE 256
   char line[MAX_LINE] = "";
   int count = 0;

   if ( fpIn == NULL || keyword == NULL )
      return -1;
   else
      rewind( fpIn );

   while ( fgets( line, MAX_LINE, fpIn ) != NULL )
      if ( strstr( line, keyword ) != NULL )
      {
         ++count;
         fputs( line, stdout );
      }

   if ( !feof( fpIn ) )
      return -1;
   else
      return count;
}</text>
		</p>
		<p n="xc_searchNewName">
			<text>
				<![CDATA[// setNewName.c : 
// The following example uses an index table to store the positions of records in the
// file. This approach permits direct access to a record that needs to be updated.

// setNewName(): Finds a keyword in an index table
// and updates the corresponding record in the file.
// The file containing the records must be opened in
// "update mode"; i.e., with the mode string "r+b".
// Arguments: - A FILE pointer to the open data file;
//            - The key;
//            - The new name.
// Return value: A pointer to the updated record,
//               or NULL if no such record was found.
// ---------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include "record.h"   // Defines the types Record_t, IndexEntry_t:
                      // typedef struct { long key; char name[32];
                      //                  /* ... */ } Record_t;
                      // typedef struct { long key, pos; } IndexEntry_t;

extern IndexEntry_t indexTab[];         // The index table.
extern int indexLen;                    // The number of table entries.

Record_t *setNewName( FILE *fp, long key, const char *newname )
{
   static Record_t record;
   int i;

   for ( i = 0; i < indexLen; ++i )
   {
      if ( key == indexTab[i].key )
         break;                             // Found the specified key.
   }
   if ( i == indexLen )
      return NULL;                          // No match found.

   // Set the file position to the record:
   if (fseek( fp, indexTab[i].pos, SEEK_SET ) != 0 )
      return NULL;                          // Positioning failed.

   // Read the record:
   if ( fread( &record, sizeof(Record_t), 1, fp ) != 1 )
      return NULL; // Error on reading.
   if ( key != record.key )                 // Test the key.
      return NULL;
   else
   {                                        // Update the record:
      size_t size = sizeof(record.name);
      strncpy( record.name, newname, size-1 );
      record.name[size-1] = '\0';

      if ( fseek( fp, indexTab[i].pos, SEEK_SET ) != 0 )
         return NULL;                       // Error setting file position.
      if ( fwrite( &record, sizeof(Record_t), 1, fp ) != 1 )
         return NULL;                       // Error writing to file.

      return &record;
   }
}
%\l]]>
			</text>
		</p>
		<p n="xc_searNewNAme_call">
			<text>
				<![CDATA[// setNewName_call.c : 
// The main function creates an index table for the file records.dat
// and calls the setNewName() function.

#include <stdio.h>
#include <string.h>
#include "record.h"   // Defines the types Record_t, IndexEntry_t:
                      // typedef struct { long key; char name[32];
                      //                  /* ... */ } Record_t;
                      // typedef struct { long key, pos; } IndexEntry_t;

#define TAB_LEN 100
IndexEntry_t indexTab[TAB_LEN];         // The index table.
int indexLen = 0;                       // The number of table entries.

char dataFile[] = "records.dat";

int main()
{
    FILE *fpData = NULL;
    Record_t record;
    int i;

    if( (fpData = fopen( dataFile, "r+b")) == NULL)
    {
        fprintf( stderr, "Error on opening the file \"%s\".\n", dataFile);
        return 1;
    }
    for( i = 0; i < TAB_LEN; ++i)
    {
        indexTab[i].pos = ftell(fpData);          // current file position.
        if( fread( &record, sizeof(Record_t), 1, fpData) < 1)
            break;
        indexTab[i].key = record.key;
//        printf("%4ld : %ld\n", indexTab[i].key, indexTab[i].pos);
    }
    if( !feof( fpData))
    {
        fprintf( stderr, "Error on reading the file \"%s\".\n", dataFile);
        return 2;
    }
    indexLen = i;

    if( setNewName( fpData, 1825L, "John Quincy") == NULL)
       fprintf( stderr, "Error on updating the file \"%s\".\n", dataFile);

    // List the records:
    rewind( fpData);
    while( fread( &record, sizeof(Record_t), 1, fpData) == 1) %\S
    {
       printf("%8ld : %s\n", record.key, record.name);
    }

    fclose( fpData);
    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_cputime_dif">
			<text>
				<![CDATA[#include <time.h>
clock_t t1 = clock();
clock_t t2 = clock();]]>
			</text>
		</p>
		<p n="xc_parallel_sum">
			<text>
				<![CDATA[// Example 14-1. Calculating the sum of array elements in several parallel threads
// parallelSum.c
// ----------------------------------------------------------------------------
#include <stdbool.h>
#include <threads.h>

#define MAX_THREADS 8             // 1, 2, 4, 8 ... Maximum number
                                  // of threads to create.
#define MIN_BLOCK_SIZE 100        // Minimum size of an array block.

typedef struct                    // Arguments for the parallel_sum() function.
{
    float *start;                 // Start and length of the
    int len;                      // array block passed to parallel_sum().
    int block_size;               // Size of the smallest blocks.
    double sum;                   // The result.
} Sum_arg;

int parallel_sum(void *arg);      // Prototype of the thread function.

// ---------------------------------------------------------------
// Calculate the sum of array elements and write it to *sumPtr.
// sum() calls the function parallel_sum() for parallel processing.
// Return value: true if no error occurs, otherwise false.

bool sum(float arr[], int len, double* sumPtr)
{
    int block_size = len / MAX_THREADS;
    if (block_size < MIN_BLOCK_SIZE) block_size = len;

    Sum_arg args = { arr, len, block_size, 0.0 };
    if (parallel_sum(&args))
    { %\S
        *sumPtr = args.sum; %\S
        return true;
    }
    else
        return false;
}

// ---------------------------------------------------------------
// Recursive helper function to divide the work among several threads.

int parallel_sum(void *arg)
{
    Sum_arg *argp = (Sum_arg*)arg;       // A pointer to the arguments.
    if (argp->len <= argp->block_size)   // If length <= block_size,
    {                                    // add up the elements.
        for (int i = 0; i < argp->len; ++i)
        argp->sum += argp->start[i];
        return 1;
    }
    else                                  // If length > block_size,
    {                                     // divide the array.
        int mid = argp->len / 2;
        Sum_arg arg2 = { argp->start+mid, argp->len-mid,
                         argp->block_size, 0};   // Specifies 2nd half
        argp->len = mid;                         // Length of first half

        thrd_t th;                     // Process 1st half in a new thread.
        int res = 0;

        if (thrd_create(&th, parallel_sum, arg) != thrd_success)
            return 0;                  // Couldn't spawn a thread

        if (!parallel_sum(&arg2))      // Process 2nd half by recursion
                                       // in the current thread.
        {
            thrd_detach(th); return 0; // Recursive call failed
        }
        thrd_join(th, &res);
        if (!res)
            return 0;                  // Sibling thread reported failure

        argp->sum += arg2.sum;
        return 1;
    }
}
%\l]]>
			</text>
		</p>
		<p n="xc_thread">
			<text>
				<![CDATA[// Example 14-2. Concurrent memory access without synchronization
// inc_dec.c

#include <stdio.h>
#include <threads.h>
//#include <stdatomic.h>

#define COUNT 10000000L

long counter = 0;
//_Atomic long counter = ATOMIC_VAR_INIT(0L);

void incFunc(void) { for (long i = 0; i < COUNT; ++i) ++counter; }
void decFunc(void) { for (long i = 0; i < COUNT; ++i) --counter; }

int main(void)
{
    clock_t cl = clock();
    thrd_t th1, th2;

    if( thrd_create(&th1, (thrd_start_t)incFunc, NULL) != thrd_success
        || thrd_create(&th2, (thrd_start_t)decFunc, NULL) != thrd_success)
    {
        fprintf(stderr,"Error creating thread\n"); return -1;
    }
    thrd_join(th1, NULL);
    thrd_join(th2, NULL);

    printf("Counter: %ld \t", counter);
    printf("CPU time: %ld ms\n", (clock()-cl)*1000L/CLOCKS_PER_SEC);

    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_mutex">
			<text>
				<![CDATA[// Example 14-3. Adding a mutex to the program in Example 14-2

#include <stdio.h>
#include <threads.h>

#define COUNT 10000000L

long counter = 0;
mtx_t mtx;                        // A mutex for access to counter

void incFunc(void)
{
    for (long i = 0; i < COUNT; ++i)
    { mtx_lock(&mtx); ++counter; mtx_unlock(&mtx); }
}
void decFunc(void)
{
    for (long i = 0; i < COUNT; ++i)
    { mtx_lock(&mtx); --counter; mtx_unlock(&mtx); }
}

int main(void)
{
    if (mtx_init(&mtx, mtx_plain) != thrd_success)
    {
        fprintf(stderr, "Error initializing the mutex.\n");
        return -1;
    }

    // As in Example 14-2: %\S
    // start threads, wait for them to finish, print output:
    clock_t cl = clock();
    thrd_t th1, th2;

    if( thrd_create(&th1, (thrd_start_t)incFunc, NULL) != thrd_success
        || thrd_create(&th2, (thrd_start_t)decFunc, NULL) != thrd_success)
    {
        fprintf(stderr,"Error creating thread\n"); return -1;
    }
    thrd_join(th1, NULL);
    thrd_join(th2, NULL);

    printf("Counter: %ld \t", counter);
    printf("CPU time: %ld ms\n", (clock()-cl)*1000L/CLOCKS_PER_SEC);

    mtx_destroy(&mtx);
    return 0;
}

%\l]]>
			</text>
		</p>
		<p n="xc_ring_buffer_c">
			<text>
				<![CDATA[// Example 14-4. A ring buffer for the producer-consumer model

/* -------------------------------------------------------------
 * buffer.c
 * Definitions of functions operating on Buffer.
 */

#include "buffer.h"
#include <stdlib.h>           // For malloc() and free()

bool bufInit( Buffer *bufPtr, size_t size)
{
    if ((bufPtr->data = malloc( size * sizeof(int))) == NULL)
       return false;
    bufPtr->size = size;
    bufPtr->count = 0;
    bufPtr->tip = bufPtr->tail = 0;
    return    mtx_init( &bufPtr->mtx, mtx_plain) == thrd_success
           && cnd_init( &bufPtr->cndPut) == thrd_success
           && cnd_init( &bufPtr->cndGet) == thrd_success;
}

void bufDestroy(Buffer *bufPtr)
{
    cnd_destroy( &bufPtr->cndGet );
    cnd_destroy( &bufPtr->cndPut );
    mtx_destroy( &bufPtr->mtx );
    free( bufPtr->data );
}

// Insert a new element in the buffer:
bool bufPut(Buffer *bufPtr, int data)
{
    mtx_lock( &bufPtr->mtx );

    while (bufPtr->count == bufPtr->size)
       if (cnd_wait( &bufPtr->cndPut, &bufPtr->mtx ) != thrd_success)
          return false;

    bufPtr->data[bufPtr->tip] = data;
    bufPtr->tip = (bufPtr->tip + 1) % bufPtr->size;
    ++bufPtr->count;

    mtx_unlock( &bufPtr->mtx );
    cnd_signal( &bufPtr->cndGet );

    return true;
}

// Remove an element from the buffer. If the buffer is empty,
// wait no more than sec seconds.
bool bufGet(Buffer *bufPtr, int *dataPtr, int sec)
{
    struct timespec ts;
    timespec_get( &ts, TIME_UTC );     // The current time
    ts.tv_sec += sec;                  // + sec seconds delay.

    mtx_lock( &bufPtr->mtx );

    while ( bufPtr->count == 0 )
       if (cnd_timedwait(&bufPtr->cndGet,
                         &bufPtr->mtx, &ts) != thrd_success)
           return false;

    *dataPtr = bufPtr->data[bufPtr->tail];
    bufPtr->tail = (bufPtr->tail + 1) % bufPtr->size;
    --bufPtr->count;

    mtx_unlock( &bufPtr->mtx );
    cnd_signal( &bufPtr->cndPut );

    return true;
}

%\l]]>
			</text>
		</p>
		<p n="xc_ring_buffer_h">
			<text>
				<![CDATA[#include <stdbool.h>
#include <threads.h>

typedef struct Buffer
{
    int *data;              // Pointer to the array of data.
    size_t size, count;     // Maximum and current numbers of elements.
    size_t tip, tail;       // tip = index of the next free spot.
    mtx_t mtx;              // A mutex and
    cnd_t cndPut, cndGet;   // two condition variables.
} Buffer;

bool bufInit( Buffer *bufPtr, size_t size );
void bufDestroy(Buffer *bufPtr);

bool bufPut(Buffer *bufPtr, int data);
bool bufGet(Buffer *bufPtr, int *dataPtr, int sec);]]>
			</text>
		</p>
		<p n="xc_abort_ex">
			<text>void abort_ex()
{   %\S
   /* ... */
   struct record *new = (struct record *)malloc( sizeof(struct record) );
   if ( new != NULL )                   // Check whether malloc failed!
   {
       fprintf( stderr, "%s: out of memory!\n", __func__ );
       abort();
   }
   else
   { %\S
       puts("working ...");
       // a fatal error occurs:
       abort();                          // abort the programm.
   }
}</text>
		</p>
		<p n="xc_asctime_ex">
			<text>
				<![CDATA[time_t now;
time( &now );          /* Get the time (seconds since 1/1/70) */
printf( "Date: %.24s GMT\n", asctime( gmtime( &now ) ));]]>
			</text>
		</p>
		<p n="xc_acos">
			<text>#define PI 3.141593
#define DEG_PER_RAD (180.0/PI)


    double floor_width = 30.0;
    double roof_width = 34.6;

    double roof_pitch = acos( floor_width / roof_width ) * DEG_PER_RAD ;
%\l</text>
		</p>
		<p n="xc_abs_ex">
			<text>
				<![CDATA[int amount = -1234;
    char currencysym[2] = "$";
    char sign[2] = "-";
    div_t dollarsandcents = { 0, 0 };

    if ( amount >= 0 )
       sign[0] = '\0';

    dollarsandcents = div(abs( amount ), 100 );]]>
			</text>
		</p>
		<p n="xc_acosh_ex">
			<text>double x, y1, y2;
errno = 0;
y1 = acosh(x);
if ( errno == EDOM)
{
perror("acosh"); break;
}
y2 = log( x + sqrt( x*x - 1));
printf("x = %f; acosh(x) = %f; log(x + sqrt(x*x-1)) = %f\n",x, y1, y2);</text>
		</p>
		<p n="xc_asctime_s_ex">
			<text>
				<![CDATA[#include <time.h>
time_t now;
struct tm timeStruct;
char timeStr[26];
time(&now);                       // Date and time as an integer.
localtime_s(&now, &timeStruct);   // Convert to a structure.
if( asctime_s( timeStr, sizeof(timeStr), &timeStruct) == 0)
printf("Date and time: %s", timeStr);]]>
			</text>
		</p>
		<p n="xc_asin_ex">
			<text>
				<![CDATA[#include <math.h> 
#define PI 3.141593
#define DEG_PER_RAD (180.0/PI)
float height = 2.20F;
float length = 1.23F;
float altitude = asinf( height / sqrtf( height*height + length*length));]]>
			</text>
		</p>
		<p n="xc_asinh_ex">
			<text>
				<![CDATA[#include <math.h> 
for ( double x = -2.0; x < 2.1; x += 0.5)
printf("%6.2f %15f %20f\n", x, asinh(x), log( x + sqrt(x*x+1)));]]>
			</text>
		</p>
		<p n="xc_assert_ex">
			<text>
				<![CDATA[#include <assert.h>
int units_in_stock = 10;
int units_shipped = 9;
units_shipped++;
units_in_stock--;
units_in_stock -= units_shipped;
assert(units_in_stock >= 0);]]>
			</text>
		</p>
		<p n="xc_at_quick_exit_ex">
			<text>
				<![CDATA[void nexit(void) { puts("Program terminated normally."); }
void qexit(void) { puts("Programm terminated by \"quick_exit()\"."); }
int a = -1;
atexit( nexit);
at_quick_exit( qexit);
if( a < 0)
quick_exit(EXIT_FAILURE);]]>
			</text>
		</p>
		<p n="xc_atan_ex">
			<text>  #ifdef PI
    printf("The symbol PI was already defined.\n");
    long double pi = (long double) PI;
  #else
    long double pi = 4.0L * atanl( 1.0L );    // Because tan(pi/4) = 1
  #endif
    printf( "Assume pi equals %.17Lf.\n", pi);</text>
		</p>
		<p n="xc_atoi">
			<text>
				<![CDATA[%\l
#include <stdlib.h>       // int atoi( const char *s );
                          // long atol( const char *s );
                          // long long atoll( const char *s );
#include <stdio.h>

int main()
{
    char *s = " -135792468.00 Balance on Dec. 31";
    printf("\"%s\" becomes %ld\n", s, atol(s));

    return 0;
}
%\l]]>
			</text>
		</p>
		<p n="xc_atof">
			<text>%\l</text>
		</p>
		<p n="xc_erf">
			<text>
				<![CDATA[// erf_ex.c : erf() example
// -------------------------------------------------------------

#include <math.h>   // double erf( double x );
                    // float erff( float x );
                    // long double erfl( long double x );
#include <stdio.h>

/*
 * Given a normal distribution with mean 0 and standard deviation 1,
 * calculate the probability that the random variable is within the
 * range [0, 1.125]
 */

int main()
{
    double sigma = 1.0;     // The standard deviation
    double bound = 1.125;
    double probability;     // probability that mean <= value <= bound

    probability = 0.5 *erf( bound / (sigma * sqrt(2.0)) );

    printf("Given a normal distribution with mean 0 and standard deviation 1,\n"
           "the probability that a random variable is within the range [0, 1.125]\n"
           "is %%lf.\n", probability ); 

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exit_ex">
			<text>
				<![CDATA[// exit_ex.c : exit() example
// -------------------------------------------------------------

#include <stdlib.h>     // _Noreturn void exit( int status );
#include <stdio.h>

int main( int argc, char *argv[])
{
    FILE *f_in, *f_out;

    enum { X_OK = 0, X_ARGS, X_NOIN, X_NOOUT };

    if ( argc != 3 ) {
       fprintf( stderr, "Usage: program input-file output-file\n");
       exit( X_ARGS );
    }

    f_in = fopen(argv[1], "r");
    if ( f_in == NULL ) {
       fprintf( stderr, "Unable to open input file.\n");
       exit( X_NOIN );
    }
    f_out = fopen(argv[2], "a+");
    if ( f_out == NULL ) {
       fprintf( stderr, "Unable to open output file.\n");
       exit( X_NOOUT );
    }

    /* ... read, process, write, close files ... */

    exit( X_OK );           //  return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exp2_ex">
			<text>
				<![CDATA[// exp2_ex.c : exp2() example
// -------------------------------------------------------------

#include <math.h>        // double exp2( double x );
                         // float exp2f( float x );
                         // long double exp2l( long double x );
#include <stdio.h>

// The famous grains-of-rice-on-a-chessboard problem.
// The sultan loses a chess game. The wager was one grain for square 1
// on the chessboard, then double the last number for each successive
// square. How much rice in all?

int main()
{
    int squares = 64;
    long double gramspergrain = 0.0025L;   // A grain of rice weighs 25 mg.
    long double sum = 0.0L;

    for ( int i = 0; i < squares; i++ )
        sum += gramspergrain * exp2l( (long double)i );

    printf( "The sultan's wager costs him %%.3Lf metric tons of rice.\n",
             sum / 1000000.0L );           // A million grams per ton.

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_exp_ex">
			<text>
				<![CDATA[// exp_ex.c : exp() example
// -------------------------------------------------------------

#include <math.h>        // double exp( double x );
                         // float expf( float x );
                         // long double expl( long double x );
#include <stdio.h>

int main()
{
    /* Amount owed = principal * e^(interest_rate * time) */

    int principal = 10000;   // Initial debt is ten thousand dollars.
    int balance = 0;
    double rate = 0.055;     // Interest rate is 5.5%% annually.
    double time = 1.5;       // Period is eighteen months.

    balance = principal * exp( rate * time );

    printf("Invest %%d dollars at %%.1f%%%% compound interest, and "
           "in %%.1f years \nyou'll have %%d dollars.\n",
           principal, rate*100.0, time, balance );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fclose_ex">
			<text>
				<![CDATA[// fclose_ex.c : fclose() example
// -------------------------------------------------------------

#include <stdio.h>   // int fclose( FILE *fp );

/* Print a file to the console, line by line. */

int main()
{
    FILE *fp_infile;
    char linebuffer[512];

    if (( fp_infile= fopen("input.dat", "r")) == NULL )
    {
       fprintf(stderr, "Couldn't open input file.\n");
       return -1;
    }

    while ( fgets( linebuffer, sizeof(linebuffer), fp_infile ) != NULL )
        fputs( linebuffer, stdout );

    if ( ! feof(fp_infile) )         // This means "if not end of file"
       fprintf( stderr, "Error reading from input file.\n" );

    if ( fclose(fp_infile) != 0 )
    {
       fprintf(stderr, "Error closing input file.\n");
       return -2;
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fdim_ex">
			<text>
				<![CDATA[// fdim_ex.c : fdim() example
// -------------------------------------------------------------

#include <math.h>        // double fdim( double x, double y );
                         // float fdimf( float x, float y );
                         // long double fdiml( long double x, long double y );
#include <stdio.h>

int main()
{
    /* Make sure an argument is within the domain of asin() */

    double sign, argument = -1.5, result;
    /* ... */

    sign = copysign( 1.0, argument );           // Save the sign ...
    argument = copysign( argument, 1.0 );       // then use only positive values

    argument = 1.0 - fdim( 1.0, argument );     // Trim excess beyond 1.0
    result = asin( copysign(argument, sign) );  // Restore sign and
                                                // call asin()
    printf( "For the argument %%.2lf the asin function returns %%lf.\n",
             copysign(argument, sign), result );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_deholdexcept_ex">
			<text>
				<![CDATA[// feholdexcept_ex.c : feholdexcept() example
// -------------------------------------------------------------

#include <fenv.h>     // int feholdexcept( fenv_t *envp );
#include <math.h>
#include <float.h>

/*
 * Compute the hypotenuse of a right triangle, avoiding intermediate
 * overflow or underflow.
 *
 * (This example ignores the case of one argument having
 * great magnitude and the other small, causing both overflow
 * and underflow!)
 */
double hypotenuse(double sidea, double sideb)
{
#pragma STDC FENV_ACCESS ON
    double sum, scale, ascaled, bscaled, invscale;
    fenv_t fpenv;
    int fpeflags;

    if ( signbit(sidea))  sidea = fabs(sidea);
    if ( signbit(sideb))  sideb = fabs(sideb);

    feholdexcept(&fpenv);        // Save previous environment,
                                 // clear exceptions,
                                 // switch to nonstop processing.
    invscale = 1.0;
    sum = sidea * sidea + sideb * sideb;    // First try whether a^2 + b^2
                                            // causes any exceptions.

    fpeflags = fetestexcept(FE_UNDERFLOW | FE_OVERFLOW);    // Did it?
    if (fpeflags & FE_OVERFLOW && sidea > 1.0 && sideb > 1.0)
    {
        /* a^2 + b^2 caused an overflow. Scale the triangle down. */
        feclearexcept(FE_OVERFLOW);
        scale = scalbn( 1.0, (DBL_MIN_EXP / 2));

        invscale = 1.0 / scale;
        ascaled = scale * sidea;
        bscaled = scale * sideb;
        sum = ascaled * ascaled + bscaled * bscaled;
    }
    else if (fpeflags & FE_UNDERFLOW && sidea < 1.0 && sideb < 1.0)
    {
        /* a^2 + b^2 caused an underflow. Scale the triangle up. */
        feclearexcept(FE_UNDERFLOW);
        scale = scalbn( 1.0, (DBL_MAX_EXP / 2));

        invscale = 1.0 / scale;
        ascaled = scale * sidea;
        bscaled = scale * sideb;
        sum = ascaled * ascaled + bscaled * bscaled;
    }

    feupdateenv(&fpenv);     // restore the caller's environment, and
                             // raise any new exceptions

    /* c = (1/scale) * sqrt((a * scale)^2 + (b * scale)^2): */
    return invscale * sqrt(sum);
}

#include <stdio.h>

int main()
{
    double sidec = hypotenuse( 1E-10, 2E-200);
    printf("The hypotenuse of the right triangle is %%.10lG\n", sidec);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_deraiseexcept_ex">
			<text>
				<![CDATA[// feraiseexcept_ex.c : feraiseexcept() example
// -------------------------------------------------------------

#include <fenv.h>     // int feraiseexcept( int excepts );
//#include <math.h>
#include <stdlib.h>
#include <stdio.h>

// Although user programs rarely need to raise a floating-point exception by artificial
// means, the following example illustrates how to do so:

int main()
{
    int result, except_set, except_test;

    #pragma STDC FENV_ACCESS ON

    feclearexcept (FE_ALL_EXCEPT);

    except_set = FE_OVERFLOW;
    result = feraiseexcept( except_set );
    if ( result != 0 )
    {
        printf( "feraisexcept() failed (%%d)\n", result );
        exit( result );
    }

    except_test = fetestexcept( except_set );
    if ( except_test != except_set )
        printf( "Tried to raise flags %%X, but only raised flags %%X.\n",
                 except_set, except_test );
    else
       printf( "Raised the floating-point exception FE_ALL_EXCEPT = %%X\n",
                except_set );       
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fflush_ex">
			<text>
				<![CDATA[// fflush_ex.c : fflush() example
// -------------------------------------------------------------

#include <stdio.h>   // int fflush( FILE *fp );
#include <signal.h>

/* Tests the effect of flushing output file buffers. */

int main()
{
    FILE *fp;

#ifdef FLUSH
    char filename[ ] = "twice.txt";
#else
    char filename[ ] = "once.txt";
#endif  /* FLUSH */

    fp = fopen( filename, "w" );
    if ( fp == NULL)
       fprintf( stderr, "Failed to open file '%%s' to write.\n", filename );

    fputs( "Going once ...\n", fp );
    fflush( fp );                 // Flush the output unconditionally

    fputs( "Going twice ...\n", fp );

#ifdef FLUSH
    fflush( fp );                 // Now flush only if compiled with '-DFLUSH'
#endif

    raise( SIGKILL );             // End the program abruptly.

    fputs( "Gone.\n", fp );       // These three lines will never be executed.
    fclose( fp );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgets_ex">
			<text>
				<![CDATA[// fgets_ex.c : fgets() example
// -------------------------------------------------------------

#include <stdio.h>   // char *fgets( char * restrict buffer, int n,
                     //              FILE * restrict fp );
#include <string.h>

int main()
{
    FILE *titlefile;
    char title[256];
    int counter = 0;

    if ((titlefile = fopen("titles.txt", "r")) == NULL)
       perror( "Opening title file" );
    else
    {
       while ( fgets( title, 256, titlefile ) != NULL )
       {
          title[ strlen(title) -1 ] = '\0';   // Trim off newline character.
          printf( "%%3d: \"%%s\"\n", ++counter, title );
       }
       /* fgets() returned NULL: either EOF or an error occurred. */
       if ( feof(titlefile) )
         printf("Total: %%d titles.\n", counter);
    }
    fclose( titlefile );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgetwc_ex">
			<text>
				<![CDATA[// fgetwc_ex.c : fgetwc() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>   // wint_t fgetwc( FILE *fp );
#include <stdlib.h>
#include <locale.h>

int main()
{
    char file_in[ ]  = "local_in.txt",
         file_out[ ] = "local_out.txt";
    FILE *fp_in_wide, *fp_out_wide;
    wint_t wc;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
       fwprintf( stderr,
                 L"Sorry, couldn't change to the system's native locale.\n"),
       exit(1);

    if (( fp_in_wide = fopen( file_in, "r" )) == NULL )
       fprintf( stderr, "Error opening the file %%s\n", file_in), exit(2);

    if (( fp_out_wide = fopen( file_out, "w" )) == NULL )
       fprintf( stderr, "Error opening the file %%s\n", file_out), exit(3);

    fwide( fp_in_wide, 1);            // Not strictly necessary, since first
    fwide( fp_out_wide, 1);           // file access also sets wide or byte mode.

    while (( wc = fgetwc( fp_in_wide )) != WEOF )
    {
       // ... process each wide character read ...

       if ( fputwc( (wchar_t)wc, fp_out_wide) == WEOF)
         break;
    }
    if ( ferror( fp_in_wide))
       fprintf( stderr, "Error reading the file %%s\n", file_in);
    if ( ferror( fp_out_wide))
       fprintf( stderr, "Error writing to the file %%s\n", file_out);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fgetws_ex">
			<text>
				<![CDATA[// fgetws_ex.c : fgetws() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>   // wchar_t *fgetws( wchar_t * restrict buffer,
                     //                  int n, FILE * restrict fp );
//#include <stdlib.h>
#include <locale.h>

int main()
{
    FILE *fp_in_wide;
    wchar_t buffer[4096];
    wchar_t *line = buffer;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr, L"Sorry, couldn't change to the system's native locale.\n");
       return -1;
    }
    if (( fp_in_wide = fopen( "local_in.txt", "r" )) == NULL )
    {   perror( "Opening input file");  return -1;   }

    fwide( fp_in_wide, 1);

    line = fgetws( buffer, sizeof(buffer), fp_in_wide );
    if ( line == NULL )
       perror( "Reading from input file" );
    else
       if( fputws( line, stdout) < 0)
          perror( "Writing to stdout" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fma_ex">
			<text>
				<![CDATA[// fma_ex.c : fma() example
// -------------------------------------------------------------

#include <math.h>   // double fma( double x, double y, double z );
                    // float fmaf( float x, float y, float z );
                    // long double fmal( long double x, 
                    //             long double y, long double z );
#include <stdio.h>

int main()
{
    double x, y, z;

    x = nextafter( 3.0, 4.0 );     // Smallest possible double value
                                   // greater than 3
    y = 1.0/3.0;
    z = -1.0;

    printf( "x = %%.15G\n"
            "y = %%.15G\n"
            "z = %%.15G\n", x, y, z );

// #ifdef FP_FAST_FMA

    printf( "fma( x, y, z) = %%.15G\n", fma( x, y, z) );

// #else // i.e., not def FP_FAST_FMA

   double product = x * y;
   printf( "x times y = %%.15G\n", product );
   printf( "%%.15G + z = %%.15G\n", product, product + z );

// #endif // def FP_FAST_FMA
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fmax_ex">
			<text>
				<![CDATA[// fmax_ex.c : fmax() example
// -------------------------------------------------------------

#include <math.h>   // double fmax( double x, double y );
                    // float fmaxf( float x, float y );
                    // long double fmaxl( long double x , long double y );
#include <float.h>
#include <stdio.h>

int main()
{
    // Let big equal the second-greatest-possible double value ...
    const double big = nextafter( DBL_MAX, 0.0 );
    // ... and small the second-least possible-double value:
    const double small = nextafter( DBL_MIN, 0.0 );

    double a, b, c;
    /* ... */
    a = DBL_MIN;  b = 0.0;  c = 1.0;

    if ( fmin( fmin( a, b ), c ) <= small )
       printf( "At least one value is too small.\n" );
    if ( fmax( fmax( a, b ), c ) >= big )
       printf( "At least one value is too great.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fmod_ex">
			<text>
				<![CDATA[// fmod_ex.c : fmod() example
// -------------------------------------------------------------

#include <math.h>   // double fmod( double x, double y );
                    // float fmodf( float x, float y );
                    // long double fmodl( long double x, long double y );
#include <fenv.h>
#include <stdio.h>

int main()
{
    double people = -2.25, 
           apples = 3.3, 
           eachgets = 0.0, 
           someleft = 0.0;

    int saverounding = fegetround();       // Save previous setting
    fesetround(FE_TOWARDZERO);

    eachgets = rint( apples / people );
    someleft = fmod( apples, people );

    printf( "If there are %%+.2f of us and %%+.2f apples, \n"
            "each of us gets %%+.2f, with %%+.2f left over.\n",
            people, apples, eachgets, someleft );

    fesetround( saverounding );            // Restore previous setting

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fopen_ex">
			<text>
				<![CDATA[// fopen_ex.c : fopen() example
// -------------------------------------------------------------

#include <stdio.h>   // FILE *fopen( const char * restrict name,
                     //              const char * restrict mode );
#include <stdlib.h>
#include <string.h>

int main( int argc, char *argv[])
{
    FILE *in, *out;
    int c;

    if ( argc != 3 )
       fprintf( stderr, "Usage: program input-file output-file\n"), exit(1);

    // If "-" appears in place of input filename, use stdin:
    in = (strcmp(argv[1], "-") == 0) ? stdin : fopen(argv[1], "r");
    if ( in == NULL )
    {  perror( "Opening input file" ); return -1;  }

    // If "-" appears in place of output filename, use stdout:
    out = (strcmp(argv[2], "-") == 0) ? stdout : fopen(argv[2], "a+");
    if ( out == NULL )
    {   perror( "Opening output file" ); return -1; }

    while (( c = fgetc( in )) != EOF)
       if ( fputc(c, out) == EOF )
          break;

    if ( !feof( in ))
       perror( "Error while copying" );

    fclose(in), fclose(out);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fpclassify_ex">
			<text>
				<![CDATA[// fpclassify_ex.c : fpclassify() example
// -------------------------------------------------------------

#include <math.h>       // int fpclassify( x );
#include <stdio.h>

double minimum( double a, double b )
{
    register int aclass = fpclassify( a );
    register int bclass = fpclassify( b );

    if ( aclass == FP_NAN || bclass == FP_NAN )
       return NAN; 

    if ( aclass == FP_INFINITE )         // -Inf is less than anything;
       return ( signbit( a ) ? a : b );  // +inf is greater than anything.

    if ( bclass == FP_INFINITE )
       return ( signbit( b ) ? b : a );

    return ( a < b ? a : b );
}

int main()
{
    double x = 0.0;

    double min = minimum( x, -HUGE_VAL); 

    printf( "min = %%G\n", min);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fputws_ex">
			<text>
				<![CDATA[// fputws_ex.c : fputws() example
// -------------------------------------------------------------

#include <wchar.h>   // int fputws( const wchar_t * restrict ws,
                     //              FILE * restrict fp );
#include <stdio.h>
#include <locale.h>

int main()
{
    FILE *fpw;
    char fname_wide[] = "widetest.txt";
    int widemodeflag = 1;
    int result;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr, L"Sorry, couldn't change to the system's native locale.\n");
       return -1;
    }
    wchar_t widestring[] = L"How many umlauts are there in Fahrvergnügen?\n";

    if ((fpw = fopen(fname_wide, "a")) == NULL)
    {    perror( "Opening output file" ); return -1; }

    // Set file to wide-character orientation:
    widemodeflag = fwide(fpw, widemodeflag);
    if ( widemodeflag <= 0 )
    {
       fprintf(stderr, "Unable to set output file %%s to wide characters\n",
                       fname_wide);
       (void)fclose(fpw);
       return -1;
    }
    // Write wide-character string to the file:
    result = fputws( widestring, fpw );
    if ( result < 0 )
    {
       fprintf(stderr, "Error on writing file %%s.\n", fname_wide);
       return -1;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_freopen_s_ex">
			<text>
				<![CDATA[// freopen_s_ex.c : freopen_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdio.h>   // errno_t freopen_s( FILE * restrict * restrict fpPtr,
                     //                    const char * restrict name,
                     // const char * restrict mode,
                     // FILE * restrict fp );
#include <stdlib.h>
#include <errno.h>

int main()      // Redirect standard output to the file redirect.txt:
{
    char filename[] = "redirect.txt";
    FILE *fp;

    errno_t err = freopen_s( &fp, filename, "w", stdout);
    if( err != 0)
    { 
       fprintf( stderr, "Unable to redirect stdout to %%s\n", filename);
       exit(err);
    }

    printf("This text is being written to the file %%s.\n", filename);

    fclose(stdout);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_frexp_ex">
			<text>
				<![CDATA[// frexp_ex.c : frexp() example
// -------------------------------------------------------------

#include <math.h>    // double frexp( double x, int *exp );
                     // float frexpf( float x, int *exp );
                     // long double frexpl( long double x, int *exp );
#include <stdio.h>
#include <stdlib.h>

double fourthrt( double x )
{
    int exponent, exp_mod_4;
    double mantissa = frexp( x, &exponent );

    exp_mod_4 = exponent %% 4;
    exponent -= ( exp_mod_4 );    // Get an exponent that's
                                  // divisible by four ...
    for ( int i = abs( exp_mod_4 ); i > 0; i-- )
    {
        if ( exp_mod_4 > 0 )      // ... and compensate in the mantissa.
           mantissa *= 2.0;
       else
           mantissa /= 2.0;
    }
    return ldexp( sqrt( sqrt( mantissa )), exponent / 4 );
}

int main()
{
    double x = 64.0;      // 16 * 4

    printf( "The fourth root of %%f is %%G.\n", x, fourthrt(x) );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fscnf_ex">
			<text>
				<![CDATA[// fscanf_ex.c : fscanf() example
//
// The example code reads information about a user from a file, which we will
// suppose contains a line of colon-separated strings like this:
//    tony:x:1002:31:Tony Crawford,,:/home/tony:/bin/bash// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for fscanf_s()
#include <stdio.h> 
// int fscanf( FILE * restrict fp, const char * restrict format, ... );
// int fscanf_s( FILE * restrict fp, const char * restrict format, ... ); 

#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct pwrecord {             // Structure for contents of passwd fields.
    unsigned int uid;
    unsigned int gid;
    char user[32];
    char pw [32];
    char realname[128];
    char home [128];
    char shell [128];
};

int main()
{
    FILE *fp;
    char pwfile[] = "pwfile.txt";
    int results = 0;
    struct pwrecord record, *recptr = &record;;
    char gecos[256] = "";

    /* ... Open the password file to read ... */

    fp = fopen( pwfile, "r");
    if ( fp == NULL )
    {  perror( "Opening input file" ); return -1;  }

    /* 1. Read login name, password, UID and GID. */

    record = (struct pwrecord) { UINT_MAX, UINT_MAX, "", "", "", "", "" };
    results = fscanf( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                      recptr->user, recptr->pw, &recptr->uid, &recptr->gid );

    // If the implementation supports the secure functions, the function fscanf_s()
    // can be used as an alternative to fscanf():
    /*
    results = fscanf_s( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                        recptr->user, sizeof(recptr->user),
                        recptr->pw, sizeof(recptr->pw),
                        &recptr->uid, &recptr->gid );
    */
    if ( results < 4 )
    {
       fprintf( stderr, "Unable to parse line.\n" );
       fscanf( fp, "%%*[^\n]\n" ); // Read and discard rest of line.
    }

    /* 2. Read the "gecos" field, which may contain nothing, or just the
     * real name, or comma-separated sub-fields.
    */
    results = fscanf( fp, "%%255[^:]:", gecos );
    if ( results < 1 )
       strcpy( recptr->realname, "[No real name available]" );
    else
       sscanf( gecos, "%%127[^,]", recptr->realname );    // Truncate at
                                                         // first comma.

    /* 3. Read two more fields before the end of the line. */

    results = fscanf( fp, "%%127[^:]:%%127[^:\n]\n", recptr->home, recptr->shell );
    if ( results < 2 )
    {
        fprintf( stderr, "Unable to parse line.\n" );
        fscanf( fp, "%%*[^\n]\n" );            // Read and discard rest of line.
    }
    printf( "The user account %%s with UID %%u belongs to %%s.\n",
             recptr->user, recptr->uid, recptr->realname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fscanf_ex">
			<text>
				<![CDATA[// fscanf_ex.c : fscanf() example
//
// The example code reads information about a user from a file, which we will
// suppose contains a line of colon-separated strings like this:
//    tony:x:1002:31:Tony Crawford,,:/home/tony:/bin/bash// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for fscanf_s()
#include <stdio.h> 
// int fscanf( FILE * restrict fp, const char * restrict format, ... );
// int fscanf_s( FILE * restrict fp, const char * restrict format, ... ); 

#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct pwrecord {             // Structure for contents of passwd fields.
    unsigned int uid;
    unsigned int gid;
    char user[32];
    char pw [32];
    char realname[128];
    char home [128];
    char shell [128];
};

int main()
{
    FILE *fp;
    char pwfile[] = "pwfile.txt";
    int results = 0;
    struct pwrecord record, *recptr = &record;;
    char gecos[256] = "";

    /* ... Open the password file to read ... */

    fp = fopen( pwfile, "r");
    if ( fp == NULL )
    {  perror( "Opening input file" ); return -1;  }

    /* 1. Read login name, password, UID and GID. */

    record = (struct pwrecord) { UINT_MAX, UINT_MAX, "", "", "", "", "" };
    results = fscanf( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                      recptr->user, recptr->pw, &recptr->uid, &recptr->gid );

    // If the implementation supports the secure functions, the function fscanf_s()
    // can be used as an alternative to fscanf():
    /*
    results = fscanf_s( fp, "%%31[^:]:%%31[^:]:%%u:%%u:",
                        recptr->user, sizeof(recptr->user),
                        recptr->pw, sizeof(recptr->pw),
                        &recptr->uid, &recptr->gid );
    */
    if ( results < 4 )
    {
       fprintf( stderr, "Unable to parse line.\n" );
       fscanf( fp, "%%*[^\n]\n" ); // Read and discard rest of line.
    }

    /* 2. Read the "gecos" field, which may contain nothing, or just the
     * real name, or comma-separated sub-fields.
    */
    results = fscanf( fp, "%%255[^:]:", gecos );
    if ( results < 1 )
       strcpy( recptr->realname, "[No real name available]" );
    else
       sscanf( gecos, "%%127[^,]", recptr->realname );    // Truncate at
                                                         // first comma.

    /* 3. Read two more fields before the end of the line. */

    results = fscanf( fp, "%%127[^:]:%%127[^:\n]\n", recptr->home, recptr->shell );
    if ( results < 2 )
    {
        fprintf( stderr, "Unable to parse line.\n" );
        fscanf( fp, "%%*[^\n]\n" );            // Read and discard rest of line.
    }
    printf( "The user account %%s with UID %%u belongs to %%s.\n",
             recptr->user, recptr->uid, recptr->realname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fseek_ex">
			<text>
				<![CDATA[// fseek_ex.c : fseek() example
// -------------------------------------------------------------

#include <stdio.h>   // int fseek( FILE *fp, long offset, int origin );

typedef struct { long id;
                 double value;
               } record;

// void writeRecords();

int main()
{
    FILE *fp;
    record cur_rec = (record) { 0, 0.0 };
    int reclength_file = sizeof(record);
    long seek_id = 123L;

    if ( (fp = fopen("records", "rb")) == NULL)
        perror( "Unable to open records file" );
    else do
    {
        if ( 1 > fread( &cur_rec.id, sizeof (long), 1, fp ))
        {
           fprintf( stderr, "Record with ID %%ld not found.\n", seek_id );
           break;
        }
        else                                      // Skip rest of record
           if ( fseek( fp, reclength_file - sizeof(long), 1 ) )
           {
              perror( "fseek failed" );
              break;
           }
    } while ( cur_rec.id != seek_id );

    if( cur_rec.id == seek_id )
        printf( "Record with ID %%ld found.\n", seek_id );
   
    return 0;
}
/*
void writeRecords()
{
    FILE *fp;
    record someRecords[] = {  { 101L, 10.0 }, { 123L, 20.0 },{ 146L, 30.0 } };
    size_t n = sizeof( someRecords) / sizeof( *someRecords);

    if ((fp = fopen("records", "wb")) == NULL)
       perror( "Unable to open records file" );
    else 
    {
       if( fwrite( someRecords, sizeof(record), n, fp) < n) 
          perror( "Unable to write records" );
       fclose(fp);
    }
}
*/
]]>
			</text>
		</p>
		<p n="xc_ftell_ex">
			<text>
				<![CDATA[// ftell_ex.c : ftell() example
// -------------------------------------------------------------

// This example searches in a file, whose name is the second command-line
// argument, for a string, which the user can specify in the first
// command-line argument.

#include <stdio.h>       // long ftell( FILE *fp );
#include <stdlib.h>
#include <string.h>

#define MAX_LINE 256

int main( int argc, char *argv[])
{
    FILE *fp;
    long lOffset = 0L;
    char sLine[MAX_LINE] = "";
    int  lineno = 0;

    if ( argc != 3 )
       fprintf( stderr, "Usage: program search_string file_name\n"), exit(1);

    if ((fp = fopen(argv[2], "r")) == NULL)
    {
        fprintf(stderr, "Unable to open file %%s\n", argv[2]);
        exit(-1);
    }
    do
    {
        lOffset = ftell(fp);      // Bookmark the beginning of
                                  // the line we're about to read.
        if ( -1L == lOffset )
            fprintf(stderr, "Unable to obtain offset in %%s\n", argv[2]);
        else
            lineno++;

        if ( !fgets(sLine, MAX_LINE, fp))     // Read next line from file.
            break;
    } while ( strstr( sLine, argv[1]) == NULL);    // Test for argument
                                                   // in sLine.

    /* Dropped out of loop: Found search keyword or EOF */
    if ( feof(fp) || ferror(fp) )
    {
        fprintf(stderr, "Unable to find \"%%s\" in %%s\n", argv[1], argv[2]);
        rewind(fp);
    }
    else
    {
        printf( "%%s (%%d): %%s\n", argv[2], lineno, sLine);
        fseek( fp, lOffset, 0);           // Set file pointer at beginning of
                                          // the line containing the keyword
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_fwprintf_ex">
			<text>
				<![CDATA[// fwprintf_ex.c : fwprintf() example
// -------------------------------------------------------------

#include <stdio.h>     // int fwprintf( FILE * restrict fp,
#include <wchar.h>     //               const wchar_t * restrict format, ... );
                       // int fwprintf_s( FILE * restrict fp,
                       //                 const wchar_t * restrict format, ...);
#include <wchar.h>
#include <locale.h>

int main()
{
    wchar_t name_local[ ] = L"Ka\u0142u\u017Cny";
    char name_portable[ ]= "Kaluzny";
    char locale[ ] = "pl_PL.UTF-8";
    char * newlocale;

    newlocale = setlocale( LC_ALL, locale );
    if ( newlocale == NULL )
       fprintf( stderr, "Sorry, couldn't change the locale to %%s.\n"
                "The current locale is %%s.\n",
                locale, setlocale( LC_ALL, NULL ));

    fwprintf( stdout,
              L"Customer's name: %%ls (Single-byte transliteration: %%s)\n",
              name_local, name_portable );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_getenv_s_ex">
			<text>
				<![CDATA[// getenv_s_ex.c : getenv_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // errno_t getenv_s( size_t * restrict len,
                     //                   char * restrict value,
                     //                   rsize_t maxsize,
                     //                   const char * restrict name);
#include <stdio.h>
#include <errno.h>

int main()
{
    char envStr[512];
    size_t len;

    if( getenv_s( &len, envStr, sizeof(envStr),"PATH") == 0)
        printf("PATH variable (%%zu characters): \n%%s\n", len, envStr);
    else if( len > 0)
        printf("The PATH variable (%%zu characters) is more than "
               "%%zu bytes long.\n", len, sizeof(envStr));
    else
        printf("PATH variable not found.\n");

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_gmtime_ex">
			<text>
				<![CDATA[// gmtime_ex.c : gmtime() example
// -------------------------------------------------------------

#include <time.h>   // struct tm *gmtime( const time_t *timer );
#include <stdio.h>
#include <string.h>

int main()
{
    time_t rawtime;
    struct tm utc_tm, local_tm, *ptr_tm;
    char buffer[1024] = "";

    time( &rawtime );                 // Get current time as an integer.

    ptr_tm = gmtime( &rawtime );      // Convert to UTC in a struct tm.
    memcpy( &utc_tm, ptr_tm, sizeof(struct tm) ); // Save a local copy.

    ptr_tm = localtime( &rawtime );   // Do the same for local time zone.
    memcpy( &local_tm, ptr_tm, sizeof(struct tm) );

    if ( strftime( buffer, sizeof(buffer),
                   "It's %%A, %%B %%d, %%Y, %%R o'clock, UTC.", &utc_tm ) )
       puts( buffer );

    if ( strftime( buffer, sizeof(buffer),
                   "Here it's %%A, %%B %%d, %%Y, %%R o'clock, UTC %%z.", &local_tm ) )
       puts( buffer );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_hypot_ex">
			<text>
				<![CDATA[// hypot_ex.c : hypot() example
// -------------------------------------------------------------

#include <math.h>   // double hypot( double x, double y );
                    // float hypotf( float x, float y );
                    // long double hypotl( long double x, long double y );
#include <stdio.h>
#include <errno.h>

int main()
{
    double x, y, h;        // Three sides of a triangle

    printf( "How many kilometers do you want to go westward? " );
    scanf( "%%lf", &x );

    printf( "And how many southward? " );
    scanf( "%%lf", &y );

    errno = 0;
    h = hypot( x, y );
    if ( errno )
       perror( __FILE__ );
    else
       printf( "Then you'll be %%4.2lf km from where you started.\n", h );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ignore_handler_s_ex">
			<text>
				<![CDATA[// ignore_handler_s_ex.c : ignore_handler_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // void ignore_handler_s( const char * restrict msg,
                     //                        void * restrict ptr, 
                     //                        errno_t error);
#include <string.h>
#include <stdio.h>
#include <errno.h>

// Handle runtime constraint violations using only
// the return value of secure functions.

int main()
{
    char message[20] = "Hello, ",
         name[20];
    set_constraint_handler_s(ignore_handler_s);

    printf("Please enter your name: ");
    if( gets_s( name, sizeof(name)) == NULL)
    { 
       puts("Error: You entered more than 19 characters."); 
       // ...
    }
    else if( strcat_s( message, sizeof(message), name) != 0)
    {
       puts("Error: message array is too small.");
       // ...
    }
    else
       puts( message);

    // ...

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ilogb_ex">
			<text>
				<![CDATA[// ilogb_ex.c : ilogb() example
// -------------------------------------------------------------

#include <math.h>    // int ilogb( double x )
                     // int ilogbf( float x )
                     // int ilogbl( long double x )
#include <stdio.h>
#include <limits.h>

int main()
{
    int exponent = 0;
    double x = -1.509812734e200;

    while ( exponent < INT_MAX )
    {
       exponent = ilogb( x );
       printf( "The exponent of %%g is %%d.\n", x, exponent );

       if ( x < 0.0 && x * x > 1.0 )
          x /= 1e34;
       else
          x += 1.1, x *= 2.2e34 ;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_imaxdiv_ex">
			<text>
				<![CDATA[// imaxdiv_ex.c : imaxdiv() example
// -------------------------------------------------------------

#include <inttypes.h>  // imaxdiv_t imaxdiv( intmax_t dividend, 
                       //                    intmax_t divisor );
#include <stdio.h>

int main()
{
    intmax_t people = 110284, apples = 9043291;
    imaxdiv_t share;

    if ( people == 0 )       // Avoid dividing by zero.
    {
       printf( "There's no one here to take the apples.\n" ); 
       return -1;
    }
    else
       share = imaxdiv( apples, people );

    printf( "If there are %%ji of us and %%ji apples,\n"
            "each of us gets %%ji, with %%ji left over.\n",
            people, apples, share.quot, share.rem );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_isfinite_ex">
			<text>
				<![CDATA[// isfinite_ex.c : isfinite() example
// -------------------------------------------------------------

#include <math.h>     // int isfinite( float x );
                      // int isfinite( double x );
                      // int isfinite( long double x );

#include <stdarg.h>

double vsum( int n, ... )
// n is the number of arguments in the list
{
    va_list argptr;
    double sum = 0.0, next = 0.0;

    va_start( argptr, n );
    while ( n-- )
    {
        next = va_arg( argptr, double );
        sum += next;
        if ( isfinite( sum ) == 0 )
           break;         // If sum reaches infinity, stop adding.
    }
    va_end( argptr );
    return sum;
}

#include <stdio.h>
#include <float.h>

int main()
{
    printf( "1. Sum: %%lf\n", vsum( 3, 1.0, 2.0, 3.0) );

    double x = DBL_MAX;
    printf( "2. Sum: %%lf\n", vsum( 2, x, x) );
   
    return 0;
}

]]>
			</text>
		</p>
		<p n="xc_isprintf_ex">
			<text>
				<![CDATA[// isprint_ex.c : isprint() example
// And also an example for
// isalnum(), isalpha(), isblank(), iscntrl(), isdigit(),
// isgraph(), islower(), ispunct(), isspace().
// -------------------------------------------------------------

#include <ctype.h>    // int isprint( int c); int isalnum( int c); ...
#include <stdio.h>
#include <locale.h>

int main()
{
    unsigned int c;

//    setlocale(LC_CTYPE, "");
    printf("\nThe current locale for the 'is ...' functions is '%%s'.\n",
           setlocale(LC_CTYPE, NULL));

    printf("Here is a table of the 'is ...' values for the characters"
           " from 0 to 127 in this locale:\n\n");

    for ( c = 0; c < 128; c++ )   // Loop iteration for each table row.
    {
        if ( c %% 24 == 0 )        // Repeat table header every 24 rows.
        {
            printf("Code char alnum alpha blank cntrl digit graph lower"
                   " print punct space\n");
            printf("---------------------------------------------------"
                   "------------------\n");
        }
        printf( "%%4u %%4c %%3c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c\n",
                 c,                             // Print numeric character code.
                 ( isprint( c ) ?  c  : ' ' ),  // Print the glyph, or a space
                                                // if it's not printable.
                 ( isalnum( c ) ? 'X' : '-' ),  // In a column for each category,
                 ( isalpha( c ) ? 'X' : '-' ),  // print X for yes or - for no.
                 ( isblank( c ) ? 'X' : '-' ),
                 ( iscntrl( c ) ? 'X' : '-' ),
                 ( isdigit( c ) ? 'X' : '-' ),
                 ( isgraph( c ) ? 'X' : '-' ),
                 ( islower( c ) ? 'X' : '-' ),
                 ( isprint( c ) ? 'X' : '-' ),
                 ( ispunct( c ) ? 'X' : '-' ),
                 ( isspace( c ) ? 'X' : '-' ) );
    }  // end of loop for each character value

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswalnum_ex">
			<text>
				<![CDATA[// iswalnum_ex.c : iswalnum() example
// -------------------------------------------------------------

#include <wctype.h>     // int iswalnum( wint_t wc );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wint_t wc;
    int i, dummy;

    setlocale( LC_CTYPE, "" );
    wprintf( L"\nThe current locale for the 'is ...' functions is '%%s'.\n",
             setlocale( LC_CTYPE, NULL ) );

    wprintf( L"These are the alphanumeric wide characters"
             " in this locale:\n\n" );
    for ( wc = 0, i = 0; wc < 1024; wc++ )
    if ( iswalnum( wc ) )
    {
       if ( i %% 25 == 0 )
       {
           wprintf( L"... more ...\n" );
           dummy = getchar();              // Wait before printing more
           wprintf( L"Wide character Code\n" );
           wprintf( L"-----------------------\n" );
       }
       wprintf( L"%%5lc %%4lu\n", wc, wc );
       i++;
    }
    wprintf( L"-----------------------\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswalpha_Ex">
			<text>
				<![CDATA[// iswalpha_ex.c : iswalpha() example
// And also an example for
// iswalnum(), iswblank(), iswcntrl(), iswdigit(), iswgraph(),
// iswlower(), iswprint(), iswpunct(), iswspace().
// -------------------------------------------------------------

#include <wctype.h>    // int iswalpha( wint_t wc);  ...
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wint_t wc;

    if ( setlocale( LC_CTYPE, "" ) == NULL)
    {
       fwprintf( stderr,
                 L"Sorry, couldn't change to the system's native locale.\n");
       return 1;
    }
    wprintf( L"The current locale for the 'isw ...' functions is '%%s'.\n",
             setlocale(LC_CTYPE, NULL));

    wprintf( L"Here is a table of the 'isw ...' values for the characters "
             L"from 128 to 255 in this locale:\n\n");

    for ( wc = 128; wc < 255; ++wc ) // Loop iteration for each table row.
    {
       if ( (wc-128) %% 24 == 0 ) // Repeat table header every 24 rows.
       {
         wprintf(L"Code char alnum alpha blank cntrl digit graph lower"
                 L" print punct space\n");
         wprintf(L"---------------------------------------------------"
                 L"------------------\n");
       }
       wprintf(L"%%4u %%4lc %%3c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c %%5c\n",
               wc,                              // Print numeric character code.
               ( iswprint( wc ) ? wc  : ' ' ),  // Print the glyph, or a space
                                                // if it's not printable.
               ( iswalnum( wc ) ? 'X' : '-' ),  // In a column for each
               ( iswalpha( wc ) ? 'X' : '-' ),  // category, print X for
               ( iswblank( wc ) ? 'X' : '-' ),  // yes or - for no.
               ( iswcntrl( wc ) ? 'X' : '-' ),
               ( iswdigit( wc ) ? 'X' : '-' ),
               ( iswgraph( wc ) ? 'X' : '-' ),
               ( iswlower( wc ) ? 'X' : '-' ),
               ( iswprint( wc ) ? 'X' : '-' ),
               ( iswpunct( wc ) ? 'X' : '-' ),
               ( iswspace( wc ) ? 'X' : '-' ) );
    } // end of loop for each character value

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_iswctype_ex">
			<text>
				<![CDATA[// iswctype_ex.c : iswctype() example
// -------------------------------------------------------------

#include <wctype.h>    // int iswctype( wint_t wc, wctype_t description );
#include <wchar.h>
#include <locale.h>

int main()
{
    wint_t wc = L'ß';

    setlocale( LC_CTYPE, "de_DE.UTF-8" );
    if ( iswctype( wc, wctype( "alpha" )) )
    {
        if ( iswctype( wc, wctype( "lower" ) ))
           wprintf( L"The character %%lc is lowercase.\n", wc );
        if ( iswctype( wc, wctype( "upper" ) ))
           wprintf( L"The character %%lc is uppercase.\n", wc );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_localtime_s_ex">
			<text>
				<![CDATA[// gmtime_ex.c : gmtime() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <time.h>    // struct tm *localtime_s( const time_t * restrict timer,
                     //                         struct tm * restrict result);
#include <stdio.h>

int main()
{
    time_t now;    struct tm timeStruct;    char timeStr[26];

    time(&now);                           // Current time as an integer.

    // Convert to local time as a struct tm:
    if( localtime_s(&now, &timeStruct) != NULL)
    {
        timeStruct.tm_year += 1;          // One year later.
        if( asctime_s( timeStr, sizeof(timeStr), &timeStruct) == 0)
            printf("A year from today: %%s", timeStr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log1p_ex">
			<text>
				<![CDATA[// log1p_ex.c : log1p() example
// -------------------------------------------------------------

#include <math.h>    // double log1p( double x )
                     // float log1pf( float x )
                     // long double log1pl( long double x )
#include <stdio.h>

// atanh(x) is defined as 0.5 * ( log(x+1) - log(-x+1).
// Rounding errors can result in different results
// for different methods.

int main()
{
    puts("   x         atanh(x)    atanh(x) - 0.5*(log1p(x) - log1p(-x))\n"
         "--------------------------------------------------------------");
    for ( double x = -0.8; x < 1.0; x += 0.4)
    {
       double y = atanh(x);
       printf("%%6.2f %%14f %%20E\n", x, y, y - 0.5*(log1p(x) - log1p(-x)) );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log2_ex">
			<text>
				<![CDATA[// log2_ex.c : log2() example
// -------------------------------------------------------------

#include <math.h>    // double log2( double x )
                     // float log2f( float x )
                     // long double log2l( long double x )
#include <errno.h>
#include <stdio.h>

int main()
{
    double x[] = { 0, 0.7, 1.8, 1234, INFINITY };

    for ( int i = 0; i < sizeof( x ) / sizeof( double ); i++ )
    {
        errno = 0;
        printf( "The base 2 log of  %%.1f is %%.3f.\n", x[i], log2( x[i] ) );
        if ( errno == EDOM || errno == ERANGE )
           perror( __FILE__ );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_log_ex">
			<text>
				<![CDATA[// log_ex.c : log() example
// The following code prints some sample values for base 2, 
// base e, and base 10 logarithms.
// -------------------------------------------------------------

#include <math.h>    // double log( double x )
                     // float logf( float x )
                     // long double logl( long double x )
#include <stdio.h>

int main()
{
    double x[] = { 1E-100, 0.5, 2, exp(1), 10, 1E+100 };

    puts("       x           log2(x)            log(x)          log10(x)\n"
         " ---------------------------------------------------------------");
    for ( int i = 0; i < sizeof(x) / sizeof(x[0]); ++i )
    {
        printf("%%#10.3G %%+17.10G %%+17.10G %%+17.10G\n",
                x[i], log2(x[i]), log(x[i]), log10(x[i]) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_logb_ex">
			<text>
				<![CDATA[// logb_ex.c : logb() example
// -------------------------------------------------------------

#include <math.h>    // double logb( double x )
                     // float logbf( float x )
                     // long double logbl( long double x )
#include <errno.h>
#include <stdio.h>

int main()
{
    double x[] = { 0, 0, 0.7, 1.8, 1234, INFINITY };

    x[1] = nextafter( 0.0, 1.0 );

    for ( int i = 0; i < sizeof( x ) / sizeof( double ); i++ )
    {
        errno = 0;
        printf( "The exponent in the binary representation of %%g is %%g.\n",
                x[i], logb( x[i] ) );
        if ( errno == EDOM || errno == ERANGE )
           perror( __FILE__ );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_malloc_ex">
			<text>
				<![CDATA[// malloc_ex.c : malloc() example
// -------------------------------------------------------------

#include <stdlib.h>    // void *malloc( size_t size );
#include <stdio.h>
#include <string.h>
//#include <errno.h>

int main()
{
    struct linelink { char *line;
                      struct linelink *next;
    };
    struct linelink *head = NULL, *tail = NULL;

    char buffer[2048];
    FILE *fp_in;

    /* ... 0pen input file ... */
    char filename[] = "malloc.txt";
    if ((fp_in = fopen( filename, "r")) == NULL)
       perror( "Opening input file" );

    while ( NULL != fgets(buffer, sizeof(buffer), fp_in ))
    {
        if ( head == NULL )    /* Chain not yet started; add first link */
        {
            head = tail = malloc( sizeof(struct linelink));
            if ( head != NULL )
            {
               head->line = malloc( strlen( buffer ) + 1 );
               if ( head->line != NULL )
               {  strcpy( head->line, buffer);  head->next = NULL; }
               else
               {  fprintf( stderr, "Out of memory\n" ); return -1; }
            }
            else
            {  fprintf( stderr, "Out of memory\n" ); return -1; }
         }
         else          /* Chain already started; add another link ... */
         {
             puts( "Adding another link ...");
             /* ... */ 
             break;
         }
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mblen_ex">
			<text>
				<![CDATA[// mblen_ex.c : mblen() example
// -------------------------------------------------------------

#include <stdlib.h>   // int mblen( const char *s, size_t maxsize );
#include <wchar.h>
#include <string.h>

size_t mbsrcat( char * restrict s1, char * restrict s2,
                mbstate_t * restrict p_s1state, size_t n )
/* mbsrcat: multibyte string restartable concatenation.
 * Appends s2 to s1, respecting final shift state of destination string,
 * indicated by *p_s1state. String s2 must start in the initial shift
 * state.
 * Returns: number of bytes written, or (size_t)-1 on encoding error.
 * Max. total length (incl. terminating null byte) is <= n;
 * stores ending state of concatenated string in *s1state.
 */
{
   int result;
   size_t i = strlen( s1 );
   size_t j = 0;

   if ( i >= n - (MB_CUR_MAX+1))   // Sanity check: room for 1 multibyte
                                   // char + string terminator.
      return 0;                    // Report 0 bytes written.

   // Shift s1 down to initial state:

   if ( !mbsinit( p_s1state ))     // If not initial state, then append
   {                               // shift sequence to get initial state.
      if ( ( result = wcrtomb( s1+i, L'\0', p_s1state )) == -1 )
      {                            // Encoding error:
         s1[i] = '\0';             // Try restoring termination.
         return (size_t)-1;        // Report error to caller.
      }
      else
        i += result;
   }

   // Copy only whole multibyte characters at a time.
   // Get length of next char w/o changing state:
   while (( result = mblen( s2+j, MB_CUR_MAX )) <= (n - ( 1 + i )) )
   {
      if ( result == 0 ) break;
      if ( result == -1 )
      {                        // Encoding error:
         s1[i] = '\0';         // Terminate now.
         return (size_t)-1;    // Report error to caller.
      }
      // Next character fits; copy it and update state:
      strncpy( s1+i, s2+j, mbrlen( s2+j, MB_CUR_MAX, p_s1state ));
      i += result;
      j += result;
   }
   s1[i] = '\0';
   return j;
}

#include <locale.h>
#include <stdio.h>

int main()
{
   if( setlocale(LC_ALL, "") == NULL)
      fputs("Unable to set the locale.\n", stderr);
   printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

   char str1[100] = "";
   mbstate_t mbstate = {0};
   size_t nChars = 0;

   nChars = mbsrcat( str1, "große ", &mbstate, sizeof(str1) );
   if( (int)nChars < 0)
   {   fputs("Error ...", stderr);  return -1;  }
   printf("%%zu characters.\n", nChars);

   nChars = mbsrcat( str1, "Füße", &mbstate, sizeof(str1) );
   if( (int)nChars < 0)
   {   fputs("Error ...", stderr);  return -1;  }
   printf("%%zu characters.\n", nChars);

   puts( str1);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbrtoc16_ex">
			<text>
				<![CDATA[// mbrtoc16_ex.c : mbrtoc16() example
// -------------------------------------------------------------

#include <uchar.h>     // size_t mbrtoc16( char16_t * restrict pc16,
                       //                  const char * restrict s,
                       //                  size_t n, 
                       //                  mbstate_t * restrict state );
//#include <stdlib.h>
#include <string.h>

// The function mbsToC16s() uses mbrtoc16() to convert a string of
// multibyte characters into a string of 16-bit characters
// (typically in UTF-16 encoding).
// Return value: the number of char16_t characters produced, or
//               -1 if an error occurred.

int mbsToC16s( const char *mbStr, char16_t *c16Str, size_t len)
{
   if( mbStr == NULL || c16Str == NULL || len == 0)   // Sanity checks.
      return -1;

   mbstate_t mbstate = {0};
   char16_t c16;
   int count = 0, i = 0, rv = 0,
       nBytes = (int)strlen(mbStr)+1;

   do {
      rv = (int)mbrtoc16( &c16, mbStr+i, nBytes-i, &mbstate);
      switch( rv)
      {
        case 0:  c16Str[count] = 0; i = nBytes;   // End of string.
                 break;
        case -1:                                  // Encoding error.
        case -2: count = -1;
                 break;
        default:
           if( count < (int)len-1 )
           {
              c16Str[count++] = c16;
              if( rv > 0) i += rv;                // rv != -3
           }
           else count = -1;
      }
   } while( count > 0 && i < nBytes);

   return count;
}

#include <locale.h>
#include <stdio.h>

int main(void)
{
   if( setlocale(LC_ALL, "en_US.utf8") == NULL)
      fputs("Unable to set the locale.\n", stderr);

   char *u8Str = u8"Grüße";
   char16_t c16Str[100];
   int nChars = 0;

   nChars = mbsToC16s( u8Str, c16Str, 100);
   if( nChars < 0)
      fputs("Error ...", stderr);
   else
   {
      printf("%%d UTF-16 characters.\n", nChars);
      // ...
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbrtowc_ex">
			<text>
				<![CDATA[// mbrtowc_ex.c : mbrtowc() example
// -------------------------------------------------------------

#include <wchar.h>    // size_t mbrtowc( wchar_t * restrict widebuffer,
                      //                 const char * restrict string,
                      //                 size_t maxsize, 
                      //                 mbstate_t * restrict state );
#include <wctype.h>
#include <stdlib.h>
#include <string.h>

size_t mbstoupper( char *s1, char *s2, size_t n )
/* Copies the multibyte string from s2 to s1, converting all the
   characters to uppercase on the way.
   Because there are no standard functions for case-mapping in multibyte
   encodings, converts to and from the wide-character encoding (using the
   current locale setting for the LC_CTYPE category). The source string
   must begin in the initial shift state.
   Returns: the number of bytes written;
            or (size_t)-1 on an encoding error.
*/
{
   char *inptr = s2, *outptr = s1;
   wchar_t thiswc[1];
   size_t inresult, outresult;

   mbstate_t states[2], *instate = &states[0], *outstate = &states[1];

   memset( states, '\0', sizeof states );

   do
   {
      inresult = mbrtowc( thiswc, inptr, MB_CUR_MAX, instate );
      switch ( inresult )
      {
      case (size_t)-2:     // The (MB_CUR_MAX) bytes at inptr do not make
                           // a complete mb character. Maybe there is a
                           // redundant sequence of shift codes. Treat the
                           // same as an encoding error.
         *outptr = '\0';
         return (size_t)-1;

      case (size_t)-1:     // Found an invalid mb sequence at inptr:
         return inresult;  // pass the error to the caller.

      case 0:              // Got a null character. Make a last null wc.
                           // The default action, with wcrtomb, does this
                           // nicely, so *no break statement* necessary here.

      default:             // Read <result> mb characters to get one wide
                           // character.
      /* Check for length limit before writing anything but a null.
         Note: Using inresult as an approximation for the output
         length.
         The actual output length could conceivably be different
         due to a different succession of state-shift sequences.
      */
      if (( outptr - s1 ) + inresult + MB_CUR_MAX > n )
      {   // i.e., if bytes written + bytes to write + termination > n,
          // then terminate now by simulating a null-character input.
         thiswc[0] = L'\0';
         inresult = 0;
      }
      inptr += inresult;
      if (( outresult = wcrtomb( outptr,
                                (wchar_t)towupper(thiswc[0]),
                                 outstate )) == -1 )
      {                               // Encoding error on output:
         *outptr = '\0';              // Terminate and return error.
         return outresult;
      }
      else
         outptr += outresult;
      }
   } while ( inresult );              // Drop out after handling '\0'.
   return outptr - s1;
}

#include <locale.h>
#include <stdio.h>

int main()
{
   if( setlocale(LC_ALL, "en_US.utf-8") == NULL)
      fputs("Unable to set the locale.\n", stderr);
   printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

   char strin[] = "Grüße", strout[64];
   size_t nByte = 0;

   nByte = mbstoupper( strout, strin, 64 );

   if( (int)nByte < 0)
   {   fputs("Error ...", stderr);  return -1;  }

   puts( strout);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbsrtowcs_ex">
			<text>
				<![CDATA[// mbsrtowcs_ex.c : mbsrtowcs() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t mbsrtowcs( wchar_t * restrict dest, 
                     //                   const char ** restrict src,
                     //                   size_t n,
                     //                   mbstate_t * restrict state );
#include <string.h>
#include <locale.h>
#include <stdio.h>

int main()
{
   size_t result;

   char mbstring[ ] = "This is originally a multibyte string.\n";
   const char *mbsptr = mbstring;

   wchar_t widestring[256] = { L'\0' };

   mbstate_t state;
   memset( &state, '\0', sizeof state );

   printf( "The current locale is %%s.\n", setlocale( LC_CTYPE, "" ));

   result = mbsrtowcs( widestring, &mbsptr, 256, &state );
   if ( result == (size_t)-1 )
   {
      fputs( "Encoding error in multibyte string", stderr );
      return -1;
   }
   else
   {
      printf( "Converted %%u multibyte characters. The result:\n", result );
      printf( "%%ls", widestring );
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbsrtowcs_s_ex">
			<text>
				<![CDATA[// mbsrtowcs_s_ex.c : mbsrtowcs_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t mbsrtowcs_s(size_t * restrict retval,
                     //                     wchar_t * restrict dst,
                     //                     size_t dstmax,
                     //                     const char ** restrict src,
                     //                     size_t n,
                     //                     mbstate_t * restrict state );
#include <stdio.h>

int main()
{
    const char *mbptr = "Any multibyte string";
    wchar_t wcstr[10];            // A buffer for wide characters
    size_t len;                   // and its capacity.
    mbstate_t state = {0};

    if( mbsrtowcs_s( &len, wcstr, 10, &mbptr, 9, &state) != 0)
        printf("The array contains an invalid multibyte character.\n");
    else
    {
       printf("Length: %%zu; text: %%ls\n", len, wcstr);
       printf("The remaining characters: %%s\n", mbptr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mbtowc_ex">
			<text>
				<![CDATA[// mbtowc_ex.c : mbtowc() example
// -------------------------------------------------------------

#include <stdlib.h>   // int mbtowc( wchar_t * restrict wc,
                      //             const char * restrict s,
                      //             size_t maxsize );
#include <locale.h>
#include <stdio.h>

int main()
{
    int i = 0, n = 0;
    wchar_t wc;
    char mbstring[256] = "This is originally a multibyte string.\n";

    printf( "The current locale is %%s.\n", setlocale(LC_CTYPE, "" ));
    while ( (n = mbtowc( &wc, &mbstring[i], MB_CUR_MAX )) != 0 )
    {
        if ( n == -1 )
        {
           fputs( "Encoding error in multibyte string", stderr );
           break;
        }
        printf( "%%lc", (wint_t)wc );
        i += n;
   }
   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mktime_ex">
			<text>
				<![CDATA[// mktime_ex.c : mkctime() example
// -------------------------------------------------------------

#include <time.h>    // time_t mktime( struct tm *timeptr );
#include <stdio.h>

int main()
{
    time_t seconds;
    struct tm sometime;

    sometime.tm_sec   = 10;
    sometime.tm_min   = 80;
    sometime.tm_hour  = 40;
    sometime.tm_mday  = 23;
    sometime.tm_mon   = 1;
    sometime.tm_year  = 105;
    sometime.tm_wday  = 11;
    sometime.tm_yday  = 111;
    sometime.tm_isdst = -1;

    seconds = mktime( &sometime );

    if ( seconds == -1 )
    {
        printf( "mktime() couldn't make sense of its input.\n" );
        return -1;
    }

    printf( "The return value, %%ld, represents %%s",
            (long)seconds, ctime(&seconds) );

    printf( "The structure has been adjusted as follows:\n"
            "tm_sec   == %%d\n"
            "tm_min   == %%d\n"
            "tm_hour  == %%d\n"
            "tm_mday  == %%d\n"
            "tm_mon   == %%d\n"
            "tm_year  == %%d\n"
            "tm_wday  == %%d\n"
            "tm_yday  == %%d\n"
            "tm_isdst == %%d\n",

            sometime.tm_sec,
            sometime.tm_min,
            sometime.tm_hour,
            sometime.tm_mday,
            sometime.tm_mon,
            sometime.tm_year,
            sometime.tm_wday,
            sometime.tm_yday,
            sometime.tm_isdst );

    printf( "The structure now represents %%s", asctime( &sometime ));
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_mtx_timedlock_ex">
			<text>
				<![CDATA[// mtx_timedlock_ex.c : mtx_timedlock() example
// -------------------------------------------------------------

#include <threads.h>   // int mtx_timedlock( mtx_t *restrict mtx,
                       //                    const struct timespec *restrict ts);
#include <stdio.h>

mtx_t mtx;
int func(void * thrd);                   // Thread function.

int main()
{
    thrd_t th;
    if( mtx_init(&mtx, mtx_timed) != thrd_success)
    { fputs("Initialization error.\n", stderr); return 1; }

    mtx_lock(&mtx);                      // Lock the mutex.
    if( thrd_create(&th, func, "Thread A") != thrd_success)
    { fputs("Thread error.\n", stderr); return 2; }

    thrd_join(th, NULL);
    mtx_destroy( &mtx);
    return 0;
}

int func(void * thrd)
{
    struct timespec ts;
    timespec_get( &ts, TIME_UTC);        // The current time;
    ts.tv_sec += 3;                      // 3 seconds from now.

    printf("%%s waiting ...\n", (char*)thrd);
    int res = mtx_timedlock(&mtx, &ts);
    switch(res)
    {
        case thrd_success:
           puts("Obtained mutex\n... releasing ...");
           mtx_unlock(&mtx);   break;
        case thrd_timedout:
           puts("Timed out.");   break;
        default:
           puts("mtx_timedlock: error.");
    };
    return res;
}
]]>
			</text>
		</p>
		<p n="xc_mtx_trylock_ex">
			<text>
				<![CDATA[// mtx_trylock_ex.c : mtx_trylock() example
// -------------------------------------------------------------

#include <threads.h>   // int mtx_trylock( mtx_t *mtx);
#include <stdio.h>

#define NUM_THREADS 3
mtx_t mtx;

struct timespec duration = { .tv_nsec = 1 };   // One nanosecond.
int func(void * thrd_num)                      // Thread function.
{
    int num = *(int*)thrd_num;
    int res, count = 1;

    while( (res = mtx_trylock(&mtx)) == thrd_busy)
    { ++count;  thrd_sleep( &duration, NULL); }

    if( res == thrd_success)
    {
       printf("Thread %%d succeeded after %%d attempts.\n", num, count);
       thrd_sleep( &duration, NULL);
       mtx_unlock(&mtx);
       return 0;
    }
    else return -1;
}
int main(void)
{
    struct { thrd_t th; int id; } th_arr[NUM_THREADS];

    if( mtx_init(&mtx, mtx_plain) != thrd_success)
       return 1;

    // Create threads:
    for( int i = 0; i < NUM_THREADS; ++i)
    {
       th_arr[i].id = i;
       if( thrd_create( &th_arr[i].th, func, &th_arr[i].id) 
           != thrd_success)
          return -2;
    }
    // Wait for threads to finish:
    for( int i = 0; i < NUM_THREADS; ++i)
     thrd_join( th_arr[i].th, NULL);

    mtx_destroy( &mtx);
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_nearbyint_ex">
			<text>
				<![CDATA[// nearbyint_ex.c : nearbyint() example
// -------------------------------------------------------------

#include <math.h>    // double nearbyint( double x );
                     // float nearbyintf( float x );
                     // long double nearbyintl( long double x );
#include <fenv.h>
#include <stdio.h>

int main()
{
    if ( fesetround( FE_TOWARDZERO) == 0)
       printf("The current rounding mode is \"round toward 0.\"\n");
    else
       printf("The rounding mode is unchanged.\n");

    printf( "nearbyint(1.9) = %%4.1f    nearbyint(-1.9) = %%4.1f\n",
            nearbyint(1.9), nearbyint(-1.9) );

    printf( "round(1.9) = %%4.1f        round(-1.9) = %%4.1f\n",
            round(1.9), round(-1.9) );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_perror_ex">
			<text>
				<![CDATA[// perror_ex.c : perror() example
// -------------------------------------------------------------

#include <stdio.h>      // void perror( const char *string );
#include <errno.h>

#define MSGLEN_MAX 256

int main( int argc, char *argv[] )
{
    FILE *fp;
    char msgbuf[MSGLEN_MAX] = "";

    if (( fp = fopen( "nonexistentfile", "r" )) == NULL )
    {
       snprintf( msgbuf, MSGLEN_MAX, "%%s, function %%s, file %%s, line %%d",
                 argv[0], __func__, __FILE__, __LINE__ );
       perror( msgbuf );
       return errno;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_printf_ex">
			<text>
				<![CDATA[// printf_ex.c : printf() example
// -------------------------------------------------------------

#include <stdio.h>      // int printf( const char * restrict format, ... );
#include <math.h>
#include <assert.h>

void print_line( double x);

int main()
{
    double pi = 3.1415926;
    double bignumber = 8 * 8 * 8 * pi * pi * pi;
    printf("512 times pi cubed equals %%.2e, or %%.2a.\n",
                                      bignumber, bignumber);

    print_line( 11.22);
    return 0;
}

// The print_line function illustrates the use of the %%n conversion specification
// to count the characters in the output string:
void print_line( double x)
{
    int n1, n2;
    printf("x = %%5.2f exp(x) = %%n%%10.5f%%n\n", x, &n1, exp(x), &n2);
    assert( n2-n1 <= 10);           // Did printf() stretch the field width?
}
]]>
			</text>
		</p>
		<p n="xc_putchar_ex">
			<text>
				<![CDATA[// putchar_ex.c : putchar() example
// -------------------------------------------------------------

// The following example reads the beginning of a file repetitively,
// and reports its progress on stdout.

#include <stdio.h>      // int putchar( int c );

int main()
{
    long count; const long CYCLES = 5000;
    char readback[1024];

    FILE *fp = fopen( "infile.txt", "r" );
    if( fp == NULL)
    { fprintf( stderr, "Couldn't open input file.\n" ); return -1; }

    for (count = 0; count <= CYCLES; ++count)
    {
      /* Start output with '\r' to re-use same screen line. */
       printf( "\rPerformed %%li file reads. ", count );

       rewind( fp );
       fgets( readback, 1024, fp );

      /* Scroll a new screen line every hundred cycles. */
       if (count %% 100 != 0) continue;
       putchar( '\n' );
    }
    puts( "Done." );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_qsort_ex">
			<text>
				<![CDATA[// qsort_ex.c : qsort() example
// -------------------------------------------------------------

#include <stdlib.h>
         // void qsort( void *array, size_t n, size_t size,
         //             int (*compare)( const void *, const void *) );

#include <stdio.h>

int strptrcmp( const void *sp1, const void *sp2 );

int main()
{
    char *words[] = { "Then", "he", "shouted", "What", "I",
                      "didn't", "hear", "what", "you", "said" };

    int n = sizeof(words) / sizeof(char *);

    qsort( words, n, sizeof(char *), strptrcmp );

    for ( int j = 0 ; j < n ; j++ )
        puts( words[j] );
}

#include <string.h>

int strptrcmp( const void *sp1, const void *sp2 )
// Compare two strings by reference.
{
    // qsort() passes a pointer to the pointer:
    // dereference it to pass a char * to strcmp.
    const char * s1 = *(char **)sp1;
    const char * s2 = *(char **)sp2;
    return strcmp( s1, s2 );
}
]]>
			</text>
		</p>
		<p n="xc_rand_ex">
			<text>
				<![CDATA[// rand_ex.c : rand() example
// -------------------------------------------------------------

#include <stdlib.h>       // int rand( void );
#include <time.h>
#include <ctype.h>
#include <stdio.h>

int main()
{
    printf( "Think of a number between one and twenty.\n"
            "Press Enter when you're ready." );
    getchar();

    srand( (unsigned)time( NULL ) );
    for ( int i = 0; i < 3; i++ )     // We get three guesses.
    {
        printf( "Is it %%u? (y or n) ", 1 + rand() %% 20 );
        if ( tolower( getchar() ) == 'y' )
        {
            printf( "Ha! I knew it!\n" );
            exit( 0 );
        }
        getchar();                     // Discard newline character.
    }
    printf( "I give up.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="ex_realloc_ex">
			<text>
				<![CDATA[// realloc_ex.c : realloc() example
// -------------------------------------------------------------

#include <stdlib.h>       // void *realloc( void *ptr, size_t n );
#include <stdio.h>

int main()
{
    typedef struct { int len;
                     float array[];
                   } DynArray_t;

    DynArray_t *daPtr = malloc( sizeof(DynArray_t) + 10*sizeof(float) );
    if ( daPtr == NULL ) return -1;

    daPtr->len = 10;

    for ( int i = 0; i < daPtr->len; ++i )
        daPtr->array[i] = 1.0F/(i+1);

    /* daPtr->array[10] = 0.1F               // Invalid array index! */

    DynArray_t *daResizePtr = realloc( daPtr,
                                       sizeof(DynArray_t) + 11*sizeof(float));
    if ( daResizePtr != NULL )
    {
       daPtr = daResizePtr ;
       daPtr->len = 11;
       daPtr->array[10] = 0.1F / 12;         // OK now.
    }
    else
    {
       /* We'll just have to get along with the array of 10 floats.
       ...   */
       return -1;
    }
      
    for ( int i = 0; i < daPtr->len; ++i )
        printf( "%%2d : %%8f\n", i, daPtr->array[i] );
    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remainder_ex">
			<text>
				<![CDATA[// remainder_ex.c : remainder() example
// -------------------------------------------------------------

#include <math.h>   // double remainder( double x, double y );
                    // float remainderf( float x, float y );
                    // long double remainderl( long double x, long double y );
#include <stdio.h>

int main()
{
    double apples = 0.0, people = 0.0, share = 0.0, left = 0.0;

    printf( "\nHow many people? ");
    scanf( "%%lf", &people );

    printf( "\nHow many apples? ");
    scanf( "%%lf", &apples );

    left = remainder( apples, people );     // left may be negative!
    share = ( apples - left ) / people;

    printf( "If there are %%.1lf of us and %%.1lf apples, "
            "each of us gets %%.1lf of %%s, with %%.1lf left over.\n",
             people, apples, share, ( share < 1 ) ? "one" : "them", left );
    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remove_ex">
			<text>
				<![CDATA[// remove_ex.c : remove() example
// -------------------------------------------------------------

#include <stdio.h>     // int remove( const char *filename );
#include <errno.h>

int main()
{
    char fname_tmp[L_tmpnam] = "";
    FILE *fp;
    int result;

    tmpnam( fname_tmp );
    fp = fopen( fname_tmp, "w+" );
    if( fp == NULL)
    {  fprintf(stderr, "Couldn't open file \"%%s\".\n", fname_tmp);
       return -1;
    }

    /* ... write something in the file, edit it ... */
    fputs( "hello ...\n", fp);

    fclose( fp );

    result = rename( fname_tmp, "finished.txt" );
    if ( result )     // Delete previous "finished.txt" and try again.
    {
        remove( "finished.txt" );
        result = rename( fname_tmp, "finished.txt" );
        if ( result )                   // Give up and log the error.
           fprintf( stderr, "Error %%d on trying to rename output file\n",
                                                                   errno );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_remquo_ex">
			<text>
				<![CDATA[// remquo_ex.c : remquo() example
// -------------------------------------------------------------

#include <math.h>   // double remquo( double x, double y, int *quo );
                    // float remquof( float x, float y, int *quo );
                    // long double remquol( long double x, long double y,
                    //                      int *quo );
#include <stdio.h>

int main()
{
    double apples = 0.0, people = 0.0, left = 0.0, share = 0.0;
    int quotient = 0;

    printf( "\nHow many people? ");
    scanf( "%%lf", &people );

    printf( "\nHow many apples? ");
    scanf( "%%lf", &apples );

    share = nearbyint( apples / people );
    left = remquo( apples, people, &quotient );    

    printf( "If there are %%.2lf of us and %%.2lf apples, "
            "each of us gets %%.2lf apple%%s, with %%.2lf left over.\n",
            people, apples, share, ( share == 1 ) ? "" : "s", left );

    printf( "remquo() stored %%d as the quotient "
            " of the division (modulo 8).\n", quotient );

    printf( "Test: share modulo 8 - quotient = %%d\n",
            (int) share %% 8 - quotient );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_rewind_ex">
			<text>
				<![CDATA[// rewind_ex.c : rewind() example
// This example prints the contents of a file twice, converting 
// each character to lowercase the first time through, and to 
// uppercase the second time:
// -------------------------------------------------------------

#include <stdio.h>   // void rewind( FILE *fp );
#include <stdlib.h>
#include <ctype.h>

int main( int argc, char *argv[])
{
    FILE *fp; int c;

    if ( argc != 2 )
       printf( "Usage: program input-file\n"), exit(1);

    if (( fp = fopen( argv[1], "r" )) == NULL )
        fprintf( stderr, "Failed to open file %%s\n", argv[1] );
    else
    {
        puts( "Contents of the file in lowercase:" );
        while (( c = fgetc( fp )) != EOF )
            putchar( tolower( c ));

        rewind( fp );

        puts( "Same again in uppercase:" );
        while (( c = fgetc( fp )) != EOF )
            putchar( toupper( c ));

       fclose( fp );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_rint_ex">
			<text>
				<![CDATA[// rint_ex.c : rint() example
// -------------------------------------------------------------

#include <math.h>    // double rint( double x );
                     // float rintf( float x );
                     // long double rintl( long double x );
#include <fenv.h>
#include <stdio.h>

struct round_modes { int id; char *str; } arrModes[ ] =
{
 #ifdef FE_TONEAREST
   { FE_TONEAREST,
     "FE_TONEAREST: round to nearest representable value" },
 #endif
 #ifdef FE_DOWNWARD
    { FE_DOWNWARD, "FE_DOWNWARD: round toward -Inf" },
 #endif
 #ifdef FE_UPWARD
   { FE_UPWARD, "FE_UPWARD: round toward +Inf" },
 #endif
 #ifdef FE_TOWARDZERO
   { FE_TOWARDZERO, "FE_TOWARDZERO: round toward 0" }
 #endif
};

int main()
{
    int nModes = sizeof( arrModes) / sizeof(*arrModes);

    #pragma STDC FENV_ACCESS ON

    for ( int i = 0; i < nModes; ++i)
    {
        if ( fesetround( arrModes[i].id) != 0)
           break;
        printf( "Rounding mode: %%s\n", arrModes[i].str );

        printf( "rint(1.4)  = %%4.1f    rint(1.5)  = %%4.1f\n",
                rint(1.4), rint(1.5) );
        printf( "rint(-1.4) = %%4.1f    rint(-1.5) = %%4.1f\n",
                rint(-1.4), rint(-1.5) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_cacukate">
			<text>
				<![CDATA[// calculate.c: Perform some calculations.
// Functions: calculate1(), calculate2().
// -------------------------------------------------------------

#include <math.h>
#include <setjmp.h>
#include <errno.h>

extern jmp_buf jmp_dest;             // Destination for longjmp()

double calculate1( double x)
{
    if ( x < 0)
        longjmp( jmp_dest, EDOM);    // Domain error
    else
        return sqrt(x);
}

double calculate2( double x)
{
    double y = exp(x);
    if ( y == HUGE_VAL)
        longjmp( jmp_dest, ERANGE);  // Range error
    else
        return y;
}
]]>
			</text>
		</p>
		<p n="sc_set_constraint_handler_s_ex">
			<text>
				<![CDATA[// set_constraint_handler_s_ex.c : set_constraint_handler_s() example
// -------------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // constraint_handler_t set_constraint_handler_s(
                     //                      constraint_handler_t handler);
#include <errno.h>
#include <string.h>
#include <stdio.h>

// Use a custom handler:
void myConstraintHandler(const char* msg, void * ptr, errno_t error)
{
    printf("A runtime constraint violation "
           "occurred: \n%%s; ", msg);
    printf("error code: %%d\n", error);  fflush(stdout);
    exit(error);
}

void func( const char *str)
{
    constraint_handler_t prevHandler =
               set_constraint_handler_s(myConstraintHandler);
    printf_s("The argument: %%s\n", str);        // Error if str
                                                // is a null pointer.
    int len = strlen(str);
    char str2[len];
    strcpy_s( str2, len, str);    // Error: str2 is one byte too short.
    // . . .
    set_constraint_handler_s(prevHandler);
}

int main()
{
    func("Hi");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_set_constraint_handler_s_ex">
			<text>
				<![CDATA[// set_constraint_handler_s_ex.c : set_constraint_handler_s() example
// -------------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <stdlib.h>  // constraint_handler_t set_constraint_handler_s(
                     //                      constraint_handler_t handler);
#include <errno.h>
#include <string.h>
#include <stdio.h>

// Use a custom handler:
void myConstraintHandler(const char* msg, void * ptr, errno_t error)
{
    printf("A runtime constraint violation "
           "occurred: \n%%s; ", msg);
    printf("error code: %%d\n", error);  fflush(stdout);
    exit(error);
}

void func( const char *str)
{
    constraint_handler_t prevHandler =
               set_constraint_handler_s(myConstraintHandler);
    printf_s("The argument: %%s\n", str);        // Error if str
                                                // is a null pointer.
    int len = strlen(str);
    char str2[len];
    strcpy_s( str2, len, str);    // Error: str2 is one byte too short.
    // . . .
    set_constraint_handler_s(prevHandler);
}

int main()
{
    func("Hi");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_setjmp_ex">
			<text>
				<![CDATA[// setjmp_ex.c : setjmp() - longjmp() example
// -------------------------------------------------------------

#include <setjmp.h>       // int setjmp( jmp_buf env );
                          // void longjmp( jmp_buf environment,
                          //               int returnval );
#include <stdlib.h> 
#include <stdio.h>
#include <errno.h>

double calculate1( double x);     // Functions defined
double calculate2( double x);     // in calculate.c.

jmp_buf jmp_dest;                 // Destination for longjmp()

int main()
{
    double x = 0, y1, y2;
    int n = 0;

    puts("--- Demonstrating non-local jumps ---\n");

    switch( setjmp( jmp_dest)) // Jump to here for error handling
    {
    case 0:                    // The original setjmp() call
        break;
    case EDOM:                 // Arrived via longjmp() call with EDOM
        puts("Domain error. "
             "Negative numbers are not permitted.");
        break;
    case ERANGE:               // Arrived via longjmp() call with ERANGE
        puts("Range error. "
             "The number you entered is too big.");
        break;
    default:                   // We should never arrive here.
        puts("Unknown error.");
        exit( EXIT_FAILURE );
    }

    printf("Enter a number: ");
    do
    {
        if ( (n = scanf("%%lf", &x)) < 0)  // Read in a number.
           exit( EXIT_FAILURE );          // Read end of file.
        while ( getchar() != '\n')        // Clear the input buffer.
          ;
        if ( n == 0 )
           printf("Invalid entry. Try again: ");
    }while ( n == 0 );

    y1 = calculate1(x);
    y2 = calculate2(x);

    printf("\nResult of Calculation 1: %%G\n", y1);
    printf(  "Result of Calculation 2: %%G\n", y2);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_setlocale_ex">
			<text>
				<![CDATA[// setlocale_ex.c : setlocale() example
// -------------------------------------------------------------

#include <locale.h>    // char *setlocale( int category, 
                       //                  const char *locale_name );
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_STRING 80

int main()
{
    char name[MAX_STRING];
    char locale[MAX_STRING];
    char *newlocale;
    int i;

    printf( "Who are you? " );
    fgets( name, sizeof(name), stdin );

    printf( "What is your locale? " );
    fgets( locale, sizeof(locale), stdin );

    name[ strlen(name) - 1 ] = '\0';     // Chomp off the newlines.
    locale[ strlen(locale) - 1 ] = '\0';

    newlocale = setlocale( LC_CTYPE, locale );
    if ( newlocale == NULL )
       printf( "Sorry, couldn't change the locale to %%s.\n"
               "The current locale is %%s. ",
               locale, setlocale( LC_CTYPE, NULL ));
    else
        printf( "The new locale is %%s. ", newlocale );

    name[0] = toupper( name[0] );   // Force the first letter to uppercase.

    i = 1;
    if ( isupper( name[i] ) )       // Is the second letter also uppercase?
    {
       while ( name[i] != '\0' )    // If so, force all the rest to lowercase.
       {
          name[i] = tolower( name[i] );
          ++i;
       }
    }
    printf( "Hello there, %%s!\n", name );

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_signal_ex">
			<text>
				<![CDATA[// signal_ex.c : signal() example
// -----------------------------------------------------------------------

#include <signal.h>   // void ( *signal( int sig, void (*handler)(int) ) )(int);
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdint.h>   // Defines SIG_ATOMIC_MAX

void sigint_handler(int sig);
volatile sig_atomic_t i;   // A counter accessed by main and the
                           // handler.

int main()
{
    if ( signal( SIGINT, sigint_handler ) == SIG_ERR )
    {
        perror("Failed to install SIGINT handler");
        exit(3);
    }

    while (1)
    {
        puts( "Press Ctrl+C to interrupt me.");
        for ( i = 0 ; i < SIG_ATOMIC_MAX ; i++ )
            if ( i %% 100000 == 0)
            {
                printf( "\r%%d ", i / 100000 );
                fflush( stdout );
            }
        raise( SIGINT );   // Simulate a Ctrl+C in case the user didn't
                           // type it.
    }
    return 0;
}

void sigint_handler( int sig )
{
    int c = 0;

    if ( sig != SIGINT ) exit( 1 );

    signal( SIGINT, SIG_IGN );         // Ignore a second Ctrl+C

    puts( "\nThis is the function sigint_handler()."
          "\nDo you want to exit the program now? [y/n]");
    while (( c = tolower( getchar( ) )) != 'y' && c != 'n' && c != EOF )
      ;

    if ( c != 'n' )
       exit(0);
    else
       i = 0;                          // Reset timer

    signal( SIGINT, sigint_handler );  // Reinstall this handler.

    /* No return value; just fall off the end of the function. */
}
]]>
			</text>
		</p>
		<p n="xc_signb_ex">
			<text>
				<![CDATA[// signbit_ex.c : signbit() example
// -------------------------------------------------------------

#include <math.h>   // int signbit(x );
#include <stdio.h>

int main()
{
    double x[ ] = { -0.0, 187.234, sqrt( -1.0 ), 1.0 / -0.0 };

    for ( int i = 0 ; i < ( sizeof(x) / sizeof(double)) ; i++ )
        printf( "x[%%d] equals %%lF, and is%%s negative.\n",
                 i, x[i], signbit( x[i] ) ? "" : " not" );    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sin_ex">
			<text>
				<![CDATA[// sin_ex.c : sin() example
// -------------------------------------------------------------

#include <math.h>    // double sin( double x );
                     // double sinf( float x );
                     // long double sinl( long double x );
#include <stdio.h>
#include <stdlib.h>

#define DEG_PER_RAD ( 180.0 / PI )

int main()
{
    const double PI = 4.0 * atan( 1.0 );
    double a[4];

    printf( "\nEnter an acute angle measure, in degrees: " );

    if ( scanf( "%%lf", a ) < 1 || ( a[0] <= 0 || a[0] >= 90 ) )
        printf( "\nThat's not an acute angle.\n" ), exit( 1 );
    else
    {
        a[1] = a[0] + 90 ;
        a[2] = 180 - a[0] ;
        a[3] = 225 + a[0] ;

        for ( int i = 0 ; i < 4 ; i ++ )
            printf( "The sine of %%6.2lf degrees is %%6.4lf.\n",
                    a[i], sin( a[i] / DEG_PER_RAD ) );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sinh_ex">
			<text>
				<![CDATA[// sinh_ex.c : sinh() example
// -------------------------------------------------------------

#include <math.h>    // double sinh( double x );
                     // double sinhf( float x );
                     // long double sinhl( long double x );
#include <stdio.h>

// A chain hanging from two points forms a curve called a catenary.
// A catenary is a segment of the graph of the function
// cosh(k*x)/k, for some constant k.
// The length along the catenary over a certain span, bounded by the
// two vertical lines at x=a and x=b, is equal to
// sinh(k*b)/k - sinh(k*a)/k.

int main()
{
    double x, k;

    puts("Catenary f(x) = cosh(k*x)/k\n"
         "Length along the catenary from a to b: "
         "sinh(k*b)/k - sinh(k*a)/k)\n");

    puts("            f(-1.0)  f(0.0)   f(1.0)   f(2.0)   Length(-1.0 to 2.0)\n"
         "-------------------------------------------------------------------");
    for ( k = 0.5; k < 5; k *= 2)
    {
        printf("k = %%.1f: ", k);
        for ( x = -1.0; x < 2.1; x += 1.0)
           printf("%%8.2f ", cosh(k*x)/k );

        printf(" %%12.2f\n", (sinh(2*k) - sinh(-1*k))/ k);
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_snprintf_ex">
			<text>
				<![CDATA[// snprintf_ex.c : snprintf() example
// -------------------------------------------------------------

#include <stdio.h>   // int snprintf( char * restrict dest, size_t n,
                     //               const char * restrict format, ... );

int main()
{
    char buffer[80];
    double x = 1234.5, y = 678.9, z = -753.1, a = x * y + z;
    int output_len = 0;

    output_len = snprintf( buffer, 80, "For the input values %%lf, %%lf,"
                           " and %%lf,\nthe result was %%lf.\n",
                           x, y, z, a );
    puts( buffer );
    if ( output_len >= 80 )
       fprintf( stderr, "Output string truncated! Lost %%d characters.\n",
                output_len - 79 );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sprintf_ex">
			<text>
				<![CDATA[// sprintf_ex.c : sprintf() example
// -------------------------------------------------------------

#include <stdio.h>   // int sprintf( char * restrict dest, 
                     //              const char * restrict format, ... );

int main()
{
    char buffer[80];
    double x = 1234.5, y = 678.9, z = -753.1, a = x * y + z;
    int output_len = 0;

    output_len = sprintf( buffer, "For the input values %%lf, %%lf, and %%lf,"
                          "\nthe result was %%lf.\n",
                          x, y, z, a );
    puts( buffer );
    if ( output_len >= 80 )
       fprintf( stderr, "Output string overflowed by %%d characters.\n"
                "The variables x, y, z and a may have been corrupted:\n"
                "x now contains %%lf, y %%lf, z %%lf, and a %%lf.\n",
                 output_len - 79, x, y, z, a );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_sqrt_ex">
			<text>
				<![CDATA[// sqrt_ex.c : sqrt() example
// -------------------------------------------------------------

#include <math.h>    // double sqrt( double x );
                     // double sqrtf( float x );
                     // long double sqrtl( long double x );
#include <stdio.h>
#include <errno.h>

int main()
{
    double x[ ] = { 0.5, 0.0, -0.0, -0.5 };

    for ( int i = 0; i < ( sizeof(x) / sizeof(double) ); i++)
    {
       printf("The square root of %%.2F equals %%.4F\n", x[i], sqrt( x[i] ) );
       if ( errno )
          perror( __FILE__ );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcat_ex">
			<text>
				<![CDATA[// strcat_ex.c : strcat(), strcat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for strcat_s()

#include <string.h>  // char *strcat( char * restrict s1, 
                     //               const char * restrict s2 );
                     // errno_t strcat_s( char * restrict s1, rsize_t s1max,
                     //                   const char * restrict s2 );
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char  lastname[32];
    char  firstname[32];
    _Bool ismale;
} Name;

int main()
{
    char displayname[80];
    Name *newName = calloc( 1, sizeof(Name) );

    /* ... check for calloc failure; read in the name parts ... */
    if( newName == NULL)
    {  fprintf( stderr, "Out of memory\n" ); return -1; }
    *newName = (Name) { "Lincoln", "Abraham", 1 };

    strcpy( displayname, ( newName->ismale ? "Mr. " : "Ms. " ) );

    strcat( displayname, newName->firstname );
    strcat( displayname, " " );
    strcat( displayname, newName->lastname );

    // Better to use strcat_s() in case the fields in the Name
    // structure are ever enlarged:
    // strcat_s( displayname, sizeof(displayname), newName->firstname );
    // strcat_s( displayname, sizeof(displayname), " " );
    // strcat_s( displayname, sizeof(displayname), newName->lastname );

    puts( displayname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strchr_ex">
			<text>
				<![CDATA[// strchr_ex.c : strchr() example
// -------------------------------------------------------------

#include <string.h>  // char *strchr( const char *s, int c );
#include <stdio.h>
#include <stdlib.h>

typedef struct { char street[32];
                 char city[32];
                 char stateprovince[32];
                 char zip[16];
               } Address;

char printaddr[128] = "720 S. Michigan Ave.\nChicago, IL 60605\n";

int main()
{
    int sublength;
    Address *newAddr = calloc( 1, sizeof(Address) );

    if ( newAddr != NULL )
    {
        sublength = strchr( printaddr, '\n' ) - printaddr;
        strncpy( newAddr->street, printaddr,
                 ( sublength < 31 ? sublength : 31 ) );
        /* ... */
        puts(newAddr->street);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcmp_ex">
			<text>
				<![CDATA[// strcmp_ex.c : strcmp() example
// -------------------------------------------------------------

#include <string.h>  // int strcmp( const char *s1, const char *s2);
#include <stdio.h>

int main()
{
    int result = 0;
    char word1[256], word2[256], *greaterlessequal;

    while ( result < 2 )
    {
        puts( "Type two words, please." );
        result = scanf( "%%s%%s", word1, word2 );
    }
    result = strcmp( word1, word2 );

    if ( result < 0 )
       greaterlessequal = "less than";
    else if ( result > 0 )
       greaterlessequal = "greater than";
    else
       greaterlessequal = "the same as";

    printf( "The word \"%%s\" is %%s the word \"%%s\".\n",
            word1, greaterlessequal, word2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcoll_ex">
			<text>
				<![CDATA[// strcoll_ex.c : strcoll() example
// -------------------------------------------------------------

#include <string.h>  // int strcoll( const char *s1, const char *s2 );
#include <stdio.h>
#include <locale.h>

int main()
{
    char *samples[ ] = { "curso", "churro" };

    if( setlocale( LC_COLLATE, "es_US.UTF-8" ) == NULL)
       fputs("Unable to set the locale.\n", stderr);

    int result = strcoll( samples[0], samples[1] );

    if ( result == 0 )
       printf( "The strings \"%%s\" and \"%%s\" are alphabetically "
               "equivalent.\n", samples[0], samples[1] );
    else if ( result < 0 )
       printf( "The string \"%%s\" comes before \"%%s\" alphabetically.\n",
               samples[0], samples[1] );
    else if ( result > 0 )
       printf( "The string \"%%s\" comes after \"%%s\" alphabetically.\n",
               samples[0], samples[1] );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcpy_ex">
			<text>
				<![CDATA[// strcpy_ex.c : strcpy(), strcpy_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for strcpy_s()

#include <string.h>  // char *strcpy( char * restrict dest,
                     //               const char * restrict src );
                     // errno_t strcpy_s( char * restrict dest, 
                     //                   rsize_t destmax,
                     //                   const char * restrict src );
#include <stdio.h>

int main()
{
    struct guest {
       char name[64]; int age; _Bool male, smoking, discount; } this;
    int result;

    printf( "Last name: " );
    result = scanf( "%%[^\n]", this.name );
    if ( result < 1 )
       strcpy( this.name, "[not available]" );
   // or
   // strcpy_s( this.name, sizeof(this.name), "[not available]" );

    printf( "Name: %%s\n", this.name );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strcspn_ex">
			<text>
				<![CDATA[// strcspn_ex.c : strcspn() example
// -------------------------------------------------------------

#include <string.h>  // int strcspn( const char *s1, const char *s2 );
#include <stdio.h>

int main()
{
    char *path = "/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games";
    int separator;
    char *basename = "aprogram";
    char fullname[1024] = "";

    separator = strcspn( path, ":" );  // Obtain the index of the first
                                       // colon.
    strncpy( fullname, path, separator );
    fullname[separator] = '\0';        // Terminate the copied string
                                       // fragment.
    strncat( fullname, "/", sizeof(fullname) - strlen(fullname) -1 );
    strncat( fullname, basename, sizeof(fullname) - strlen(fullname) -1 );

    puts( fullname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strerror_ex">
			<text>
				<![CDATA[// strerror_ex.c : strerror() example
// -------------------------------------------------------------

#include <string.h>     // char *strerror( int errornumber );
#include <errno.h>
#include <stdio.h>

int main( int argc, char *argv[])
{
    FILE *fp;
    char msgbuf[1024] = { '\0' };

    /* Open input file: */
    if (( fp = fopen( "nonexistent", "r" )) == NULL)
    {
       int retval = errno;
       snprintf( msgbuf, sizeof(msgbuf),
                 "%%s: file %%s, function %%s, line %%d: error %%d,\n%%s.\n",
                 argv[0], __FILE__, __func__, __LINE__, retval,
                 strerror( retval ));
       fputs( msgbuf, stderr );
       return retval;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strerror_s_ex">
			<text>
				<![CDATA[// strerror_s_ex.c : strerror_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>     // errno_t strerror_s(char *s, rsize_t maxsize,
                        //                    errno_t errnum);
#include <stdio.h>
#include <errno.h>
#include <math.h>

int main()
{
    double x = -1.0, y = 0;
  // ...
    errno = 0;
    y = sqrt(x);
    if( errno == EDOM)
    {
        char msg[30] = "";
        strerror_s( msg, sizeof(msg), errno);
        fprintf( stderr, "sqrt: %%s\n", msg);
    }
  // ...
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strftime_ex">
			<text>
				<![CDATA[// strftime_ex.c : strftime() example
// -------------------------------------------------------------

#include <time.h>   // size_t strftime( char * restrict s, size_t n,
                    //                  const char * restrict format,
                    //                  const struct tm * restrict timeptr );
#include <stdio.h>

int main()
{
    time_t now;
    struct tm *localnow;
    char hdr_date[999] = "";

    time( &now );
    localnow = localtime( &now );

    if ( strftime( hdr_date, 78, "Date: %%a, %%d %%b %%Y %%T %%z", localnow ) )
        puts( hdr_date );
    else
        return -1;

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strlen_ex">
			<text>
				<![CDATA[// strlen_ex.c : strlen() example
// -------------------------------------------------------------

#include <string.h>  // size_t strlen( const char *s );
#include <stdio.h>

int main()
{
    char line[1024] =
         "This string could easily be hundreds of characters long.";
    char *readptr = line;
    int columns = 80;

    // While the text is longer than a row:
    while ( strlen( readptr ) > columns )
    {   // print a row with a backslash at the end:
        printf( "%%.*s\\", columns-1, readptr);
        readptr += columns -1;
    }   
    // Then print the rest with a newline at the end:
    printf( "%%s\n", readptr );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strncat_ex">
			<text>
				<![CDATA[// strncat_ex.c : strncat(), strncat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1    // For the secure functions.

#include <string.h>  // char *strncat( char * restrict s1,
                     //                const char * restrict s2, size_t n );
                     // errno_t strncat_s( char * restrict s1, rsize_t s1max,
                     //                    const char * restrict s2, rsize_t n);
#include <stdlib.h>
#include <stdio.h>

int main()
{
    char str1[] = "hello ",       // 7 bytes
         str2[10] = "hello ",     // 7 + 3 bytes
         str3[10] = "hello ";     // 7 + 3 bytes

 // strncat( str1, "Jimi", 1);    // Severe error: buffer overflow!
 // strncat( str2, "Jimi", 3);    // OK: "hello Jim"
 // strncat( str3, "Jim", 100);   // OK.

 // Or, using strncat_s(), with the variables defined above:
    int ret1, ret2, ret3;

    set_constraint_handler_s(ignore_handler_s);
    ret1 = strncat_s( str1, sizeof(str1), "Jimi", 1);   // ret1 != 0 and
                                                        // str1[0] == '\0'
    printf( "ret1: %%d    str1: %%s\n", ret1, str1 );

    ret2 = strncat_s( str2, sizeof(str2), "Jimi", 3);   // OK: ret2 == 0
    printf( "ret2: %%d    str2: %%s\n", ret2, str2 );

    ret3 = strncat_s( str3, sizeof(str3), "Jim", 100);  // OK: ret3 == 0
    printf( "ret3: %%d    str3: %%s\n", ret3, str3 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strneln_s_ex">
			<text>
				<![CDATA[// strnlen_s_ex.c : strnlen_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1    // For the secure functions.
#include <string.h>  // size_t strnlen_s(const char *s, size_t maxsize);
#include <stdio.h>

int main()
{
    char str[] = "hello";

    size_t len = strnlen_s( str, 1000);  // len = 5

    if( strnlen_s( str, 4) == 4)
    { 
        puts("str is more than 4 characters long."); 
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strpbrk_ex">
			<text>
				<![CDATA[// strpbrk_ex.c : strpbrk() example
// -------------------------------------------------------------

#include <string.h>    // char *strpbrk( const char *s1, 
                       //                const char *s2 );
#include <stdio.h>

int main()
{
    char *story = "He shouted: \"What? I can't hear you!\"\n";
    char separators[] = " \t\n.:?!\"";
    char *start = story, *end = NULL;
    char words[16][16];     // An array of char arrays to collect words in.
    int i = 0;

    while ( i < 16 && ( end = strpbrk( start, separators ) ) != NULL )
    {
      if ( end != start )   // If the separator wasn't the first character,
      {                     // then save a word in an array.
         strncpy( words[i], start, end - start );
         words[i][end - start] = '\0';     // And terminate it.
         i++;
      }
      start = end + 1;      // Next strpbrk call starts with
    }                       // the character after this separator.

    puts( story );

    for ( int j = 0 ; j < i ; j++ )
       puts( words[j] );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strrchr_ex">
			<text>
				<![CDATA[// strrchr_ex.c : strrchr() example
// -------------------------------------------------------------

#include <string.h>     // char *strrchr( const char *s, int c );
#include <stdio.h>

int main( int argc, char *argv[])
{
    char *mybasename = strrchr( argv[0], '/' );       // Find end of path.
    if ( mybasename != NULL )
        mybasename++;       // Point to the first character after the slash.
    else
        mybasename = argv[0];

    printf( "This program was invoked as %%s.\n", mybasename );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strspn_ex">
			<text>
				<![CDATA[// strspn_ex.c : strspn() example
// -------------------------------------------------------------

#include <string.h>  // int strspn( const char *s1, const char *s2 );
#include <stdio.h>

int main()
{
    char wordin[256];
    double val;

    puts( "Enter a floating-point number, please:" );
    scanf( "%%s", wordin );

    int index = strspn( wordin, "+-0123456789eE." );
    if ( index < strlen( wordin ) )
       printf( "Sorry, but the character %%c is not permitted.\n",
               wordin[index] );
    else
    {
        sscanf( wordin, "%%lg", &val );
        printf( "You entered the value %%g\n", val );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtod_ex">
			<text>
				<![CDATA[// strtod_ex.c : strtod() example
// -------------------------------------------------------------

#include <stdlib.h>  // double strtod( const char * restrict s,
                     //                char ** restrict endptr );
#include <stdio.h>

int main()
{
    char in[1024], *this = in, *next = in;
    double val;

    puts( "Enter some floating-point numbers, please:" );
    scanf( "%%[^\n]", in );

    puts( "Here are the values you entered:" );
    while ( 1 )
    {
        val = strtod( this, &next );
        if ( next == this )     // Means no conversion was possible.
            break ;
        printf( "\t%%g\n", val );
        this = next;            // Try again with the rest of the input string.
    }
    puts( "Done." );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtok_ex">
			<text>
				<![CDATA[// strtok_ex.c : strtok() example
// -------------------------------------------------------------

#include <string.h>  // char *strtok( char * restrict s1, 
                     //               const char * restrict s2 );
#include <stdio.h>

int main()
{
    char *command, *arg1, *arg2, *comment;
    char line[] = " mul eax,[ebp+4] ; Multiply by y\n";

    command = strtok(line," \t");   // First word, between spaces or tabs.
    arg1 = strtok( NULL, ",");      // From there to the comma is arg1.
                                    // (Trim off any spaces later.)
    arg2 = strtok( NULL, ";\n");    // From there to a semicolon or line end.
    comment = strtok( NULL, "\n\r\v\f" );  // From there to end of line or
                                           //page.
    printf( "Command:      %%s\n"
            "1st argument: %%s\n"
            "2nd argument: %%s\n"
            "Comment:      %%s\n\n",
            command, arg1, arg2, comment );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtok_s_ex">
			<text>
				<![CDATA[// strtok_s_ex.c : strtok_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>  // char *strtok_s( char * restrict s1, 
                     //                 rsize_t * restrict s1max,
                     //                 const char * restrict s2, 
                     //                 char ** restrict ptr);
#include <stdio.h>

int main()
{
    char str[] = "Lennon, John: 10/9/1940";
    char *ptr;
    size_t size = sizeof(str);
    char *firstname, *lastname, *birthday;

    lastname = strtok_s( str, &size, ", ", &ptr);
    if( lastname != NULL)
       firstname = strtok_s(NULL, &size, ": ", &ptr);
    if( firstname != NULL)
       birthday = strtok_s(NULL, &size, "", &ptr);
    if(birthday != NULL)
       printf("%%s %%s was born on %%s.\n",
              firstname, lastname, birthday);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strtoul_ex">
			<text>
				<![CDATA[// strtoul_ex.c : strtoul() example
// -------------------------------------------------------------

#include <stdlib.h>  // unsigned long strtoul( const char * restrict s,
                     //                        char ** restrict endptr,
                     //                        int base );
#include <stdio.h>

int main()
{
    char dotted[ ] = "172.16.2.10", *ptr = dotted, *nextdot = NULL;
    unsigned long dest = 0;

    // This for loop uses stroul() to convert an IPv4 address from a 
    // dotted-decimal string to a 32-bit integer value:
    for ( int i = 0; i < 4; i++)
    {
        dest <<= 8;
        dest += strtoul( ptr, &nextdot, 10 );
        ptr = nextdot + 1;
    }
    printf( "The IPv4 address %%s\n"
            "represents the 32-bit integer value %%lu\n",
             dotted, dest );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_strxfrm_ex">
			<text>
				<![CDATA[// strxfrm_ex.c : strxfrm() example
// -------------------------------------------------------------

#include <string.h>  // size_t strxfrm( char * restrict dest,
                     //                 const char * restrict src,
                     //                 size_t n );
#include <locale.h>
#include <stdlib.h>
#include <stdio.h>

typedef struct stringpair { char * original;
                            char * xformed; } Stringpair_t ;

Stringpair_t stringpairs[8] =
             { { "Chávez", NULL },        { "Carron", NULL },
               { "Canoso", NULL },        { "Cañoso", NULL },
               { "Carteño", NULL },       { "Cortillo", NULL },
               { "Cortiluz S.A.", NULL }, { "Corriando", NULL } };

char xformbuffer[1024];           // Space to catch each strxfrm() result.

int stringpaircmp( const void * p1, const void *p2 );
                                  // Defined externally.

int main()
{
    setlocale( LC_COLLATE, "");    // Use the host system's locale setting.
//    printf( "The locale is %%s.\n", setlocale( LC_COLLATE, NULL) );

    for ( int i = 0; i < 8 ; i++ )
    {
        stringpairs[i].xformed
        = malloc( strxfrm( xformbuffer, stringpairs[i].original, 1024 ) + 1 );
        if ( stringpairs[i].xformed != NULL )
           strcpy(stringpairs[i].xformed, xformbuffer);
    }

    qsort( stringpairs, 8, sizeof(Stringpair_t), stringpaircmp );

    for ( int i = 0; i < 8 ; i++ )
        puts( stringpairs[i].original );

    return 0;
}

int stringpaircmp( const void * sp1, const void *sp2 )
{
    const char * s1 = ((Stringpair_t *)sp1)->xformed;
    const char * s2 = ((Stringpair_t *)sp2)->xformed;
    return strcmp( s1, s2 );
}
]]>
			</text>
		</p>
		<p n="xc_swprintf_ex">
			<text>
				<![CDATA[// swprintf_ex.c : swprintf() example
// -------------------------------------------------------------

#include <wchar.h>  // int swprintf( wchar_t * restrict dest, size_t n,
                    //               const wchar_t * restrict format, ... );
#include <stdlib.h>

const wchar_t *dollar_as_wstr( long amount)
// Converts a number of cents into a wide string
// showing dollars and cents.
// For example, converts -123456 into the wide string L"-$1234.56"
{
    static wchar_t buffer[16];
    wchar_t sign[2] = L"";

    if ( amount < 0L)
       amount = -amount, sign[0] = '-';

    ldiv_t dollars_cents = ldiv( amount, 100);
    swprintf( buffer, sizeof(buffer),
              L"%%ls$%%ld.%%2ld", sign, dollars_cents.quot, dollars_cents.rem);

    return buffer;
}

#include <stdio.h>

int main()
{
    fputws( dollar_as_wstr( -123456), stdout );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_system_ex">
			<text>
				<![CDATA[// system_ex.c : system() example
// -------------------------------------------------------------

#include <stdlib.h>    // int system( const char *s );
#include <stdio.h>

int main()
{
    if ( system( NULL ))
       system( "echo \"Shell: $SHELL; process ID: $$\"");
    else
       printf( "No command processor available.\n" );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tan_ex">
			<text>
				<![CDATA[// tan_ex.c : tan() example
// -------------------------------------------------------------

#include <math.h>    // double tan( double x );
                     // float tanf( float x );
                     // long double tanl( long double x );
#include <stdio.h>

int main()
{
    const double pi = 4.0L * atan( 1.0 );     // Because tan(pi/4) = 1
    double shadow_length = 85.5,
           angle = 36.2;         // Sun's elevation from the horizon, in
                                 // degrees
    double height = shadow_length *tan ( angle * pi/180);

    printf("The tower is %%.2f meters high.\n", height);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tanh_ex">
			<text>
				<![CDATA[// tanh_ex.c : tanh() example
// -------------------------------------------------------------

#include <math.h>    // double tanh( double x );
                     // float tanhf( float x );
                     // long double tanhl( long double x );
#include <stdio.h>

int main()
{
    double x = -0.5, y1, y2;

    y1 = tanh(x);
    y2 = exp(2*x);
    y2 = (y2 -1) / (y2 + 1);

    printf("The tanh() function returns     %%.15f.\n", y1 );
    printf("Using the function exp() yields %%.15f.\n", y2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_create_ex">
			<text>
				<![CDATA[// thrd_create_ex.c : thrd_create() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
#include <stdio.h>

int th_func(void * arg)         // The thread function.
{
    puts("Hello from th_func ...");
    ++*(int*)arg;
    return 0;
}

int main()
{
    thrd_t th; int n = 1;

    if ( thrd_create(&th, th_func, &n) != thrd_success) {
       fprintf(stderr, "Error creating thread.\n"); return -1;
    }
    puts("Main thread here ...");

    thrd_join(th, NULL);
    printf("The value of n is %%d\n", n);       // n == 2

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_detach_ex">
			<text>
				<![CDATA[// thrd_detach_ex.c : thrd_detach() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_detach( thrd_t thr);
#include <stdio.h>

void independent_thread(void)
{
    puts("Working independently in the background ... ");
    // . . .
    thrd_exit(0);
}
int create_independent_thread(void)
{
    thrd_t th;
    if( thrd_create(&th, (thrd_start_t)independent_thread, "")
                                              != thrd_success)
      return -1;
    if( thrd_detach(th) != thrd_success)
       return -1;
    puts("Started independent thread.");
    return 0;
}

int main()
{
    create_independent_thread();

    puts("Main thread here ...");

    // Working ...
    struct timespec d = { .tv_nsec = 1E6 };  // 1 ms. 
    thrd_sleep( &d, NULL);

    puts("Main thread done.");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_thrd_equal_ex">
			<text>
				<![CDATA[// thrd_equal_ex.c : thrd_equal() example
// -------------------------------------------------------------

#include <threads.h>  // int thrd_equal(thrd_t thr1, thrd_t thr2);
#include <stdio.h>

thrd_t mainThrd;

int func(void)
{
    if( thrd_equal( thrd_current(), mainThrd) )
    { puts("Main thread here ...");  return 0; }
    else
    { puts("Other thread here ..."); return 1; }
}

int main()
{
    thrd_t th;

    mainThrd = thrd_current();

    if ( thrd_create(&th, (thrd_start_t)func, NULL) != thrd_success)
    { fprintf(stderr, "Error creating thread.\n"); return -1; }

    func();
    thrd_join(th, NULL);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_timespec_get_ex">
			<text>
				<![CDATA[// timespec_get_ex.c : timespec_get() example
// -------------------------------------------------------------

#include <time.h>   // int timespec_get(struct timespec *ts, int base);
#include <stdio.h>

int main()
{
    struct timespec ts;

    if( timespec_get( &ts, TIME_UTC) != 0)
        printf("The exact local time:\n"
               "%%.24s and %%09lu nanoseconds\n", ctime(&ts.tv_sec), ts.tv_nsec);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tmpfile_ex">
			<text>
				<![CDATA[// tmpfile_ex.c : tmpfile(), tmpfile_s() example
// -------------------------------------------------------------

#include <stdio.h>   // FILE *tmpfile( void );
                     // errno_t tmpfile_s(FILE * restrict * restrict streamPtr);
#include <errno.h>

int main()
{
    FILE *fpTmp, *fpRx;
    int c;

    /* ... open Rx stream ... */
    fpRx = stdin;

    if (( fpTmp = tmpfile() ) == NULL )
    // or
    // if( tmpfile_s( &fpTmp) != 0 )
        fputs( "Unable to open a temporary file.", stderr );
    else
    {
        while (( c = fgetc( fpRx )) != EOF )
            if ( fputc( c, fpTmp ) == EOF )
               break;
    }
    fclose( fpRx );

    /* ... process the data captured in fpTmp ... */

    rewind( fpTmp);
    while( (c = fgetc( fpTmp)) != EOF)
       putchar(c);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_tmpnam_ex">
			<text>
				<![CDATA[// tmpnam_ex.c : tmpnam(), tmpnam_s() example
// -------------------------------------------------------------

#include <stdio.h>   // char *tmpnam( char *s );
                     // errno_t tmpnam_s(char *s, rsize_t maxsize);
#include <errno.h>

int main()
{
    char fname[L_tmpnam];
    // or
    // char fname[L_tmpnam_s];
    FILE *fpOut;

    if( tmpnam( fname) == NULL)
    // or
    // if( tmpnam_s( fname, sizeof(fname)) != 0)
    {
        fputs( "Error generating a temporary file name.", stderr );
        return -1;
    }

    fpOut = fopen( fname, "w+" );

    fputs( "... write and edit something in the file ...\n", fpOut );    
    fclose( fpOut );
    printf( "The results have been saved in %%s.\n", fname );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_towctrans_ex">
			<text>
				<![CDATA[// towctrans_ex.c : towctrans() example
// -------------------------------------------------------------

#include <wctype.h>  // wint_t towctrans( wint_t wc, wctrans_t desc );
#include <wchar.h>

int main()
{
   wint_t before = L'\0', after = L'\0';
   wctrans_t mapping;
   mapping = wctrans("toupper");

   while (( before = getwchar() ) != WEOF )
   {
       after = towctrans( before, mapping );
       putwchar( after );
       if ( after == L'Q' )
          break;
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_trunc_ex">
			<text>
				<![CDATA[// trunc_ex.c : trunc() example
// -------------------------------------------------------------

#include <math.h>    // double trunc( double x );
                     // float truncf( float x );
                     // long double truncl( long double x );
#include <stdio.h>

int main()
{
    printf("trunc(-1.7) = %%.2f  trunc(1.4) = %%.2f  trunc(1.5) = %%.2f\n",
            trunc(-1.7), trunc(1.4), trunc(1.5) );

    printf("round(-1.7) = %%.2f  round(1.4) = %%.2f  round(1.5) = %%.2f\n",
            round(-1.7), round(1.4), round(1.5) );

    return 0;
}
]]>
			</text>
		</p>
		<p n="tss_set_ex">
			<text>
				<![CDATA[// tss_set_ex.c : tss_set() example
// -------------------------------------------------------------

#include <threads.h>  // int tss_set(tss_t *key, void * ptr);
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

tss_t key;               // Global key for a TSS pointer
                         // tss_create(&key, ...) has been called.

typedef char Data_t;

size_t size_data( Data_t *dPtr)
{
    size_t size = strlen( dPtr) + 1;
    return size;
}

// Process some data of some type Data_t:
int process_data(void)   // Use thread-specific storage.
{
    Data_t *ptr = (Data_t*)tss_get(key); // Pointer to TSS

    puts("Process data ...");
    puts( ptr);
    return 0;
}

int thread_func( void* arg)
{
    size_t size = size_data( arg);   // A helper function to find the
                                     // required storage size.
    // Set thread-specific storage:
    if( tss_set(key, malloc(size)) != thrd_success)
       return -1;

    // Store and process data ...
    memcpy( tss_get(key), arg, size);
    return process_data();           // return calls the destructor, if
}                                    // the tss_create() call set one.

void destructor(void *data)
{
    printf("Destructor for %%s\n", (char*)data);
    free(data);                    // Release memory.
}

int main(void)
{
    thrd_t th1, th2;
    int result1 = 0, result2 = 0;

    // Create the TSS key:
    if (tss_create(&key, destructor) != thrd_success)
       return -2;

    // Create threads:
    if ( thrd_create(&th1, thread_func, "Thread_1 ... ")
                                           != thrd_success
         || thrd_create(&th2, thread_func, "... Thread_2 ")
                                           != thrd_success )
       return -3;

    thrd_join( th1, &result1);
    thrd_join( th2, &result2);
    if ( result1 != 0 || result2 != 0)
       fputs("Thread error\n", stderr);
    else
       puts("Threads finished without error.");

    tss_delete(key); // Free all resources of the TSS pointer.
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_ungetc_ex">
			<text>
				<![CDATA[// ungetc_ex.c : ungetc() example
// -------------------------------------------------------------

#include <stdio.h>       // int ungetc( int c, FILE *fp );
#include <stdlib.h>
#include <ctype.h>

int main()
{
    char file[ ] = "input.dat";
    FILE *fp;
    int c;
    char numstr[64];

    if (( fp = fopen( file, "r" )) == NULL )
       fprintf( stderr, "Can't read the file %%s\n", file), exit(1);

    while ( (c = getc(fp)) != EOF )
    {
       if ( isdigit(c) )              // Collect a sequence of digits.
       {
          int i = 0;
          do
          {
             numstr[i++] = (char)c;
             c = getc(fp);
          }while ( isdigit(c) && i+1 < sizeof(numstr) );

          numstr[i] = '\0';            // Terminate the numeral string.

          /* ... process the numeral string ... */
          puts( numstr);

          if ( ungetc( c, fp) == EOF)  // Put back the first non-digit.
             break;
          continue;
       }

       /* ... process any non-digit characters ... */
    }
    if ( !feof( fp))
       fprintf( stderr, "Error processing the file %%s\n", file);

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_va_arg_ex">
			<text>
				<![CDATA[// va_arg_ex.c : va_arg(), va_copy, va_end(), va_start() example
// -------------------------------------------------------------

#include <stdarg.h>  // void va_start( va_list argptr, last_fixed_arg );
                     // type va_arg( va_list argptr, type );
                     // void va_copy( va_list dest, va_list src );
                     // void va_end( va_list argptr );
#include <stdio.h>
#include <string.h>
#include <math.h>

double vproduct( int n, va_list argptr );
double vsum( int n, va_list argptr );

double vop( const char * op, int argcount, ... );

// main() calls vop() to perform calculations. vop()'s arguments are:
// (1) the name of the operation ("sum", "product",
//     "sum minus the product");
// (2) the number of operands;
// (3 through n) the operands themselves.
// Iterates through operations twice: once with three operands, once
// with six.

int main()
{
    double d1, d2, d3, d4, d5, d6;

    puts( "Enter six floating-point numbers, please:" );
    scanf( "%%lf%%lf%%lf%%lf%%lf%%lf", &d1, &d2, &d3, &d4, &d5, &d6 );

    char *operation[] = {"sum", "product", "product minus the sum",NULL};

    printf("\nUsing the three numbers %%lf, %%lf, and %%lf.\n", d1, d2, d3);
    for ( int i = 0; operation[i] != NULL; i++ )
    {
        printf( "The %%s of these %%d numbers is %%lf\n", 
                 operation[i], 3, vop( operation[i], 3, d1, d2, d3 ) );
    }

    printf( "\nUsing six numbers:"
            "\n\t%%lf \t%%lf \t%%lf \n\t%%lf \t%%lf \t%%lf\n",
            d1, d2, d3, d4, d5, d6 );
    for ( int i = 0; operation[i] != NULL; i++ )
    {
        printf( "The %%s of these %%d numbers is %%lf\n",
                operation[i], 6, 
                vop( operation[i], 6, d1, d2, d3, d4, d5, d6 ) );
    }
}

double vop( const char * op, int argcount, ... )
{
    va_list argptr;
    double result;

    va_start( argptr, argcount );
    if ( strcmp( op, "sum" ) == 0 )
       result = vsum( argcount, argptr );
    else if ( strcmp( op, "product" ) == 0 )
       result = vproduct( argcount, argptr );
    else if ( strcmp( op, "product minus the sum" ) == 0 )
    {
       va_list duplicate_argptr;       // Clone the va_list in its present
                                       // state.
       va_copy( duplicate_argptr, argptr );
       result = vproduct( argcount, argptr )
                - vsum( argcount, duplicate_argptr );
       va_end( duplicate_argptr );     // Clean up the clone.
    }

    else result = NAN;

    va_end( argptr ); // Clean up the original.
    return result;
}

double vproduct( int n, va_list argptr )
{
    double product = 1.0;

    for ( int i = 0; i < n; i ++ )
        product *= va_arg( argptr, double );

    return product;
}

double vsum( int n, va_list argptr )
{
    double sum = 0.0;

    for ( int i = 0; i < n; i ++ )
        sum += va_arg( argptr, double );

    return sum;
}
]]>
			</text>
		</p>
		<p n="xc_vfprintf_ex">
			<text>
				<![CDATA[// vfprintf_ex.c : vfprintf() example
// -------------------------------------------------------------

#include <stdio.h>   
#include <stdarg.h>
// int vfprintf( FILE * restrict fp, const char * restrict format, va_list argptr );
// int vprintf( const char * restrict format, va_list argptr );
// int vsprintf( char * restrict buffer, const char * restrict format,
//               va_list argptr );
// int vsnprintf( char * restrict buffer, size_t n, const char * restrict format, //                va_list argptr );

#include <time.h>

// write_log appends a line to the log file associated with the
// FILE pointer fp_log.
// The format string and optional arguments are the same as for printf().

FILE *fp_log;
 
void write_log(const char *function_name, unsigned int line_num,
               const char *format_str, ...)
{
    if ( fp_log == NULL)
       return;
    time_t timestamp = time(NULL);
    va_list argptr;

    // Set argptr to the first optional argument:
    va_start( argptr, format_str);

    // First print the timestamp, function name, and line number:
    fprintf( fp_log, "%%.8s %%s (line %%u): ",
                     ctime(&timestamp)+11, function_name, line_num);
    // Then print the rest of the message:
    vfprintf( fp_log, format_str, argptr);
}

void myFunc( int param)
{
    write_log( __func__, __LINE__, "param = %%d\n", param);
    /* ... */
}

int main()
{
    fp_log = stderr;
    myFunc( 777);    
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_vfscanf_ex">
			<text>
				<![CDATA[// vfscanf_ex.c : vscanf() example
// -------------------------------------------------------------

#include <stdio.h>   
#include <stdarg.h>
// int vfscanf( FILE * restrict fp, const char * restrict format,
//              va_list argptr );
// int vscanf( const char * restrict format, va_list argptr );
// int vsscanf( const char * restrict src, const char * restrict format,
//              va_list argptr );


typedef struct {
    char lastname[20];
    char firstname[20];
    int dob_month;
    int dob_day;
    int dob_year;
} person;

person employee;

int read_person( char *lname, char *fname, ... )
// As variable arguments (...) use NULL
// or three int pointers (month, day, year).
{
    va_list args;
    int count;

    puts( "Enter the last name and first name (Example: Smith, Sally)");
    count = scanf( "%%[^,], %%[^\n]", lname, fname );      // Read the name.

    va_start(args, fname);    // Initialize args to start with the argument
                              // that follows fname in the function call.
    if ( count == 2 && va_arg(args, int*) != NULL )
    {
        va_end( args);
        va_start( args, fname);     // Initialize args again.

        printf( "Enter the date of birth. (Example: 9/21/1962)\n");
        count += vscanf( "%%d/%%d/%%d", args ); // Read date of birth.
    }
#ifdef DEBUG
    fprintf( stderr, "Read %%d fields.\n", count);
#endif // def DEBUG

    va_end( args );
    return count;
}

int main()
{
   person *pEmployee = &employee;
   int result;

   result = read_person( pEmployee->lastname,
                         pEmployee->firstname,
                         &pEmployee->dob_month,
                         &pEmployee->dob_day,
                         &pEmployee->dob_year );
#ifdef DEBUG
    fprintf( stderr, "Fields read: %%s, %%s; born %%d-%%d-%%d\n",
             pEmployee->lastname,
             pEmployee->firstname,
             pEmployee->dob_month,
             pEmployee->dob_day,
             pEmployee->dob_year );
#endif // def DEBUG
}
]]>
			</text>
		</p>
		<p n="xc_wcrtomb_s_ex">
			<text>
				<![CDATA[// wcrtomb_s_ex.c : wcrtomb_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t wcrtomb_s( size_t * restrict retval,
                     //                    char * restrict dest, rsize_t destmax,
                     //                    wchar_t wc, mbstate_t * restrict ps);
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);
    printf( "\nThe current locale is '%%s'.\n", setlocale( LC_CTYPE, NULL ) );

    wchar_t wc = L'\u00b1';     //'±'
    char mbStr[MB_CUR_MAX];
    size_t nBytes = 0;
    mbstate_t state = {0};

    if( wcrtomb_s( &nBytes, mbStr, sizeof(mbStr), wc, &state ) != 0)
    { /* Handle the error ... */
        fputs("Error ...", stderr);  return -1;
    }

    printf("Character: '%%lc'; multibyte code:", wc);     // '±'
    for( unsigned i = 0; i < nBytes; ++i)
        printf(" %%#04x", (unsigned char)mbStr[i]);       // 0xc2 0xb1
    putchar('\n');

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscat_ex">
			<text>
				<![CDATA[// wcscat_ex.c : wcscat(), wcscat_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for wcscat_s()

#include <wchar.h>
   // wchar_t *wcscat( wchar_t * restrict s1, const wchar_t * restrict s2 );
   // errno_t wcscat_s( wchar_t * restrict s1, rsize_t s1max,
   //                   const wchar_t * restrict s2);
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    wchar_t  lastname[32];
    wchar_t  firstname[32];
    _Bool    ismale;
} Name;

int main()
{
    Name *newName = calloc( 1, sizeof(Name) );

    /* ... check for calloc failure; read in the name parts ... */
    if( newName == NULL)
    {  fprintf( stderr, "Out of memory\n" ); return -1; }
    *newName = (Name) { L"Lincoln", L"Abraham", 1 };

    // Then display the new name
    wchar_t displayname[80];
    wcscpy( displayname, ( newName->ismale ? L"Mr. " : L"Ms. " ) );
    wcscat( displayname, newName->firstname );
    wcscat( displayname, L" " );
    wcscat( displayname, newName->lastname );
    wcscat( displayname, L"\n" );

    // Better to use wcscat_s() in case the fields in the Name
    // structure are ever enlarged:
    // wcscat_s( displayname, sizeof(displayname), newName->firstname );
    // wcscat_s( displayname, sizeof(displayname), L" " );
    // wcscat_s( displayname, sizeof(displayname), newName->lastname );
    // wcscat_s( displayname, sizeof(displayname), L"\n" );

    fputws( displayname, stdout );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcschr_ex">
			<text>
				<![CDATA[// wcschr_ex.c : wcschr() example
// -------------------------------------------------------------

#include <wchar.h>   // wchar_t *wcschr( const wchar_t *s, wchar_t c );
#include <stdio.h>
#include <stdlib.h>

typedef struct { wchar_t street[32];
                 wchar_t city[32];
                 wchar_t stateprovince[32];
                 wchar_t zip[16];
               } Address;

wchar_t printaddr[128] = L"720 S. Michigan Ave.\nChicago, IL 60605\n";

int main()
{
    int sublength;
    Address *newAddr = calloc( 1, sizeof(Address) );

    if ( newAddr != NULL )
    {
        sublength = wcschr( printaddr, L'\n' ) - printaddr;
        wcsncpy( newAddr->street, printaddr,
                 (sublength < 31 ? sublength : 31) );
        /* ... */
        fputws( newAddr->street, stdout );
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscmp_ex">
			<text>
				<![CDATA[// wcscmp_ex.c : wcscmp() example
// -------------------------------------------------------------

#include <wchar.h>   // int wcscmp( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>

int main()
{
    int result = 0;
    wchar_t word1[255]=L"X1", word2[256] = L"X2", *greaterlessequal;

    while ( result < 2 )
    {
        fputws( L"Type two words, please: ", stdout );
        result = wscanf( L"%%255ls %%255ls", word1, word2 );
        if ( result == EOF )
           return EOF;
    }
    result = wcscmp( word1, word2 );

    if ( result < 0 )
       greaterlessequal = L"less than";
    else if ( result > 0 )
       greaterlessequal = L"greater than";
    else
       greaterlessequal = L"the same as";

    wprintf( L"The word \"%%ls\" is %%ls the word \"%%ls\".\n", 
             word1, greaterlessequal, word2 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscoll_ex">
			<text>
				<![CDATA[// wcscoll_ex.c : wcscoll() example
// -------------------------------------------------------------

#include <wchar.h>  // int wcscoll( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>
#include <locale.h>

int main()
{
    wchar_t *samples[ ] = { L"anejo", L"añeja",};

    setlocale( LC_COLLATE, "es_US.UTF-8" );
    
    int result = wcscoll( samples[0], samples[1] );

    wprintf( L"In the locale %%s, ", setlocale( LC_COLLATE, NULL ));

    if ( result == 0 )
        wprintf( L"the wide strings \"%%ls\" and \"%%ls\" are alphabetically "
                 "equivalent.\n", samples[0], samples[1] );
    else if ( result < 0 )
        wprintf( L"the wide string \"%%ls\" precedes \"%%ls\" "
                 "alphabetically.\n", samples[0], samples[1] );
    else if ( result > 0 )
        wprintf( L"the wide string \"%%ls\" comes after \"%%ls\" "
                 "alphabetically.\n", samples[0], samples[1] );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscpy_ex">
			<text>
				<![CDATA[// wcscpy_ex.c : wcscpy(), wcscpy_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1   // for wcscpy_s()

#include <wchar.h>  // wchar_t *wcscpy(wchar_t * restrict dest,
                    //                 const wchar_t * restrict src);
                    // errno_t wcscpy_s(wchar_t * restrict dest,
                    //                  rsize_t destmax,
                    //                  const wchar_t * restrict src);
#include <stdio.h>

int main()
{
    struct record {
      wchar_t name[64];
      int age;
      _Bool male, smoking, discount;
    } this;
    int results;

    wprintf( L"Last name: " );
    results = wscanf( L"%%63l[^\n]", this.name );

    if ( results < 1 )
        wcscpy( this.name, L"[Name not available]" );
    // or:
    // wcscpy_s( this.name, sizeof(this.name)/sizeof(wchar_t),
    //           L"[Name not available]" );

    wprintf( L"%%ls\n", this.name );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcscspn_ex">
			<text>
				<![CDATA[// wcscspn_ex.c : wcscspn() example
// -------------------------------------------------------------

#include <wchar.h>  // size_t wcscspn( const wchar_t *s1, const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t *path = L"/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games";
    int separator;

    wchar_t *basename = L"aprogram";
    wchar_t fullname[1024] = L"";

    separator = wcscspn( path, L":" );  // Obtain the index of the first colon.

    wcsncpy( fullname, path, separator );
    fullname[separator] = '\0';

    wcsncat( fullname, L"/", sizeof(fullname) - wcslen(fullname) -1 );
    wcsncat( fullname, basename, sizeof(fullname) - wcslen(fullname) -1 );

    fputws( fullname, stdout );

    return 0;
}
]]>
			</text>
		</p>
		<p n="ex_wcsftime_ex">
			<text>
				<![CDATA[// wcsftime_ex.c : wcsftime() example
// -------------------------------------------------------------

#include <time.h>   // size_t wcsftime( wchar_t * restrict s, size_t n,
#include <wchar.h>  //                  const wchar_t * restrict format,
                    //                  const struct tm * restrict timeptr );
#include <stdio.h>

#define MAX_HDR 1024

int main()
{
    time_t now;
    struct tm *localnow;
    wchar_t hdr_date[MAX_HDR] = L"";

    time( &now );
    localnow = localtime( &now );

    if( wcsftime( hdr_date, MAX_HDR, L"Date: %%a, %%d %%b %%Y %%T %%z", localnow))
       fputws( hdr_date, stdout );
    else
       return -1;

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcslen_ex">
			<text>
				<![CDATA[// wcslen_ex.c : wcslen() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcslen( const wchar_t *s );

int main()
{
    wchar_t line[1024] =
            L"This string could easily be 400 or 500 characters long. "
            L"This string could easily be 400 or 500 characters long. "
            L"\n";
    wchar_t *readptr = line;

    int columns = 80;
    while( wcslen( readptr ) > columns)  // While remaining text is too long,
    {                                    // print a chunk with a final
       wprintf(L"%%.*ls\\\n", columns-1, readptr);  // backslash and newline.
       readptr += columns -1;
    }
    wprintf( L"%%ls\n", readptr);     // Print the rest, ending with a newline.

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsncmp_ex">
			<text>
				<![CDATA[// wcsncmp_ex.c : wcsncmp() example
// -------------------------------------------------------------

#include <wchar.h>   // int wcsncmp( const wchar_t *s1,
                     //              const wchar_t *s2, size_t n );

int main()
{
    wchar_t *months[] = { L"January", L"February", L"March", L"April",
                          L"May", L"June", L"July", L"August",
                          L"September", L"October", L"November", L"December"};

    wchar_t date[ ] = L"Thu, 10 Mar 2005 13:44:18 +0100";
    int mo = 0;
    while (( mo < 12 ) && ( wcsncmp( date + 8, months[mo], 3 ) != 0 ))
        mo++;

    if( mo < 12)
       wprintf( L"Month: %%ls\n", months[mo] ); 

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcspbrk_ex">
			<text>
				<![CDATA[// wcspbrk_ex.c : wcspbrk() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wcspbrk( const wchar_t *s1,
                       //                   const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t *story = L"He shouted: \"What? I can't hear you!\"\n";
    wchar_t separators[ ] = L" \t\n.:?!\"";
    wchar_t *start = story, *end = NULL;
    wchar_t words[16][16];   // An array of wchar_t arrays to collect words in. 
    int i = 0;

    while ( i < 16 && ( end = wcspbrk( start, separators ) ) != NULL )
    {
      if ( end != start )             // If the separator wasn't the first
      {                               // character in the substring,
         wcsncpy( words[i], start, end - start );  // then save a word.
         words[i][end - start] = L'\0';            // And terminate it.
         i++;
      }
      start = end + 1;                // Next wcspbrk call starts with the
    }                                 // character after this separator.

    fputws( story, stdout );

    for ( int j = 0 ; j < i ; j++ )
    {
       fputws( words[j], stdout );
       fputwc( L'\n', stdout );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsrchr_ex">
			<text>
				<![CDATA[// wcsrchr_ex.c : wcsrchr() example
// -------------------------------------------------------------

#include <wchar.h>  // wchar_t *wcsrchr( const wchar_t *s, wchar_t wc );
#include <stdlib.h>

int main( int argc, char ** argv )
{
    wchar_t wmyname[256];

    size_t result = mbstowcs( wmyname, argv[0], 256 );
    if ( result == -1 )
       return -1;

    wchar_t *mybasename = wcsrchr( wmyname, L'/' ); // End of path
    if ( mybasename != NULL )
      mybasename++;
    else
      mybasename = wmyname;

    wprintf( L"This program was invoked as %%ls.\n", mybasename );
}
]]>
			</text>
		</p>
		<p n="xc_wcsrtombs_ex">
			<text>
				<![CDATA[// wcsrtombs_ex.c : wcsrtombs() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcsrtombs( char * restrict dest,
                     //                   const wchar_t **restrict src,
                     //                   size_t n, 
                     //                   mbstate_t * restrict state );
#include <string.h>
#include <locale.h>
#include <stdio.h>

int main()
{
    int i = 0, n = 0;
    size_t result;
    wchar_t wc;
    char mbstring[256] = { '\0' };

    wchar_t widestring[]
            = L"This is originally a string of wide characters.";
    const wchar_t *wcsptr = widestring;
    mbstate_t state;

    printf( "The current locale is %%s.\n", setlocale(LC_CTYPE, "") );

    memset( &state, '\0', sizeof state );
    result = wcsrtombs( mbstring, &wcsptr, 256, &state );

    printf("The return value: %%d\n", (int)result );
    if( result > 0 && wcsptr == NULL )
       printf("The multibyte string: \"%%s\"\n", mbstring);

   return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsrtombs_s_ex">
			<text>
				<![CDATA[// wcsrtombs_s_ex.c : wcsrtombs_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1
#include <wchar.h>   // errno_t wcsrtombs_s(size_t * restrict retval,
                     //                     char * restrict dest, 
                     //                     rsize_t destmax,
                     //                     const wchar_t ** restrict src,
                     //                     rsize_t n,
                     //                     mbstate_t * restrict state);
#include <locale.h>
#include <stdio.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);

    wchar_t widestr[] = L"A wide-character string ...";
    const wchar_t *wcptr = widestr;     // A pointer to a wide character.
    char mbstr[100] = "";               // For the multibyte string.
    size_t mblen = 0;
    mbstate_t mbstate = {0};            // Conversion state.

    if( wcsrtombs_s( &mblen, mbstr, sizeof(mbstr),
                     &wcptr, 3, &mbstate) == 0)
    {
        printf("Multibyte length: %%zu; character codes: [", mblen);
        for( size_t i = 0; i < mblen; ++i)
            printf(" %%X", (unsigned char)mbstr[i]);
        puts(" ]");

        if( wcptr != NULL)
            printf("Wide characters remaining: \"%%ls\"\n", wcptr);
    }
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsspn_ex">
			<text>
				<![CDATA[// wcsspn_ex.c : wcsspn() example
// -------------------------------------------------------------

#include <wchar.h>     // size_t wcsspn( const wchar_t *s1,
                       //                const wchar_t *s2 );
#include <stdio.h>

int main()
{
    wchar_t wordin[256];
    double val;

    fputws( L"Enter a floating-point number, please: ", stdout );
    wscanf( L"%%ls", wordin );

    int index = wcsspn( wordin, L"+-0123456789eE." );
    if ( index < wcslen( wordin ) )
       wprintf ( L"Sorry, but the character %%lc is not permitted.\n",
                 wordin[index] );
    else
    {
       swscanf( wordin, L"%%lg", &val );
       wprintf( L"You entered the value %%g\n", val );
    }

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsstr_ex">
			<text>
				<![CDATA[// wcsstr_ex.c : wcsstr() example
// -------------------------------------------------------------

#include <wchar.h>     // size_t wcsstr( const wchar_t *s1,
                       //                const wchar_t *s2 );
#include <stdlib.h>
#include <stdio.h>

#define MAX_LINE 1024

int main( int argc, char **argv )
{
    FILE *fpIn = NULL;
    wchar_t keyword[MAX_LINE] = { L'\0' };
    wchar_t line[MAX_LINE] = { L'\0' };

    if ( argc != 3 )
    {
        wprintf( L"Syntax: %%s <keyword> <filename>\n", argv[0] );
        return -1;
    }

    if (( fpIn = fopen( argv[2], "r" )) == NULL )
       return -2;
    else
       fwide( fpIn, 1 );

    if ( mbstowcs( keyword, argv[1], MAX_LINE ) == -1 )
       return -3;

    int count = 0;
    while ( fgetws( line, MAX_LINE, fpIn ) != NULL )
       if ( wcsstr( line, keyword ) != NULL )
       {
           ++count;
           fputws( line, stdout );
       }

    if ( !feof( fpIn ))
       return -4;
    else
       return count;
}
]]>
			</text>
		</p>
		<p n="xc_wcstod_ex">
			<text>
				<![CDATA[// wcstod_ex.c : wcstod() example
// -------------------------------------------------------------

#include <wchar.h>     // double wcstod( const wchar_t * restrict wcs,
                       //                wchar_t ** restrict endptr );
                       // float wcstof( const wchar_t * restrict wcs,
                       //               wchar_t ** restrict endptr ); 
                       // long double wcstold( const wchar_t * restrict wcs,
                       //                      wchar_t ** restrict endptr );
#include <stdio.h>

int main()
{
    wchar_t in[1024], *this = in, *next = in;
    double val;

    fputws( L"Enter some floating-point numbers, please:\n", stdout );
    wscanf( L"%%l[^\n]", in );

    fputws( L"Here are the values you entered:\n", stdout );
    while ( 1 )
    {
        val = wcstod( this, &next );
        if ( next == this )           // Means no conversion possible.
            break ;
        this = next;
        wprintf( L"\t%%g\n", val );
    }
    fputws( L"Done.\n", stdout );
    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstok_ex">
			<text>
				<![CDATA[// wcstok_ex.c : wcstok() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wcstok( wchar_t * restrict s1, 
                       //                  const wchar_t * restrict s2,
                       //                  wchar_t ** restrict ptr );

int main()
{
    wchar_t *mnemonic, *arg1, *arg2, *comment, *ptr;
    wchar_t line[ ] = L" mul eax,[ebp+4] ; Multiply by y\n";

    // First word between spaces or tabs
    mnemonic = wcstok( line, L" \t", &ptr );
    arg1 = wcstok( NULL, L",", &ptr );    // From there to the comma is arg1.
                                          // Trim off any spaces later.
    arg2 = wcstok( NULL, L";\n", &ptr );  // From there to the semicolon is
                                          // arg2.
    // To line or page end is comment:
    comment = wcstok( NULL, L"\n\r\v\f", &ptr );

    wprintf( L"Mnemonic:     %%ls\n"
             L"1st argument: %%ls\n"
             L"2nd argument: %%ls\n"
             L"Comment:      %%ls\n\n",
             mnemonic, arg1, arg2, comment );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstol_ex">
			<text>
				<![CDATA[// wcstol_ex.c : wcstol(), wcstoll() example
// -------------------------------------------------------------

#include <wchar.h>     // long int wcstol( const wchar_t * restrict wcs,
                       //                  wchar_t ** restrict endptr, int base );
                       // long long int wcstoll( const wchar_t * restrict wcs,
                       //                        wchar_t ** restrict endptr, 
                       //                        int base );

int main()
{
    wchar_t date[ ] = L"10/3/2005, 13:44:18 +0100", *more = date;
    long day, mo, yr, hr, min, sec, tzone;

    day = wcstol( more, &more, 10 ); // &more is the address of a
    mo  = wcstol( more+1, &more, 10 ); // pointer
    yr  = wcstol( more+1, &more, 10 );
    hr  = wcstol( more+1, &more, 10 );
    min = wcstol( more+1, &more, 10 );
    sec = wcstol( more+1, &more, 10 );
    tzone = wcstol( more+1, &more, 10 );

    wprintf( L"It's now %%02ld:%%02ld o'clock on %%02ld-%%02ld-%%02ld.\n",
             hr, min, mo, day, yr %% 100 );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstombs_ex">
			<text>
				<![CDATA[// wcstombs_ex.c : wcstombs() example
// -------------------------------------------------------------

#include <stdlib.h>   // size_t wcstombs( char * restrict dest, 
                      //                  const wchar_t * restrict src,
                      //                  size_t n );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    if( setlocale(LC_ALL, "") == NULL)
       fputs("Unable to set the locale.\n", stderr);

    wchar_t fmt_amount[128] = { L'\0' };
    wchar_t prefix[32]  = L"-";
    wchar_t suffix[32]  = L"€";
    wchar_t number[128] = L"123.456,78";
    char output_amount[256];

    wcscpy( fmt_amount, prefix );
    wcscat( fmt_amount, number );
    wcscat( fmt_amount, suffix );

    if ( -1 != wcstombs( output_amount, fmt_amount, 256 ))
        printf( "Full amount: %%s\n", output_amount );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcstoumax_ex">
			<text>
				<![CDATA[// wcstoumax_ex.c : wcstoumax() example
// -------------------------------------------------------------

#include <stddef.h>
#include <inttypes.h>  // uintmax_t wcstoumax( const wchar_t * restrict wcs,
                       //                      wchar_t ** restrict endptr, int base );
#include <wchar.h>

typedef struct {
    uintmax_t packets, bytes;
    wchar_t policy[16];
    wchar_t protocol[6];
    /* ... */
} stats_t ;

int main()
{
    stats_t iface_in = {0};
    wchar_t wcsstat[] =
            L"25183 1633438 ACCEPT tcp -- eth2 * 0.0.0.0/0 tcp dpts:80";
    wchar_t *wcsptr = wcsstat;

    iface_in.packets = wcstoumax( wcsptr, &wcsptr, 10 );
    iface_in.bytes = wcstoumax( ++wcsptr, &wcsptr, 10 );
    /* ... */

    wprintf( L"Packets: %%" PRIuMAX "; bytes: %%" PRIuMAX "; policy: ...\n",
             iface_in.packets, iface_in.bytes );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wcsxfrm_ex">
			<text>
				<![CDATA[// wcsxfrm_ex.c : wcsxfrm() example
// -------------------------------------------------------------

#include <wchar.h>   // size_t wcsxfrm( wchar_t * restrict dest, 
                     //                 const wchar_t * restrict src,
                     //                 size_t n );
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

typedef struct stringpair { wchar_t * original;
                            wchar_t * xformed;
                          } Stringpair_t ;

int stringpaircmp( const void *p1, const void *p2 );

int main()
{
    wchar_t *originals[] = { L"Chávez", L"Carron", L"Canoso",
                             L"Cañoso", L"Carteño", L"Corriando",
                             L"Carilo", L"Carillón", };
    wchar_t xformbuffer[1024];

    /* Make an array of structures out of the strings and their
       xformations */

    const int elementcount = sizeof(originals) / sizeof(wchar_t *);
    Stringpair_t stringpairs[elementcount];

    setlocale( LC_ALL, "es_US.UTF-8" );   // Set the locale to US Spanish
    wprintf( L"Sorting order in the locale %%s:\n",
             setlocale( LC_COLLATE, NULL ));

    for ( int i = 0; i < elementcount ; i++ )
    {
        stringpairs[i].original = originals[i];
        stringpairs[i].xformed
                    = malloc( wcsxfrm( xformbuffer, originals[i], 1024 ));
        if ( stringpairs[i].xformed != NULL )
           wcscpy( stringpairs[i].xformed, xformbuffer );
    }

    qsort( stringpairs, elementcount,
           sizeof(Stringpair_t), stringpaircmp );

    for ( int i = 0; i < elementcount ; i++ )
    {
        fputws( stringpairs[i].original, stdout );
        fputwc( L'\n', stdout );
    }
} // end of main()

/* A comparison function for use by qsort. Uses wcscmp() rather
 * that wcscoll(), assuming strings are paired with their wcsxfrm()
 * results in a Stringpair_t structure.
*/
int stringpaircmp( const void *p1, const void *p2 )
{
    const Stringpair_t * sp1 = (Stringpair_t *)p1;
    const Stringpair_t * sp2 = (Stringpair_t *)p2;

    return wcscmp( sp1->xformed, sp2->xformed );
}
]]>
			</text>
		</p>
		<p n="xc_wctomb_ex">
			<text>
				<![CDATA[// wctomb_ex.c : wctomb() example
// -------------------------------------------------------------

#include <stdlib.h>   // int wctomb( char *s, wchar_t wc );
#include <wchar.h>
#include <stdio.h>
#include <limits.h>
#include <locale.h>

int main()
{
    char mbbuffer[MB_LEN_MAX] = { '\0' };
    wchar_t wcs[] = L"Wir stehen auf den Füßen von Riesen";
    int n = 0, i = 0;

    printf( "The current locale is %%s.\n", setlocale( LC_CTYPE, "" ));
    printf( "The locale's multibyte encoding is %%s.\n",
             (wctomb( NULL, L'\0' ) ? "stateful" : "stateless" ));

    do {
        n += wctomb( mbbuffer, wcs[i] );
    } while ( wcs[i++] != L'\0' );

    printf( "The wide string \"%%ls\" \nis %%u wide characters long.\n"
            "Its multibyte representation requires a buffer of %%u bytes.\n",
            wcs, wcslen( wcs ), n );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wctomb_s_ex">
			<text>
				<![CDATA[// wctomb_s_ex.c : wctomb_s() example
// -------------------------------------------------------------

#define __STDC_WANT_LIB_EXT1__ 1         // For wctomb_s()

#include <stdlib.h>   // errno_t wctomb_s( int * restrict status,
                      //                   char * restrict s,
                      //                   rsize_t smax, 
                      //                   wchar_t wc);
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    setlocale(LC_ALL, "en_US.utf8");

    wchar_t wc = L'\u03B1';       // Greek lowercase alpha α
    char mbStr[MB_CUR_MAX];
    int nBytes = 0;

    // if( (nBytes = wctomb( mbStr, wc )) < 0)
    // is equivalent to
    if( wctomb_s( &nBytes, mbStr, sizeof(mbStr), wc ) != 0)
    { /* error: */ return -1; }

    printf("Wide-character code: %%#06x; character: '%%lc'; "
           "multibyte code:", wc, wc);
    for( int i = 0; i < nBytes; ++i)
        printf(" %%#04x", (unsigned char)mbStr[i]);
    putchar('\n');

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wctype_ex">
			<text>
				<![CDATA[// wctype_ex.c : wctype() example
// -------------------------------------------------------------

#include <wctype.h>   // wctype_t wctype( const char *property );
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main()
{
    wctype_t wct_kanji, wct_kata, wct_hira  /* , ... */ ;

    if ( setlocale( LC_CTYPE, "ja_JP.UTF-8" ) == NULL)
        fputws(L"Unable to set the locale.\n", stderr);

    if (( wct_kata = wctype( "jkata" ) ) == 0 )
    {   wprintf( L"The locale doesn't support the wide-character type "
                  "string \"jkata\".\n" ); 
        return -1;
    }
    /* ... */
    wchar_t wc = fgetwc( stdin );
    if ( iswctype( wc, wct_kata ) )          // Mainly 0xFF66 − 0xFF9F.
        wprintf( L"%%lc is a katakana character.\n", wc );
    else
        wprintf( L"%%lc is a not katakana character.\n", wc );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_wmemcpy_ex">
			<text>
				<![CDATA[// wmemcpy_ex.c : wmemcpy(), wmemcpy_s() example
// -------------------------------------------------------------

#include <wchar.h>     // wchar_t *wmemcpy( wchar_t * restrict dest, 
                       //                   const wchar_t * restrict src,
                       //                   size_t n );
                       // errno_t wmemcpy_s( wchar_t * restrict dest, rsize_t destmax,
                       //                    const wchar_t * restrict src, 
                       //                    rsize_t n);
#include <stdio.h>
#include <stdlib.h>

#define BUFFERSIZE 2048     // Size as a number of wchar_t elements.

wchar_t inputbuffer[BUFFERSIZE] = { L'\0' },
        *writeptr = inputbuffer;

struct block { wchar_t *text;
               struct block *next;
               struct block *prev;
             } firstblock = { NULL },  // The first block is the list head.
               *tmp = NULL;

struct block *newblock( struct block *lastblock );
                                           // Creates a linked-list member.
wchar_t *storetext( struct block *listhead,
                    wchar_t *buffer,
                    size_t bufsize );
                         // Copies input buffer to a new linked-list member.

int main()
{
    while( fgetws( writeptr, BUFFERSIZE - (writeptr - inputbuffer), stdin)
           != NULL )
    {
       // Set writeptr to end of the input string:
       writeptr = wmemchr( inputbuffer, L'\0',
                           sizeof(inputbuffer) / sizeof(wchar_t) );

       if ( BUFFERSIZE - (writeptr - inputbuffer) < 80 )
                                            // If block full, or nearly so:
       {                                    // copy buffer to a data block.
           writeptr = storetext( &firstblock, inputbuffer, BUFFERSIZE );
           if ( writeptr == NULL )          // Out of memory!
              abort();
       }
    }    // Here if fgetws() returns NULL.

    writeptr = storetext( &firstblock, inputbuffer, BUFFERSIZE );
    if ( writeptr == NULL )                 // Out of memory!
       abort();
}

// ----------------------------
wchar_t *storetext(struct block *listhead,
                   wchar_t *buffer, size_t bufsize)
    // Copies input buffer to a new chained-list member;
    // returns pointer to input buffer, or NULL on failure.
{
    struct block *tmp = listhead;     // create new block on end of list ...
    while ( tmp->next != NULL )
       tmp = tmp->next;
    if (( tmp = newblock( tmp )) != NULL )
       wmemcpy( tmp->text, buffer, bufsize );     // ... and copy the text.
    // Or:
    // wmemcpy_s( tmp->text, BUFFERSIZE, buffer, bufsize );
    else            // Out of memory!
       return NULL;

#ifdef DEBUG
    fwprintf( stderr, L"\nStored a block with this text:\n%%ls\n",
              tmp->text );
#endif

    return buffer;     // Return pointer to buffer, now ready for re-use.
}

// ----------------------------
struct block *newblock( struct block *lastblock )
   // Allocates a new block and appends it to the chained list;
   // returns pointer to new block, or NULL on failure.
{
   if (( lastblock->next = malloc( sizeof(struct block) )) != NULL
         && ( lastblock->next->text
                 = malloc( BUFFERSIZE * sizeof(wchar_t) )) != NULL)
   {
      lastblock->next->prev = lastblock;
      lastblock->next->next = NULL;
      return lastblock->next;
   }
   else            // Out of memory!
      return NULL;
}
]]>
			</text>
		</p>
		<p n="xc_wscanf_ex">
			<text>
				<![CDATA[// wscanf_ex.c : wscanf() example
// -------------------------------------------------------------

#include <stdio.h>
#include <wchar.h>
    // int wscanf( const wchar_t * restrict format, ... );
    // int wscanf_s( const wchar_t * restrict format, ... );

int main()
{
    wchar_t perms[12];
    wchar_t name[256];
    unsigned int ownerid, groupid, links;
    unsigned long size;
    int count;

    count = wscanf( L"%%11l[rwxsStTld-+]%%u%%u%%u%%lu%%*10s%%*5s%%256ls",
                    perms, &links, &ownerid, &groupid, &size, name );

wprintf(L"%%ls %%u %%u %%u %%lu %%ls\n", 
         perms, links, ownerid, groupid, size, name );
    wprintf( L"\nThe file %%ls has a length of %%lu bytes.\n", name, size );

    return 0;
}
]]>
			</text>
		</p>
		<p n="xc_circle">
			<text>
				<![CDATA[// circle.c: Calculate the areas of circles and
// print them in ncurses mode
// $ gcc -o circle  circle.c -lncurses

#include <curses.h>               // Console control functions
double circularArea( double r );  // Function for the math
void circle();                    // Function for output

int main()        // Starts and stops curses display mode
{

/* Set up the console behavior: */
    (void) initscr();      // Initialize the curses system
    keypad(stdscr, TRUE);  // Enable keyboard mapping
    (void) nonl();         // Disable line-end translation
    (void) cbreak();       // Take single input characters

/* Run the circle routine: */
    circle(); 
    printw( "Press any key to exit." );
    refresh();             // Put the output on the screen

/* Finish: */
    getch();               // Wait for user to press a key
    endwin();              // Shut down curses console
    return 0;
}

// The circle.c program from Example 1.1, but replacing the
// standard library function printf() with printw() from the
// ncurses library.
void circle()
{
  double radius = 1.0, area = 0.0;
  printw("    Areas of Circles\n\n" );
  printw("     Radius          Area\n"
          "-------------------------\n" );
  area = circularArea( radius );
  printw( "%%10.1f     %%10.2f\n", radius, area ); 
  radius = 5.0;
  area = circularArea( radius );
  printw( "%%10.1f     %%10.2f\n", radius, area ); 
}

// Return the area of a circle with radius r
double circularArea( double r )
{
  const double pi = 3.1415926536; // Pi is a constant 
  return  pi * r * r;
}
]]>
			</text>
		</p>
		<p n="xlnx_epoll">
			<text>
				<![CDATA[/***************************************** 

* File Name : epoll.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : https://suchprogramming.com/epoll-in-3-easy-steps/

******************************************/

/**
 *  Purpose:
 *
 */

#define MAX_EVENTS 5
#define READ_SIZE 10
#include <stdio.h>     // for fprintf()
#include <unistd.h>    // for close(), read()
#include <sys/epoll.h> // for epoll_create1(), epoll_ctl(), struct epoll_event
#include <string.h>    // for strncmp

int main()
{
  int running = 1, event_count, i;
  size_t bytes_read;
  char read_buffer[READ_SIZE + 1];
  struct epoll_event event;
  struct epoll_event events[MAX_EVENTS];
  int epoll_fd = epoll_create1(0);

  if(epoll_fd == -1)
  {
    fprintf(stderr, "Failed to create epoll file descriptor\n");
    return 1;
  }

  event.events = EPOLLIN;
  event.data.fd = 0;

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, 0, &event))
  {
    fprintf(stderr, "Failed to add file descriptor to epoll\n");
    close(epoll_fd);
    return 1;
  }

  while(running)
  {
    printf("\nPolling for input...\n");
    event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, 30000);
    printf("%%d ready events\n", event_count);
    for(i = 0; i < event_count; i++)
    {
      printf("Reading file descriptor '%%d' -- ", events[i].data.fd);
      bytes_read = read(events[i].data.fd, read_buffer, READ_SIZE);
      printf("%%zd bytes read.\n", bytes_read);
      read_buffer[bytes_read] = '\0';
      printf("Read '%%s'\n", read_buffer);

      if(!strncmp(read_buffer, "stop\n", 5))
        running = 0;
    }
  }


  if(close(epoll_fd))
  {
    fprintf(stderr, "Failed to close epoll file descriptor\n");
    return 1;
  }
  return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_mmap">
			<text>
				<![CDATA[/***************************************** 

* File Name : mmap.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>

/**
 * ******************************************************
 * 
void * realloc (void *addr, size_t len)
{
        size_t old_size = look_up_mapping_size (addr);
        void *p;

        p = mremap (addr, old_size, len, MREMAP_MAYMOVE);
        if (p == MAP_FAILED)
                return NULL;
        return p;
}
 * ******************************************************
**/


/**
 * ******************************************************
 * #include <sys/mman.h>

int mprotect (const void *addr,
              size_t len,
              int prot);
 * ******************************************************
**/

/**
 * ******************************************************
 * #include <sys/mman.h>

int msync (void *addr, size_t len, int flags);
 * ******************************************************
**/


/**
 * ******************************************************
 * The only unfamiliar system call in this example should be 
 * fstat(), which we will cover in Chapter 8. All you need to
 * know at this point is that fstat() returns information 
 * about a given file. 
 *
 * The S_ISREG() macro can check some 
 * of this information so that we can ensure that the given
 * file is a regular file (as opposed to a device file or a 
 * directory) before we map it. 
 *
 * The behavior of nonregular
 * files when mapped depends on the backing device.
 * Some device files are mmap-able; other nonregular files 
 * are not mmap-able and will set errno to EACCES.
 *
 * The rest of the example should be straightforward. The program is
 * passed a filename as an argument. It opens the file, ensures 
 * it is a regular file, maps it, closes it, prints the file 
 * byte-by-byte to standard out, and then unmaps the file from memory.
 * ******************************************************
**/
int main (int argc, char *argv[])
{
        struct stat sb;
        off_t len;
        char *p;
        int fd;

        if (argc < 2) {
                fprintf (stderr, "usage: %%s <file>\n", argv[0]);
                return 1;
        }

        fd = open (argv[1], O_RDONLY);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        if (fstat (fd, &sb) == -1) {
                perror ("fstat");
                return 1;
        }

        if (!S_ISREG (sb.st_mode)) {
                fprintf (stderr, "%%s is not a file\n", argv[1]);
                return 1;
        }

        p = mmap (0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
        if (p == MAP_FAILED) {
                perror ("mmap");
                return 1;
        }

        if (close (fd) == -1) {
                perror ("close");
                return 1;
        }

        for (len = 0; len < sb.st_size; len++)
                putchar (p[len]);

        if (munmap (p, sb.st_size) == -1) {
                perror ("munmap");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_readv">
			<text>
				<![CDATA[/***************************************** 

* File Name : readv.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/uio.h>

int main ()
{
        char foo[48], bar[51], baz[49];
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        fd = open ("buccaneer.txt", O_RDONLY);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        /* set up our iovec structures */
        iov[0].iov_base = foo;
        iov[0].iov_len = sizeof (foo);
        iov[1].iov_base = bar;
        iov[1].iov_len = sizeof (bar);
        iov[2].iov_base = baz;
        iov[2].iov_len = sizeof (baz);

        /* read into the structures with a single call */
        nr = readv (fd, iov, 3);
        if (nr == -1) {
                perror ("readv");
                return 1;
        }

        for (i = 0; i < 3; i++)
                printf ("%%d: %%s", i, (char *) iov[i].iov_base);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_writev">
			<text>
				<![CDATA[/***************************************** 

* File Name : writev.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/uio.h>

int main ()
{
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        char *buf[] = {
                "The term buccaneer comes from the word boucan.\n",
                "A boucan is a wooden frame used for cooking meat.\n",
                "Buccaneer is the West Indies name for a pirate.\n" };

        fd = open ("buccaneer.txt", O_WRONLY | O_CREAT | O_TRUNC);
        if (fd == -1) {
                perror ("open");
                return 1;
        }

        /* fill out three iovec structures */
        for (i = 0; i < 3; i++) {
                iov[i].iov_base = buf[i];
                iov[i].iov_len = strlen(buf[i]) + 1;
        }
        /* with a single call, write them all out */
        nr = writev (fd, iov, 3);
        if (nr == -1) {
                perror ("writev");
                return 1;
        }
        printf ("wrote %%d bytes\n", (int)nr);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_processor_affinity">
			<text>
				<![CDATA[/***************************************** 

* File Name : processor_affinity.c

* Creation Date : 18-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#define _GNU_SOURCE

#include <sched.h>
#include <error.h>
#include <stdio.h>

#if 0
typedef struct cpu_set_t;

size_t CPU_SETSIZE;

void CPU_SET (unsigned long cpu, cpu_set_t *set);
void CPU_CLR (unsigned long cpu, cpu_set_t *set);
int CPU_ISSET (unsigned long cpu, cpu_set_t *set);
void CPU_ZERO (cpu_set_t *set);

int sched_setaffinity (pid_t pid, size_t setsize,
                       const cpu_set_t *set);

int sched_getaffinity (pid_t pid, size_t setsize,
                       cpu_set_t *set);
#endif


/**
 * ******************************************************
 *  Checks if the cpu is set
 * ******************************************************
**/
void check_set_processors() {
    cpu_set_t set;
    int ret, i;

    CPU_ZERO (&set);
    ret = sched_getaffinity (0, sizeof (cpu_set_t), &set);
    if (ret == -1)
            perror ("sched_getaffinity");

    for (i = 0; i < 8 /*nr of cores*/; i++) {
            int cpu;

            cpu = CPU_ISSET (i, &set);
            printf ("cpu=%%i is %%s\n", i,
                    cpu ? "set" : "unset");
    }
}

/**
 * ******************************************************
 *  Set the hard affinity for the process
 * ******************************************************
**/
void set_hard_affinity() {
    cpu_set_t set;
    int ret, i;

    CPU_ZERO (&set);        /* clear all CPUs */
    CPU_SET (0, &set);      /* allow CPU #0 */
    //CPU_CLR (1, &set);      /* disallow CPU #1 */
                              /* clearing is not necessary */
    ret = sched_setaffinity (0, sizeof (cpu_set_t), &set);
    if (ret == -1)
            perror ("sched_setaffinity");

    for (i = 0; i < 8 /*nr of cores*/; i++) {
            int cpu;

            cpu = CPU_ISSET (i, &set);
            printf ("cpu=%%i is %%s\n", i,
                    cpu ? "set" : "unset");
    }
}

int main(int argc, char ** argv) {
    check_set_processors();
    set_hard_affinity();
}
]]>
			</text>
		</p>
		<p n="xlnx_scheduling">
			<text>
				<![CDATA[/***************************************** 

* File Name : scheduling.c

* Creation Date : 18-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <sched.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>



void wrapper_sched_yield() {
    while(1) {
        sched_yield();
    }
}

/**
 * ******************************************************
 *  Sets the processor niceness:
 *  -20 to 19
 * ******************************************************
**/
void wrapper_nice() {
    int ret, val;

    /* get current nice value */
    val = nice (0);

    /* we want a nice value of 10 */
    val = 10 - val;
    errno = 0;
    ret = nice (val);
    if (ret == -1 && errno != 0)
            perror ("nice");
    else
            printf ("nice value is now %%d\n", ret);
}

/**
 * ******************************************************
 *  which: PRIO_PROCESS
 *         PRIO_PGRP
 *         PRIO_USER
 *
 *  who: PID
 *       0 means current process, group or user
 * ******************************************************
**/
void wrapper_getpriority(int which, int who) {
    int ret = getpriority(which, who);
    printf("nice value is %%d\n", ret);
}

void wrapper_setpriority(int which, int who, int prio) {
    int ret = setpriority(which, who, prio);
    if (ret == -1) perror ("setpriority");
}


int main(int argc, char ** argv) {

}
]]>
			</text>
		</p>
		<p n="xlnx_buffered_io">
			<text>
				<![CDATA[/***************************************** 

* File Name : main.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

/* fcloseall() */
#define _GNU_SOURCE

/* open(), creat(), lseek(), ftruncate */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <stdio.h>

/**
 * ******************************************************
 *  Fopen wrapper
 * ******************************************************
**/
void wrapper_fopen() {
    FILE *stream = NULL;

    stream = fopen("/etc/manifest", "r");
    if (!stream) perror("fopen");

    int close = fclose(stream);
    (void)close;
}

void wrapper_fdopen() {
    FILE *stream = NULL;
    int fd, close;

    fd = open("/tmp/test.txt", O_RDONLY);
    if (fd == -1) perror ("open:");

    stream = fdopen(fd, "r");
    if (!stream) perror("fopen");

    close = fclose(stream);
    (void)close;
}

/**
 * ******************************************************
 *  fgetc wrapper
 * ******************************************************
**/
void wrapper_getc() {
    FILE *stream = NULL;
    int c;

    c = fgetc(stream);

    if (c == EOF) perror("getc:");
    else printf("c=%%c'n", (char) c);

    int ret = ungetc(c, stream);
    (void)ret;
}


/**
 * ******************************************************
 *  fgets() wrapper
 * ******************************************************
**/
void wrapper_fgets() {
    int line_max = 100;
    char buf[line_max];
    FILE *stream = NULL;

    if (!fgets (buf, line_max, stream)) {
        perror("fgets:");
    }
}

/**
 * ******************************************************
 *  Reads a line of data. Also stops reading at delimiter 
 *  'd'
 * ******************************************************
**/
void fgets_substitute(int n, char d, char* str, FILE *stream) {
    char *s;
    int c;

    s = str;

    while (--n > 0 && (c = fgetc(stream)) != EOF && (*s++ = c) != d)
        ;

    if (c == d)
        *--s = '\0';
    else
        *s ='\0' ;
}


/**
 * ******************************************************
 *  Fread() wrapper
 * ******************************************************
**/
void wrapper_fread() {
    FILE *stream = NULL;
    size_t size = 100;
    char buf[(int)size];
    size_t  nr = 1;

    stream = fopen("/etc/manifest", "r");
    if (!stream) perror("fopen");

    size_t ret = fread(buf, size, nr, stream);

    if (ret == 0) perror("fread:");

    int close = fclose(stream);
    (void)close;
}


/**
 * ******************************************************
 *  Wrappers for writing
 * ******************************************************
**/
void wrapper_fputc(FILE *stream) {
    if (fputc('p', stream) == EOF) {
    }
}

void wrapper_fputs() {
    FILE *stream;

    stream = fopen("/tmp/test.txt", "a");
    if (!stream) {
        perror("fopen:");
    }

    if (fputs("The ship is made of wood.\n", stream) == EOF) perror("fputs");

    if (fclose(stream) == EOF) perror("fclose:");
}

void wrapper_fwrite(void *buf, size_t size, size_t nr, FILE *stream) {
    size_t ret = fwrite(buf, size, nr, stream);
    (void) ret;
}


#if 0
#include <stdio.h>
int fseek (FILE *stream, long offset, int whence);
#endif

#if 0
#include <stdio.h>
int fsetpos (FILE *stream, fpos_t *pos);
#endif

#if 0
#include <stdio.h>
void rewind (FILE *stream);o

errno = 0;
rewind (stream);
if (errno)
        /* error */
#endif


#if 0
#include <stdio.h>
long ftell (FILE *stream);
#endif

#if 0
#include <stdioh.h>
int fgetpos (FILE *stream, fpos_t *pos);
#endif


#if 0
#include <stdio.h>
int fflush (FILE *stream);
#endif


#if 0
#include <stdio.h>
int ferror (FILE *stream);
#endif

#if 0
#include <stdio.h>

int feof (FILE *stream);
#endif

#if 0
#include <stdio.h>

void clearerr (FILE *stream);
#endif


#if 0
#include <stdio.h>

int fileno (FILE *stream);
#endif

#if 0
#include <stdio.h>

int setvbuf (FILE *stream, char *buf, int mode, size_t size);
#endif


int main (void)
{
        FILE *in, *out;
        struct pirate {
                char            name[100]; /* real name */
                unsigned long   booty;     /* in pounds sterling */
                unsigned int    beard_len; /* in inches */
        } p, blackbeard = { "Edward Teach", 950, 48 };

        out = fopen ("data", "w");
        if (!out) {
                perror ("fopen");
                return 1;
        }

        if (!fwrite (&blackbeard, sizeof (struct pirate), 1, out)) {
                perror ("fwrite");
                return 1;
        }

        if (fclose (out)) {
                perror ("fclose");
                return 1;
        }

        in = fopen ("data", "r");
        if (!in) {
                perror ("fopen");
                return 1;
        }

        if (!fread (&p, sizeof (struct pirate), 1, in)) {
                perror ("fread");
                return 1;
        }

        if (fclose (in)) {
                perror ("fclose");
                return 1;
        }

        printf ("name=\"%%s\" booty=%%lu beard_len=%%u\n",
                p.name, p.booty, p.beard_len);

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_file_stat">
			<text>
				<![CDATA[/***************************************** 

* File Name : file_stat.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <sys/statvfs.h>
#include <stdlib.h>
#include <sys/types.h>
#include <grp.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <dirent.h>
#include <errno.h>
#include <string.h>
#include <sys/sysmacros.h>
#include <time.h>
#include <math.h>
#include <mntent.h>


/*
 * is_on_physical_device - returns a positive
 * integer if 'fd' resides on a physical device,
 * 0 if the file resides on a nonphysical or
 * virtual device (e.g., on an NFS mount), and
 * −1 on error.
 */
int is_on_physical_device (int fd)
{
        struct stat sb;
        int ret;

        ret = fstat (fd, &sb);
        if (ret) {
                perror ("fstat");
                return -1;
        }

        //return gnu_dev_major (sb.st_dev);
        return 0;
}

void wrapper_change_mod() {
    int ret;
    ret = chmod ("./map.png", S_IRUSR | S_IWUSR);

    if (ret) {
        perror("chmod");
    }
}

void wrapper_fchange_mod(int fd) {
    int ret;
    ret = fchmod (fd, S_IRUSR | S_IWUSR);

    if (ret) {
        perror("fchmod");
    }
}

void wrapper_owner() {
    struct group *gr;
    int ret;
    /*
     * getgrnam() returns information on a group
     * given its name.
     */
    gr = getgrnam ("officers");
    if (!gr) {
            /* likely an invalid group */
            perror ("getgrnam");
            return;
    }

    /* set manifest.txt's group to 'officers' */
    ret = chown("manifest.txt", -1, gr->gr_gid);
    if (ret)
            perror ("chown");
}


/*
 * make_root_owner - changes the owner and group of the file
 * given by 'fd' to root. Returns 0 on success and −1 on
 * failure.
 */
int make_root_owner (int fd)
{
        int ret;

        /* 0 is both the gid and the uid for root */
        ret = fchown (fd, 0, 0);
        if (ret)
                perror ("fchown");

        return ret;
}

/*
 * find_file_in_dir - searches the directory 'path' for a
 * file named 'file'.
 *
 * Returns 0 if 'file' exists in 'path' and a nonzero
 * value otherwise.
 */
int find_file_in_dir (const char *path, const char *file)
{
        struct dirent *entry;
        int ret = 1;
        DIR *dir;

        dir = opendir (path);

        errno = 0;
        while ((entry = readdir (dir)) != NULL) {
                if (strcmp(entry->d_name, file) == 0) {
                        ret = 0;
                        break;
                }
        }

        if (errno && !entry)
                perror ("readdir");

        closedir (dir);
        return ret;
}

void process(const char *filename)
{
	FILE *fp;
	struct mntent *fs;

	fp = setmntent(filename, "r");	/* read only */
	if (fp == NULL) {
		fprintf(stderr, "%%s: could not open: %%s\n",
			filename, strerror(errno));
		exit(1);
	}

	while ((fs = getmntent(fp)) != NULL) {
		//do_statvfs(fs);
        printf("MNT_DIR %%s", fs->mnt_dir);
        printf("fsname %%s", fs->mnt_fsname);
    }

	endmntent(fp);
}

int main (int argc, char *argv[])
{
#if 0
        struct stat sb;
        int ret;

        if (argc < 2) {
                fprintf (stderr,
                         "usage: %%s <file>\n", argv[0]);
                return 1;
        }

        ret = stat (argv[1], &sb);
        if (ret) {
                perror ("stat");
                return 1;
        }

        printf ("%%s is %%ld bytes\n",
                argv[1], sb.st_size);


        printf ("File type: ");
        switch (sb.st_mode & S_IFMT) {
        case S_IFBLK:
                printf("block device node\n");
                break;
        case S_IFCHR:
                printf("character device node\n");
                break;
        case S_IFDIR:
                printf("directory\n");
                break;
        case S_IFIFO:
                printf("FIFO\n");
                break;
        case S_IFLNK:
                printf("symbolic link\n");
                break;
        case S_IFREG:
                printf("regular file\n");
                break;
        case S_IFSOCK:
                printf("socket\n");
                break;
        default:
                printf("unknown\n");
                break;
        }

        return 0;
#endif
        struct stat sb;

        if (argc != 2) {
            fprintf(stderr, "Usage: %%s <pathname>\n", argv[0]);
            exit(1);
        }

        if (lstat(argv[1], &sb) == -1) {
            perror("lstat");
            exit(1);
        }

        printf("ID of containing device:  [%%lx,%%lx]\n",
               (long) major(sb.st_dev), (long) minor(sb.st_dev));

        printf("File type:		     ");

        switch (sb.st_mode & S_IFMT) {
            case S_IFBLK:  printf("block device\n");	       break;
            case S_IFCHR:  printf("character device\n");        break;
            case S_IFDIR:  printf("directory\n");	       break;
            case S_IFIFO:  printf("FIFO/pipe\n");	       break;
            case S_IFLNK:  printf("symlink\n");		       break;
            case S_IFREG:  printf("regular file\n");	       break;
            case S_IFSOCK: printf("socket\n");		       break;
            default:	  printf("unknown?\n"); 	       break;
        }

        printf("I-node number:	     %%ld\n", (long) sb.st_ino);

        printf("Mode:		     %%lo (octal)\n",
               (unsigned long) sb.st_mode);

        printf("Link count:		     %%ld\n", (long) sb.st_nlink);
        printf("Ownership:		     UID=%%ld   GID=%%ld\n",
               (long) sb.st_uid, (long) sb.st_gid);

        printf("Preferred I/O block size: %%ld bytes\n",
               (long) sb.st_blksize);
        printf("File size:		     %%lld bytes\n",
               (long long) sb.st_size);
        printf("Blocks allocated:	     %%lld\n",
               (long long) sb.st_blocks);

        printf("Last status change:	     %%s", ctime(&sb.st_ctime));
        printf("Last file access:	     %%s", ctime(&sb.st_atime));
        printf("Last file modification:   %%s", ctime(&sb.st_mtime));

        struct statvfs stat;

        if (statvfs(argv[1], &stat) != 0) {
            // error happens, just quits here
            return -1;
        }

        printf("Total space: %%.3f GB\n",  (stat.f_bsize * stat.f_blocks) / pow(1024, 3));
        printf("Available space: %%.3f GB\n", (stat.f_bsize * stat.f_bavail) / pow(1024, 3));

        process(argv[1]);

        exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_file_io_main">
			<text>
				<![CDATA[/***************************************** 

* File Name : main.c

* Creation Date : 13-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdbool.h>

/* open(), creat(), lseek(), ftruncate */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/* getcwd(), read(), write(), fsync(), close() */
/* lseek(), pread(), pwrite(), ftruncate() */
#include <unistd.h>

/* printf() */
#include <stdio.h>

/* PATH_MAX */
#include <limits.h>

/* str* calls */
#include <string.h>

/* errno */
#include <errno.h>

/* */
#include "multiplexed_io.h"


/**
 * ******************************************************
 * Opens a file. `man open` for all the flags.
 * ******************************************************
**/
int wrapper_open(const char* str, int flags) {
    int fd = 0;

    fd = open (str, flags);
    if (fd == -1) {
        perror("Error opening file:");
        return 1;
    } else {
        printf("Opened: %%s\n", str);
    }

    return fd;
}


/**
 * ******************************************************
 * The combination of O_WRONLY | O_CREAT | O_TRUNC is so 
 * common that a system call exists to provide just that 
 * behavior:
 * ******************************************************
**/
int wrapper_creat() {
    int fd;
    fd = creat ("some_file", 0644);
    if (fd == -1) {      /* error */
    }

    return 0;
}

/**
 * ******************************************************
 * Wrapper for read.
 * read() can have a plethora of results.
 * `man read` for  possible return values.
 * * also check pread()
 * ******************************************************
**/
ssize_t wrapper_blocking_read(int fd, void *buf, size_t len) {

    ssize_t ret, total_ret = 0;

    if (len > SSIZE_MAX) len = SSIZE_MAX;

    while (len != 0 && (ret = read(fd, buf, len)) != 0) {
        if (ret == -1) {
            if (errno == EINTR) continue;
            /* else */
            perror("blocking read");
            break;
        }
        len -= ret;
        buf += ret;
        total_ret += ret;
    }

    return total_ret;
}

ssize_t wrapper_nonblocking_read(int fd, void *buf, size_t len) {
    ssize_t ret = 0;

    if (len > SSIZE_MAX) len = SSIZE_MAX;

start:
    ret = read(fd, buf, len);
    if (ret == -1) {
        if (errno == EINTR) goto start;
        if (errno == EAGAIN) {
            /* Do some usefull stuff */
            /* Resubmit read again later */
        } else {
            /* else error */
            perror("non-blocking read");
        }
    }

    return ret;
}

/**
 * ******************************************************
 * Write wrapper
 * * also check pwrite()
 * ******************************************************
**/
ssize_t wrapper_write(int fd, const void *buf, size_t count) {
    ssize_t nr;
    int ret;
    bool essential_data_only = true;

    nr = write(fd, buf, strlen(buf));
    if (nr == -1) {
        perror("write error");
    } else if (nr != count) {
        /* possible error, but errno is not set*/
    }

    // Alternativley, open with O_SYNC, O_DSYNC, O_RSYNC
    if (essential_data_only ) {
        ret = fdatasync(fd);
        if (ret == -1) perror("fdatasync error:");
    } else {
        ret = fsync(fd);
        if (ret == -1) perror("fsync error:");
    }

    return nr;
}


ssize_t wrapper_socket_write(int fd, const void *buf, size_t len) {
    ssize_t ret, total_ret;

    /* Trying to write more than SSIZE_MAX results in 
     * undefined behaviour */
    if (len > SSIZE_MAX) len = SSIZE_MAX;

    while (len != 0 && (ret = write (fd, buf, len)) != 0) {
        if (ret == -1) {
            if (errno == EINTR) continue; 
            /*else */
            perror ("write");
            break;
        }
#if 0
        // Uncomment this if you want to flush the data to the hdd
        // Alternativley, open with O_SYNC, O_DSYNC, O_RSYNC
        if (essential_data_only ) {
            ret = fdatasync(fd);
            if (ret == -1) perror("fdatasync error:");
        } else {
            ret = fsync(fd);
            if (ret == -1) perror("fsync error:");
        }
#endif

        len -= ret;
        buf += ret;
        total_ret += ret;
    }

    return total_ret;
}

/**
 * ******************************************************
 *  Close wrapper
 * ******************************************************
**/
int wrapper_close(int fd) {
    int ret = 0;
    if ( (ret = close(fd)) == -1) {
        perror ("close");
    }

    return ret;
}

/**
 * ******************************************************
 *  Lseek wrapper. curr + pos
 *
 *   - SEEK_CUR: if pos = 0, sets cursor to curr pos
 *   - SEEK_END: if pos = 0, sets cursor to end
 *   - SEEK_SET: if pos = 0, sets cursor to beginning
 *
 *   * also check pread() and pwrite()
 *
 * ******************************************************
**/
off_t wrapper_lseek(int fd, off_t pos, int origin) {
    off_t ret;

    /* Set the cursor to poistion pos */
    ret = lseek(fd, pos, SEEK_SET);
    if (ret == (off_t) -1) {
        perror("lseek:");
    }

    return ret;
}

/**
 * ******************************************************
 *  Truncate wrapper
 * ******************************************************
**/
int wrapper_truncate(const char* path, off_t len) {
    int ret;
    ret = truncate ("./pirate.txt", 45);
    if (ret == -1) {
        perror ("truncate");
        return -1;
    } 
    return 0;
}

/**
 * ******************************************************
 *  Sscanf wrapper.
 * ******************************************************
**/
void wrapper_sscanf() {
    int nr = 10;
    const char * line = "10 ten(";
    char str[128];
    if (sscanf (line, "%%d %%64[^(]", &nr, str) < 2) {
        fprintf(stderr, "Bad command in wrapper scanf\n");
        printf("%%s\n", str);
    }
    else {
        printf("%%s\n", str);
    }
}

/**
 * ******************************************************
 *  Main
 * ******************************************************
**/
int main(int argc, char ** argv) {
    int fd;
    char cwd[PATH_MAX];
    char abs_path[PATH_MAX + 30];

    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("Current working dir: %%s\n", cwd);
    } else {
        perror("getcwd() error");
        return 1;
    }

    wrapper_sscanf();

    fd = wrapper_open("/home/teach/pearl", O_WRONLY | O_TRUNC);
    
    strcat(abs_path, cwd);
    strcat(abs_path, "/perl");

    fd = wrapper_open((const char*)abs_path, O_WRONLY | O_TRUNC);
    (void)fd;

    wrapper_select();
    wrapper_poll();

    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_file_io_multiplexed">
			<text>
				<![CDATA[/***************************************** 

* File Name : multiplexed_io.c

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include "multiplexed_io.h"

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <poll.h>

#define TIMEOUT 5
#define BUF_LEN 1024

/**
 * ******************************************************
 * @brief 
 * 1. Tell me when any of these fds become ready for i/o
 * 2. Sleep until one or more fds are ready
 * 3. Woken up! What is ready?
 * 4. Handle all fds ready for i/o without blocking
 * 5. go back to 1.
 * ******************************************************
**/
int wrapper_select() {
    int ret;
    struct timeval tv;
    fd_set readfds;

    /* Wait on stdin for input. */
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);

    /* Wait up to five seconds */
    /* !!!! 
     * This needs to be reinitialized on subsequent calls.
     * pselect() leaves the structure alone. 
     * !!!! */
    tv.tv_sec = TIMEOUT;
    tv.tv_usec = 0;

    /* Now block */
    ret = select(STDIN_FILENO + 1,
                &readfds,
                0,
                0,
                &tv);

    if (ret == -1) {
        perror("select:");
        return 1;
    } else if (!ret) {
        printf("%%d seconds elapsed.\n", TIMEOUT);
        /* The time structure is modified by the select() */
        printf("tv_sec %%d.\n", (int)tv.tv_sec);
        printf("tv_usec %%d.\n", (int)tv.tv_usec);
        return 0;
    }

    /* 
     * Is our fd ready to read?
     * Only one provided, so yes.
     * */
    if (FD_ISSET(STDIN_FILENO, &readfds)) {
        char buf[BUF_LEN + 1];
        int len;

        /* guaranteed to not block */
        len = read (STDIN_FILENO, buf, BUF_LEN);
        if (len == -1) {
            perror("read:");
            return 1;
        }

        if (len) {
            buf[len] = '\0';
            printf("read: %%s.\n", buf);
            /* The time structure is modified by the select() */
            printf("tv_sec %%d.\n", (int)tv.tv_sec);
            printf("tv_usec %%d.\n", (int)tv.tv_usec);
        }

        return 0;
    }

    fprintf(stderr, "This should not happen!\n");
    return 1;
}

/*
 * There are three differences between pselect() and select():
 *  - pselect() uses the timespec structure, not the timeval structure, for its 
 *    timeout parameter. The timespec structure uses seconds and nanoseconds,
 *    not seconds and microseconds, providing theoretically superior timeout 
 *    resolution. In practice, however, neither call reliably provides even
 *    microsecond resolution.
 *  - A call to pselect() does not modify the timeout parameter.
 *    Consequently, this parameter does not need to be
 *    reinitialized on subsequent invocations.
 *  - The select() system call does not have the sigmask parameter.
 *    With respect to signals, when this parameter is set to NULL, pselect()
 *    behaves like select().
 *
 *    The motivation for pselect() are the signals. The app can block indefinetly
 *    if the signall arives between the check for the global signal flag
 *    and the call to select().
 *    sigmask in pselect() blocks signals. Blocked signals are not handled
 *    until they are unblocked. Once pselec() returns, the kernel restors the
 *    old signal mask.
 */



int wrapper_poll() {
    int ret;

    struct pollfd fds[2];
    /* watch stdin for input */
    fds[0].fd = STDIN_FILENO;
    fds[0].events = POLLIN;
    /* watch stdout for ability to write (almost always true) */
    //fds[1].fd = STDOUT_FILENO;
    //fds[1].events = POLLOUT;
    /* All set, block! */
    ret = poll (fds, 1, TIMEOUT * 1000);
    if (ret == -1) {
        perror ("poll");
        return 1;
    }
    if (!ret) {
        printf ("%%d seconds elapsed.\n", TIMEOUT);
        return 0;
    }
    if (fds[0].revents & POLLIN) {
        char buf[BUF_LEN + 1];
        int len;

        /* guaranteed to not block */
        len = read (STDIN_FILENO, buf, BUF_LEN);
        if (len == -1) {
            perror("read:");
            return 1;
        }

        if (len) {
            buf[len] = '\0';
            printf("read: %%s.\n", buf);
        }
        printf ("stdin is readable\n");
    }
    if (fds[1].revents & POLLOUT)
        printf ("stdout is writable\n");
    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_mmap2">
			<text>
				<![CDATA[/***************************************** 

* File Name : mmap.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

/**
 * ******************************************************
 * As an alternative to standard file I/O, the kernel
 * provides an interface that allows an application to
 * map a file into memory, meaning that there is a 
 * one-to-one correspondence between a memory address 
 * and a word in the file. The programmer can then access
 * the file directly through memory, identically to any
 * other chunk of memory-resident data—it is even possible 
 * to allow writes to the memory region to transparently 
 * map back to the file on disk.
 *
 *  - or -
 *
 *  Perhaps because you want to force the use of a memory 
 *  mapping over the heap for a specific allocation, or 
 *  perhaps because you are writing your own memory allocation 
 *  system, you may want to manually create your own 
 *  anonymous memory mapping—either way, Linux makes it easy. 
 *  Recall from Chapter 4 that the system call mmap()
 *  creates a memory mapping and the system call munmap() 
 *  destroys a mapping:
 * ******************************************************
**/
int main(int argc, char ** argv) {
    void *p;
    int fd;

    /* open /dev/zero for reading and writing */
    fd = open ("/dev/zero", O_RDWR);
    if (fd < 0) {
            perror ("open");
            return −1;
    }

    /* map [0,page size) of /dev/zero */
    p = mmap (NULL,                   /* do not care where */
              getpagesize (),         /* map one page */
              PROT_READ | PROT_WRITE, /* map read/write */
              MAP_PRIVATE,            /* private mapping */
              fd,                     /* map /dev/zero */
              0);                     /* no offset */

    if (p == MAP_FAILED) {
            perror ("mmap");
            if (close (fd))
                    perror ("close");
            return −1;
    }

    /* close /dev/zero, no longer needed */
    if (close (fd))
            perror ("close");

    /* 'p' points at one page of memory, use it... */  
}
]]>
			</text>
		</p>
		<p n="xlnx_daemon">
			<text>
				<![CDATA[/***************************************** 

* File Name : daemon.c

* Creation Date : 17-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */


#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/fs.h>

/**
 * ******************************************************
 *  This main() actually is synonymous for:
 *  #include <unistd.h>
 *  int daemon (int nochdir, int noclose)
 * ******************************************************
**/
int main (void)
{
        pid_t pid;
//        int i;

        /* create new process */
        pid = fork ();
        if (pid == -1)
                return -1;
        else if (pid != 0)
                exit (EXIT_SUCCESS);

        /* create new session and process group */
        if (setsid () == -1)
                return -1;

        /* set the working directory to the root directory */
        if (chdir ("/") == -1)
                return -1;

        /* close all open files--NR_OPEN is overkill, but works */
//        for (i = 0; i < NR_OPEN; i++)
//                close (i);

        /* redirect fd's 0,1,2 to /dev/null */
        open ("/dev/null", O_RDWR);     /* stdin */
        dup (0);                        /* stdout */
        dup (0);                        /* stderror */

        /* do its daemon thing... */

        /* Just so you can see it with `ps | grep daemon` */
        while (1) {
            sleep(1);
        }

        return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_exec_prog">
			<text>
				<![CDATA[/***************************************** 

* File Name : exec_prog.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <errno.h>
#include <unistd.h>


int main(int argc, char ** argv) {

    char * const args[] = { "program_name_here", "/hooks.txt", NULL };
    int ret;

    ret = execv ("/usr/bin/vi", args);
    if (ret == -1) perror ("execvp");

    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_fork_call">
			<text>
				<![CDATA[/***************************************** 

* File Name : fork_call.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

void parent_out() {
    printf("parent atexit() succeeded!\n");
}

void child_out() {
    printf("child atexit() succeeded!\n");
}


int main(int argc, char ** argv) {

    pid_t pid;

    pid = fork ();
    if (pid == -1) perror ("fork");
    else if (pid > 0) {
        printf("I am the parent of pid=%%d.\n", pid);
        printf("My pid is =%%d.\n", getpid());

        /* Will call the parent_out function when falling of the 
         * edge. */
        if (atexit(parent_out)) {
            fprintf(stderr, "atexit() failed!\n");
        }

        return 0;
    }
    else if (!pid) {
        /* the child ... */
        printf(" -- I am the the child of pid=%%d.\n", getppid());
        printf(" -- My pid is =%%d.\n", getpid());
        printf(" -- I list files:\n");
        char *const args[] = { "list_child", NULL };
        int ret;

        if (atexit(child_out)) {
            fprintf(stderr, "atexit() failed!\n");
        }
        /* If I uncomment the line below then , the program ends with
         * "atexit() succeeded." Otherwise the execv() flushes all 
         * registered functions with atexit(). */
        //exit(0);

        ret = execv ("/bin/ls", args);
        if (ret == -1) {
                perror ("execv");
                exit (EXIT_FAILURE);
        }

        /* Other things which are lost on exec() family commands:
         *  - Any pending signals are lost.
         *  - Any signals that the process is catching (see Chapter 10)
         *    are returned to their default behavior, as the signal handlers
         *    no longer exist in the process’s address space. 
         *  - Any memory locks (see Chapter 9) are dropped. 
         *  - Most thread attributes are returned to the default values. 
         *  - Most process statistics are reset.  
         *  - Anything related to the process’s memory address space, including any mapped files, 
         *    is cleared. 
         *  - Anything that exists solely in user space, including features of the C library,
         *    such as atexit() behavior, is cleared.  
         *
         * Some properties of the process, 
         * however, do not change. For example, the pid, parent pid, priority, and owning 
         * user and group all remain the same.  Normally, open files are inherited across an exec.
         * This means the newly executed program has full access to all of the files open in the 
         * original process, assuming it knows the file descriptor values. However, this is
         * often not the desired behavior. 
         *
         * The usual practice is to close files before the exec, 
         * although it is also possible to instruct the kernel to 
         * do so automatically via fcntl().  
         */

        return 0;
    }

}
]]>
			</text>
		</p>
		<p n="xlnx_wait_call">
			<text>
				<![CDATA[/***************************************** 

* File Name : wait_call.c

* Creation Date : 16-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdlib.h>
#include <signal.h>


#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>

/**
 * ******************************************************
 *  system(): A short hand function for fork() -> exec()
 * ******************************************************
**/
void wrapper_system() {
    /*
     * During execution of the command, SIGCHLD is blocked, 
     * and SIGINT and SIGQUIT are ignored. Ignoring SIGINT 
     * and SIGQUIT has several implications,
     * particularly if system() is invoked inside a loop. 
     * If calling system() from within a loop, you should 
     * ensure that the program properly checks the exit status of the child.
     * For example:
     */
    do {
        int ret;

        ret = system ("pidof rudderd");
        if (WIFSIGNALED (ret) &&
            (WTERMSIG (ret) == SIGINT ||
             WTERMSIG (ret) == SIGQUIT))
                break; /* or otherwise handle */
    } while (1);
}

/**
 * ******************************************************
 *  The waitid(), more options than waitpid().
 * ******************************************************
**/
void wrapper_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {
    int ret = waitid (idtype, id, infop, options);

    (void)ret;
}

int main(int argc, char ** argv) {
    int status;
    pid_t pid;

    if (!fork ())
            return 1;

    //pid = wait (&status); // Weaksauce

    pid = waitpid(-1, &status, 0); // Better
    /*
     * < −1
     * Wait for any child process whose process group ID 
     * is equal to the absolute value of this value. 
     * For example, passing −500 waits for any process in process group 500.
     *
     * −1
     * Wait for any child process. This is the same behavior as wait().
     *
     * 0
     * Wait for any child process that belongs to the same process 
     * group as the calling process.
     *
     * > 0
     * Wait for any child process whose pid is exactly the value provided.
     * For example, passing 500 waits for the child process with pid 500.
     */

    /*
     * The options parameter is a binary OR of zero or more of the following 
     * options:
     * 
     *  - WNOHANG
     * Do not block, but return immediately if no matching child process has 
     * already terminated (or stopped or continued).
     *  
     *  - WUNTRACED
     * If set, the WIFSTOPPED bit in the returned status parameter is set,
     * even if the calling process is not tracing the child process. 
     * This flag allows for the implementation of more general job control,
     * as in a shell.
     *
     *  - WCONTINUED
     * If set, the WIFCONTINUED bit in the returned status parameter is
     * set even if the calling process is not tracing the child process.
     * As with WUNTRACED, this flag is useful for implementing a shell.
     */
    if (pid == -1)
            perror ("wait");

    printf ("pid=%%d\n", pid);

    if (WIFEXITED (status))
            printf ("Normal termination with exit status=%%d\n",
                    WEXITSTATUS (status));

    if (WIFSIGNALED (status))
            printf ("Killed by signal=%%d%%s\n",
                    WTERMSIG (status),
                    WCOREDUMP (status) ? " (dumped core)" : "");

    if (WIFSTOPPED (status))
            printf ("Stopped by signal=%%d\n",
                    WSTOPSIG (status));

    if (WIFCONTINUED (status))
            printf ("Continued\n");

   return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_signal_handling">
			<text>
				<![CDATA[/***************************************** 

* File Name : signal_handling.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 * https://en.wikipedia.org/wiki/Reentrancy_(computing)
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

/* handler for SIGINT and SIGTERM */
static void signal_handler (int signo)
{
        if (signo == SIGINT)
                printf ("Caught SIGINT!\n");
        else if (signo == SIGTERM)
                printf ("Caught SIGTERM!\n");
        else {
                /* this should never happen */
                fprintf (stderr, "Unexpected signal!\n");
                exit (EXIT_FAILURE);
        }
        exit (EXIT_SUCCESS);
}

int main (void)
{
        /*
         * Register signal_handler as our signal handler
         * for SIGINT.
         */
        if (signal (SIGINT, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGINT!\n");
                exit (EXIT_FAILURE);
        }

        /*
         * Register signal_handler as our signal handler
         * for SIGTERM.
         */
        if (signal (SIGTERM, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGTERM!\n");
                exit (EXIT_FAILURE);
        }

        /* Reset SIGPROF's behavior to the default. */
        if (signal (SIGPROF, SIG_DFL) == SIG_ERR) {
                fprintf (stderr, "Cannot reset SIGPROF!\n");
                exit (EXIT_FAILURE);
        }

        /* Ignore SIGHUP. */
        if (signal (SIGHUP, SIG_IGN) == SIG_ERR) {
                fprintf (stderr, "Cannot ignore SIGHUP!\n");
                exit (EXIT_FAILURE);
        }

        int i = 0;
        while (1) {
            i++;
            printf("Sleeping %%d\n", i);
            sleep(1);
        }

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_threading">
			<text>
				<![CDATA[/***************************************** 

* File Name : threading.c

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License :

******************************************/

/**
 *  Purpose:
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

void * start_thread (void *message)
{
        printf ("%%s\n", (const char *) message);
        return message;
}

int main (void)
{
        pthread_t thing1, thing2;
        const char *message1 = "Thing 1";
        const char *message2 = "Thing 2";

        /* Create two threads, each with a different message. */
        pthread_create (&thing1, NULL, start_thread, (void *) message1);
        pthread_create (&thing2, NULL, start_thread, (void *) message2);

        /*
         * Wait for the threads to exit. If we didn't join here,
         * we'd risk terminating this main thread before the
         * other two threads finished.
         */
        pthread_join (thing1, NULL);
        pthread_join (thing2, NULL);

        return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_thread_safety_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : thread_saftey.h

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef _THREAD_SAFTEY_H_
#define _THREAD_SAFTEY_H_

/**
 * ******************************************************
 * #include <stdio.h>

void flockfile (FILE *stream);
 * ******************************************************
**/

/**
 * ******************************************************
 * #include <stdio.h>

void funlockfile (FILE *stream);
 * ******************************************************
**/


/**
 * ******************************************************
 *  #include <stdio.h>

int ftrylockfile (FILE *stream);
 * ******************************************************
**/


/**
 * ******************************************************
 * 
flockfile (stream);

fputs ("List of treasure:\n", stream);
fputs ("    (1) 500 gold coins\n", stream);
fputs ("    (2) Wonderfully ornate dishware\n", stream);

funlockfile (stream);
 * ******************************************************
**/


/**
 * ******************************************************
 * 
 * #define _GNU_SOURCE

#include <stdio.h>

int fgetc_unlocked (FILE *stream);
char *fgets_unlocked (char *str, int size, FILE *stream);
size_t fread_unlocked (void *buf, size_t size, size_t nr,
                       FILE *stream);
int fputc_unlocked (int c, FILE *stream);
int fputs_unlocked (const char *str, FILE *stream);
size_t fwrite_unlocked (void *buf, size_t size, size_t nr,
                        FILE *stream);
int fflush_unlocked (FILE *stream);
int feof_unlocked (FILE *stream);
int ferror_unlocked (FILE *stream);
int fileno_unlocked (FILE *stream);
void clearerr_unlocked (FILE *stream);
 * ******************************************************
**/


#endif
]]>
			</text>
		</p>
		<p n="xlnx_multiplexed_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : multiplexed_io.h

* Creation Date : 14-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef __MULTIPLEXED_IO_H_
#define __MULTIPLEXED_IO_H_

#include <sys/select.h>
#include <sys/time.h>

/**
 * ******************************************************
 * @brief 
 * 1. Tell me when any of these fds become ready for i/o
 * 2. Sleep until one or more fds are ready
 * 3. Woken up! What is ready?
 * 4. Handle all fds ready for i/o without blocking
 * 5. go back to 1.
 * ******************************************************
**/
int wrapper_select();

int wrapper_poll();

#endif
]]>
			</text>
		</p>
		<p n="xlnx_drv_lddbus">
			<text>
				<![CDATA[/*
 * A virtual bus for LDD sample code devices to plug into.  This
 * code is heavily borrowed from drivers/base/sys.c
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */
/* $Id: lddbus.c,v 1.9 2004/09/26 08:12:27 gregkh Exp $ */

#include <linux/device.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/string.h>
#include "lddbus.h"

MODULE_AUTHOR("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");
static char *Version = "$Revision: 1.9 $";

/*
 * Respond to hotplug events.
 */
static int ldd_hotplug(struct device *dev, char **envp, int num_envp,
		char *buffer, int buffer_size)
{
	envp[0] = buffer;
	if (snprintf(buffer, buffer_size, "LDDBUS_VERSION=%%s",
			    Version) >= buffer_size)
		return -ENOMEM;
	envp[1] = NULL;
	return 0;
}

/*
 * Match LDD devices to drivers.  Just do a simple name test.
 */
static int ldd_match(struct device *dev, struct device_driver *driver)
{
	return !strncmp(dev->bus_id, driver->name, strlen(driver->name));
}


/*
 * The LDD bus device.
 */
static void ldd_bus_release(struct device *dev)
{
	printk(KERN_DEBUG "lddbus release\n");
}
	
struct device ldd_bus = {
	.bus_id   = "ldd0",
	.release  = ldd_bus_release
};


/*
 * And the bus type.
 */
struct bus_type ldd_bus_type = {
	.name = "ldd",
	.match = ldd_match,
	.hotplug  = ldd_hotplug,
};

/*
 * Export a simple attribute.
 */
static ssize_t show_bus_version(struct bus_type *bus, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%%s\n", Version);
}

static BUS_ATTR(version, S_IRUGO, show_bus_version, NULL);



/*
 * LDD devices.
 */

/*
 * For now, no references to LDDbus devices go out which are not
 * tracked via the module reference count, so we use a no-op
 * release function.
 */
static void ldd_dev_release(struct device *dev)
{ }

int register_ldd_device(struct ldd_device *ldddev)
{
	ldddev->dev.bus = &ldd_bus_type;
	ldddev->dev.parent = &ldd_bus;
	ldddev->dev.release = ldd_dev_release;
	strncpy(ldddev->dev.bus_id, ldddev->name, BUS_ID_SIZE);
	return device_register(&ldddev->dev);
}
EXPORT_SYMBOL(register_ldd_device);

void unregister_ldd_device(struct ldd_device *ldddev)
{
	device_unregister(&ldddev->dev);
}
EXPORT_SYMBOL(unregister_ldd_device);

/*
 * Crude driver interface.
 */


static ssize_t show_version(struct device_driver *driver, char *buf)
{
	struct ldd_driver *ldriver = to_ldd_driver(driver);

	sprintf(buf, "%%s\n", ldriver->version);
	return strlen(buf);
}
		

int register_ldd_driver(struct ldd_driver *driver)
{
	int ret;
	
	driver->driver.bus = &ldd_bus_type;
	ret = driver_register(&driver->driver);
	if (ret)
		return ret;
	driver->version_attr.attr.name = "version";
	driver->version_attr.attr.owner = driver->module;
	driver->version_attr.attr.mode = S_IRUGO;
	driver->version_attr.show = show_version;
	driver->version_attr.store = NULL;
	return driver_create_file(&driver->driver, &driver->version_attr);
}

void unregister_ldd_driver(struct ldd_driver *driver)
{
	driver_unregister(&driver->driver);
}
EXPORT_SYMBOL(register_ldd_driver);
EXPORT_SYMBOL(unregister_ldd_driver);



static int __init ldd_bus_init(void)
{
	int ret;

	ret = bus_register(&ldd_bus_type);
	if (ret)
		return ret;
	if (bus_create_file(&ldd_bus_type, &bus_attr_version))
		printk(KERN_NOTICE "Unable to create version attribute\n");
	ret = device_register(&ldd_bus);
	if (ret)
		printk(KERN_NOTICE "Unable to register ldd0\n");
	return ret;
}

static void ldd_bus_exit(void)
{
	device_unregister(&ldd_bus);
	bus_unregister(&ldd_bus_type);
}

module_init(ldd_bus_init);
module_exit(ldd_bus_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_faulty">
			<text>
				<![CDATA[/*
 * complete.c -- the writers awake the readers
 *
 * Copyright (C) 2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: complete.c,v 1.2 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/module.h>
#include <linux/init.h>

#include <linux/sched.h>  /* current and everything */
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>     /* everything... */
#include <linux/types.h>  /* size_t */
#include <linux/completion.h>

MODULE_LICENSE("Dual BSD/GPL");

static int complete_major = 0;

DECLARE_COMPLETION(comp);

ssize_t complete_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) going to sleep\n",
			current->pid, current->comm);
	wait_for_completion(&comp);
	printk(KERN_DEBUG "awoken %%i (%%s)\n", current->pid, current->comm);
	return 0; /* EOF */
}

ssize_t complete_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) awakening the readers...\n",
			current->pid, current->comm);
	complete(&comp);
	return count; /* succeed, to avoid retrial */
}


struct file_operations complete_fops = {
	.owner = THIS_MODULE,
	.read =  complete_read,
	.write = complete_write,
};


int complete_init(void)
{
	int result;

	/*
	 * Register your major, and accept a dynamic number
	 */
	result = register_chrdev(complete_major, "complete", &complete_fops);
	if (result < 0)
		return result;
	if (complete_major == 0)
		complete_major = result; /* dynamic */
	return 0;
}

void complete_cleanup(void)
{
	unregister_chrdev(complete_major, "complete");
}

module_init(complete_init);
module_exit(complete_cleanup);

]]>
			</text>
		</p>
		<p n="xlnx_drv_complete">
			<text>
				<![CDATA[/*
 * complete.c -- the writers awake the readers
 *
 * Copyright (C) 2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: complete.c,v 1.2 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/module.h>
#include <linux/init.h>

#include <linux/sched.h>  /* current and everything */
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>     /* everything... */
#include <linux/types.h>  /* size_t */
#include <linux/completion.h>

MODULE_LICENSE("Dual BSD/GPL");

static int complete_major = 0;

DECLARE_COMPLETION(comp);

ssize_t complete_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) going to sleep\n",
			current->pid, current->comm);
	wait_for_completion(&comp);
	printk(KERN_DEBUG "awoken %%i (%%s)\n", current->pid, current->comm);
	return 0; /* EOF */
}

ssize_t complete_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) awakening the readers...\n",
			current->pid, current->comm);
	complete(&comp);
	return count; /* succeed, to avoid retrial */
}


struct file_operations complete_fops = {
	.owner = THIS_MODULE,
	.read =  complete_read,
	.write = complete_write,
};


int complete_init(void)
{
	int result;

	/*
	 * Register your major, and accept a dynamic number
	 */
	result = register_chrdev(complete_major, "complete", &complete_fops);
	if (result < 0)
		return result;
	if (complete_major == 0)
		complete_major = result; /* dynamic */
	return 0;
}

void complete_cleanup(void)
{
	unregister_chrdev(complete_major, "complete");
}

module_init(complete_init);
module_exit(complete_cleanup);

]]>
			</text>
		</p>
		<p n="xlnx_drv_hello">
			<text>
				<![CDATA[/*                                                     
 * $Id: hello.c,v 1.5 2004/10/26 03:32:21 corbet Exp $ 
 */                                                    
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
	printk(KERN_ALERT "Hello, world\n");
	return 0;
}

static void hello_exit(void)
{
	printk(KERN_ALERT "Goodbye, cruel world\n");
}

module_init(hello_init);
module_exit(hello_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_hellop">
			<text>
				<![CDATA[/*                                                     
 * $Id: hellop.c,v 1.4 2004/09/26 07:02:43 gregkh Exp $ 
 */                                                    
#include <linux/init.h>
#include <linux/module.h>
#include <linux/moduleparam.h>

MODULE_LICENSE("Dual BSD/GPL");

/*                                                        
 * These lines, although not shown in the book,           
 * are needed to make hello.c run properly even when      
 * your kernel has version support enabled                
 */                                                       
                                                          

/*
 * A couple of parameters that can be passed in: how many times we say
 * hello, and to whom.
 */
static char *whom = "world";
static int howmany = 1;
module_param(howmany, int, S_IRUGO);
module_param(whom, charp, S_IRUGO);

static int hello_init(void)
{
	int i;
	for (i = 0; i < howmany; i++)
		printk(KERN_ALERT "(%%d) Hello, %%s\n", i, whom);
	return 0;
}

static void hello_exit(void)
{
	printk(KERN_ALERT "Goodbye, cruel world\n");
}

module_init(hello_init);
module_exit(hello_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_jiq">
			<text>
				<![CDATA[/*
 * jiq.c -- the just-in-queue module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: jiq.c,v 1.7 2004/09/26 07:02:43 gregkh Exp $
 */
 
#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/sched.h>
#include <linux/kernel.h>
#include <linux/fs.h>     /* everything... */
#include <linux/proc_fs.h>
#include <linux/errno.h>  /* error codes */
#include <linux/workqueue.h>
#include <linux/preempt.h>
#include <linux/interrupt.h> /* tasklets */

MODULE_LICENSE("Dual BSD/GPL");

/*
 * The delay for the delayed workqueue timer file.
 */
static long delay = 1;
module_param(delay, long, 0);


/*
 * This module is a silly one: it only embeds short code fragments
 * that show how enqueued tasks `feel' the environment
 */

#define LIMIT	(PAGE_SIZE-128)	/* don't print any more after this size */

/*
 * Print information about the current environment. This is called from
 * within the task queues. If the limit is reched, awake the reading
 * process.
 */
static DECLARE_WAIT_QUEUE_HEAD (jiq_wait);


static struct work_struct jiq_work;



/*
 * Keep track of info we need between task queue runs.
 */
static struct clientdata {
	int len;
	char *buf;
	unsigned long jiffies;
	long delay;
} jiq_data;

#define SCHEDULER_QUEUE ((task_queue *) 1)



static void jiq_print_tasklet(unsigned long);
static DECLARE_TASKLET(jiq_tasklet, jiq_print_tasklet, (unsigned long)&jiq_data);


/*
 * Do the printing; return non-zero if the task should be rescheduled.
 */
static int jiq_print(void *ptr)
{
	struct clientdata *data = ptr;
	int len = data->len;
	char *buf = data->buf;
	unsigned long j = jiffies;

	if (len > LIMIT) { 
		wake_up_interruptible(&jiq_wait);
		return 0;
	}

	if (len == 0)
		len = sprintf(buf,"    time  delta preempt   pid cpu command\n");
	else
		len =0;

  	/* intr_count is only exported since 1.3.5, but 1.99.4 is needed anyways */
	len += sprintf(buf+len, "%%9li  %%4li     %%3i %%5i %%3i %%s\n",
			j, j - data->jiffies,
			preempt_count(), current->pid, smp_processor_id(),
			current->comm);

	data->len += len;
	data->buf += len;
	data->jiffies = j;
	return 1;
}


/*
 * Call jiq_print from a work queue
 */
static void jiq_print_wq(void *ptr)
{
	struct clientdata *data = (struct clientdata *) ptr;
    
	if (! jiq_print (ptr))
		return;
    
	if (data->delay)
		schedule_delayed_work(&jiq_work, data->delay);
	else
		schedule_work(&jiq_work);
}



static int jiq_read_wq(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{
	DEFINE_WAIT(wait);
	
	jiq_data.len = 0;                /* nothing printed, yet */
	jiq_data.buf = buf;              /* print in this place */
	jiq_data.jiffies = jiffies;      /* initial time */
	jiq_data.delay = 0;
    
	prepare_to_wait(&jiq_wait, &wait, TASK_INTERRUPTIBLE);
	schedule_work(&jiq_work);
	schedule();
	finish_wait(&jiq_wait, &wait);

	*eof = 1;
	return jiq_data.len;
}


static int jiq_read_wq_delayed(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{
	DEFINE_WAIT(wait);
	
	jiq_data.len = 0;                /* nothing printed, yet */
	jiq_data.buf = buf;              /* print in this place */
	jiq_data.jiffies = jiffies;      /* initial time */
	jiq_data.delay = delay;
    
	prepare_to_wait(&jiq_wait, &wait, TASK_INTERRUPTIBLE);
	schedule_delayed_work(&jiq_work, delay);
	schedule();
	finish_wait(&jiq_wait, &wait);

	*eof = 1;
	return jiq_data.len;
}




/*
 * Call jiq_print from a tasklet
 */
static void jiq_print_tasklet(unsigned long ptr)
{
	if (jiq_print ((void *) ptr))
		tasklet_schedule (&jiq_tasklet);
}



static int jiq_read_tasklet(char *buf, char **start, off_t offset, int len,
                int *eof, void *data)
{
	jiq_data.len = 0;                /* nothing printed, yet */
	jiq_data.buf = buf;              /* print in this place */
	jiq_data.jiffies = jiffies;      /* initial time */

	tasklet_schedule(&jiq_tasklet);
	interruptible_sleep_on(&jiq_wait);    /* sleep till completion */

	*eof = 1;
	return jiq_data.len;
}




/*
 * This one, instead, tests out the timers.
 */

static struct timer_list jiq_timer;

static void jiq_timedout(unsigned long ptr)
{
	jiq_print((void *)ptr);            /* print a line */
	wake_up_interruptible(&jiq_wait);  /* awake the process */
}


static int jiq_read_run_timer(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{

	jiq_data.len = 0;           /* prepare the argument for jiq_print() */
	jiq_data.buf = buf;
	jiq_data.jiffies = jiffies;

	init_timer(&jiq_timer);              /* init the timer structure */
	jiq_timer.function = jiq_timedout;
	jiq_timer.data = (unsigned long)&jiq_data;
	jiq_timer.expires = jiffies + HZ; /* one second */

	jiq_print(&jiq_data);   /* print and go to sleep */
	add_timer(&jiq_timer);
	interruptible_sleep_on(&jiq_wait);  /* RACE */
	del_timer_sync(&jiq_timer);  /* in case a signal woke us up */
    
	*eof = 1;
	return jiq_data.len;
}



/*
 * the init/clean material
 */

static int jiq_init(void)
{

	/* this line is in jiq_init() */
	INIT_WORK(&jiq_work, jiq_print_wq, &jiq_data);

	create_proc_read_entry("jiqwq", 0, NULL, jiq_read_wq, NULL);
	create_proc_read_entry("jiqwqdelay", 0, NULL, jiq_read_wq_delayed, NULL);
	create_proc_read_entry("jitimer", 0, NULL, jiq_read_run_timer, NULL);
	create_proc_read_entry("jiqtasklet", 0, NULL, jiq_read_tasklet, NULL);

	return 0; /* succeed */
}

static void jiq_cleanup(void)
{
	remove_proc_entry("jiqwq", NULL);
	remove_proc_entry("jiqwqdelay", NULL);
	remove_proc_entry("jitimer", NULL);
	remove_proc_entry("jiqtasklet", NULL);
}


module_init(jiq_init);
module_exit(jiq_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_jit">
			<text>
				<![CDATA[/*
 * jit.c -- the just-in-time module
 *
 * Copyright (C) 2001,2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001,2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: jit.c,v 1.16 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/time.h>
#include <linux/timer.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/types.h>
#include <linux/spinlock.h>
#include <linux/interrupt.h>

#include <asm/hardirq.h>
/*
 * This module is a silly one: it only embeds short code fragments
 * that show how time delays can be handled in the kernel.
 */

int delay = HZ; /* the default delay, expressed in jiffies */

module_param(delay, int, 0);

MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

/* use these as data pointers, to implement four files in one function */
enum jit_files {
	JIT_BUSY,
	JIT_SCHED,
	JIT_QUEUE,
	JIT_SCHEDTO
};

/*
 * This function prints one line of data, after sleeping one second.
 * It can sleep in different ways, according to the data pointer
 */
int jit_fn(char *buf, char **start, off_t offset,
	      int len, int *eof, void *data)
{
	unsigned long j0, j1; /* jiffies */
	wait_queue_head_t wait;

	init_waitqueue_head (&wait);
	j0 = jiffies;
	j1 = j0 + delay;

	switch((long)data) {
		case JIT_BUSY:
			while (time_before(jiffies, j1))
				cpu_relax();
			break;
		case JIT_SCHED:
			while (time_before(jiffies, j1)) {
				schedule();
			}
			break;
		case JIT_QUEUE:
			wait_event_interruptible_timeout(wait, 0, delay);
			break;
		case JIT_SCHEDTO:
			set_current_state(TASK_INTERRUPTIBLE);
			schedule_timeout (delay);
			break;
	}
	j1 = jiffies; /* actual value after we delayed */

	len = sprintf(buf, "%%9li %%9li\n", j0, j1);
	*start = buf;
	return len;
}

/*
 * This file, on the other hand, returns the current time forever
 */
int jit_currentime(char *buf, char **start, off_t offset,
                   int len, int *eof, void *data)
{
	struct timeval tv1;
	struct timespec tv2;
	unsigned long j1;
	u64 j2;

	/* get them four */
	j1 = jiffies;
	j2 = get_jiffies_64();
	do_gettimeofday(&tv1);
	tv2 = current_kernel_time();

	/* print */
	len=0;
	len += sprintf(buf,"0x%%08lx 0x%%016Lx %%10i.%%06i\n"
		       "%%40i.%%09i\n",
		       j1, j2,
		       (int) tv1.tv_sec, (int) tv1.tv_usec,
		       (int) tv2.tv_sec, (int) tv2.tv_nsec);
	*start = buf;
	return len;
}

/*
 * The timer example follows
 */

int tdelay = 10;
module_param(tdelay, int, 0);

/* This data structure used as "data" for the timer and tasklet functions */
struct jit_data {
	struct timer_list timer;
	struct tasklet_struct tlet;
	int hi; /* tasklet or tasklet_hi */
	wait_queue_head_t wait;
	unsigned long prevjiffies;
	unsigned char *buf;
	int loops;
};
#define JIT_ASYNC_LOOPS 5

void jit_timer_fn(unsigned long arg)
{
	struct jit_data *data = (struct jit_data *)arg;
	unsigned long j = jiffies;
	data->buf += sprintf(data->buf, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			     j, j - data->prevjiffies, in_interrupt() ? 1 : 0,
			     current->pid, smp_processor_id(), current->comm);

	if (--data->loops) {
		data->timer.expires += tdelay;
		data->prevjiffies = j;
		add_timer(&data->timer);
	} else {
		wake_up_interruptible(&data->wait);
	}
}

/* the /proc function: allocate everything to allow concurrency */
int jit_timer(char *buf, char **start, off_t offset,
	      int len, int *eof, void *unused_data)
{
	struct jit_data *data;
	char *buf2 = buf;
	unsigned long j = jiffies;

	data = kmalloc(sizeof(*data), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	init_timer(&data->timer);
	init_waitqueue_head (&data->wait);

	/* write the first lines in the buffer */
	buf2 += sprintf(buf2, "   time   delta  inirq    pid   cpu command\n");
	buf2 += sprintf(buf2, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			j, 0L, in_interrupt() ? 1 : 0,
			current->pid, smp_processor_id(), current->comm);

	/* fill the data for our timer function */
	data->prevjiffies = j;
	data->buf = buf2;
	data->loops = JIT_ASYNC_LOOPS;
	
	/* register the timer */
	data->timer.data = (unsigned long)data;
	data->timer.function = jit_timer_fn;
	data->timer.expires = j + tdelay; /* parameter */
	add_timer(&data->timer);

	/* wait for the buffer to fill */
	wait_event_interruptible(data->wait, !data->loops);
	if (signal_pending(current))
		return -ERESTARTSYS;
	buf2 = data->buf;
	kfree(data);
	*eof = 1;
	return buf2 - buf;
}

void jit_tasklet_fn(unsigned long arg)
{
	struct jit_data *data = (struct jit_data *)arg;
	unsigned long j = jiffies;
	data->buf += sprintf(data->buf, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			     j, j - data->prevjiffies, in_interrupt() ? 1 : 0,
			     current->pid, smp_processor_id(), current->comm);

	if (--data->loops) {
		data->prevjiffies = j;
		if (data->hi)
			tasklet_hi_schedule(&data->tlet);
		else
			tasklet_schedule(&data->tlet);
	} else {
		wake_up_interruptible(&data->wait);
	}
}

/* the /proc function: allocate everything to allow concurrency */
int jit_tasklet(char *buf, char **start, off_t offset,
	      int len, int *eof, void *arg)
{
	struct jit_data *data;
	char *buf2 = buf;
	unsigned long j = jiffies;
	long hi = (long)arg;

	data = kmalloc(sizeof(*data), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	init_waitqueue_head (&data->wait);

	/* write the first lines in the buffer */
	buf2 += sprintf(buf2, "   time   delta  inirq    pid   cpu command\n");
	buf2 += sprintf(buf2, "%%9li  %%3li     %%i    %%6i   %%i   %%s\n",
			j, 0L, in_interrupt() ? 1 : 0,
			current->pid, smp_processor_id(), current->comm);

	/* fill the data for our tasklet function */
	data->prevjiffies = j;
	data->buf = buf2;
	data->loops = JIT_ASYNC_LOOPS;
	
	/* register the tasklet */
	tasklet_init(&data->tlet, jit_tasklet_fn, (unsigned long)data);
	data->hi = hi;
	if (hi)
		tasklet_hi_schedule(&data->tlet);
	else
		tasklet_schedule(&data->tlet);

	/* wait for the buffer to fill */
	wait_event_interruptible(data->wait, !data->loops);

	if (signal_pending(current))
		return -ERESTARTSYS;
	buf2 = data->buf;
	kfree(data);
	*eof = 1;
	return buf2 - buf;
}



int __init jit_init(void)
{
	create_proc_read_entry("currentime", 0, NULL, jit_currentime, NULL);
	create_proc_read_entry("jitbusy", 0, NULL, jit_fn, (void *)JIT_BUSY);
	create_proc_read_entry("jitsched",0, NULL, jit_fn, (void *)JIT_SCHED);
	create_proc_read_entry("jitqueue",0, NULL, jit_fn, (void *)JIT_QUEUE);
	create_proc_read_entry("jitschedto", 0, NULL, jit_fn, (void *)JIT_SCHEDTO);

	create_proc_read_entry("jitimer", 0, NULL, jit_timer, NULL);
	create_proc_read_entry("jitasklet", 0, NULL, jit_tasklet, NULL);
	create_proc_read_entry("jitasklethi", 0, NULL, jit_tasklet, (void *)1);

	return 0; /* success */
}

void __exit jit_cleanup(void)
{
	remove_proc_entry("currentime", NULL);
	remove_proc_entry("jitbusy", NULL);
	remove_proc_entry("jitsched", NULL);
	remove_proc_entry("jitqueue", NULL);
	remove_proc_entry("jitschedto", NULL);

	remove_proc_entry("jitimer", NULL);
	remove_proc_entry("jitasklet", NULL);
	remove_proc_entry("jitasklethi", NULL);
}

module_init(jit_init);
module_exit(jit_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_kdataalign">
			<text>
				<![CDATA[/*
 * kdatasize.c -- print the size of common data items from kernel space
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/utsname.h>
#include <linux/errno.h>

/*
 * Define several data structures, all of them start with a lone char
 * in order to present an unaligned offset for the next field
 */
struct c   {char c;  char      t;} c;
struct s   {char c;  short     t;} s;
struct i   {char c;  int       t;} i;
struct l   {char c;  long      t;} l;
struct ll  {char c;  long long t;} ll;
struct p   {char c;  void *    t;} p;
struct u1b {char c;  __u8      t;} u1b;
struct u2b {char c;  __u16     t;} u2b;
struct u4b {char c;  __u32     t;} u4b;
struct u8b {char c;  __u64     t;} u8b;

static void data_cleanup(void)
{
	/* never called */
}

static int data_init(void)
{
	/* print information and return an error */
	printk("arch  Align:  char  short  int  long   ptr long-long "
		" u8 u16 u32 u64\n");
	printk("%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
		"%%3i %%3i %%3i %%3i\n",
		system_utsname.machine,
		/* note that gcc can subtract void * values, but it's not ansi */
		(int)((void *)(&c.t)   - (void *)&c),
		(int)((void *)(&s.t)   - (void *)&s),
		(int)((void *)(&i.t)   - (void *)&i),
		(int)((void *)(&l.t)   - (void *)&l),
		(int)((void *)(&p.t)   - (void *)&p),
		(int)((void *)(&ll.t)  - (void *)&ll),
		(int)((void *)(&u1b.t) - (void *)&u1b),
		(int)((void *)(&u2b.t) - (void *)&u2b),
		(int)((void *)(&u4b.t) - (void *)&u4b),
		(int)((void *)(&u8b.t) - (void *)&u8b));
	return -ENODEV;
}

module_init(data_init);
module_exit(data_cleanup);

MODULE_LICENSE("Dual BSD/GPL");
]]>
			</text>
		</p>
		<p n="xlnx_drv_kdatasize">
			<text>
				<![CDATA[/*
 * kdatasize.c -- print the size of common data items from kernel space
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/utsname.h>
#include <linux/errno.h>

static void data_cleanup(void)
{
	/* never called */
}

int data_init(void)
{
	/* print information and return an error */
	printk("arch   Size:  char  short  int  long   ptr long-long "
		" u8 u16 u32 u64\n");
	printk("%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
		"%%3i %%3i %%3i %%3i\n",
		system_utsname.machine,
		(int)sizeof(char), (int)sizeof(short), (int)sizeof(int),
		(int)sizeof(long),
		(int)sizeof(void *), (int)sizeof(long long), (int)sizeof(__u8),
		(int)sizeof(__u16), (int)sizeof(__u32), (int)sizeof(__u64));
	return -ENODEV;
}

module_init(data_init);
module_exit(data_cleanup);

MODULE_LICENSE("Dual BSD/GPL");
]]>
			</text>
		</p>
		<p n="xlnx_drv_seq">
			<text>
				<![CDATA[/*
 * Simple demonstration of the seq_file interface.
 *
 * $Id: seq.c,v 1.3 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/fs.h>
#include <linux/seq_file.h>
#include <linux/slab.h>


MODULE_AUTHOR("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");



/*
 * The sequence iterator functions.  The position as seen by the
 * filesystem is just the count that we return.
 */
static void *ct_seq_start(struct seq_file *s, loff_t *pos)
{
	loff_t *spos = kmalloc(sizeof(loff_t), GFP_KERNEL);
	if (!spos)
		return NULL;
	*spos = *pos;
	return spos;
}

static void *ct_seq_next(struct seq_file *s, void *v, loff_t *pos)
{
	loff_t *spos = (loff_t *) v;
	*pos = ++(*spos);
	return spos;
}

static void ct_seq_stop(struct seq_file *s, void *v)
{
	kfree (v);
}

/*
 * The show function.
 */
static int ct_seq_show(struct seq_file *s, void *v)
{
	loff_t *spos = (loff_t *) v;
	seq_printf(s, "%%Ld\n", *spos);
	return 0;
}

/*
 * Tie them all together into a set of seq_operations.
 */
static struct seq_operations ct_seq_ops = {
	.start = ct_seq_start,
	.next  = ct_seq_next,
	.stop  = ct_seq_stop,
	.show  = ct_seq_show
};


/*
 * Time to set up the file operations for our /proc file.  In this case,
 * all we need is an open function which sets up the sequence ops.
 */

static int ct_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ct_seq_ops);
};

/*
 * The file operations structure contains our open function along with
 * set of the canned seq_ ops.
 */
static struct file_operations ct_file_ops = {
	.owner   = THIS_MODULE,
	.open    = ct_open,
	.read    = seq_read,
	.llseek  = seq_lseek,
	.release = seq_release
};
	
	
/*
 * Module setup and teardown.
 */

static int ct_init(void)
{
	struct proc_dir_entry *entry;

	entry = create_proc_entry("sequence", 0, NULL);
	if (entry)
		entry->proc_fops = &ct_file_ops;
	return 0;
}

static void ct_exit(void)
{
	remove_proc_entry("sequence", NULL);
}

module_init(ct_init);
module_exit(ct_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_silly">
			<text>
				<![CDATA[/*
 * silly.c -- Simple Tool for Unloading and Printing ISA Data
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: silly.c,v 1.3 2004/09/26 07:02:43 gregkh Exp $
 */

/* =========================> BIG FAT WARNING:
 * This will only work on architectures with an ISA memory range.
 * It won't work on other computers.
 */

#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>
#include <linux/version.h>

#include <linux/sched.h>
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>	  /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/ioport.h>
#include <linux/poll.h>

#include <asm/io.h>
#include <asm/uaccess.h>

int silly_major = 0;
module_param(silly_major, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

/*
 * The devices access the 640k-1M memory.
 * minor 0 uses ioread8/iowrite8
 * minor 1 uses ioread16/iowrite16
 * minor 2 uses ioread32/iowrite32
 * minor 3 uses memcpy_fromio()/memcpy_toio()
 */

/*
 * Here's our address range, and a place to store the ioremap'd base.
 */
#define ISA_BASE	0xA0000
#define ISA_MAX		0x100000  /* for general memory access */

#define VIDEO_MAX	0xC0000  /* for vga access */
#define VGA_BASE	0xb8000
static void __iomem *io_base;



int silly_open(struct inode *inode, struct file *filp)
{
	return 0;
}

int silly_release(struct inode *inode, struct file *filp)
{
	return 0;
}

enum silly_modes {M_8=0, M_16, M_32, M_memcpy};

ssize_t silly_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	int retval;
	int mode = iminor(filp->f_dentry->d_inode);
	void __iomem *add;
	unsigned long isa_addr = ISA_BASE + *f_pos;
	unsigned char *kbuf, *ptr;

	if (isa_addr + count > ISA_MAX) /* range: 0xA0000-0x100000 */
		count = ISA_MAX - isa_addr;

	/*
	 * too big an f_pos (caused by a malicious lseek())
	 * would result in a negative count
	 */
	if (count < 0)
		return 0;

	kbuf = kmalloc(count, GFP_KERNEL);
	if (!kbuf)
		return -ENOMEM;
	ptr = kbuf;
	retval = count;
	/*
	 * Convert our address into our remapped area.
	 */
	add = (void __iomem *)(io_base + (isa_addr - ISA_BASE));
	/*
	 * kbuf is aligned, but the reads might not. In order not to
	 * drive me mad with unaligned leading and trailing bytes,
	 * I downgrade the `mode' if unaligned xfers are requested.
	 */

	if (mode == M_32 && ((isa_addr | count) & 3))
		mode = M_16;
	if (mode == M_16 && ((isa_addr | count) & 1))
		mode = M_8;

	switch(mode) {
	  case M_32: 
		while (count >= 4) {
			*(u32 *)ptr = ioread32(add);
			add += 4;
			count -= 4;
			ptr += 4;
		}
		break;
	    
	  case M_16: 
		while (count >= 2) {
			*(u16 *)ptr = ioread16(add);
			add+=2;
			count-=2;
			ptr+=2;
		}
		break;
	    
	  case M_8: 
		while (count) {
			*ptr = ioread8(add);
			add++;
			count--;
			ptr++;
		}
		break;

	  case M_memcpy:
		memcpy_fromio(ptr, add, count);
		break;

	    default:
		return -EINVAL;
	}
	if ((retval > 0) && copy_to_user(buf, kbuf, retval))
		retval = -EFAULT;
	kfree(kbuf);
	*f_pos += retval;
	return retval;
}


ssize_t silly_write(struct file *filp, const char __user *buf, size_t count,
		    loff_t *f_pos)
{
	int retval;
	int mode = iminor(filp->f_dentry->d_inode);
	unsigned long isa_addr = ISA_BASE + *f_pos;
	unsigned char *kbuf, *ptr;
	void __iomem *add;

	/*
	 * Writing is dangerous.
	 * Allow root-only, independently of device permissions
	 */
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

	if (isa_addr + count > ISA_MAX) /* range: 0xA0000-0x100000 */
		count = ISA_MAX - isa_addr;

	/*
	 * too big an f_pos (caused by a malicious lseek())
	 * results in a negative count
	 */
	if (count < 0)
		return 0;

	kbuf = kmalloc(count, GFP_KERNEL);
	if (!kbuf)
		return -ENOMEM;
	ptr = kbuf;
	retval=count;

	/*
	 * kbuf is aligned, but the writes might not. In order not to
	 * drive me mad with unaligned leading and trailing bytes,
	 * I downgrade the `mode' if unaligned xfers are requested.
	 */

	if (mode == M_32 && ((isa_addr | count) & 3))
		mode = M_16;
	if (mode == M_16 && ((isa_addr | count) & 1))
		mode = M_8;

	if (copy_from_user(kbuf, buf, count)) {
		kfree(kbuf);
		return -EFAULT;
	}
	ptr = kbuf;

	/*
	 * Switch over to our remapped address space.
	 */
	add = (void __iomem *)(io_base + (isa_addr - ISA_BASE));

	switch(mode) {
	  case M_32: 
		while (count >= 4) {
			iowrite8(*(u32 *)ptr, add);
			add += 4;
			count -= 4;
			ptr += 4;
		}
		break;
	    
	  case M_16: 
		while (count >= 2) {
			iowrite8(*(u16 *)ptr, add);
			add += 2;
			count -= 2;
			ptr += 2;
		}
		break;
	    
	  case M_8: 
		while (count) {
			iowrite8(*ptr, add);
			add++;
			count--;
			ptr++;
		}
		break;

	  case M_memcpy:
		memcpy_toio(add, ptr, count);
		break;

	  default:
		return -EINVAL;
	}
	*f_pos += retval;
	kfree(kbuf);
	return retval;
}


unsigned int silly_poll(struct file *filp, poll_table *wait)
{
    return POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
}


struct file_operations silly_fops = {
	.read =	    silly_read,
	.write =    silly_write,
	.poll =	    silly_poll,
	.open =	    silly_open,
	.release =  silly_release,
	.owner =    THIS_MODULE
};

int silly_init(void)
{
	int result = register_chrdev(silly_major, "silly", &silly_fops);
	if (result < 0) {
		printk(KERN_INFO "silly: can't get major number\n");
		return result;
	}
	if (silly_major == 0)
		silly_major = result; /* dynamic */
	/*
	 * Set up our I/O range.
	 */

	/* this line appears in silly_init */
	io_base = ioremap(ISA_BASE, ISA_MAX - ISA_BASE);
	return 0;
}

void silly_cleanup(void)
{
	iounmap(io_base);
	unregister_chrdev(silly_major, "silly");
}


module_init(silly_init);
module_exit(silly_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_sleepy">
			<text>
				<![CDATA[/*
 * sleepy.c -- the writers awake the readers
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: sleepy.c,v 1.7 2004/09/26 07:02:43 gregkh Exp $
 */

#include <linux/module.h>
#include <linux/init.h>

#include <linux/sched.h>  /* current and everything */
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>     /* everything... */
#include <linux/types.h>  /* size_t */
#include <linux/wait.h>

MODULE_LICENSE("Dual BSD/GPL");

static int sleepy_major = 0;

static DECLARE_WAIT_QUEUE_HEAD(wq);
static int flag = 0;

ssize_t sleepy_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) going to sleep\n",
			current->pid, current->comm);
	wait_event_interruptible(wq, flag != 0);
	flag = 0;
	printk(KERN_DEBUG "awoken %%i (%%s)\n", current->pid, current->comm);
	return 0; /* EOF */
}

ssize_t sleepy_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *pos)
{
	printk(KERN_DEBUG "process %%i (%%s) awakening the readers...\n",
			current->pid, current->comm);
	flag = 1;
	wake_up_interruptible(&wq);
	return count; /* succeed, to avoid retrial */
}


struct file_operations sleepy_fops = {
	.owner = THIS_MODULE,
	.read =  sleepy_read,
	.write = sleepy_write,
};


int sleepy_init(void)
{
	int result;

	/*
	 * Register your major, and accept a dynamic number
	 */
	result = register_chrdev(sleepy_major, "sleepy", &sleepy_fops);
	if (result < 0)
		return result;
	if (sleepy_major == 0)
		sleepy_major = result; /* dynamic */
	return 0;
}

void sleepy_cleanup(void)
{
	unregister_chrdev(sleepy_major, "sleepy");
}

module_init(sleepy_init);
module_exit(sleepy_cleanup);

]]>
			</text>
		</p>
		<p n="xlnx_drv_asynctest">
			<text>
				<![CDATA[/*
 * asynctest.c: use async notification to read stdin
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>

int gotdata=0;
void sighandler(int signo)
{
    if (signo==SIGIO)
        gotdata++;
    return;
}

char buffer[4096];

int main(int argc, char **argv)
{
    int count;
    struct sigaction action;

    memset(&action, 0, sizeof(action));
    action.sa_handler = sighandler;
    action.sa_flags = 0;

    sigaction(SIGIO, &action, NULL);

    fcntl(STDIN_FILENO, F_SETOWN, getpid());
    fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL) | FASYNC);

    while(1) {
        /* this only returns if a signal arrives */
        sleep(86400); /* one day */
        if (!gotdata)
            continue;
        count=read(0, buffer, 4096);
        /* buggy: if avail data is more than 4kbytes... */
        write(1,buffer,count);
        gotdata=0;
    }
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_dataalign">
			<text>
				<![CDATA[/*
 * dataalign.c -- show alignment needs
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 */
#include <stdio.h>
#include <sys/utsname.h>
#include <linux/types.h>

/*
 * Define several data structures, all of them start with a lone char
 * in order to present an unaligned offset for the next field
 */
struct c   {char c;  char      t;} c;
struct s   {char c;  short     t;} s;
struct i   {char c;  int       t;} i;
struct l   {char c;  long      t;} l;
struct ll  {char c;  long long t;} ll;
struct p   {char c;  void *    t;} p;
struct u1b {char c;  __u8      t;} u1b;
struct u2b {char c;  __u16     t;} u2b;
struct u4b {char c;  __u32     t;} u4b;
struct u8b {char c;  __u64     t;} u8b;

int main(int argc, char **argv)
{
    struct utsname name;

    uname(&name); /* never fails :) */
    printf("arch  Align:  char  short  int  long   ptr long-long "
	   " u8 u16 u32 u64\n");
    printf(       "%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
	   "%%3i %%3i %%3i %%3i\n",
	   name.machine,
	   /* note that gcc can subtract void * values, but it's not ansi */
	   (int)((void *)(&c.t)   - (void *)&c),
	   (int)((void *)(&s.t)   - (void *)&s),
	   (int)((void *)(&i.t)   - (void *)&i),
	   (int)((void *)(&l.t)   - (void *)&l),
	   (int)((void *)(&p.t)   - (void *)&p),
	   (int)((void *)(&ll.t)  - (void *)&ll),
	   (int)((void *)(&u1b.t) - (void *)&u1b),
	   (int)((void *)(&u2b.t) - (void *)&u2b),
	   (int)((void *)(&u4b.t) - (void *)&u4b),
	   (int)((void *)(&u8b.t) - (void *)&u8b));
    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_datasize">
			<text>
				<![CDATA[/*
 * datasize.c -- print the size of common data items
 * This runs with any Linux kernel (not any Unix, because of <linux/types.h>)
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */
#include <stdio.h>
#include <sys/utsname.h>
#include <linux/types.h>

int main(int argc, char **argv)
{
    struct utsname name;

    uname(&name); /* never fails :) */
    printf("arch   Size:  char  short  int  long   ptr long-long "
	   " u8 u16 u32 u64\n");
    printf(       "%%-12s  %%3i   %%3i   %%3i   %%3i   %%3i   %%3i      "
	   "%%3i %%3i %%3i %%3i\n",
	   name.machine,
	   (int)sizeof(char), (int)sizeof(short), (int)sizeof(int),
	   (int)sizeof(long),
	   (int)sizeof(void *), (int)sizeof(long long), (int)sizeof(__u8),
	   (int)sizeof(__u16), (int)sizeof(__u32), (int)sizeof(__u64));
    return 0;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_inp">
			<text>
				<![CDATA[/* 
 * inp.c -- read all the ports specified in hex on the command line.
 *     The program uses the faster ioperm/iopl calls on x86, /dev/port
 *     on other platforms. The program acts as inb/inw/inl according
 *     to its own name
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <asm/io.h> /* linux-specific */

#ifdef __GLIBC__
#  include <sys/perm.h>
#endif

#define PORT_FILE "/dev/port"

char *prgname;

#ifdef __i386__
static int read_and_print_one(unsigned int port,int size)
{
    static int iopldone = 0;

    if (port > 1024) {
	if (!iopldone && iopl(3)) {
	    fprintf(stderr, "%%s: iopl(): %%s\n", prgname, strerror(errno));
	    return 1;
	}
	iopldone++;
    } else if (ioperm(port,size,1)) {
	fprintf(stderr, "%%s: ioperm(%%x): %%s\n", prgname,
		port, strerror(errno));
	return 1;
    }

    if (size == 4)
	printf("%%04x: %%08x\n", port, inl(port));
    else if (size == 2)
	printf("%%04x: %%04x\n", port, inw(port));
    else
	printf("%%04x: %%02x\n", port, inb(port));
    return 0;
}
#else /* not i386 */

static int read_and_print_one(unsigned int port,int size)
{
    static int fd = -1;
    unsigned char b; unsigned short w; unsigned int l;

    if (fd < 0)
	fd = open(PORT_FILE, O_RDONLY);
    if (fd < 0) {
	fprintf(stderr, "%%s: %%s: %%s\n", prgname, PORT_FILE, strerror(errno));
	return 1;
    }
    lseek(fd, port, SEEK_SET);
    
    if (size == 4) {
	read(fd, &l, 4);
	printf("%%04x: 0x%%08x\n", port, l);
    } else if (size == 2) {
	read(fd, &w, 2);
	printf("%%04x: 0x%%04x\n", port, w & 0xffff);
    } else {
	read(fd, &b, 1);
	printf("%%04x: 0x%%02x\n", port, b & 0xff);
    }
    return 0;
}

#endif /* i386 */


int main(int argc, char **argv)
{
    unsigned int i, n, port, size, error = 0;
    
    prgname = argv[0];
    /* find the data size */
    switch (prgname[strlen(prgname)-1]) {
        case 'w': size = 2; break;
        case 'l': size = 4; break;
        case 'b': case 'p': default:
	    size = 1;
    }

    setuid(0); /* if we're setuid, force it on */
    for (i = 1; i < argc; i++) {
        if ( sscanf(argv[i], "%%x%%n", &port, &n) < 1
	      || n != strlen(argv[i]) ) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not a hex number\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
	if (port & (size-1)) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not properly aligned\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
	error += read_and_print_one(port, size);
    }
    exit (error ? 1 : 0);
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_load50">
			<text>
				<![CDATA[/*
 * load50.c -- a simple busy-looping tool. 
 * Obviously, this runs with any kernel and any Unix
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */ 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv)
{
	int i, load=50;

	if (argc==2) {
		load=atoi(argv[1]);
	}
	printf("Bringing load to %%i\n",load);
  
	for (i=0; i<load; i++)
		if (fork()==0)
			break;

	while(1)
		;
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_mapcmp">
			<text>
				<![CDATA[/*
 * Simple program to compare two mmap'd areas.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: mapcmp.c,v 1.2 2004/03/05 17:35:41 corbet Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/errno.h>
#include <fcntl.h>

static char *mapdev (const char *, unsigned long, unsigned long);
#define PAGE_SIZE 4096

/*
 * memcmp dev1 dev2 offset pages
 */
int main (int argc, char **argv)
{
	unsigned long offset, size, i;
	char *addr1, *addr2;
/*
 * Sanity check.
 */
	if (argc != 5)
	{
		fprintf (stderr, "Usage: mapcmp dev1 dev2 offset pages\n");
		exit (1);
	}
/*
 * Map the two devices.
 */
	offset = strtoul (argv[3], NULL, 16);
	size = atoi (argv[4])*PAGE_SIZE;
	printf ("Offset is 0x%%lx\n", offset);
	addr1 = mapdev (argv[1], offset, size);
	addr2 = mapdev (argv[2], offset, size);
/*
 * Do the comparison.
 */
	printf ("Comparing...");
	fflush (stdout);
	for (i = 0; i < size; i++)
		if (*addr1++ != *addr2++)
		{
			printf ("areas differ at byte %%ld\n", i);
			exit (0);
		}
	printf ("areas are identical.\n");
	exit (0);
}



static char *mapdev (const char *dev, unsigned long offset,
		unsigned long size)
{
	char *addr;
	int fd = open (dev, O_RDONLY);

	if (fd < 0)
	{
		perror (dev);
		exit (1);
	}
	addr = mmap (0, size, PROT_READ, MAP_PRIVATE, fd, offset);
	if (addr == MAP_FAILED)
	{
		perror (dev);
		exit (1);
	}
	printf ("Mapped %%s (%%lu @ %%lx) at %%p\n", dev, size, offset, addr);
	return (addr);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_mapper">
			<text>
				<![CDATA[/*
 * mapper.c -- simple file that mmap()s a file region and prints it
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>
#include <limits.h>

int main(int argc, char **argv)
{
    char *fname;
    FILE *f;
    unsigned long offset, len;
    void *address;

    if (argc !=4
       || sscanf(argv[2],"%%li", &offset) != 1
       || sscanf(argv[3],"%%li", &len) != 1) {
        fprintf(stderr, "%%s: Usage \"%%s <file> <offset> <len>\"\n", argv[0],
                argv[0]);
        exit(1);
    }
    /* the offset might be big (e.g., PCI devices), but conversion trims it */
    if (offset == INT_MAX) {
	if (argv[2][1]=='x')
            sscanf(argv[2]+2, "%%lx", &offset);
        else
            sscanf(argv[2], "%%lu", &offset);
    }

    fname=argv[1];

    if (!(f=fopen(fname,"r"))) {
        fprintf(stderr, "%%s: %%s: %%s\n", argv[0], fname, strerror(errno));
        exit(1);
    }

    address=mmap(0, len, PROT_READ, MAP_FILE | MAP_PRIVATE, fileno(f), offset);

    if (address == (void *)-1) {
        fprintf(stderr,"%%s: mmap(): %%s\n",argv[0],strerror(errno));
        exit(1);
    }
    fclose(f);
    fprintf(stderr, "mapped \"%%s\" from %%lu (0x%%08lx) to %%lu (0x%%08lx)\n",
            fname, offset, offset, offset+len, offset+len);

    fwrite(address, 1, len, stdout);
    return 0;
}
        
]]>
			</text>
		</p>
		<p n="xlnx_drv_nbtest">
			<text>
				<![CDATA[/*
 * nbtest.c: read and write in non-blocking mode
 * This should run with any Unix
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>

char buffer[4096];

int main(int argc, char **argv)
{
	int delay = 1, n, m = 0;

	if (argc > 1)
		delay=atoi(argv[1]);
	fcntl(0, F_SETFL, fcntl(0,F_GETFL) | O_NONBLOCK); /* stdin */
	fcntl(1, F_SETFL, fcntl(1,F_GETFL) | O_NONBLOCK); /* stdout */

	while (1) {
		n = read(0, buffer, 4096);
		if (n >= 0)
			m = write(1, buffer, n);
		if ((n < 0 || m < 0) && (errno != EAGAIN))
			break;
		sleep(delay);
	}
	perror(n < 0 ? "stdin" : "stdout");
	exit(1);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_netifdebug">
			<text>
				<![CDATA[/*
 * netifdebug.c -- change the IFF_DEBUG flag of an interface
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <netinet/in.h>

int main(int argc, char **argv)
{
    int action = -1, sock;
    struct ifreq req;
    char *actname;

    if (argc < 2) {
        fprintf(stderr,"%%s: usage is \"%%s <ifname> [<on|off|tell>]\"\n",
                argv[0],argv[0]);
        exit(1);
    }
    if (argc==2)
        actname="tell";
    else
        actname=argv[2];

    /* a silly raw socket just for ioctl()ling it */
    sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (sock < 0) {
        fprintf(stderr, "%%s: socket(): %%s\n", argv[0],strerror(errno));
        exit(1);
    }

    /* retrieve flags */
    strcpy(req.ifr_name, argv[1]);
    if ( ioctl(sock, SIOCGIFFLAGS, &req) < 0) {
        fprintf(stderr, " %%s: ioctl(SIOCGIFFLAGS): %%s\n",
                argv[0],strerror(errno));
        exit(1);
    }

    if (!strcmp(actname,"on")
        || !strcmp(actname,"+")
        || !strcmp(actname,"1"))
        action = IFF_DEBUG;

    if (!strcmp(actname,"off")
        || !strcmp(actname,"-")
        || !strcmp(actname,"0"))
        action = 0;

    if (!strcmp(actname,"tell")
        || actname[0]=='t') {
        printf("%%s: debug is %%s\n", argv[1],
               req.ifr_flags & IFF_DEBUG ? "on" : "off");
        exit(0);
    }

    req.ifr_flags &= ~IFF_DEBUG;
    req.ifr_flags |= action;

    if ( ioctl(sock, SIOCSIFFLAGS, &req) < 0) {
        fprintf(stderr, " %%s: ioctl(SIOCSIFFLAGS): %%s\n",
                argv[0],strerror(errno));
        exit(1);
    }
    exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_outp">
			<text>
				<![CDATA[/* 
 * outp.c -- write all the ports specified in hex on the command line.
 *     The program uses the faster ioperm/iopl calls on x86, /dev/port
 *     on other platforms. The program acts as outb/outw/outl according
 *     to its own name
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <asm/io.h> /* linux-specific */

#ifdef __GLIBC__
#  include <sys/perm.h>
#endif

#define PORT_FILE "/dev/port"

char *prgname;

#ifdef __i386__
static int write_one(unsigned int port, unsigned int val, int size)
{
    static int iopldone = 0;

    if (port > 1024) {
	if (!iopldone && iopl(3)) {
	    fprintf(stderr, "%%s: iopl(): %%s\n", prgname, strerror(errno));
	    return 1;
	}
	iopldone++;
    } else if (ioperm(port,size,1)) {
	fprintf(stderr, "%%s: ioperm(%%x): %%s\n", prgname,
		port, strerror(errno));
	return 1;
    }

    if (size == 4)
	outl(val, port);
    else if (size == 2)
	outw(val&0xffff, port);
    else
	outb(val&0xff, port);
    return 0;
}
#else /* not i386 */

static int write_one(unsigned int port, unsigned int val, int size)
{
    static int fd = -1;
    unsigned char b; unsigned short w;

    if (fd < 0)
	fd = open(PORT_FILE, O_WRONLY);
    if (fd < 0) {
	fprintf(stderr, "%%s: %%s: %%s\n", prgname, PORT_FILE, strerror(errno));
	return 1;
    }
    lseek(fd, port, SEEK_SET);
    
    if (size == 4) {
	write(fd, &val, 4);
    } else if (size == 2) {
	w = val;
	write(fd, &w, 2);
    } else {
	b = val;
	write(fd, &b, 1);
    }
    return 0;
}

#endif /* i386 */

int main(int argc, char **argv)
{
    unsigned int i, n, port, val, size, error = 0;
    
    prgname = argv[0];
    /* find the data size */
    switch (prgname[strlen(prgname)-1]) {
        case 'w': size = 2; break;
        case 'l': size = 4; break;
        case 'b': case 'p': default:
	    size = 1;
    }
    setuid(0); /* if we're setuid, force it on */
    for (i=1;i<argc-1;i++) {
        if ( sscanf(argv[i], "%%x%%n", &port, &n) < 1
	      || n != strlen(argv[i]) ) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not a hex number\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
	if (port & (size-1)) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not properly aligned\n",
		    argv[0], argv[i]);
	    error++; continue;
	}
        if ( sscanf(argv[i+1], "%%x%%n", &val, &n) < 1
	      || n != strlen(argv[i+1]) ) {
	    fprintf(stderr, "%%s: argument \"%%s\" is not a hex number\n",
		    argv[0], argv[i+1]);
	    error++; continue;
	}
	if (size < 4 && val > (size == 1 ? 0xff : 0xffff)) {
	    fprintf(stderr, "%%s: argument \"%%s\" out of range\n",
		    argv[0], argv[i+1]);
	    error++; continue;
	}
	error += write_one(port, val, size);
    }
    exit (error ? 1 : 0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_polltest">
			<text>
				<![CDATA[/*
 * Test out reading with poll()
 * This should run with any Unix
 *
 * Copyright (C) 2003 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2003 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: polltest.c,v 1.1 2003/02/07 18:01:38 corbet Exp $
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/poll.h>
#include <fcntl.h>

char buffer[4096];

int main(int argc, char **argv)
{
    struct pollfd pfd;
    int n;

    fcntl(0, F_SETFL, fcntl(0,F_GETFL) | O_NONBLOCK); /* stdin */
    pfd.fd = 0;  /* stdin */
    pfd.events = POLLIN;

    while (1) {
        n=read(0, buffer, 4096);
        if (n >= 0)
            write(1, buffer, n);
	n = poll(&pfd, 1, -1);
	if (n < 0)
	    break;
    }
    perror( n<0 ? "stdin" : "stdout");
    exit(1);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_setconsole">
			<text>
				<![CDATA[/*
 * setconsole.c -- choose a console to receive kernel messages
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/ioctl.h>

int main(int argc, char **argv)
{
    char bytes[2] = {11,0}; /* 11 is the TIOCLINUX cmd number */

    if (argc==2) bytes[1] = atoi(argv[1]); /* the chosen console */
    else {
        fprintf(stderr, "%%s: need a single arg\n",argv[0]); exit(1);
    }
    if (ioctl(STDIN_FILENO, TIOCLINUX, bytes)<0) {    /* use stdin */
        fprintf(stderr,"%%s: ioctl(stdin, TIOCLINUX): %%s\n",
                argv[0], strerror(errno));
        exit(1);
    }
    exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_setlevel">
			<text>
				<![CDATA[/*
 * setlevel.c -- choose a console_loglevel for the kernel
 *
 * Copyright (C) 1998,2000,2001 Alessandro Rubini
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
/* #include <unistd.h> */ /* conflicting on the alpha */
#define __LIBRARY__ /* _syscall3 and friends are only available through this */
#include <linux/unistd.h>

/* define the system call, to override the library function */
_syscall3(int, syslog, int, type, char *, bufp, int, len);

int main(int argc, char **argv)
{
    int level;

    if (argc==2) {
	level = atoi(argv[1]); /* the chosen console */
    } else {
        fprintf(stderr, "%%s: need a single arg\n",argv[0]); exit(1);
    }
    if (syslog(8,NULL,level) < 0) {  
        fprintf(stderr,"%%s: syslog(setlevel): %%s\n",
                argv[0],strerror(errno));
        exit(1);
    }
    exit(0);
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_pci_skel">
			<text>
				<![CDATA[#include <linux/config.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/pci.h>
#include <linux/init.h>


static struct pci_device_id ids[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801AA_3), },
	{ 0, }
};
MODULE_DEVICE_TABLE(pci, ids);

static unsigned char skel_get_revision(struct pci_dev *dev)
{
	u8 revision;

	pci_read_config_byte(dev, PCI_REVISION_ID, &revision);
	return revision;
}

static int probe(struct pci_dev *dev, const struct pci_device_id *id)
{
	/* Do probing type stuff here.  
	 * Like calling request_region();
	 */
	pci_enable_device(dev);
	
	if (skel_get_revision(dev) == 0x42)
		return -ENODEV;


	return 0;
}

static void remove(struct pci_dev *dev)
{
	/* clean up any allocated resources and stuff here.
	 * like call release_region();
	 */
}

static struct pci_driver pci_driver = {
	.name = "pci_skel",
	.id_table = ids,
	.probe = probe,
	.remove = remove,
};

static int __init pci_skel_init(void)
{
	return pci_register_driver(&pci_driver);
}

static void __exit pci_skel_exit(void)
{
	pci_unregister_driver(&pci_driver);
}

MODULE_LICENSE("GPL");

module_init(pci_skel_init);
module_exit(pci_skel_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_sbull">
			<text>
				<![CDATA[/*
 * Sample disk driver, from the beginning.
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/sched.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/timer.h>
#include <linux/types.h>	/* size_t */
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/hdreg.h>	/* HDIO_GETGEO */
#include <linux/kdev_t.h>
#include <linux/vmalloc.h>
#include <linux/genhd.h>
#include <linux/blkdev.h>
#include <linux/buffer_head.h>	/* invalidate_bdev */
#include <linux/bio.h>

MODULE_LICENSE("Dual BSD/GPL");

static int sbull_major = 0;
module_param(sbull_major, int, 0);
static int hardsect_size = 512;
module_param(hardsect_size, int, 0);
static int nsectors = 1024;	/* How big the drive is */
module_param(nsectors, int, 0);
static int ndevices = 4;
module_param(ndevices, int, 0);

/*
 * The different "request modes" we can use.
 */
enum {
	RM_SIMPLE  = 0,	/* The extra-simple request function */
	RM_FULL    = 1,	/* The full-blown version */
	RM_NOQUEUE = 2,	/* Use make_request */
};
static int request_mode = RM_SIMPLE;
module_param(request_mode, int, 0);

/*
 * Minor number and partition management.
 */
#define SBULL_MINORS	16
#define MINOR_SHIFT	4
#define DEVNUM(kdevnum)	(MINOR(kdev_t_to_nr(kdevnum)) >> MINOR_SHIFT

/*
 * We can tweak our hardware sector size, but the kernel talks to us
 * in terms of small sectors, always.
 */
#define KERNEL_SECTOR_SIZE	512

/*
 * After this much idle time, the driver will simulate a media change.
 */
#define INVALIDATE_DELAY	30*HZ

/*
 * The internal representation of our device.
 */
struct sbull_dev {
        int size;                       /* Device size in sectors */
        u8 *data;                       /* The data array */
        short users;                    /* How many users */
        short media_change;             /* Flag a media change? */
        spinlock_t lock;                /* For mutual exclusion */
        struct request_queue *queue;    /* The device request queue */
        struct gendisk *gd;             /* The gendisk structure */
        struct timer_list timer;        /* For simulated media changes */
};

static struct sbull_dev *Devices = NULL;

/*
 * Handle an I/O request.
 */
static void sbull_transfer(struct sbull_dev *dev, unsigned long sector,
		unsigned long nsect, char *buffer, int write)
{
	unsigned long offset = sector*KERNEL_SECTOR_SIZE;
	unsigned long nbytes = nsect*KERNEL_SECTOR_SIZE;

	if ((offset + nbytes) > dev->size) {
		printk (KERN_NOTICE "Beyond-end write (%%ld %%ld)\n", offset, nbytes);
		return;
	}
	if (write)
		memcpy(dev->data + offset, buffer, nbytes);
	else
		memcpy(buffer, dev->data + offset, nbytes);
}

/*
 * The simple form of the request function.
 */
static void sbull_request(request_queue_t *q)
{
	struct request *req;

	while ((req = elv_next_request(q)) != NULL) {
		struct sbull_dev *dev = req->rq_disk->private_data;
		if (! blk_fs_request(req)) {
			printk (KERN_NOTICE "Skip non-fs request\n");
			end_request(req, 0);
			continue;
		}
    //    	printk (KERN_NOTICE "Req dev %%d dir %%ld sec %%ld, nr %%d f %%lx\n",
    //    			dev - Devices, rq_data_dir(req),
    //    			req->sector, req->current_nr_sectors,
    //    			req->flags);
		sbull_transfer(dev, req->sector, req->current_nr_sectors,
				req->buffer, rq_data_dir(req));
		end_request(req, 1);
	}
}


/*
 * Transfer a single BIO.
 */
static int sbull_xfer_bio(struct sbull_dev *dev, struct bio *bio)
{
	int i;
	struct bio_vec *bvec;
	sector_t sector = bio->bi_sector;

	/* Do each segment independently. */
	bio_for_each_segment(bvec, bio, i) {
		char *buffer = __bio_kmap_atomic(bio, i, KM_USER0);
		sbull_transfer(dev, sector, bio_cur_sectors(bio),
				buffer, bio_data_dir(bio) == WRITE);
		sector += bio_cur_sectors(bio);
		__bio_kunmap_atomic(bio, KM_USER0);
	}
	return 0; /* Always "succeed" */
}

/*
 * Transfer a full request.
 */
static int sbull_xfer_request(struct sbull_dev *dev, struct request *req)
{
	struct bio *bio;
	int nsect = 0;
    
	rq_for_each_bio(bio, req) {
		sbull_xfer_bio(dev, bio);
		nsect += bio->bi_size/KERNEL_SECTOR_SIZE;
	}
	return nsect;
}



/*
 * Smarter request function that "handles clustering".
 */
static void sbull_full_request(request_queue_t *q)
{
	struct request *req;
	int sectors_xferred;
	struct sbull_dev *dev = q->queuedata;

	while ((req = elv_next_request(q)) != NULL) {
		if (! blk_fs_request(req)) {
			printk (KERN_NOTICE "Skip non-fs request\n");
			end_request(req, 0);
			continue;
		}
		sectors_xferred = sbull_xfer_request(dev, req);
		if (! end_that_request_first(req, 1, sectors_xferred)) {
			blkdev_dequeue_request(req);
			end_that_request_last(req);
		}
	}
}



/*
 * The direct make request version.
 */
static int sbull_make_request(request_queue_t *q, struct bio *bio)
{
	struct sbull_dev *dev = q->queuedata;
	int status;

	status = sbull_xfer_bio(dev, bio);
	bio_endio(bio, bio->bi_size, status);
	return 0;
}


/*
 * Open and close.
 */

static int sbull_open(struct inode *inode, struct file *filp)
{
	struct sbull_dev *dev = inode->i_bdev->bd_disk->private_data;

	del_timer_sync(&dev->timer);
	filp->private_data = dev;
	spin_lock(&dev->lock);
	if (! dev->users) 
		check_disk_change(inode->i_bdev);
	dev->users++;
	spin_unlock(&dev->lock);
	return 0;
}

static int sbull_release(struct inode *inode, struct file *filp)
{
	struct sbull_dev *dev = inode->i_bdev->bd_disk->private_data;

	spin_lock(&dev->lock);
	dev->users--;

	if (!dev->users) {
		dev->timer.expires = jiffies + INVALIDATE_DELAY;
		add_timer(&dev->timer);
	}
	spin_unlock(&dev->lock);

	return 0;
}

/*
 * Look for a (simulated) media change.
 */
int sbull_media_changed(struct gendisk *gd)
{
	struct sbull_dev *dev = gd->private_data;
	
	return dev->media_change;
}

/*
 * Revalidate.  WE DO NOT TAKE THE LOCK HERE, for fear of deadlocking
 * with open.  That needs to be reevaluated.
 */
int sbull_revalidate(struct gendisk *gd)
{
	struct sbull_dev *dev = gd->private_data;
	
	if (dev->media_change) {
		dev->media_change = 0;
		memset (dev->data, 0, dev->size);
	}
	return 0;
}

/*
 * The "invalidate" function runs out of the device timer; it sets
 * a flag to simulate the removal of the media.
 */
void sbull_invalidate(unsigned long ldev)
{
	struct sbull_dev *dev = (struct sbull_dev *) ldev;

	spin_lock(&dev->lock);
	if (dev->users || !dev->data) 
		printk (KERN_WARNING "sbull: timer sanity check failed\n");
	else
		dev->media_change = 1;
	spin_unlock(&dev->lock);
}

/*
 * The ioctl() implementation
 */

int sbull_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{
	long size;
	struct hd_geometry geo;
	struct sbull_dev *dev = filp->private_data;

	switch(cmd) {
	    case HDIO_GETGEO:
        	/*
		 * Get geometry: since we are a virtual device, we have to make
		 * up something plausible.  So we claim 16 sectors, four heads,
		 * and calculate the corresponding number of cylinders.  We set the
		 * start of data at sector four.
		 */
		size = dev->size*(hardsect_size/KERNEL_SECTOR_SIZE);
		geo.cylinders = (size & ~0x3f) >> 6;
		geo.heads = 4;
		geo.sectors = 16;
		geo.start = 4;
		if (copy_to_user((void __user *) arg, &geo, sizeof(geo)))
			return -EFAULT;
		return 0;
	}

	return -ENOTTY; /* unknown command */
}



/*
 * The device operations structure.
 */
static struct block_device_operations sbull_ops = {
	.owner           = THIS_MODULE,
	.open 	         = sbull_open,
	.release 	 = sbull_release,
	.media_changed   = sbull_media_changed,
	.revalidate_disk = sbull_revalidate,
	.ioctl	         = sbull_ioctl
};


/*
 * Set up our internal device.
 */
static void setup_device(struct sbull_dev *dev, int which)
{
	/*
	 * Get some memory.
	 */
	memset (dev, 0, sizeof (struct sbull_dev));
	dev->size = nsectors*hardsect_size;
	dev->data = vmalloc(dev->size);
	if (dev->data == NULL) {
		printk (KERN_NOTICE "vmalloc failure.\n");
		return;
	}
	spin_lock_init(&dev->lock);
	
	/*
	 * The timer which "invalidates" the device.
	 */
	init_timer(&dev->timer);
	dev->timer.data = (unsigned long) dev;
	dev->timer.function = sbull_invalidate;
	
	/*
	 * The I/O queue, depending on whether we are using our own
	 * make_request function or not.
	 */
	switch (request_mode) {
	    case RM_NOQUEUE:
		dev->queue = blk_alloc_queue(GFP_KERNEL);
		if (dev->queue == NULL)
			goto out_vfree;
		blk_queue_make_request(dev->queue, sbull_make_request);
		break;

	    case RM_FULL:
		dev->queue = blk_init_queue(sbull_full_request, &dev->lock);
		if (dev->queue == NULL)
			goto out_vfree;
		break;

	    default:
		printk(KERN_NOTICE "Bad request mode %%d, using simple\n", request_mode);
        	/* fall into.. */
	
	    case RM_SIMPLE:
		dev->queue = blk_init_queue(sbull_request, &dev->lock);
		if (dev->queue == NULL)
			goto out_vfree;
		break;
	}
	blk_queue_hardsect_size(dev->queue, hardsect_size);
	dev->queue->queuedata = dev;
	/*
	 * And the gendisk structure.
	 */
	dev->gd = alloc_disk(SBULL_MINORS);
	if (! dev->gd) {
		printk (KERN_NOTICE "alloc_disk failure\n");
		goto out_vfree;
	}
	dev->gd->major = sbull_major;
	dev->gd->first_minor = which*SBULL_MINORS;
	dev->gd->fops = &sbull_ops;
	dev->gd->queue = dev->queue;
	dev->gd->private_data = dev;
	snprintf (dev->gd->disk_name, 32, "sbull%%c", which + 'a');
	set_capacity(dev->gd, nsectors*(hardsect_size/KERNEL_SECTOR_SIZE));
	add_disk(dev->gd);
	return;

  out_vfree:
	if (dev->data)
		vfree(dev->data);
}



static int __init sbull_init(void)
{
	int i;
	/*
	 * Get registered.
	 */
	sbull_major = register_blkdev(sbull_major, "sbull");
	if (sbull_major <= 0) {
		printk(KERN_WARNING "sbull: unable to get major number\n");
		return -EBUSY;
	}
	/*
	 * Allocate the device array, and initialize each one.
	 */
	Devices = kmalloc(ndevices*sizeof (struct sbull_dev), GFP_KERNEL);
	if (Devices == NULL)
		goto out_unregister;
	for (i = 0; i < ndevices; i++) 
		setup_device(Devices + i, i);
    
	return 0;

  out_unregister:
	unregister_blkdev(sbull_major, "sbd");
	return -ENOMEM;
}

static void sbull_exit(void)
{
	int i;

	for (i = 0; i < ndevices; i++) {
		struct sbull_dev *dev = Devices + i;

		del_timer_sync(&dev->timer);
		if (dev->gd) {
			del_gendisk(dev->gd);
			put_disk(dev->gd);
		}
		if (dev->queue) {
			if (request_mode == RM_NOQUEUE)
				blk_put_queue(dev->queue);
			else
				blk_cleanup_queue(dev->queue);
		}
		if (dev->data)
			vfree(dev->data);
	}
	unregister_blkdev(sbull_major, "sbull");
	kfree(Devices);
}
	
module_init(sbull_init);
module_exit(sbull_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_access">
			<text>
				<![CDATA[/*
 * access.c -- the files with access control on open
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: access.c,v 1.17 2004/09/26 07:29:56 gregkh Exp $
 */

/* FIXME: cloned devices as a use for kobjects? */
 
#include <linux/kernel.h> /* printk() */
#include <linux/module.h>
#include <linux/slab.h>   /* kmalloc() */
#include <linux/fs.h>     /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/types.h>  /* size_t */
#include <linux/fcntl.h>
#include <linux/cdev.h>
#include <linux/tty.h>
#include <asm/atomic.h>
#include <linux/list.h>

#include "scull.h"        /* local definitions */

static dev_t scull_a_firstdev;  /* Where our range begins */

/*
 * These devices fall back on the main scull operations. They only
 * differ in the implementation of open() and close()
 */



/************************************************************************
 *
 * The first device is the single-open one,
 *  it has an hw structure and an open count
 */

static struct scull_dev scull_s_device;
static atomic_t scull_s_available = ATOMIC_INIT(1);

static int scull_s_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_s_device; /* device information */

	if (! atomic_dec_and_test (&scull_s_available)) {
		atomic_inc(&scull_s_available);
		return -EBUSY; /* already open */
	}

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_s_release(struct inode *inode, struct file *filp)
{
	atomic_inc(&scull_s_available); /* release the device */
	return 0;
}


/*
 * The other operations for the single-open device come from the bare device
 */
struct file_operations scull_sngl_fops = {
	.owner =	THIS_MODULE,
	.llseek =     	scull_llseek,
	.read =       	scull_read,
	.write =      	scull_write,
	.ioctl =      	scull_ioctl,
	.open =       	scull_s_open,
	.release =    	scull_s_release,
};


/************************************************************************
 *
 * Next, the "uid" device. It can be opened multiple times by the
 * same user, but access is denied to other users if the device is open
 */

static struct scull_dev scull_u_device;
static int scull_u_count;	/* initialized to 0 by default */
static uid_t scull_u_owner;	/* initialized to 0 by default */
static spinlock_t scull_u_lock = SPIN_LOCK_UNLOCKED;

static int scull_u_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_u_device; /* device information */

	spin_lock(&scull_u_lock);
	if (scull_u_count && 
			(scull_u_owner != current->uid) &&  /* allow user */
			(scull_u_owner != current->euid) && /* allow whoever did su */
			!capable(CAP_DAC_OVERRIDE)) { /* still allow root */
		spin_unlock(&scull_u_lock);
		return -EBUSY;   /* -EPERM would confuse the user */
	}

	if (scull_u_count == 0)
		scull_u_owner = current->uid; /* grab it */

	scull_u_count++;
	spin_unlock(&scull_u_lock);

/* then, everything else is copied from the bare scull device */

	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_u_release(struct inode *inode, struct file *filp)
{
	spin_lock(&scull_u_lock);
	scull_u_count--; /* nothing else */
	spin_unlock(&scull_u_lock);
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_user_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_u_open,
	.release =    scull_u_release,
};


/************************************************************************
 *
 * Next, the device with blocking-open based on uid
 */

static struct scull_dev scull_w_device;
static int scull_w_count;	/* initialized to 0 by default */
static uid_t scull_w_owner;	/* initialized to 0 by default */
static DECLARE_WAIT_QUEUE_HEAD(scull_w_wait);
static spinlock_t scull_w_lock = SPIN_LOCK_UNLOCKED;

static inline int scull_w_available(void)
{
	return scull_w_count == 0 ||
		scull_w_owner == current->uid ||
		scull_w_owner == current->euid ||
		capable(CAP_DAC_OVERRIDE);
}


static int scull_w_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_w_device; /* device information */

	spin_lock(&scull_w_lock);
	while (! scull_w_available()) {
		spin_unlock(&scull_w_lock);
		if (filp->f_flags & O_NONBLOCK) return -EAGAIN;
		if (wait_event_interruptible (scull_w_wait, scull_w_available()))
			return -ERESTARTSYS; /* tell the fs layer to handle it */
		spin_lock(&scull_w_lock);
	}
	if (scull_w_count == 0)
		scull_w_owner = current->uid; /* grab it */
	scull_w_count++;
	spin_unlock(&scull_w_lock);

	/* then, everything else is copied from the bare scull device */
	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_w_release(struct inode *inode, struct file *filp)
{
	int temp;

	spin_lock(&scull_w_lock);
	scull_w_count--;
	temp = scull_w_count;
	spin_unlock(&scull_w_lock);

	if (temp == 0)
		wake_up_interruptible_sync(&scull_w_wait); /* awake other uid's */
	return 0;
}


/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_wusr_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_w_open,
	.release =    scull_w_release,
};

/************************************************************************
 *
 * Finally the `cloned' private device. This is trickier because it
 * involves list management, and dynamic allocation.
 */

/* The clone-specific data structure includes a key field */

struct scull_listitem {
	struct scull_dev device;
	dev_t key;
	struct list_head list;
    
};

/* The list of devices, and a lock to protect it */
static LIST_HEAD(scull_c_list);
static spinlock_t scull_c_lock = SPIN_LOCK_UNLOCKED;

/* A placeholder scull_dev which really just holds the cdev stuff. */
static struct scull_dev scull_c_device;   

/* Look for a device or create one if missing */
static struct scull_dev *scull_c_lookfor_device(dev_t key)
{
	struct scull_listitem *lptr;

	list_for_each_entry(lptr, &scull_c_list, list) {
		if (lptr->key == key)
			return &(lptr->device);
	}

	/* not found */
	lptr = kmalloc(sizeof(struct scull_listitem), GFP_KERNEL);
	if (!lptr)
		return NULL;

	/* initialize the device */
	memset(lptr, 0, sizeof(struct scull_listitem));
	lptr->key = key;
	scull_trim(&(lptr->device)); /* initialize it */
	init_MUTEX(&(lptr->device.sem));

	/* place it in the list */
	list_add(&lptr->list, &scull_c_list);

	return &(lptr->device);
}

static int scull_c_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev;
	dev_t key;
 
	if (!current->signal->tty) { 
		PDEBUG("Process \"%%s\" has no ctl tty\n", current->comm);
		return -EINVAL;
	}
	key = tty_devnum(current->signal->tty);

	/* look for a scullc device in the list */
	spin_lock(&scull_c_lock);
	dev = scull_c_lookfor_device(key);
	spin_unlock(&scull_c_lock);

	if (!dev)
		return -ENOMEM;

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_c_release(struct inode *inode, struct file *filp)
{
	/*
	 * Nothing to do, because the device is persistent.
	 * A `real' cloned device should be freed on last close
	 */
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_priv_fops = {
	.owner =    THIS_MODULE,
	.llseek =   scull_llseek,
	.read =     scull_read,
	.write =    scull_write,
	.ioctl =    scull_ioctl,
	.open =     scull_c_open,
	.release =  scull_c_release,
};

/************************************************************************
 *
 * And the init and cleanup functions come last
 */

static struct scull_adev_info {
	char *name;
	struct scull_dev *sculldev;
	struct file_operations *fops;
} scull_access_devs[] = {
	{ "scullsingle", &scull_s_device, &scull_sngl_fops },
	{ "sculluid", &scull_u_device, &scull_user_fops },
	{ "scullwuid", &scull_w_device, &scull_wusr_fops },
	{ "sullpriv", &scull_c_device, &scull_priv_fops }
};
#define SCULL_N_ADEVS 4

/*
 * Set up a single device.
 */
static void scull_access_setup (dev_t devno, struct scull_adev_info *devinfo)
{
	struct scull_dev *dev = devinfo->sculldev;
	int err;

	/* Initialize the device structure */
	dev->quantum = scull_quantum;
	dev->qset = scull_qset;
	init_MUTEX(&dev->sem);

	/* Do the cdev stuff. */
	cdev_init(&dev->cdev, devinfo->fops);
	kobject_set_name(&dev->cdev.kobj, devinfo->name);
	dev->cdev.owner = THIS_MODULE;
	err = cdev_add (&dev->cdev, devno, 1);
        /* Fail gracefully if need be */
	if (err) {
		printk(KERN_NOTICE "Error %%d adding %%s\n", err, devinfo->name);
		kobject_put(&dev->cdev.kobj);
	} else
		printk(KERN_NOTICE "%%s registered at %%x\n", devinfo->name, devno);
}


int scull_access_init(dev_t firstdev)
{
	int result, i;

	/* Get our number space */
	result = register_chrdev_region (firstdev, SCULL_N_ADEVS, "sculla");
	if (result < 0) {
		printk(KERN_WARNING "sculla: device number registration failed\n");
		return 0;
	}
	scull_a_firstdev = firstdev;

	/* Set up each device. */
	for (i = 0; i < SCULL_N_ADEVS; i++)
		scull_access_setup (firstdev + i, scull_access_devs + i);
	return SCULL_N_ADEVS;
}

/*
 * This is called by cleanup_module or on failure.
 * It is required to never fail, even if nothing was initialized first
 */
void scull_access_cleanup(void)
{
	struct scull_listitem *lptr, *next;
	int i;

	/* Clean up the static devs */
	for (i = 0; i < SCULL_N_ADEVS; i++) {
		struct scull_dev *dev = scull_access_devs[i].sculldev;
		cdev_del(&dev->cdev);
		scull_trim(scull_access_devs[i].sculldev);
	}

    	/* And all the cloned devices */
	list_for_each_entry_safe(lptr, next, &scull_c_list, list) {
		list_del(&lptr->list);
		scull_trim(&(lptr->device));
		kfree(lptr);
	}

	/* Free up our number space */
	unregister_chrdev_region(scull_a_firstdev, SCULL_N_ADEVS);
	return;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_main">
			<text>
				<![CDATA[/*
 * main.c -- the bare scull char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/seq_file.h>
#include <linux/cdev.h>

#include <asm/system.h>		/* cli(), *_flags */
#include <asm/uaccess.h>	/* copy_*_user */

#include "scull.h"		/* local definitions */

/*
 * Our parameters which can be set at load time.
 */

int scull_major =   SCULL_MAJOR;
int scull_minor =   0;
int scull_nr_devs = SCULL_NR_DEVS;	/* number of bare scull devices */
int scull_quantum = SCULL_QUANTUM;
int scull_qset =    SCULL_QSET;

module_param(scull_major, int, S_IRUGO);
module_param(scull_minor, int, S_IRUGO);
module_param(scull_nr_devs, int, S_IRUGO);
module_param(scull_quantum, int, S_IRUGO);
module_param(scull_qset, int, S_IRUGO);

MODULE_AUTHOR("Alessandro Rubini, Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");

struct scull_dev *scull_devices;	/* allocated in scull_init_module */


/*
 * Empty out the scull device; must be called with the device
 * semaphore held.
 */
int scull_trim(struct scull_dev *dev)
{
	struct scull_qset *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	for (dptr = dev->data; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			for (i = 0; i < qset; i++)
				kfree(dptr->data[i]);
			kfree(dptr->data);
			dptr->data = NULL;
		}
		next = dptr->next;
		kfree(dptr);
	}
	dev->size = 0;
	dev->quantum = scull_quantum;
	dev->qset = scull_qset;
	dev->data = NULL;
	return 0;
}
#ifdef SCULL_DEBUG /* use proc only if debugging */
/*
 * The proc filesystem: function to read and entry
 */

int scull_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, len = 0;
	int limit = count - 80; /* Don't print more than this */

	for (i = 0; i < scull_nr_devs && len <= limit; i++) {
		struct scull_dev *d = &scull_devices[i];
		struct scull_qset *qs = d->data;
		if (down_interruptible(&d->sem))
			return -ERESTARTSYS;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, q %%i, sz %%li\n",
				i, d->qset, d->quantum, d->size);
		for (; qs && len <= limit; qs = qs->next) { /* scan the list */
			len += sprintf(buf + len, "  item at %%p, qset at %%p\n",
					qs, qs->data);
			if (qs->data && !qs->next) /* dump only the last item */
				for (j = 0; j < d->qset; j++) {
					if (qs->data[j])
						len += sprintf(buf + len,
								"    %% 4i: %%8p\n",
								j, qs->data[j]);
				}
		}
		up(&scull_devices[i].sem);
	}
	*eof = 1;
	return len;
}


/*
 * For now, the seq_file implementation will exist in parallel.  The
 * older read_procmem function should maybe go away, though.
 */

/*
 * Here are our sequence iteration methods.  Our "position" is
 * simply the device number.
 */
static void *scull_seq_start(struct seq_file *s, loff_t *pos)
{
	if (*pos >= scull_nr_devs)
		return NULL;   /* No more to read */
	return scull_devices + *pos;
}

static void *scull_seq_next(struct seq_file *s, void *v, loff_t *pos)
{
	(*pos)++;
	if (*pos >= scull_nr_devs)
		return NULL;
	return scull_devices + *pos;
}

static void scull_seq_stop(struct seq_file *s, void *v)
{
	/* Actually, there's nothing to do here */
}

static int scull_seq_show(struct seq_file *s, void *v)
{
	struct scull_dev *dev = (struct scull_dev *) v;
	struct scull_qset *d;
	int i;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;
	seq_printf(s, "\nDevice %%i: qset %%i, q %%i, sz %%li\n",
			(int) (dev - scull_devices), dev->qset,
			dev->quantum, dev->size);
	for (d = dev->data; d; d = d->next) { /* scan the list */
		seq_printf(s, "  item at %%p, qset at %%p\n", d, d->data);
		if (d->data && !d->next) /* dump only the last item */
			for (i = 0; i < dev->qset; i++) {
				if (d->data[i])
					seq_printf(s, "    %% 4i: %%8p\n",
							i, d->data[i]);
			}
	}
	up(&dev->sem);
	return 0;
}
	
/*
 * Tie the sequence operators up.
 */
static struct seq_operations scull_seq_ops = {
	.start = scull_seq_start,
	.next  = scull_seq_next,
	.stop  = scull_seq_stop,
	.show  = scull_seq_show
};

/*
 * Now to implement the /proc file we need only make an open
 * method which sets up the sequence operators.
 */
static int scull_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &scull_seq_ops);
}

/*
 * Create a set of file operations for our proc file.
 */
static struct file_operations scull_proc_ops = {
	.owner   = THIS_MODULE,
	.open    = scull_proc_open,
	.read    = seq_read,
	.llseek  = seq_lseek,
	.release = seq_release
};
	

/*
 * Actually create (and remove) the /proc file(s).
 */

static void scull_create_proc(void)
{
	struct proc_dir_entry *entry;
	create_proc_read_entry("scullmem", 0 /* default mode */,
			NULL /* parent dir */, scull_read_procmem,
			NULL /* client data */);
	entry = create_proc_entry("scullseq", 0, NULL);
	if (entry)
		entry->proc_fops = &scull_proc_ops;
}

static void scull_remove_proc(void)
{
	/* no problem if it was not registered */
	remove_proc_entry("scullmem", NULL /* parent dir */);
	remove_proc_entry("scullseq", NULL);
}


#endif /* SCULL_DEBUG */





/*
 * Open and close
 */

int scull_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev; /* device information */

	dev = container_of(inode->i_cdev, struct scull_dev, cdev);
	filp->private_data = dev; /* for other methods */

	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible(&dev->sem))
			return -ERESTARTSYS;
		scull_trim(dev); /* ignore errors */
		up(&dev->sem);
	}
	return 0;          /* success */
}

int scull_release(struct inode *inode, struct file *filp)
{
	return 0;
}
/*
 * Follow the list
 */
struct scull_qset *scull_follow(struct scull_dev *dev, int n)
{
	struct scull_qset *qs = dev->data;

        /* Allocate first qset explicitly if need be */
	if (! qs) {
		qs = dev->data = kmalloc(sizeof(struct scull_qset), GFP_KERNEL);
		if (qs == NULL)
			return NULL;  /* Never mind */
		memset(qs, 0, sizeof(struct scull_qset));
	}

	/* Then follow the list */
	while (n--) {
		if (!qs->next) {
			qs->next = kmalloc(sizeof(struct scull_qset), GFP_KERNEL);
			if (qs->next == NULL)
				return NULL;  /* Never mind */
			memset(qs->next, 0, sizeof(struct scull_qset));
		}
		qs = qs->next;
		continue;
	}
	return qs;
}

/*
 * Data management: read and write
 */

ssize_t scull_read(struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_dev *dev = filp->private_data; 
	struct scull_qset *dptr;	/* the first listitem */
	int quantum = dev->quantum, qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos >= dev->size)
		goto out;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;

	/* find listitem, qset index, and offset in the quantum */
	item = (long)*f_pos / itemsize;
	rest = (long)*f_pos %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position (defined elsewhere) */
	dptr = scull_follow(dev, item);

	if (dptr == NULL || !dptr->data || ! dptr->data[s_pos])
		goto out; /* don't fill holes */

	/* read only up to the end of this quantum */
	if (count > quantum - q_pos)
		count = quantum - q_pos;

	if (copy_to_user(buf, dptr->data[s_pos] + q_pos, count)) {
		retval = -EFAULT;
		goto out;
	}
	*f_pos += count;
	retval = count;

  out:
	up(&dev->sem);
	return retval;
}

ssize_t scull_write(struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_dev *dev = filp->private_data;
	struct scull_qset *dptr;
	int quantum = dev->quantum, qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* value used in "goto out" statements */

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = (long)*f_pos / itemsize;
	rest = (long)*f_pos %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scull_follow(dev, item);
	if (dptr == NULL)
		goto out;
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(char *), GFP_KERNEL);
		if (!dptr->data)
			goto out;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] = kmalloc(quantum, GFP_KERNEL);
		if (!dptr->data[s_pos])
			goto out;
	}
	/* write only up to the end of this quantum */
	if (count > quantum - q_pos)
		count = quantum - q_pos;

	if (copy_from_user(dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto out;
	}
	*f_pos += count;
	retval = count;

        /* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;

  out:
	up(&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scull_ioctl(struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, tmp;
	int retval = 0;
    
	/*
	 * extract the type and number bitfields, and don't decode
	 * wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
	 */
	if (_IOC_TYPE(cmd) != SCULL_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULL_IOC_MAXNR) return -ENOTTY;

	/*
	 * the direction is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. `Type' is user-oriented, while
	 * access_ok is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err) return -EFAULT;

	switch(cmd) {

	  case SCULL_IOCRESET:
		scull_quantum = SCULL_QUANTUM;
		scull_qset = SCULL_QSET;
		break;
        
	  case SCULL_IOCSQUANTUM: /* Set: arg points to the value */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		retval = __get_user(scull_quantum, (int __user *)arg);
		break;

	  case SCULL_IOCTQUANTUM: /* Tell: arg is the value */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		scull_quantum = arg;
		break;

	  case SCULL_IOCGQUANTUM: /* Get: arg is pointer to result */
		retval = __put_user(scull_quantum, (int __user *)arg);
		break;

	  case SCULL_IOCQQUANTUM: /* Query: return it (it's positive) */
		return scull_quantum;

	  case SCULL_IOCXQUANTUM: /* eXchange: use arg as pointer */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_quantum;
		retval = __get_user(scull_quantum, (int __user *)arg);
		if (retval == 0)
			retval = __put_user(tmp, (int __user *)arg);
		break;

	  case SCULL_IOCHQUANTUM: /* sHift: like Tell + Query */
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_quantum;
		scull_quantum = arg;
		return tmp;
        
	  case SCULL_IOCSQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		retval = __get_user(scull_qset, (int __user *)arg);
		break;

	  case SCULL_IOCTQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		scull_qset = arg;
		break;

	  case SCULL_IOCGQSET:
		retval = __put_user(scull_qset, (int __user *)arg);
		break;

	  case SCULL_IOCQQSET:
		return scull_qset;

	  case SCULL_IOCXQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_qset;
		retval = __get_user(scull_qset, (int __user *)arg);
		if (retval == 0)
			retval = put_user(tmp, (int __user *)arg);
		break;

	  case SCULL_IOCHQSET:
		if (! capable (CAP_SYS_ADMIN))
			return -EPERM;
		tmp = scull_qset;
		scull_qset = arg;
		return tmp;

        /*
         * The following two change the buffer size for scullpipe.
         * The scullpipe device uses this same ioctl method, just to
         * write less code. Actually, it's the same driver, isn't it?
         */

	  case SCULL_P_IOCTSIZE:
		scull_p_buffer = arg;
		break;

	  case SCULL_P_IOCQSIZE:
		return scull_p_buffer;


	  default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}
	return retval;

}



/*
 * The "extended" operations -- only seek
 */

loff_t scull_llseek(struct file *filp, loff_t off, int whence)
{
	struct scull_dev *dev = filp->private_data;
	loff_t newpos;

	switch(whence) {
	  case 0: /* SEEK_SET */
		newpos = off;
		break;

	  case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	  case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	  default: /* can't happen */
		return -EINVAL;
	}
	if (newpos < 0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}



struct file_operations scull_fops = {
	.owner =    THIS_MODULE,
	.llseek =   scull_llseek,
	.read =     scull_read,
	.write =    scull_write,
	.ioctl =    scull_ioctl,
	.open =     scull_open,
	.release =  scull_release,
};

/*
 * Finally, the module stuff
 */

/*
 * The cleanup function is used to handle initialization failures as well.
 * Thefore, it must be careful to work correctly even if some of the items
 * have not been initialized
 */
void scull_cleanup_module(void)
{
	int i;
	dev_t devno = MKDEV(scull_major, scull_minor);

	/* Get rid of our char dev entries */
	if (scull_devices) {
		for (i = 0; i < scull_nr_devs; i++) {
			scull_trim(scull_devices + i);
			cdev_del(&scull_devices[i].cdev);
		}
		kfree(scull_devices);
	}

#ifdef SCULL_DEBUG /* use proc only if debugging */
	scull_remove_proc();
#endif

	/* cleanup_module is never called if registering failed */
	unregister_chrdev_region(devno, scull_nr_devs);

	/* and call the cleanup functions for friend devices */
	scull_p_cleanup();
	scull_access_cleanup();

}


/*
 * Set up the char_dev structure for this device.
 */
static void scull_setup_cdev(struct scull_dev *dev, int index)
{
	int err, devno = MKDEV(scull_major, scull_minor + index);
    
	cdev_init(&dev->cdev, &scull_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scull_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}


int scull_init_module(void)
{
	int result, i;
	dev_t dev = 0;

/*
 * Get a range of minor numbers to work with, asking for a dynamic
 * major unless directed otherwise at load time.
 */
	if (scull_major) {
		dev = MKDEV(scull_major, scull_minor);
		result = register_chrdev_region(dev, scull_nr_devs, "scull");
	} else {
		result = alloc_chrdev_region(&dev, scull_minor, scull_nr_devs,
				"scull");
		scull_major = MAJOR(dev);
	}
	if (result < 0) {
		printk(KERN_WARNING "scull: can't get major %%d\n", scull_major);
		return result;
	}

        /* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scull_devices = kmalloc(scull_nr_devs * sizeof(struct scull_dev), GFP_KERNEL);
	if (!scull_devices) {
		result = -ENOMEM;
		goto fail;  /* Make this more graceful */
	}
	memset(scull_devices, 0, scull_nr_devs * sizeof(struct scull_dev));

        /* Initialize each device. */
	for (i = 0; i < scull_nr_devs; i++) {
		scull_devices[i].quantum = scull_quantum;
		scull_devices[i].qset = scull_qset;
		init_MUTEX(&scull_devices[i].sem);
		scull_setup_cdev(&scull_devices[i], i);
	}

        /* At this point call the init function for any friend device */
	dev = MKDEV(scull_major, scull_minor + scull_nr_devs);
	dev += scull_p_init(dev);
	dev += scull_access_init(dev);

#ifdef SCULL_DEBUG /* only when debugging */
	scull_create_proc();
#endif

	return 0; /* succeed */

  fail:
	scull_cleanup_module();
	return result;
}

module_init(scull_init_module);
module_exit(scull_cleanup_module);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_access">
			<text>
				<![CDATA[/*
 * access.c -- the files with access control on open
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: access.c,v 1.17 2004/09/26 07:29:56 gregkh Exp $
 */

/* FIXME: cloned devices as a use for kobjects? */
 
#include <linux/kernel.h> /* printk() */
#include <linux/module.h>
#include <linux/slab.h>   /* kmalloc() */
#include <linux/fs.h>     /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/types.h>  /* size_t */
#include <linux/fcntl.h>
#include <linux/cdev.h>
#include <linux/tty.h>
#include <asm/atomic.h>
#include <linux/list.h>

#include "scull.h"        /* local definitions */

static dev_t scull_a_firstdev;  /* Where our range begins */

/*
 * These devices fall back on the main scull operations. They only
 * differ in the implementation of open() and close()
 */



/************************************************************************
 *
 * The first device is the single-open one,
 *  it has an hw structure and an open count
 */

static struct scull_dev scull_s_device;
static atomic_t scull_s_available = ATOMIC_INIT(1);

static int scull_s_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_s_device; /* device information */

	if (! atomic_dec_and_test (&scull_s_available)) {
		atomic_inc(&scull_s_available);
		return -EBUSY; /* already open */
	}

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_s_release(struct inode *inode, struct file *filp)
{
	atomic_inc(&scull_s_available); /* release the device */
	return 0;
}


/*
 * The other operations for the single-open device come from the bare device
 */
struct file_operations scull_sngl_fops = {
	.owner =	THIS_MODULE,
	.llseek =     	scull_llseek,
	.read =       	scull_read,
	.write =      	scull_write,
	.ioctl =      	scull_ioctl,
	.open =       	scull_s_open,
	.release =    	scull_s_release,
};


/************************************************************************
 *
 * Next, the "uid" device. It can be opened multiple times by the
 * same user, but access is denied to other users if the device is open
 */

static struct scull_dev scull_u_device;
static int scull_u_count;	/* initialized to 0 by default */
static uid_t scull_u_owner;	/* initialized to 0 by default */
static spinlock_t scull_u_lock = SPIN_LOCK_UNLOCKED;

static int scull_u_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_u_device; /* device information */

	spin_lock(&scull_u_lock);
	if (scull_u_count && 
			(scull_u_owner != current->uid) &&  /* allow user */
			(scull_u_owner != current->euid) && /* allow whoever did su */
			!capable(CAP_DAC_OVERRIDE)) { /* still allow root */
		spin_unlock(&scull_u_lock);
		return -EBUSY;   /* -EPERM would confuse the user */
	}

	if (scull_u_count == 0)
		scull_u_owner = current->uid; /* grab it */

	scull_u_count++;
	spin_unlock(&scull_u_lock);

/* then, everything else is copied from the bare scull device */

	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_u_release(struct inode *inode, struct file *filp)
{
	spin_lock(&scull_u_lock);
	scull_u_count--; /* nothing else */
	spin_unlock(&scull_u_lock);
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_user_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_u_open,
	.release =    scull_u_release,
};


/************************************************************************
 *
 * Next, the device with blocking-open based on uid
 */

static struct scull_dev scull_w_device;
static int scull_w_count;	/* initialized to 0 by default */
static uid_t scull_w_owner;	/* initialized to 0 by default */
static DECLARE_WAIT_QUEUE_HEAD(scull_w_wait);
static spinlock_t scull_w_lock = SPIN_LOCK_UNLOCKED;

static inline int scull_w_available(void)
{
	return scull_w_count == 0 ||
		scull_w_owner == current->uid ||
		scull_w_owner == current->euid ||
		capable(CAP_DAC_OVERRIDE);
}


static int scull_w_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev = &scull_w_device; /* device information */

	spin_lock(&scull_w_lock);
	while (! scull_w_available()) {
		spin_unlock(&scull_w_lock);
		if (filp->f_flags & O_NONBLOCK) return -EAGAIN;
		if (wait_event_interruptible (scull_w_wait, scull_w_available()))
			return -ERESTARTSYS; /* tell the fs layer to handle it */
		spin_lock(&scull_w_lock);
	}
	if (scull_w_count == 0)
		scull_w_owner = current->uid; /* grab it */
	scull_w_count++;
	spin_unlock(&scull_w_lock);

	/* then, everything else is copied from the bare scull device */
	if ((filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_w_release(struct inode *inode, struct file *filp)
{
	int temp;

	spin_lock(&scull_w_lock);
	scull_w_count--;
	temp = scull_w_count;
	spin_unlock(&scull_w_lock);

	if (temp == 0)
		wake_up_interruptible_sync(&scull_w_wait); /* awake other uid's */
	return 0;
}


/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_wusr_fops = {
	.owner =      THIS_MODULE,
	.llseek =     scull_llseek,
	.read =       scull_read,
	.write =      scull_write,
	.ioctl =      scull_ioctl,
	.open =       scull_w_open,
	.release =    scull_w_release,
};

/************************************************************************
 *
 * Finally the `cloned' private device. This is trickier because it
 * involves list management, and dynamic allocation.
 */

/* The clone-specific data structure includes a key field */

struct scull_listitem {
	struct scull_dev device;
	dev_t key;
	struct list_head list;
    
};

/* The list of devices, and a lock to protect it */
static LIST_HEAD(scull_c_list);
static spinlock_t scull_c_lock = SPIN_LOCK_UNLOCKED;

/* A placeholder scull_dev which really just holds the cdev stuff. */
static struct scull_dev scull_c_device;   

/* Look for a device or create one if missing */
static struct scull_dev *scull_c_lookfor_device(dev_t key)
{
	struct scull_listitem *lptr;

	list_for_each_entry(lptr, &scull_c_list, list) {
		if (lptr->key == key)
			return &(lptr->device);
	}

	/* not found */
	lptr = kmalloc(sizeof(struct scull_listitem), GFP_KERNEL);
	if (!lptr)
		return NULL;

	/* initialize the device */
	memset(lptr, 0, sizeof(struct scull_listitem));
	lptr->key = key;
	scull_trim(&(lptr->device)); /* initialize it */
	init_MUTEX(&(lptr->device.sem));

	/* place it in the list */
	list_add(&lptr->list, &scull_c_list);

	return &(lptr->device);
}

static int scull_c_open(struct inode *inode, struct file *filp)
{
	struct scull_dev *dev;
	dev_t key;
 
	if (!current->signal->tty) { 
		PDEBUG("Process \"%%s\" has no ctl tty\n", current->comm);
		return -EINVAL;
	}
	key = tty_devnum(current->signal->tty);

	/* look for a scullc device in the list */
	spin_lock(&scull_c_lock);
	dev = scull_c_lookfor_device(key);
	spin_unlock(&scull_c_lock);

	if (!dev)
		return -ENOMEM;

	/* then, everything else is copied from the bare scull device */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY)
		scull_trim(dev);
	filp->private_data = dev;
	return 0;          /* success */
}

static int scull_c_release(struct inode *inode, struct file *filp)
{
	/*
	 * Nothing to do, because the device is persistent.
	 * A `real' cloned device should be freed on last close
	 */
	return 0;
}



/*
 * The other operations for the device come from the bare device
 */
struct file_operations scull_priv_fops = {
	.owner =    THIS_MODULE,
	.llseek =   scull_llseek,
	.read =     scull_read,
	.write =    scull_write,
	.ioctl =    scull_ioctl,
	.open =     scull_c_open,
	.release =  scull_c_release,
};

/************************************************************************
 *
 * And the init and cleanup functions come last
 */

static struct scull_adev_info {
	char *name;
	struct scull_dev *sculldev;
	struct file_operations *fops;
} scull_access_devs[] = {
	{ "scullsingle", &scull_s_device, &scull_sngl_fops },
	{ "sculluid", &scull_u_device, &scull_user_fops },
	{ "scullwuid", &scull_w_device, &scull_wusr_fops },
	{ "sullpriv", &scull_c_device, &scull_priv_fops }
};
#define SCULL_N_ADEVS 4

/*
 * Set up a single device.
 */
static void scull_access_setup (dev_t devno, struct scull_adev_info *devinfo)
{
	struct scull_dev *dev = devinfo->sculldev;
	int err;

	/* Initialize the device structure */
	dev->quantum = scull_quantum;
	dev->qset = scull_qset;
	init_MUTEX(&dev->sem);

	/* Do the cdev stuff. */
	cdev_init(&dev->cdev, devinfo->fops);
	kobject_set_name(&dev->cdev.kobj, devinfo->name);
	dev->cdev.owner = THIS_MODULE;
	err = cdev_add (&dev->cdev, devno, 1);
        /* Fail gracefully if need be */
	if (err) {
		printk(KERN_NOTICE "Error %%d adding %%s\n", err, devinfo->name);
		kobject_put(&dev->cdev.kobj);
	} else
		printk(KERN_NOTICE "%%s registered at %%x\n", devinfo->name, devno);
}


int scull_access_init(dev_t firstdev)
{
	int result, i;

	/* Get our number space */
	result = register_chrdev_region (firstdev, SCULL_N_ADEVS, "sculla");
	if (result < 0) {
		printk(KERN_WARNING "sculla: device number registration failed\n");
		return 0;
	}
	scull_a_firstdev = firstdev;

	/* Set up each device. */
	for (i = 0; i < SCULL_N_ADEVS; i++)
		scull_access_setup (firstdev + i, scull_access_devs + i);
	return SCULL_N_ADEVS;
}

/*
 * This is called by cleanup_module or on failure.
 * It is required to never fail, even if nothing was initialized first
 */
void scull_access_cleanup(void)
{
	struct scull_listitem *lptr, *next;
	int i;

	/* Clean up the static devs */
	for (i = 0; i < SCULL_N_ADEVS; i++) {
		struct scull_dev *dev = scull_access_devs[i].sculldev;
		cdev_del(&dev->cdev);
		scull_trim(scull_access_devs[i].sculldev);
	}

    	/* And all the cloned devices */
	list_for_each_entry_safe(lptr, next, &scull_c_list, list) {
		list_del(&lptr->list);
		scull_trim(&(lptr->device));
		kfree(lptr);
	}

	/* Free up our number space */
	unregister_chrdev_region(scull_a_firstdev, SCULL_N_ADEVS);
	return;
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_pipe">
			<text>
				<![CDATA[/*
 * pipe.c -- fifo driver for scull
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */
 
#include <linux/module.h>
#include <linux/moduleparam.h>

#include <linux/kernel.h>	/* printk(), min() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/proc_fs.h>
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/fcntl.h>
#include <linux/poll.h>
#include <linux/cdev.h>
#include <asm/uaccess.h>

#include "scull.h"		/* local definitions */

struct scull_pipe {
        wait_queue_head_t inq, outq;       /* read and write queues */
        char *buffer, *end;                /* begin of buf, end of buf */
        int buffersize;                    /* used in pointer arithmetic */
        char *rp, *wp;                     /* where to read, where to write */
        int nreaders, nwriters;            /* number of openings for r/w */
        struct fasync_struct *async_queue; /* asynchronous readers */
        struct semaphore sem;              /* mutual exclusion semaphore */
        struct cdev cdev;                  /* Char device structure */
};

/* parameters */
static int scull_p_nr_devs = SCULL_P_NR_DEVS;	/* number of pipe devices */
int scull_p_buffer =  SCULL_P_BUFFER;	/* buffer size */
dev_t scull_p_devno;			/* Our first device number */

module_param(scull_p_nr_devs, int, 0);	/* FIXME check perms */
module_param(scull_p_buffer, int, 0);

static struct scull_pipe *scull_p_devices;

static int scull_p_fasync(int fd, struct file *filp, int mode);
static int spacefree(struct scull_pipe *dev);
/*
 * Open and close
 */


static int scull_p_open(struct inode *inode, struct file *filp)
{
	struct scull_pipe *dev;

	dev = container_of(inode->i_cdev, struct scull_pipe, cdev);
	filp->private_data = dev;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;
	if (!dev->buffer) {
		/* allocate the buffer */
		dev->buffer = kmalloc(scull_p_buffer, GFP_KERNEL);
		if (!dev->buffer) {
			up(&dev->sem);
			return -ENOMEM;
		}
	}
	dev->buffersize = scull_p_buffer;
	dev->end = dev->buffer + dev->buffersize;
	dev->rp = dev->wp = dev->buffer; /* rd and wr from the beginning */

	/* use f_mode,not  f_flags: it's cleaner (fs/open.c tells why) */
	if (filp->f_mode & FMODE_READ)
		dev->nreaders++;
	if (filp->f_mode & FMODE_WRITE)
		dev->nwriters++;
	up(&dev->sem);

	return nonseekable_open(inode, filp);
}



static int scull_p_release(struct inode *inode, struct file *filp)
{
	struct scull_pipe *dev = filp->private_data;

	/* remove this filp from the asynchronously notified filp's */
	scull_p_fasync(-1, filp, 0);
	down(&dev->sem);
	if (filp->f_mode & FMODE_READ)
		dev->nreaders--;
	if (filp->f_mode & FMODE_WRITE)
		dev->nwriters--;
	if (dev->nreaders + dev->nwriters == 0) {
		kfree(dev->buffer);
		dev->buffer = NULL; /* the other fields are not checked on open */
	}
	up(&dev->sem);
	return 0;
}


/*
 * Data management: read and write
 */

static ssize_t scull_p_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_pipe *dev = filp->private_data;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;

	while (dev->rp == dev->wp) { /* nothing to read */
		up(&dev->sem); /* release the lock */
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		PDEBUG("\"%%s\" reading: going to sleep\n", current->comm);
		if (wait_event_interruptible(dev->inq, (dev->rp != dev->wp)))
			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
		/* otherwise loop, but first reacquire the lock */
		if (down_interruptible(&dev->sem))
			return -ERESTARTSYS;
	}
	/* ok, data is there, return something */
	if (dev->wp > dev->rp)
		count = min(count, (size_t)(dev->wp - dev->rp));
	else /* the write pointer has wrapped, return data up to dev->end */
		count = min(count, (size_t)(dev->end - dev->rp));
	if (copy_to_user(buf, dev->rp, count)) {
		up (&dev->sem);
		return -EFAULT;
	}
	dev->rp += count;
	if (dev->rp == dev->end)
		dev->rp = dev->buffer; /* wrapped */
	up (&dev->sem);

	/* finally, awake any writers and return */
	wake_up_interruptible(&dev->outq);
	PDEBUG("\"%%s\" did read %%li bytes\n",current->comm, (long)count);
	return count;
}

/* Wait for space for writing; caller must hold device semaphore.  On
 * error the semaphore will be released before returning. */
static int scull_getwritespace(struct scull_pipe *dev, struct file *filp)
{
	while (spacefree(dev) == 0) { /* full */
		DEFINE_WAIT(wait);
		
		up(&dev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		PDEBUG("\"%%s\" writing: going to sleep\n",current->comm);
		prepare_to_wait(&dev->outq, &wait, TASK_INTERRUPTIBLE);
		if (spacefree(dev) == 0)
			schedule();
		finish_wait(&dev->outq, &wait);
		if (signal_pending(current))
			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
		if (down_interruptible(&dev->sem))
			return -ERESTARTSYS;
	}
	return 0;
}	

/* How much space is free? */
static int spacefree(struct scull_pipe *dev)
{
	if (dev->rp == dev->wp)
		return dev->buffersize - 1;
	return ((dev->rp + dev->buffersize - dev->wp) %% dev->buffersize) - 1;
}

static ssize_t scull_p_write(struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scull_pipe *dev = filp->private_data;
	int result;

	if (down_interruptible(&dev->sem))
		return -ERESTARTSYS;

	/* Make sure there's space to write */
	result = scull_getwritespace(dev, filp);
	if (result)
		return result; /* scull_getwritespace called up(&dev->sem) */

	/* ok, space is there, accept something */
	count = min(count, (size_t)spacefree(dev));
	if (dev->wp >= dev->rp)
		count = min(count, (size_t)(dev->end - dev->wp)); /* to end-of-buf */
	else /* the write pointer has wrapped, fill up to rp-1 */
		count = min(count, (size_t)(dev->rp - dev->wp - 1));
	PDEBUG("Going to accept %%li bytes to %%p from %%p\n", (long)count, dev->wp, buf);
	if (copy_from_user(dev->wp, buf, count)) {
		up (&dev->sem);
		return -EFAULT;
	}
	dev->wp += count;
	if (dev->wp == dev->end)
		dev->wp = dev->buffer; /* wrapped */
	up(&dev->sem);

	/* finally, awake any reader */
	wake_up_interruptible(&dev->inq);  /* blocked in read() and select() */

	/* and signal asynchronous readers, explained late in chapter 5 */
	if (dev->async_queue)
		kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	PDEBUG("\"%%s\" did write %%li bytes\n",current->comm, (long)count);
	return count;
}

static unsigned int scull_p_poll(struct file *filp, poll_table *wait)
{
	struct scull_pipe *dev = filp->private_data;
	unsigned int mask = 0;

	/*
	 * The buffer is circular; it is considered full
	 * if "wp" is right behind "rp" and empty if the
	 * two are equal.
	 */
	down(&dev->sem);
	poll_wait(filp, &dev->inq,  wait);
	poll_wait(filp, &dev->outq, wait);
	if (dev->rp != dev->wp)
		mask |= POLLIN | POLLRDNORM;	/* readable */
	if (spacefree(dev))
		mask |= POLLOUT | POLLWRNORM;	/* writable */
	up(&dev->sem);
	return mask;
}





static int scull_p_fasync(int fd, struct file *filp, int mode)
{
	struct scull_pipe *dev = filp->private_data;

	return fasync_helper(fd, filp, mode, &dev->async_queue);
}



/* FIXME this should use seq_file */
#ifdef SCULL_DEBUG
static void scullp_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {	/* Not there yet */
		*offset -= *len;
		*len = 0;
	}
	else {			/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}


static int scull_read_p_mem(char *buf, char **start, off_t offset, int count,
		int *eof, void *data)
{
	int i, len;
	struct scull_pipe *p;

#define LIMIT (PAGE_SIZE-200)	/* don't print any more after this size */
	*start = buf;
	len = sprintf(buf, "Default buffersize is %%i\n", scull_p_buffer);
	for(i = 0; i<scull_p_nr_devs && len <= LIMIT; i++) {
		p = &scull_p_devices[i];
		if (down_interruptible(&p->sem))
			return -ERESTARTSYS;
		len += sprintf(buf+len, "\nDevice %%i: %%p\n", i, p);
/*		len += sprintf(buf+len, "   Queues: %%p %%p\n", p->inq, p->outq);*/
		len += sprintf(buf+len, "   Buffer: %%p to %%p (%%i bytes)\n", p->buffer, p->end, p->buffersize);
		len += sprintf(buf+len, "   rp %%p   wp %%p\n", p->rp, p->wp);
		len += sprintf(buf+len, "   readers %%i   writers %%i\n", p->nreaders, p->nwriters);
		up(&p->sem);
		scullp_proc_offset(buf, start, &offset, &len);
	}
	*eof = (len <= LIMIT);
	return len;
}


#endif



/*
 * The file operations for the pipe device
 * (some are overlayed with bare scull)
 */
struct file_operations scull_pipe_fops = {
	.owner =	THIS_MODULE,
	.llseek =	no_llseek,
	.read =		scull_p_read,
	.write =	scull_p_write,
	.poll =		scull_p_poll,
	.ioctl =	scull_ioctl,
	.open =		scull_p_open,
	.release =	scull_p_release,
	.fasync =	scull_p_fasync,
};


/*
 * Set up a cdev entry.
 */
static void scull_p_setup_cdev(struct scull_pipe *dev, int index)
{
	int err, devno = scull_p_devno + index;
    
	cdev_init(&dev->cdev, &scull_pipe_fops);
	dev->cdev.owner = THIS_MODULE;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scullpipe%%d", err, index);
}

 

/*
 * Initialize the pipe devs; return how many we did.
 */
int scull_p_init(dev_t firstdev)
{
	int i, result;

	result = register_chrdev_region(firstdev, scull_p_nr_devs, "scullp");
	if (result < 0) {
		printk(KERN_NOTICE "Unable to get scullp region, error %%d\n", result);
		return 0;
	}
	scull_p_devno = firstdev;
	scull_p_devices = kmalloc(scull_p_nr_devs * sizeof(struct scull_pipe), GFP_KERNEL);
	if (scull_p_devices == NULL) {
		unregister_chrdev_region(firstdev, scull_p_nr_devs);
		return 0;
	}
	memset(scull_p_devices, 0, scull_p_nr_devs * sizeof(struct scull_pipe));
	for (i = 0; i < scull_p_nr_devs; i++) {
		init_waitqueue_head(&(scull_p_devices[i].inq));
		init_waitqueue_head(&(scull_p_devices[i].outq));
		init_MUTEX(&scull_p_devices[i].sem);
		scull_p_setup_cdev(scull_p_devices + i, i);
	}
#ifdef SCULL_DEBUG
	create_proc_read_entry("scullpipe", 0, NULL, scull_read_p_mem, NULL);
#endif
	return scull_p_nr_devs;
}

/*
 * This is called by cleanup_module or on failure.
 * It is required to never fail, even if nothing was initialized first
 */
void scull_p_cleanup(void)
{
	int i;

#ifdef SCULL_DEBUG
	remove_proc_entry("scullpipe", NULL);
#endif

	if (!scull_p_devices)
		return; /* nothing else to release */

	for (i = 0; i < scull_p_nr_devs; i++) {
		cdev_del(&scull_p_devices[i].cdev);
		kfree(scull_p_devices[i].buffer);
	}
	kfree(scull_p_devices);
	unregister_chrdev_region(scull_p_devno, scull_p_nr_devs);
	scull_p_devices = NULL; /* pedantic */
}
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullc_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare scullc char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include "scullc.h"		/* local definitions */


int scullc_major =   SCULLC_MAJOR;
int scullc_devs =    SCULLC_DEVS;	/* number of bare scullc devices */
int scullc_qset =    SCULLC_QSET;
int scullc_quantum = SCULLC_QUANTUM;

module_param(scullc_major, int, 0);
module_param(scullc_devs, int, 0);
module_param(scullc_qset, int, 0);
module_param(scullc_quantum, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct scullc_dev *scullc_devices; /* allocated in scullc_init */

int scullc_trim(struct scullc_dev *dev);
void scullc_cleanup(void);

/* declare one cache pointer: use it for all devices */
kmem_cache_t *scullc_cache;





#ifdef SCULLC_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void scullc_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int scullc_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, quantum, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct scullc_dev *d;

	*start = buf;
	for(i = 0; i < scullc_devs; i++) {
		d = &scullc_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		quantum=d->quantum;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, quantum %%i, sz %%li\n",
				i, qset, quantum, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			scullc_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					scullc_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&scullc_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLC_USE_PROC */

/*
 * Open and close
 */

int scullc_open (struct inode *inode, struct file *filp)
{
	struct scullc_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct scullc_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		scullc_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int scullc_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct scullc_dev *scullc_follow(struct scullc_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct scullc_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct scullc_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t scullc_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullc_dev *dev = filp->private_data; /* the first listitem */
	struct scullc_dev *dptr;
	int quantum = dev->quantum;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = scullc_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t scullc_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullc_dev *dev = filp->private_data;
	struct scullc_dev *dptr;
	int quantum = dev->quantum;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scullc_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Allocate a quantum using the memory cache */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] = kmem_cache_alloc(scullc_cache, GFP_KERNEL);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, scullc_quantum);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scullc_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLC_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLC_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLC_IOCRESET:
		scullc_qset = SCULLC_QSET;
		scullc_quantum = SCULLC_QUANTUM;
		break;

	case SCULLC_IOCSQUANTUM: /* Set: arg points to the value */
		ret = __get_user(scullc_quantum, (int __user *) arg);
		break;

	case SCULLC_IOCTQUANTUM: /* Tell: arg is the value */
		scullc_quantum = arg;
		break;

	case SCULLC_IOCGQUANTUM: /* Get: arg is pointer to result */
		ret = __put_user (scullc_quantum, (int __user *) arg);
		break;

	case SCULLC_IOCQQUANTUM: /* Query: return it (it's positive) */
		return scullc_quantum;

	case SCULLC_IOCXQUANTUM: /* eXchange: use arg as pointer */
		tmp = scullc_quantum;
		ret = __get_user(scullc_quantum, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLC_IOCHQUANTUM: /* sHift: like Tell + Query */
		tmp = scullc_quantum;
		scullc_quantum = arg;
		return tmp;

	case SCULLC_IOCSQSET:
		ret = __get_user(scullc_qset, (int __user *) arg);
		break;

	case SCULLC_IOCTQSET:
		scullc_qset = arg;
		break;

	case SCULLC_IOCGQSET:
		ret = __put_user(scullc_qset, (int __user *)arg);
		break;

	case SCULLC_IOCQQSET:
		return scullc_qset;

	case SCULLC_IOCXQSET:
		tmp = scullc_qset;
		ret = __get_user(scullc_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLC_IOCHQSET:
		tmp = scullc_qset;
		scullc_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t scullc_llseek (struct file *filp, loff_t off, int whence)
{
	struct scullc_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void scullc_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int scullc_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = scullc_write(iocb->ki_filp, buf, count, &pos);
	else
		result = scullc_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, scullc_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t scullc_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return scullc_defer_op(0, iocb, buf, count, pos);
}

static ssize_t scullc_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return scullc_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 

/*
 * The fops
 */

struct file_operations scullc_fops = {
	.owner =     THIS_MODULE,
	.llseek =    scullc_llseek,
	.read =	     scullc_read,
	.write =     scullc_write,
	.ioctl =     scullc_ioctl,
	.open =	     scullc_open,
	.release =   scullc_release,
	.aio_read =  scullc_aio_read,
	.aio_write = scullc_aio_write,
};

int scullc_trim(struct scullc_dev *dev)
{
	struct scullc_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					kmem_cache_free(scullc_cache, dptr->data[i]);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = scullc_qset;
	dev->quantum = scullc_quantum;
	dev->next = NULL;
	return 0;
}


static void scullc_setup_cdev(struct scullc_dev *dev, int index)
{
	int err, devno = MKDEV(scullc_major, index);
    
	cdev_init(&dev->cdev, &scullc_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scullc_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}



/*
 * Finally, the module stuff
 */

int scullc_init(void)
{
	int result, i;
	dev_t dev = MKDEV(scullc_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (scullc_major)
		result = register_chrdev_region(dev, scullc_devs, "scullc");
	else {
		result = alloc_chrdev_region(&dev, 0, scullc_devs, "scullc");
		scullc_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scullc_devices = kmalloc(scullc_devs*sizeof (struct scullc_dev), GFP_KERNEL);
	if (!scullc_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(scullc_devices, 0, scullc_devs*sizeof (struct scullc_dev));
	for (i = 0; i < scullc_devs; i++) {
		scullc_devices[i].quantum = scullc_quantum;
		scullc_devices[i].qset = scullc_qset;
		sema_init (&scullc_devices[i].sem, 1);
		scullc_setup_cdev(scullc_devices + i, i);
	}

	scullc_cache = kmem_cache_create("scullc", scullc_quantum,
			0, SLAB_HWCACHE_ALIGN, NULL, NULL); /* no ctor/dtor */
	if (!scullc_cache) {
		scullc_cleanup();
		return -ENOMEM;
	}

#ifdef SCULLC_USE_PROC /* only when available */
	create_proc_read_entry("scullcmem", 0, NULL, scullc_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, scullc_devs);
	return result;
}



void scullc_cleanup(void)
{
	int i;

#ifdef SCULLC_USE_PROC
	remove_proc_entry("scullcmem", NULL);
#endif

	for (i = 0; i < scullc_devs; i++) {
		cdev_del(&scullc_devices[i].cdev);
		scullc_trim(scullc_devices + i);
	}
	kfree(scullc_devices);

	if (scullc_cache)
		kmem_cache_destroy(scullc_cache);
	unregister_chrdev_region(MKDEV (scullc_major, 0), scullc_devs);
}


module_init(scullc_init);
module_exit(scullc_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullc_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the scullc char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "scullc.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void scullc_vma_open(struct vm_area_struct *vma)
{
	struct scullc_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void scullc_vma_close(struct vm_area_struct *vma)
{
	struct scullc_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the scullc device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *scullc_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct scullc_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the scullc device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct scullc_vm_ops = {
	.open =     scullc_vma_open,
	.close =    scullc_vma_close,
	.nopage =   scullc_vma_nopage,
};


int scullc_mmap(struct file *filp, struct vm_area_struct *vma)
{
	struct inode *inode = filp->f_dentry->d_inode;

	/* refuse to map if order is not 0 */
	if (scullc_devices[iminor(inode)].order)
		return -ENODEV;

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &scullc_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	scullc_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_sculld_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare sculld char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include "sculld.h"		/* local definitions */


int sculld_major =   SCULLD_MAJOR;
int sculld_devs =    SCULLD_DEVS;	/* number of bare sculld devices */
int sculld_qset =    SCULLD_QSET;
int sculld_order =   SCULLD_ORDER;

module_param(sculld_major, int, 0);
module_param(sculld_devs, int, 0);
module_param(sculld_qset, int, 0);
module_param(sculld_order, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct sculld_dev *sculld_devices; /* allocated in sculld_init */

int sculld_trim(struct sculld_dev *dev);
void sculld_cleanup(void);



/* Device model stuff */

static struct ldd_driver sculld_driver = {
	.version = "$Revision: 1.21 $",
	.module = THIS_MODULE,
	.driver = {
		.name = "sculld",
	},
};



#ifdef SCULLD_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void sculld_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int sculld_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, order, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct sculld_dev *d;

	*start = buf;
	for(i = 0; i < sculld_devs; i++) {
		d = &sculld_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		order = d->order;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, order %%i, sz %%li\n",
				i, qset, order, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			sculld_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					sculld_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&sculld_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLD_USE_PROC */

/*
 * Open and close
 */

int sculld_open (struct inode *inode, struct file *filp)
{
	struct sculld_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct sculld_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		sculld_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int sculld_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct sculld_dev *sculld_follow(struct sculld_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct sculld_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct sculld_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t sculld_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct sculld_dev *dev = filp->private_data; /* the first listitem */
	struct sculld_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = sculld_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t sculld_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct sculld_dev *dev = filp->private_data;
	struct sculld_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = sculld_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Here's the allocation of a single quantum */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] =
			(void *)__get_free_pages(GFP_KERNEL, dptr->order);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, PAGE_SIZE << dptr->order);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int sculld_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLD_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLD_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLD_IOCRESET:
		sculld_qset = SCULLD_QSET;
		sculld_order = SCULLD_ORDER;
		break;

	case SCULLD_IOCSORDER: /* Set: arg points to the value */
		ret = __get_user(sculld_order, (int __user *) arg);
		break;

	case SCULLD_IOCTORDER: /* Tell: arg is the value */
		sculld_order = arg;
		break;

	case SCULLD_IOCGORDER: /* Get: arg is pointer to result */
		ret = __put_user (sculld_order, (int __user *) arg);
		break;

	case SCULLD_IOCQORDER: /* Query: return it (it's positive) */
		return sculld_order;

	case SCULLD_IOCXORDER: /* eXchange: use arg as pointer */
		tmp = sculld_order;
		ret = __get_user(sculld_order, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLD_IOCHORDER: /* sHift: like Tell + Query */
		tmp = sculld_order;
		sculld_order = arg;
		return tmp;

	case SCULLD_IOCSQSET:
		ret = __get_user(sculld_qset, (int __user *) arg);
		break;

	case SCULLD_IOCTQSET:
		sculld_qset = arg;
		break;

	case SCULLD_IOCGQSET:
		ret = __put_user(sculld_qset, (int __user *)arg);
		break;

	case SCULLD_IOCQQSET:
		return sculld_qset;

	case SCULLD_IOCXQSET:
		tmp = sculld_qset;
		ret = __get_user(sculld_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLD_IOCHQSET:
		tmp = sculld_qset;
		sculld_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t sculld_llseek (struct file *filp, loff_t off, int whence)
{
	struct sculld_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void sculld_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int sculld_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = sculld_write(iocb->ki_filp, buf, count, &pos);
	else
		result = sculld_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, sculld_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t sculld_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return sculld_defer_op(0, iocb, buf, count, pos);
}

static ssize_t sculld_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return sculld_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 
/*
 * Mmap *is* available, but confined in a different file
 */
extern int sculld_mmap(struct file *filp, struct vm_area_struct *vma);


/*
 * The fops
 */

struct file_operations sculld_fops = {
	.owner =     THIS_MODULE,
	.llseek =    sculld_llseek,
	.read =	     sculld_read,
	.write =     sculld_write,
	.ioctl =     sculld_ioctl,
	.mmap =	     sculld_mmap,
	.open =	     sculld_open,
	.release =   sculld_release,
	.aio_read =  sculld_aio_read,
	.aio_write = sculld_aio_write,
};

int sculld_trim(struct sculld_dev *dev)
{
	struct sculld_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			/* This code frees a whole quantum-set */
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					free_pages((unsigned long)(dptr->data[i]),
							dptr->order);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = sculld_qset;
	dev->order = sculld_order;
	dev->next = NULL;
	return 0;
}


static void sculld_setup_cdev(struct sculld_dev *dev, int index)
{
	int err, devno = MKDEV(sculld_major, index);
    
	cdev_init(&dev->cdev, &sculld_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &sculld_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}

static ssize_t sculld_show_dev(struct device *ddev, char *buf)
{
	struct sculld_dev *dev = ddev->driver_data;

	return print_dev_t(buf, dev->cdev.dev);
}

static DEVICE_ATTR(dev, S_IRUGO, sculld_show_dev, NULL);

static void sculld_register_dev(struct sculld_dev *dev, int index)
{
	sprintf(dev->devname, "sculld%%d", index);
	dev->ldev.name = dev->devname;
	dev->ldev.driver = &sculld_driver;
	dev->ldev.dev.driver_data = dev;
	register_ldd_device(&dev->ldev);
	device_create_file(&dev->ldev.dev, &dev_attr_dev);
}


/*
 * Finally, the module stuff
 */

int sculld_init(void)
{
	int result, i;
	dev_t dev = MKDEV(sculld_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (sculld_major)
		result = register_chrdev_region(dev, sculld_devs, "sculld");
	else {
		result = alloc_chrdev_region(&dev, 0, sculld_devs, "sculld");
		sculld_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	/*
	 * Register with the driver core.
	 */
	register_ldd_driver(&sculld_driver);
	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	sculld_devices = kmalloc(sculld_devs*sizeof (struct sculld_dev), GFP_KERNEL);
	if (!sculld_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(sculld_devices, 0, sculld_devs*sizeof (struct sculld_dev));
	for (i = 0; i < sculld_devs; i++) {
		sculld_devices[i].order = sculld_order;
		sculld_devices[i].qset = sculld_qset;
		sema_init (&sculld_devices[i].sem, 1);
		sculld_setup_cdev(sculld_devices + i, i);
		sculld_register_dev(sculld_devices + i, i);
	}


#ifdef SCULLD_USE_PROC /* only when available */
	create_proc_read_entry("sculldmem", 0, NULL, sculld_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, sculld_devs);
	return result;
}



void sculld_cleanup(void)
{
	int i;

#ifdef SCULLD_USE_PROC
	remove_proc_entry("sculldmem", NULL);
#endif

	for (i = 0; i < sculld_devs; i++) {
		unregister_ldd_device(&sculld_devices[i].ldev);
		cdev_del(&sculld_devices[i].cdev);
		sculld_trim(sculld_devices + i);
	}
	kfree(sculld_devices);
	unregister_ldd_driver(&sculld_driver);
	unregister_chrdev_region(MKDEV (sculld_major, 0), sculld_devs);
}


module_init(sculld_init);
module_exit(sculld_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_sculld_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the sculld char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "sculld.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void sculld_vma_open(struct vm_area_struct *vma)
{
	struct sculld_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void sculld_vma_close(struct vm_area_struct *vma)
{
	struct sculld_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the sculld device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *sculld_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct sculld_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the sculld device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct sculld_vm_ops = {
	.open =     sculld_vma_open,
	.close =    sculld_vma_close,
	.nopage =   sculld_vma_nopage,
};


int sculld_mmap(struct file *filp, struct vm_area_struct *vma)
{
	struct inode *inode = filp->f_dentry->d_inode;

	/* refuse to map if order is not 0 */
	if (sculld_devices[iminor(inode)].order)
		return -ENODEV;

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &sculld_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	sculld_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_scullp_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare scullp char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include "scullp.h"		/* local definitions */


int scullp_major =   SCULLP_MAJOR;
int scullp_devs =    SCULLP_DEVS;	/* number of bare scullp devices */
int scullp_qset =    SCULLP_QSET;
int scullp_order =   SCULLP_ORDER;

module_param(scullp_major, int, 0);
module_param(scullp_devs, int, 0);
module_param(scullp_qset, int, 0);
module_param(scullp_order, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct scullp_dev *scullp_devices; /* allocated in scullp_init */

int scullp_trim(struct scullp_dev *dev);
void scullp_cleanup(void);






#ifdef SCULLP_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void scullp_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int scullp_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, order, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct scullp_dev *d;

	*start = buf;
	for(i = 0; i < scullp_devs; i++) {
		d = &scullp_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		order = d->order;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, order %%i, sz %%li\n",
				i, qset, order, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			scullp_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					scullp_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&scullp_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLP_USE_PROC */

/*
 * Open and close
 */

int scullp_open (struct inode *inode, struct file *filp)
{
	struct scullp_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct scullp_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		scullp_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int scullp_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct scullp_dev *scullp_follow(struct scullp_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct scullp_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct scullp_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t scullp_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullp_dev *dev = filp->private_data; /* the first listitem */
	struct scullp_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = scullp_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t scullp_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullp_dev *dev = filp->private_data;
	struct scullp_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scullp_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Here's the allocation of a single quantum */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] =
			(void *)__get_free_pages(GFP_KERNEL, dptr->order);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, PAGE_SIZE << dptr->order);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scullp_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLP_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLP_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLP_IOCRESET:
		scullp_qset = SCULLP_QSET;
		scullp_order = SCULLP_ORDER;
		break;

	case SCULLP_IOCSORDER: /* Set: arg points to the value */
		ret = __get_user(scullp_order, (int __user *) arg);
		break;

	case SCULLP_IOCTORDER: /* Tell: arg is the value */
		scullp_order = arg;
		break;

	case SCULLP_IOCGORDER: /* Get: arg is pointer to result */
		ret = __put_user (scullp_order, (int __user *) arg);
		break;

	case SCULLP_IOCQORDER: /* Query: return it (it's positive) */
		return scullp_order;

	case SCULLP_IOCXORDER: /* eXchange: use arg as pointer */
		tmp = scullp_order;
		ret = __get_user(scullp_order, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLP_IOCHORDER: /* sHift: like Tell + Query */
		tmp = scullp_order;
		scullp_order = arg;
		return tmp;

	case SCULLP_IOCSQSET:
		ret = __get_user(scullp_qset, (int __user *) arg);
		break;

	case SCULLP_IOCTQSET:
		scullp_qset = arg;
		break;

	case SCULLP_IOCGQSET:
		ret = __put_user(scullp_qset, (int __user *)arg);
		break;

	case SCULLP_IOCQQSET:
		return scullp_qset;

	case SCULLP_IOCXQSET:
		tmp = scullp_qset;
		ret = __get_user(scullp_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLP_IOCHQSET:
		tmp = scullp_qset;
		scullp_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t scullp_llseek (struct file *filp, loff_t off, int whence)
{
	struct scullp_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void scullp_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int scullp_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = scullp_write(iocb->ki_filp, buf, count, &pos);
	else
		result = scullp_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, scullp_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t scullp_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return scullp_defer_op(0, iocb, buf, count, pos);
}

static ssize_t scullp_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return scullp_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 
/*
 * Mmap *is* available, but confined in a different file
 */
extern int scullp_mmap(struct file *filp, struct vm_area_struct *vma);


/*
 * The fops
 */

struct file_operations scullp_fops = {
	.owner =     THIS_MODULE,
	.llseek =    scullp_llseek,
	.read =	     scullp_read,
	.write =     scullp_write,
	.ioctl =     scullp_ioctl,
	.mmap =	     scullp_mmap,
	.open =	     scullp_open,
	.release =   scullp_release,
	.aio_read =  scullp_aio_read,
	.aio_write = scullp_aio_write,
};

int scullp_trim(struct scullp_dev *dev)
{
	struct scullp_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			/* This code frees a whole quantum-set */
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					free_pages((unsigned long)(dptr->data[i]),
							dptr->order);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = scullp_qset;
	dev->order = scullp_order;
	dev->next = NULL;
	return 0;
}


static void scullp_setup_cdev(struct scullp_dev *dev, int index)
{
	int err, devno = MKDEV(scullp_major, index);
    
	cdev_init(&dev->cdev, &scullp_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scullp_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}



/*
 * Finally, the module stuff
 */

int scullp_init(void)
{
	int result, i;
	dev_t dev = MKDEV(scullp_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (scullp_major)
		result = register_chrdev_region(dev, scullp_devs, "scullp");
	else {
		result = alloc_chrdev_region(&dev, 0, scullp_devs, "scullp");
		scullp_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scullp_devices = kmalloc(scullp_devs*sizeof (struct scullp_dev), GFP_KERNEL);
	if (!scullp_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(scullp_devices, 0, scullp_devs*sizeof (struct scullp_dev));
	for (i = 0; i < scullp_devs; i++) {
		scullp_devices[i].order = scullp_order;
		scullp_devices[i].qset = scullp_qset;
		sema_init (&scullp_devices[i].sem, 1);
		scullp_setup_cdev(scullp_devices + i, i);
	}


#ifdef SCULLP_USE_PROC /* only when available */
	create_proc_read_entry("scullpmem", 0, NULL, scullp_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, scullp_devs);
	return result;
}



void scullp_cleanup(void)
{
	int i;

#ifdef SCULLP_USE_PROC
	remove_proc_entry("scullpmem", NULL);
#endif

	for (i = 0; i < scullp_devs; i++) {
		cdev_del(&scullp_devices[i].cdev);
		scullp_trim(scullp_devices + i);
	}
	kfree(scullp_devices);
	unregister_chrdev_region(MKDEV (scullp_major, 0), scullp_devs);
}


module_init(scullp_init);
module_exit(scullp_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullp_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the scullp char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "scullp.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void scullp_vma_open(struct vm_area_struct *vma)
{
	struct scullp_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void scullp_vma_close(struct vm_area_struct *vma)
{
	struct scullp_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the scullp device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *scullp_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct scullp_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the scullp device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */
	page = virt_to_page(pageptr);

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct scullp_vm_ops = {
	.open =     scullp_vma_open,
	.close =    scullp_vma_close,
	.nopage =   scullp_vma_nopage,
};


int scullp_mmap(struct file *filp, struct vm_area_struct *vma)
{
	struct inode *inode = filp->f_dentry->d_inode;

	/* refuse to map if order is not 0 */
	if (scullp_devices[iminor(inode)].order)
		return -ENODEV;

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &scullp_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	scullp_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_scullv_main">
			<text>
				<![CDATA[/* -*- C -*-
 * main.c -- the bare scullv char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _main.c.in,v 1.21 2004/10/14 20:11:39 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/slab.h>		/* kmalloc() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/types.h>	/* size_t */
#include <linux/proc_fs.h>
#include <linux/fcntl.h>	/* O_ACCMODE */
#include <linux/aio.h>
#include <asm/uaccess.h>
#include <linux/vmalloc.h>
#include "scullv.h"		/* local definitions */


int scullv_major =   SCULLV_MAJOR;
int scullv_devs =    SCULLV_DEVS;	/* number of bare scullv devices */
int scullv_qset =    SCULLV_QSET;
int scullv_order =   SCULLV_ORDER;

module_param(scullv_major, int, 0);
module_param(scullv_devs, int, 0);
module_param(scullv_qset, int, 0);
module_param(scullv_order, int, 0);
MODULE_AUTHOR("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");

struct scullv_dev *scullv_devices; /* allocated in scullv_init */

int scullv_trim(struct scullv_dev *dev);
void scullv_cleanup(void);






#ifdef SCULLV_USE_PROC /* don't waste space if unused */
/*
 * The proc filesystem: function to read and entry
 */

void scullv_proc_offset(char *buf, char **start, off_t *offset, int *len)
{
	if (*offset == 0)
		return;
	if (*offset >= *len) {
		/* Not there yet */
		*offset -= *len;
		*len = 0;
	} else {
		/* We're into the interesting stuff now */
		*start = buf + *offset;
		*offset = 0;
	}
}

/* FIXME: Do we need this here??  It be ugly  */
int scullv_read_procmem(char *buf, char **start, off_t offset,
                   int count, int *eof, void *data)
{
	int i, j, order, qset, len = 0;
	int limit = count - 80; /* Don't print more than this */
	struct scullv_dev *d;

	*start = buf;
	for(i = 0; i < scullv_devs; i++) {
		d = &scullv_devices[i];
		if (down_interruptible (&d->sem))
			return -ERESTARTSYS;
		qset = d->qset;  /* retrieve the features of each device */
		order = d->order;
		len += sprintf(buf+len,"\nDevice %%i: qset %%i, order %%i, sz %%li\n",
				i, qset, order, (long)(d->size));
		for (; d; d = d->next) { /* scan the list */
			len += sprintf(buf+len,"  item at %%p, qset at %%p\n",d,d->data);
			scullv_proc_offset (buf, start, &offset, &len);
			if (len > limit)
				goto out;
			if (d->data && !d->next) /* dump only the last item - save space */
				for (j = 0; j < qset; j++) {
					if (d->data[j])
						len += sprintf(buf+len,"    %% 4i:%%8p\n",j,d->data[j]);
					scullv_proc_offset (buf, start, &offset, &len);
					if (len > limit)
						goto out;
				}
		}
	  out:
		up (&scullv_devices[i].sem);
		if (len > limit)
			break;
	}
	*eof = 1;
	return len;
}

#endif /* SCULLV_USE_PROC */

/*
 * Open and close
 */

int scullv_open (struct inode *inode, struct file *filp)
{
	struct scullv_dev *dev; /* device information */

	/*  Find the device */
	dev = container_of(inode->i_cdev, struct scullv_dev, cdev);

    	/* now trim to 0 the length of the device if open was write-only */
	if ( (filp->f_flags & O_ACCMODE) == O_WRONLY) {
		if (down_interruptible (&dev->sem))
			return -ERESTARTSYS;
		scullv_trim(dev); /* ignore errors */
		up (&dev->sem);
	}

	/* and use filp->private_data to point to the device data */
	filp->private_data = dev;

	return 0;          /* success */
}

int scullv_release (struct inode *inode, struct file *filp)
{
	return 0;
}

/*
 * Follow the list 
 */
struct scullv_dev *scullv_follow(struct scullv_dev *dev, int n)
{
	while (n--) {
		if (!dev->next) {
			dev->next = kmalloc(sizeof(struct scullv_dev), GFP_KERNEL);
			memset(dev->next, 0, sizeof(struct scullv_dev));
		}
		dev = dev->next;
		continue;
	}
	return dev;
}

/*
 * Data management: read and write
 */

ssize_t scullv_read (struct file *filp, char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullv_dev *dev = filp->private_data; /* the first listitem */
	struct scullv_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset; /* how many bytes in the listitem */
	int item, s_pos, q_pos, rest;
	ssize_t retval = 0;

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;
	if (*f_pos > dev->size) 
		goto nothing;
	if (*f_pos + count > dev->size)
		count = dev->size - *f_pos;
	/* find listitem, qset index, and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

    	/* follow the list up to the right position (defined elsewhere) */
	dptr = scullv_follow(dev, item);

	if (!dptr->data)
		goto nothing; /* don't fill holes */
	if (!dptr->data[s_pos])
		goto nothing;
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* read only up to the end of this quantum */

	if (copy_to_user (buf, dptr->data[s_pos]+q_pos, count)) {
		retval = -EFAULT;
		goto nothing;
	}
	up (&dev->sem);

	*f_pos += count;
	return count;

  nothing:
	up (&dev->sem);
	return retval;
}



ssize_t scullv_write (struct file *filp, const char __user *buf, size_t count,
                loff_t *f_pos)
{
	struct scullv_dev *dev = filp->private_data;
	struct scullv_dev *dptr;
	int quantum = PAGE_SIZE << dev->order;
	int qset = dev->qset;
	int itemsize = quantum * qset;
	int item, s_pos, q_pos, rest;
	ssize_t retval = -ENOMEM; /* our most likely error */

	if (down_interruptible (&dev->sem))
		return -ERESTARTSYS;

	/* find listitem, qset index and offset in the quantum */
	item = ((long) *f_pos) / itemsize;
	rest = ((long) *f_pos) %% itemsize;
	s_pos = rest / quantum; q_pos = rest %% quantum;

	/* follow the list up to the right position */
	dptr = scullv_follow(dev, item);
	if (!dptr->data) {
		dptr->data = kmalloc(qset * sizeof(void *), GFP_KERNEL);
		if (!dptr->data)
			goto nomem;
		memset(dptr->data, 0, qset * sizeof(char *));
	}
	/* Allocate a quantum using virtual addresses */
	if (!dptr->data[s_pos]) {
		dptr->data[s_pos] = (void *)vmalloc(PAGE_SIZE << dptr->order);
		if (!dptr->data[s_pos])
			goto nomem;
		memset(dptr->data[s_pos], 0, PAGE_SIZE << dptr->order);
	}
	if (count > quantum - q_pos)
		count = quantum - q_pos; /* write only up to the end of this quantum */
	if (copy_from_user (dptr->data[s_pos]+q_pos, buf, count)) {
		retval = -EFAULT;
		goto nomem;
	}
	*f_pos += count;
 
    	/* update the size */
	if (dev->size < *f_pos)
		dev->size = *f_pos;
	up (&dev->sem);
	return count;

  nomem:
	up (&dev->sem);
	return retval;
}

/*
 * The ioctl() implementation
 */

int scullv_ioctl (struct inode *inode, struct file *filp,
                 unsigned int cmd, unsigned long arg)
{

	int err = 0, ret = 0, tmp;

	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
	if (_IOC_TYPE(cmd) != SCULLV_IOC_MAGIC) return -ENOTTY;
	if (_IOC_NR(cmd) > SCULLV_IOC_MAXNR) return -ENOTTY;

	/*
	 * the type is a bitmask, and VERIFY_WRITE catches R/W
	 * transfers. Note that the type is user-oriented, while
	 * verify_area is kernel-oriented, so the concept of "read" and
	 * "write" is reversed
	 */
	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err =  !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err)
		return -EFAULT;

	switch(cmd) {

	case SCULLV_IOCRESET:
		scullv_qset = SCULLV_QSET;
		scullv_order = SCULLV_ORDER;
		break;

	case SCULLV_IOCSORDER: /* Set: arg points to the value */
		ret = __get_user(scullv_order, (int __user *) arg);
		break;

	case SCULLV_IOCTORDER: /* Tell: arg is the value */
		scullv_order = arg;
		break;

	case SCULLV_IOCGORDER: /* Get: arg is pointer to result */
		ret = __put_user (scullv_order, (int __user *) arg);
		break;

	case SCULLV_IOCQORDER: /* Query: return it (it's positive) */
		return scullv_order;

	case SCULLV_IOCXORDER: /* eXchange: use arg as pointer */
		tmp = scullv_order;
		ret = __get_user(scullv_order, (int __user *) arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *) arg);
		break;

	case SCULLV_IOCHORDER: /* sHift: like Tell + Query */
		tmp = scullv_order;
		scullv_order = arg;
		return tmp;

	case SCULLV_IOCSQSET:
		ret = __get_user(scullv_qset, (int __user *) arg);
		break;

	case SCULLV_IOCTQSET:
		scullv_qset = arg;
		break;

	case SCULLV_IOCGQSET:
		ret = __put_user(scullv_qset, (int __user *)arg);
		break;

	case SCULLV_IOCQQSET:
		return scullv_qset;

	case SCULLV_IOCXQSET:
		tmp = scullv_qset;
		ret = __get_user(scullv_qset, (int __user *)arg);
		if (ret == 0)
			ret = __put_user(tmp, (int __user *)arg);
		break;

	case SCULLV_IOCHQSET:
		tmp = scullv_qset;
		scullv_qset = arg;
		return tmp;

	default:  /* redundant, as cmd was checked against MAXNR */
		return -ENOTTY;
	}

	return ret;
}

/*
 * The "extended" operations
 */

loff_t scullv_llseek (struct file *filp, loff_t off, int whence)
{
	struct scullv_dev *dev = filp->private_data;
	long newpos;

	switch(whence) {
	case 0: /* SEEK_SET */
		newpos = off;
		break;

	case 1: /* SEEK_CUR */
		newpos = filp->f_pos + off;
		break;

	case 2: /* SEEK_END */
		newpos = dev->size + off;
		break;

	default: /* can't happen */
		return -EINVAL;
	}
	if (newpos<0) return -EINVAL;
	filp->f_pos = newpos;
	return newpos;
}


/*
 * A simple asynchronous I/O implementation.
 */

struct async_work {
	struct kiocb *iocb;
	int result;
	struct work_struct work;
};

/*
 * "Complete" an asynchronous operation.
 */
static void scullv_do_deferred_op(void *p)
{
	struct async_work *stuff = (struct async_work *) p;
	aio_complete(stuff->iocb, stuff->result, 0);
	kfree(stuff);
}


static int scullv_defer_op(int write, struct kiocb *iocb, char __user *buf,
		size_t count, loff_t pos)
{
	struct async_work *stuff;
	int result;

	/* Copy now while we can access the buffer */
	if (write)
		result = scullv_write(iocb->ki_filp, buf, count, &pos);
	else
		result = scullv_read(iocb->ki_filp, buf, count, &pos);

	/* If this is a synchronous IOCB, we return our status now. */
	if (is_sync_kiocb(iocb))
		return result;

	/* Otherwise defer the completion for a few milliseconds. */
	stuff = kmalloc (sizeof (*stuff), GFP_KERNEL);
	if (stuff == NULL)
		return result; /* No memory, just complete now */
	stuff->iocb = iocb;
	stuff->result = result;
	INIT_WORK(&stuff->work, scullv_do_deferred_op, stuff);
	schedule_delayed_work(&stuff->work, HZ/100);
	return -EIOCBQUEUED;
}


static ssize_t scullv_aio_read(struct kiocb *iocb, char __user *buf, size_t count,
		loff_t pos)
{
	return scullv_defer_op(0, iocb, buf, count, pos);
}

static ssize_t scullv_aio_write(struct kiocb *iocb, const char __user *buf,
		size_t count, loff_t pos)
{
	return scullv_defer_op(1, iocb, (char __user *) buf, count, pos);
}


 
/*
 * Mmap *is* available, but confined in a different file
 */
extern int scullv_mmap(struct file *filp, struct vm_area_struct *vma);


/*
 * The fops
 */

struct file_operations scullv_fops = {
	.owner =     THIS_MODULE,
	.llseek =    scullv_llseek,
	.read =	     scullv_read,
	.write =     scullv_write,
	.ioctl =     scullv_ioctl,
	.mmap =	     scullv_mmap,
	.open =	     scullv_open,
	.release =   scullv_release,
	.aio_read =  scullv_aio_read,
	.aio_write = scullv_aio_write,
};

int scullv_trim(struct scullv_dev *dev)
{
	struct scullv_dev *next, *dptr;
	int qset = dev->qset;   /* "dev" is not-null */
	int i;

	if (dev->vmas) /* don't trim: there are active mappings */
		return -EBUSY;

	for (dptr = dev; dptr; dptr = next) { /* all the list items */
		if (dptr->data) {
			/* Release the quantum-set */
			for (i = 0; i < qset; i++)
				if (dptr->data[i])
					vfree(dptr->data[i]);

			kfree(dptr->data);
			dptr->data=NULL;
		}
		next=dptr->next;
		if (dptr != dev) kfree(dptr); /* all of them but the first */
	}
	dev->size = 0;
	dev->qset = scullv_qset;
	dev->order = scullv_order;
	dev->next = NULL;
	return 0;
}


static void scullv_setup_cdev(struct scullv_dev *dev, int index)
{
	int err, devno = MKDEV(scullv_major, index);
    
	cdev_init(&dev->cdev, &scullv_fops);
	dev->cdev.owner = THIS_MODULE;
	dev->cdev.ops = &scullv_fops;
	err = cdev_add (&dev->cdev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk(KERN_NOTICE "Error %%d adding scull%%d", err, index);
}



/*
 * Finally, the module stuff
 */

int scullv_init(void)
{
	int result, i;
	dev_t dev = MKDEV(scullv_major, 0);
	
	/*
	 * Register your major, and accept a dynamic number.
	 */
	if (scullv_major)
		result = register_chrdev_region(dev, scullv_devs, "scullv");
	else {
		result = alloc_chrdev_region(&dev, 0, scullv_devs, "scullv");
		scullv_major = MAJOR(dev);
	}
	if (result < 0)
		return result;

	
	/* 
	 * allocate the devices -- we can't have them static, as the number
	 * can be specified at load time
	 */
	scullv_devices = kmalloc(scullv_devs*sizeof (struct scullv_dev), GFP_KERNEL);
	if (!scullv_devices) {
		result = -ENOMEM;
		goto fail_malloc;
	}
	memset(scullv_devices, 0, scullv_devs*sizeof (struct scullv_dev));
	for (i = 0; i < scullv_devs; i++) {
		scullv_devices[i].order = scullv_order;
		scullv_devices[i].qset = scullv_qset;
		sema_init (&scullv_devices[i].sem, 1);
		scullv_setup_cdev(scullv_devices + i, i);
	}


#ifdef SCULLV_USE_PROC /* only when available */
	create_proc_read_entry("scullvmem", 0, NULL, scullv_read_procmem, NULL);
#endif
	return 0; /* succeed */

  fail_malloc:
	unregister_chrdev_region(dev, scullv_devs);
	return result;
}



void scullv_cleanup(void)
{
	int i;

#ifdef SCULLV_USE_PROC
	remove_proc_entry("scullvmem", NULL);
#endif

	for (i = 0; i < scullv_devs; i++) {
		cdev_del(&scullv_devices[i].cdev);
		scullv_trim(scullv_devices + i);
	}
	kfree(scullv_devices);
	unregister_chrdev_region(MKDEV (scullv_major, 0), scullv_devs);
}


module_init(scullv_init);
module_exit(scullv_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullv_mmap">
			<text>
				<![CDATA[/*  -*- C -*-
 * mmap.c -- memory mapping for the scullv char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: _mmap.c.in,v 1.13 2004/10/18 18:07:36 corbet Exp $
 */

#include <linux/config.h>
#include <linux/module.h>

#include <linux/mm.h>		/* everything */
#include <linux/errno.h>	/* error codes */
#include <asm/pgtable.h>

#include "scullv.h"		/* local definitions */


/*
 * open and close: just keep track of how many times the device is
 * mapped, to avoid releasing it.
 */

void scullv_vma_open(struct vm_area_struct *vma)
{
	struct scullv_dev *dev = vma->vm_private_data;

	dev->vmas++;
}

void scullv_vma_close(struct vm_area_struct *vma)
{
	struct scullv_dev *dev = vma->vm_private_data;

	dev->vmas--;
}

/*
 * The nopage method: the core of the file. It retrieves the
 * page required from the scullv device and returns it to the
 * user. The count for the page must be incremented, because
 * it is automatically decremented at page unmap.
 *
 * For this reason, "order" must be zero. Otherwise, only the first
 * page has its count incremented, and the allocating module must
 * release it as a whole block. Therefore, it isn't possible to map
 * pages from a multipage block: when they are unmapped, their count
 * is individually decreased, and would drop to 0.
 */

struct page *scullv_vma_nopage(struct vm_area_struct *vma,
                                unsigned long address, int *type)
{
	unsigned long offset;
	struct scullv_dev *ptr, *dev = vma->vm_private_data;
	struct page *page = NOPAGE_SIGBUS;
	void *pageptr = NULL; /* default to "missing" */

	down(&dev->sem);
	offset = (address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT);
	if (offset >= dev->size) goto out; /* out of range */

	/*
	 * Now retrieve the scullv device from the list,then the page.
	 * If the device has holes, the process receives a SIGBUS when
	 * accessing the hole.
	 */
	offset >>= PAGE_SHIFT; /* offset is a number of pages */
	for (ptr = dev; ptr && offset >= dev->qset;) {
		ptr = ptr->next;
		offset -= dev->qset;
	}
	if (ptr && ptr->data) pageptr = ptr->data[offset];
	if (!pageptr) goto out; /* hole or end-of-file */

	/*
	 * After scullv lookup, "page" is now the address of the page
	 * needed by the current process. Since it's a vmalloc address,
	 * turn it into a struct page.
	 */
	page = vmalloc_to_page(pageptr);

	/* got it, now increment the count */
	get_page(page);
	if (type)
		*type = VM_FAULT_MINOR;
  out:
	up(&dev->sem);
	return page;
}



struct vm_operations_struct scullv_vm_ops = {
	.open =     scullv_vma_open,
	.close =    scullv_vma_close,
	.nopage =   scullv_vma_nopage,
};


int scullv_mmap(struct file *filp, struct vm_area_struct *vma)
{

	/* don't do anything here: "nopage" will set up page table entries */
	vma->vm_ops = &scullv_vm_ops;
	vma->vm_flags |= VM_RESERVED;
	vma->vm_private_data = filp->private_data;
	scullv_vma_open(vma);
	return 0;
}

]]>
			</text>
		</p>
		<p n="xlnx_drv_short">
			<text>
				<![CDATA[/*
 * short.c -- Simple Hardware Operations and Raw Tests
 * short.c -- also a brief example of interrupt handling ("short int")
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: short.c,v 1.16 2004/10/29 16:45:40 corbet Exp $
 */

/*
 * FIXME: this driver is not safe with concurrent readers or
 * writers.
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/sched.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/delay.h>	/* udelay */
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/ioport.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/poll.h>
#include <linux/wait.h>

#include <asm/io.h>

#define SHORT_NR_PORTS	8	/* use 8 ports by default */

/*
 * all of the parameters have no "short_" prefix, to save typing when
 * specifying them at load time
 */
static int major = 0;	/* dynamic by default */
module_param(major, int, 0);

static int use_mem = 0;	/* default is I/O-mapped */
module_param(use_mem, int, 0);

/* default is the first printer port on PC's. "short_base" is there too
   because it's what we want to use in the code */
static unsigned long base = 0x378;
unsigned long short_base = 0;
module_param(base, long, 0);

/* The interrupt line is undefined by default. "short_irq" is as above */
static int irq = -1;
volatile int short_irq = -1;
module_param(irq, int, 0);

static int probe = 0;	/* select at load time how to probe irq line */
module_param(probe, int, 0);

static int wq = 0;	/* select at load time whether a workqueue is used */
module_param(wq, int, 0);

static int tasklet = 0;	/* select whether a tasklet is used */
module_param(tasklet, int, 0);

static int share = 0;	/* select at load time whether install a shared irq */
module_param(share, int, 0);

MODULE_AUTHOR ("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");


unsigned long short_buffer = 0;
unsigned long volatile short_head;
volatile unsigned long short_tail;
DECLARE_WAIT_QUEUE_HEAD(short_queue);

/* Set up our tasklet if we're doing that. */
void short_do_tasklet(unsigned long);
DECLARE_TASKLET(short_tasklet, short_do_tasklet, 0);

/*
 * Atomicly increment an index into short_buffer
 */
static inline void short_incr_bp(volatile unsigned long *index, int delta)
{
	unsigned long new = *index + delta;
	barrier();  /* Don't optimize these two together */
	*index = (new >= (short_buffer + PAGE_SIZE)) ? short_buffer : new;
}


/*
 * The devices with low minor numbers write/read burst of data to/from
 * specific I/O ports (by default the parallel ones).
 * 
 * The device with 128 as minor number returns ascii strings telling
 * when interrupts have been received. Writing to the device toggles
 * 00/FF on the parallel data lines. If there is a loopback wire, this
 * generates interrupts.  
 */

int short_open (struct inode *inode, struct file *filp)
{
	extern struct file_operations short_i_fops;

	if (iminor (inode) & 0x80)
		filp->f_op = &short_i_fops; /* the interrupt-driven node */
	return 0;
}


int short_release (struct inode *inode, struct file *filp)
{
	return 0;
}


/* first, the port-oriented device */

enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};

ssize_t do_short_read (struct inode *inode, struct file *filp, char __user *buf,
		size_t count, loff_t *f_pos)
{
	int retval = count, minor = iminor (inode);
	unsigned long port = short_base + (minor&0x0f);
	void *address = (void *) short_base + (minor&0x0f);
	int mode = (minor&0x70) >> 4;
	unsigned char *kbuf = kmalloc(count, GFP_KERNEL), *ptr;
    
	if (!kbuf)
		return -ENOMEM;
	ptr = kbuf;

	if (use_mem)
		mode = SHORT_MEMORY;
	
	switch(mode) {
	    case SHORT_STRING:
		insb(port, ptr, count);
		rmb();
		break;

	    case SHORT_DEFAULT:
		while (count--) {
			*(ptr++) = inb(port);
			rmb();
		}
		break;

	    case SHORT_MEMORY:
		while (count--) {
			*ptr++ = ioread8(address);
			rmb();
		}
		break;
	    case SHORT_PAUSE:
		while (count--) {
			*(ptr++) = inb_p(port);
			rmb();
		}
		break;

	    default: /* no more modes defined by now */
		retval = -EINVAL;
		break;
	}
	if ((retval > 0) && copy_to_user(buf, kbuf, retval))
		retval = -EFAULT;
	kfree(kbuf);
	return retval;
}


/*
 * Version-specific methods for the fops structure.  FIXME don't need anymore.
 */
ssize_t short_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	return do_short_read(filp->f_dentry->d_inode, filp, buf, count, f_pos);
}



ssize_t do_short_write (struct inode *inode, struct file *filp, const char __user *buf,
		size_t count, loff_t *f_pos)
{
	int retval = count, minor = iminor(inode);
	unsigned long port = short_base + (minor&0x0f);
	void *address = (void *) short_base + (minor&0x0f);
	int mode = (minor&0x70) >> 4;
	unsigned char *kbuf = kmalloc(count, GFP_KERNEL), *ptr;

	if (!kbuf)
		return -ENOMEM;
	if (copy_from_user(kbuf, buf, count))
		return -EFAULT;
	ptr = kbuf;

	if (use_mem)
		mode = SHORT_MEMORY;

	switch(mode) {
	case SHORT_PAUSE:
		while (count--) {
			outb_p(*(ptr++), port);
			wmb();
		}
		break;

	case SHORT_STRING:
		outsb(port, ptr, count);
		wmb();
		break;

	case SHORT_DEFAULT:
		while (count--) {
			outb(*(ptr++), port);
			wmb();
		}
		break;

	case SHORT_MEMORY:
		while (count--) {
			iowrite8(*ptr++, address);
			wmb();
		}
		break;

	default: /* no more modes defined by now */
		retval = -EINVAL;
		break;
	}
	kfree(kbuf);
	return retval;
}


ssize_t short_write(struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	return do_short_write(filp->f_dentry->d_inode, filp, buf, count, f_pos);
}




unsigned int short_poll(struct file *filp, poll_table *wait)
{
	return POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
}






struct file_operations short_fops = {
	.owner	 = THIS_MODULE,
	.read	 = short_read,
	.write	 = short_write,
	.poll	 = short_poll,
	.open	 = short_open,
	.release = short_release,
};

/* then,  the interrupt-related device */

ssize_t short_i_read (struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	int count0;
	DEFINE_WAIT(wait);

	while (short_head == short_tail) {
		prepare_to_wait(&short_queue, &wait, TASK_INTERRUPTIBLE);
		if (short_head == short_tail)
			schedule();
		finish_wait(&short_queue, &wait);
		if (signal_pending (current))  /* a signal arrived */
			return -ERESTARTSYS; /* tell the fs layer to handle it */
	} 
	/* count0 is the number of readable data bytes */
	count0 = short_head - short_tail;
	if (count0 < 0) /* wrapped */
		count0 = short_buffer + PAGE_SIZE - short_tail;
	if (count0 < count) count = count0;

	if (copy_to_user(buf, (char *)short_tail, count))
		return -EFAULT;
	short_incr_bp (&short_tail, count);
	return count;
}

ssize_t short_i_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	int written = 0, odd = *f_pos & 1;
	unsigned long port = short_base; /* output to the parallel data latch */
	void *address = (void *) short_base;

	if (use_mem) {
		while (written < count)
			iowrite8(0xff * ((++written + odd) & 1), address);
	} else {
		while (written < count)
			outb(0xff * ((++written + odd) & 1), port);
	}

	*f_pos += count;
	return written;
}




struct file_operations short_i_fops = {
	.owner	 = THIS_MODULE,
	.read	 = short_i_read,
	.write	 = short_i_write,
	.open	 = short_open,
	.release = short_release,
};

irqreturn_t short_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	struct timeval tv;
	int written;

	do_gettimeofday(&tv);

	    /* Write a 16 byte record. Assume PAGE_SIZE is a multiple of 16 */
	written = sprintf((char *)short_head,"%%08u.%%06u\n",
			(int)(tv.tv_sec %% 100000000), (int)(tv.tv_usec));
	BUG_ON(written != 16);
	short_incr_bp(&short_head, written);
	wake_up_interruptible(&short_queue); /* awake any reading process */
	return IRQ_HANDLED;
}

/*
 * The following two functions are equivalent to the previous one,
 * but split in top and bottom half. First, a few needed variables
 */

#define NR_TIMEVAL 512 /* length of the array of time values */

struct timeval tv_data[NR_TIMEVAL]; /* too lazy to allocate it */
volatile struct timeval *tv_head=tv_data;
volatile struct timeval *tv_tail=tv_data;

static struct work_struct short_wq;


int short_wq_count = 0;

/*
 * Increment a circular buffer pointer in a way that nobody sees
 * an intermediate value.
 */
static inline void short_incr_tv(volatile struct timeval **tvp)
{
	if (*tvp == (tv_data + NR_TIMEVAL - 1))
		*tvp = tv_data;	 /* Wrap */
	else
		(*tvp)++;
}



void short_do_tasklet (unsigned long unused)
{
	int savecount = short_wq_count, written;
	short_wq_count = 0; /* we have already been removed from the queue */
	/*
	 * The bottom half reads the tv array, filled by the top half,
	 * and prints it to the circular text buffer, which is then consumed
	 * by reading processes
	 */

	/* First write the number of interrupts that occurred before this bh */
	written = sprintf((char *)short_head,"bh after %%6i\n",savecount);
	short_incr_bp(&short_head, written);

	/*
	 * Then, write the time values. Write exactly 16 bytes at a time,
	 * so it aligns with PAGE_SIZE
	 */

	do {
		written = sprintf((char *)short_head,"%%08u.%%06u\n",
				(int)(tv_tail->tv_sec %% 100000000),
				(int)(tv_tail->tv_usec));
		short_incr_bp(&short_head, written);
		short_incr_tv(&tv_tail);
	} while (tv_tail != tv_head);

	wake_up_interruptible(&short_queue); /* awake any reading process */
}


irqreturn_t short_wq_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	/* Grab the current time information. */
	do_gettimeofday((struct timeval *) tv_head);
	short_incr_tv(&tv_head);

	/* Queue the bh. Don't worry about multiple enqueueing */
	schedule_work(&short_wq);

	short_wq_count++; /* record that an interrupt arrived */
	return IRQ_HANDLED;
}


/*
 * Tasklet top half
 */

irqreturn_t short_tl_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	do_gettimeofday((struct timeval *) tv_head); /* cast to stop 'volatile' warning */
	short_incr_tv(&tv_head);
	tasklet_schedule(&short_tasklet);
	short_wq_count++; /* record that an interrupt arrived */
	return IRQ_HANDLED;
}




irqreturn_t short_sh_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	int value, written;
	struct timeval tv;

	/* If it wasn't short, return immediately */
	value = inb(short_base);
	if (!(value & 0x80))
		return IRQ_NONE;
	
	/* clear the interrupting bit */
	outb(value & 0x7F, short_base);

	/* the rest is unchanged */

	do_gettimeofday(&tv);
	written = sprintf((char *)short_head,"%%08u.%%06u\n",
			(int)(tv.tv_sec %% 100000000), (int)(tv.tv_usec));
	short_incr_bp(&short_head, written);
	wake_up_interruptible(&short_queue); /* awake any reading process */
	return IRQ_HANDLED;
}

void short_kernelprobe(void)
{
	int count = 0;
	do {
		unsigned long mask;

		mask = probe_irq_on();
		outb_p(0x10,short_base+2); /* enable reporting */
		outb_p(0x00,short_base);   /* clear the bit */
		outb_p(0xFF,short_base);   /* set the bit: interrupt! */
		outb_p(0x00,short_base+2); /* disable reporting */
		udelay(5);  /* give it some time */
		short_irq = probe_irq_off(mask);

		if (short_irq == 0) { /* none of them? */
			printk(KERN_INFO "short: no irq reported by probe\n");
			short_irq = -1;
		}
		/*
		 * if more than one line has been activated, the result is
		 * negative. We should service the interrupt (no need for lpt port)
		 * and loop over again. Loop at most five times, then give up
		 */
	} while (short_irq < 0 && count++ < 5);
	if (short_irq < 0)
		printk("short: probe failed %%i times, giving up\n", count);
}

irqreturn_t short_probing(int irq, void *dev_id, struct pt_regs *regs)
{
	if (short_irq == 0) short_irq = irq;	/* found */
	if (short_irq != irq) short_irq = -irq; /* ambiguous */
	return IRQ_HANDLED;
}

void short_selfprobe(void)
{
	int trials[] = {3, 5, 7, 9, 0};
	int tried[]  = {0, 0, 0, 0, 0};
	int i, count = 0;

	/*
	 * install the probing handler for all possible lines. Remember
	 * the result (0 for success, or -EBUSY) in order to only free
	 * what has been acquired
      */
	for (i = 0; trials[i]; i++)
		tried[i] = request_irq(trials[i], short_probing,
				SA_INTERRUPT, "short probe", NULL);

	do {
		short_irq = 0; /* none got, yet */
		outb_p(0x10,short_base+2); /* enable */
		outb_p(0x00,short_base);
		outb_p(0xFF,short_base); /* toggle the bit */
		outb_p(0x00,short_base+2); /* disable */
		udelay(5);  /* give it some time */

		/* the value has been set by the handler */
		if (short_irq == 0) { /* none of them? */
			printk(KERN_INFO "short: no irq reported by probe\n");
		}
		/*
		 * If more than one line has been activated, the result is
		 * negative. We should service the interrupt (but the lpt port
		 * doesn't need it) and loop over again. Do it at most 5 times
		 */
	} while (short_irq <=0 && count++ < 5);

	/* end of loop, uninstall the handler */
	for (i = 0; trials[i]; i++)
		if (tried[i] == 0)
			free_irq(trials[i], NULL);

	if (short_irq < 0)
		printk("short: probe failed %%i times, giving up\n", count);
}



/* Finally, init and cleanup */

int short_init(void)
{
	int result;

	/*
	 * first, sort out the base/short_base ambiguity: we'd better
	 * use short_base in the code, for clarity, but allow setting
	 * just "base" at load time. Same for "irq".
	 */
	short_base = base;
	short_irq = irq;

	/* Get our needed resources. */
	if (!use_mem) {
		if (! request_region(short_base, SHORT_NR_PORTS, "short")) {
			printk(KERN_INFO "short: can't get I/O port address 0x%%lx\n",
					short_base);
			return -ENODEV;
		}

	} else {
		if (! request_mem_region(short_base, SHORT_NR_PORTS, "short")) {
			printk(KERN_INFO "short: can't get I/O mem address 0x%%lx\n",
					short_base);
			return -ENODEV;
		}

		/* also, ioremap it */
		short_base = (unsigned long) ioremap(short_base, SHORT_NR_PORTS);
		/* Hmm... we should check the return value */
	}
	/* Here we register our device - should not fail thereafter */
	result = register_chrdev(major, "short", &short_fops);
	if (result < 0) {
		printk(KERN_INFO "short: can't get major number\n");
		release_region(short_base,SHORT_NR_PORTS);  /* FIXME - use-mem case? */
		return result;
	}
	if (major == 0) major = result; /* dynamic */

	short_buffer = __get_free_pages(GFP_KERNEL,0); /* never fails */  /* FIXME */
	short_head = short_tail = short_buffer;

	/*
	 * Fill the workqueue structure, used for the bottom half handler.
	 * The cast is there to prevent warnings about the type of the
	 * (unused) argument.
	 */
	/* this line is in short_init() */
	INIT_WORK(&short_wq, (void (*)(void *)) short_do_tasklet, NULL);

	/*
	 * Now we deal with the interrupt: either kernel-based
	 * autodetection, DIY detection or default number
	 */

	if (short_irq < 0 && probe == 1)
		short_kernelprobe();

	if (short_irq < 0 && probe == 2)
		short_selfprobe();

	if (short_irq < 0) /* not yet specified: force the default on */
		switch(short_base) {
		    case 0x378: short_irq = 7; break;
		    case 0x278: short_irq = 2; break;
		    case 0x3bc: short_irq = 5; break;
		}

	/*
	 * If shared has been specified, installed the shared handler
	 * instead of the normal one. Do it first, before a -EBUSY will
	 * force short_irq to -1.
	 */
	if (short_irq >= 0 && share > 0) {
		result = request_irq(short_irq, short_sh_interrupt,
				SA_SHIRQ | SA_INTERRUPT,"short",
				short_sh_interrupt);
		if (result) {
			printk(KERN_INFO "short: can't get assigned irq %%i\n", short_irq);
			short_irq = -1;
		}
		else { /* actually enable it -- assume this *is* a parallel port */
			outb(0x10, short_base+2);
		}
		return 0; /* the rest of the function only installs handlers */
	}

	if (short_irq >= 0) {
		result = request_irq(short_irq, short_interrupt,
				SA_INTERRUPT, "short", NULL);
		if (result) {
			printk(KERN_INFO "short: can't get assigned irq %%i\n",
					short_irq);
			short_irq = -1;
		}
		else { /* actually enable it -- assume this *is* a parallel port */
			outb(0x10,short_base+2);
		}
	}

	/*
	 * Ok, now change the interrupt handler if using top/bottom halves
	 * has been requested
	 */
	if (short_irq >= 0 && (wq + tasklet) > 0) {
		free_irq(short_irq,NULL);
		result = request_irq(short_irq,
				tasklet ? short_tl_interrupt :
				short_wq_interrupt,
				SA_INTERRUPT,"short-bh", NULL);
		if (result) {
			printk(KERN_INFO "short-bh: can't get assigned irq %%i\n",
					short_irq);
			short_irq = -1;
		}
	}

	return 0;
}

void short_cleanup(void)
{
	if (short_irq >= 0) {
		outb(0x0, short_base + 2);   /* disable the interrupt */
		if (!share) free_irq(short_irq, NULL);
		else free_irq(short_irq, short_sh_interrupt);
	}
	/* Make sure we don't leave work queue/tasklet functions running */
	if (tasklet)
		tasklet_disable(&short_tasklet);
	else
		flush_scheduled_work();
	unregister_chrdev(major, "short");
	if (use_mem) {
		iounmap((void __iomem *)short_base);
		release_mem_region(short_base, SHORT_NR_PORTS);
	} else {
		release_region(short_base,SHORT_NR_PORTS);
	}
	if (short_buffer) free_page(short_buffer);
}

module_init(short_init);
module_exit(short_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_shortprint">
			<text>
				<![CDATA[/*
 * A version of the "short" driver which drives a parallel printer directly,
 * with a lot of simplifying assumptions.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: shortprint.c,v 1.4 2004/09/26 08:01:04 gregkh Exp $
 */
#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>

#include <linux/sched.h>
#include <linux/kernel.h> /* printk() */
#include <linux/fs.h>	  /* everything... */
#include <linux/errno.h>  /* error codes */
#include <linux/delay.h>  /* udelay */
#include <linux/slab.h>
#include <linux/ioport.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/timer.h>
#include <linux/poll.h>

#include <asm/io.h>
#include <asm/semaphore.h>
#include <asm/atomic.h>

#include "shortprint.h"

#define SHORTP_NR_PORTS 3

/*
 * all of the parameters have no "shortp_" prefix, to save typing when
 * specifying them at load time
 */
static int major = 0; /* dynamic by default */
module_param(major, int, 0);

/* default is the first printer port on PC's. "shortp_base" is there too
   because it's what we want to use in the code */
static unsigned long base = 0x378;
unsigned long shortp_base = 0;
module_param(base, long, 0);

/* The interrupt line is undefined by default. "shortp_irq" is as above */
static int irq = -1;
static int shortp_irq = -1;
module_param(irq, int, 0);

/* Microsecond delay around strobe. */
static int delay = 0;
static int shortp_delay;
module_param(delay, int, 0);

MODULE_AUTHOR ("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");

/*
 * Forwards.
 */
static void shortp_cleanup(void);
static void shortp_timeout(unsigned long unused);

/*
 * Input is managed through a simple circular buffer which, among other things,
 * is allowed to overrun if the reader isn't fast enough.  That makes life simple
 * on the "read" interrupt side, where we don't want to block.
 */
static unsigned long shortp_in_buffer = 0;
static unsigned long volatile shortp_in_head;
static volatile unsigned long shortp_in_tail;
DECLARE_WAIT_QUEUE_HEAD(shortp_in_queue);
static struct timeval shortp_tv;  /* When the interrupt happened. */

/*
 * Atomicly increment an index into shortp_in_buffer
 */
static inline void shortp_incr_bp(volatile unsigned long *index, int delta)
{
	unsigned long new = *index + delta;
	barrier ();  /* Don't optimize these two together */
	*index = (new >= (shortp_in_buffer + PAGE_SIZE)) ? shortp_in_buffer : new;
}


/*
 * On the write side we have to be more careful, since we don't want to drop
 * data.  The semaphore is used to serialize write-side access to the buffer;
 * there is only one consumer, so read-side access is unregulated.  The
 * wait queue will be awakened when space becomes available in the buffer.
 */
static unsigned char *shortp_out_buffer = NULL;
static volatile unsigned char *shortp_out_head, *shortp_out_tail;
static struct semaphore shortp_out_sem;
static DECLARE_WAIT_QUEUE_HEAD(shortp_out_queue);

/*
 * Feeding the output queue to the device is handled by way of a
 * workqueue.
 */
static void shortp_do_work(void *);
static DECLARE_WORK(shortp_work, shortp_do_work, NULL);
static struct workqueue_struct *shortp_workqueue;

/*
 * Available space in the output buffer; should be called with the semaphore
 * held.  Returns contiguous space, so caller need not worry about wraps.
 */
static inline int shortp_out_space(void)
{
	if (shortp_out_head >= shortp_out_tail) {
		int space = PAGE_SIZE - (shortp_out_head - shortp_out_buffer);
		return (shortp_out_tail == shortp_out_buffer) ? space - 1 : space;
	} else
		return (shortp_out_tail - shortp_out_head) - 1;
}

static inline void shortp_incr_out_bp(volatile unsigned char **bp, int incr)
{
	unsigned char *new = (unsigned char *) *bp + incr;
	if (new >= (shortp_out_buffer + PAGE_SIZE))
		new -= PAGE_SIZE;
	*bp = new;
}

/*
 * The output "process" is controlled by a spin lock; decisions on
 * shortp_output_active or manipulation of shortp_out_tail require
 * that this lock be held.
 */
static spinlock_t shortp_out_lock;
volatile static int shortp_output_active;
DECLARE_WAIT_QUEUE_HEAD(shortp_empty_queue); /* waked when queue empties */

/*
 * When output is active, the timer is too, in case we miss interrupts.	 Hold
 * shortp_out_lock if you mess with the timer.
 */
static struct timer_list shortp_timer;
#define TIMEOUT 5*HZ  /* Wait a long time */


/*
 * Open the device.
 */
static int shortp_open(struct inode *inode, struct file *filp)
{
	return 0;
}


static int shortp_release(struct inode *inode, struct file *filp)
{
	/* Wait for any pending output to complete */
	wait_event_interruptible(shortp_empty_queue, shortp_output_active==0);

	return 0;
}



static unsigned int shortp_poll(struct file *filp, poll_table *wait)
{
    return POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
}



/*
 * The read routine, which doesn't return data from the device; instead, it
 * returns timing information just like the "short" device.
 */
static ssize_t shortp_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	int count0;
	DEFINE_WAIT(wait);

	while (shortp_in_head == shortp_in_tail) {
		prepare_to_wait(&shortp_in_queue, &wait, TASK_INTERRUPTIBLE);
		if (shortp_in_head == shortp_in_tail)
			schedule();
		finish_wait(&shortp_in_queue, &wait);
		if (signal_pending (current))  /* a signal arrived */
			return -ERESTARTSYS; /* tell the fs layer to handle it */
	}

	/* count0 is the number of readable data bytes */
	count0 = shortp_in_head - shortp_in_tail;
	if (count0 < 0) /* wrapped */
		count0 = shortp_in_buffer + PAGE_SIZE - shortp_in_tail;
	if (count0 < count)
		count = count0;

	if (copy_to_user(buf, (char *)shortp_in_tail, count))
		return -EFAULT;
	shortp_incr_bp(&shortp_in_tail, count);
	return count;
}


/*
 * Wait for the printer to be ready; this can sleep.
 */
static void shortp_wait(void)
{
	if ((inb(shortp_base + SP_STATUS) & SP_SR_BUSY) == 0) {
		printk(KERN_INFO "shortprint: waiting for printer busy\n");
		printk(KERN_INFO "Status is 0x%%x\n", inb(shortp_base + SP_STATUS));
		while ((inb(shortp_base + SP_STATUS) & SP_SR_BUSY) == 0) {
			set_current_state(TASK_INTERRUPTIBLE);
			schedule_timeout(10*HZ); 
		}
	}
}


/*
 * Write the next character from the buffer.  There should *be* a next
 * character...	 The spinlock should be held when this routine is called.
 */
static void shortp_do_write(void)
{
	unsigned char cr = inb(shortp_base + SP_CONTROL);

	/* Something happened; reset the timer */
	mod_timer(&shortp_timer, jiffies + TIMEOUT);

	/* Strobe a byte out to the device */
	outb_p(*shortp_out_tail, shortp_base+SP_DATA);
	shortp_incr_out_bp(&shortp_out_tail, 1);
	if (shortp_delay)
		udelay(shortp_delay);
	outb_p(cr | SP_CR_STROBE, shortp_base+SP_CONTROL);
	if (shortp_delay)
		udelay(shortp_delay);
	outb_p(cr & ~SP_CR_STROBE, shortp_base+SP_CONTROL);
}


/*
 * Start output; call under lock.
 */
static void shortp_start_output(void)
{
	if (shortp_output_active) /* Should never happen */
		return;

	/* Set up our 'missed interrupt' timer */
	shortp_output_active = 1;
	shortp_timer.expires = jiffies + TIMEOUT;
	add_timer(&shortp_timer);

	/*  And get the process going. */
	queue_work(shortp_workqueue, &shortp_work);
}


/*
 * Write to the device.
 */
static ssize_t shortp_write(struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	int space, written = 0;
	unsigned long flags;
	/*
	 * Take and hold the semaphore for the entire duration of the operation.  The
	 * consumer side ignores it, and it will keep other data from interleaving
	 * with ours.
	 */
	if (down_interruptible(&shortp_out_sem))
		return -ERESTARTSYS;
	/*
	 * Out with the data.
	 */
	while (written < count) {
		/* Hang out until some buffer space is available. */
		space = shortp_out_space();
		if (space <= 0) {
			if (wait_event_interruptible(shortp_out_queue,
					    (space = shortp_out_space()) > 0))
				goto out;
		}

		/* Move data into the buffer. */
		if ((space + written) > count)
			space = count - written;
		if (copy_from_user((char *) shortp_out_head, buf, space)) {
			up(&shortp_out_sem);
			return -EFAULT;
		}
		shortp_incr_out_bp(&shortp_out_head, space);
		buf += space;
		written += space;

		/* If no output is active, make it active. */
		spin_lock_irqsave(&shortp_out_lock, flags);
		if (! shortp_output_active)
			shortp_start_output();
		spin_unlock_irqrestore(&shortp_out_lock, flags);
	}

out:
	*f_pos += written;
	up(&shortp_out_sem);
	return written;
}


/*
 * The bottom-half handler.
 */


static void shortp_do_work(void *unused)
{
	int written;
	unsigned long flags;

	/* Wait until the device is ready */
	shortp_wait();
	
	spin_lock_irqsave(&shortp_out_lock, flags);

	/* Have we written everything? */
	if (shortp_out_head == shortp_out_tail) { /* empty */
		shortp_output_active = 0;
		wake_up_interruptible(&shortp_empty_queue);
		del_timer(&shortp_timer);  
	}
	/* Nope, write another byte */
	else
		shortp_do_write();

	/* If somebody's waiting, maybe wake them up. */
	if (((PAGE_SIZE + shortp_out_tail - shortp_out_head) %% PAGE_SIZE) > SP_MIN_SPACE) {
		wake_up_interruptible(&shortp_out_queue);
	}
	spin_unlock_irqrestore(&shortp_out_lock, flags);

	/* Handle the "read" side operation */
	written = sprintf((char *)shortp_in_head, "%%08u.%%06u\n",
			(int)(shortp_tv.tv_sec %% 100000000),
			(int)(shortp_tv.tv_usec));
	shortp_incr_bp(&shortp_in_head, written);
	wake_up_interruptible(&shortp_in_queue); /* awake any reading process */
}


/*
 * The top-half interrupt handler.
 */
static irqreturn_t shortp_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	if (! shortp_output_active) 
		return IRQ_NONE;

	/* Remember the time, and farm off the rest to the workqueue function */ 
	do_gettimeofday(&shortp_tv);
	queue_work(shortp_workqueue, &shortp_work);
	return IRQ_HANDLED;
}

/*
 * Interrupt timeouts.	Just because we got a timeout doesn't mean that
 * things have gone wrong, however; printers can spend an awful long time
 * just thinking about things.
 */
static void shortp_timeout(unsigned long unused)
{
	unsigned long flags;
	unsigned char status;
   
	if (! shortp_output_active)
		return;
	spin_lock_irqsave(&shortp_out_lock, flags);
	status = inb(shortp_base + SP_STATUS);

	/* If the printer is still busy we just reset the timer */
	if ((status & SP_SR_BUSY) == 0 || (status & SP_SR_ACK)) {
		shortp_timer.expires = jiffies + TIMEOUT;
		add_timer(&shortp_timer);
		spin_unlock_irqrestore(&shortp_out_lock, flags);
		return;
	}

	/* Otherwise we must have dropped an interrupt. */
	spin_unlock_irqrestore(&shortp_out_lock, flags);
	shortp_interrupt(shortp_irq, NULL, NULL);
}
    




static struct file_operations shortp_fops = {
	.read =	   shortp_read,
	.write =   shortp_write,
	.open =	   shortp_open,
	.release = shortp_release,
	.poll =	   shortp_poll,
	.owner	 = THIS_MODULE
};




/*
 * Module initialization
 */

static int shortp_init(void)
{
	int result;

	/*
	 * first, sort out the base/shortp_base ambiguity: we'd better
	 * use shortp_base in the code, for clarity, but allow setting
	 * just "base" at load time. Same for "irq".
	 */
	shortp_base = base;
	shortp_irq = irq;
	shortp_delay = delay;

	/* Get our needed resources. */
	if (! request_region(shortp_base, SHORTP_NR_PORTS, "shortprint")) {
		printk(KERN_INFO "shortprint: can't get I/O port address 0x%%lx\n",
				shortp_base);
		return -ENODEV;
	}	

	/* Register the device */
	result = register_chrdev(major, "shortprint", &shortp_fops);
	if (result < 0) {
		printk(KERN_INFO "shortp: can't get major number\n");
		release_region(shortp_base, SHORTP_NR_PORTS);
		return result;
	}
	if (major == 0)
		major = result; /* dynamic */

	/* Initialize the input buffer. */
	shortp_in_buffer = __get_free_pages(GFP_KERNEL, 0); /* never fails */
	shortp_in_head = shortp_in_tail = shortp_in_buffer;

	/* And the output buffer. */
	shortp_out_buffer = (unsigned char *) __get_free_pages(GFP_KERNEL, 0);
	shortp_out_head = shortp_out_tail = shortp_out_buffer;
	sema_init(&shortp_out_sem, 1);
    
	/* And the output info */
	shortp_output_active = 0;
	spin_lock_init(&shortp_out_lock);
	init_timer(&shortp_timer);
	shortp_timer.function = shortp_timeout;
	shortp_timer.data = 0;
    
	/* Set up our workqueue. */
	shortp_workqueue = create_singlethread_workqueue("shortprint");

	/* If no IRQ was explicitly requested, pick a default */
	if (shortp_irq < 0)
		switch(shortp_base) {
		    case 0x378: shortp_irq = 7; break;
		    case 0x278: shortp_irq = 2; break;
		    case 0x3bc: shortp_irq = 5; break;
		}

	/* Request the IRQ */
	result = request_irq(shortp_irq, shortp_interrupt, 0, "shortprint", NULL);
	if (result) {
		printk(KERN_INFO "shortprint: can't get assigned irq %%i\n",
				shortp_irq);
		shortp_irq = -1;
		shortp_cleanup ();
		return result;
	}

	/* Initialize the control register, turning on interrupts. */
	outb(SP_CR_IRQ | SP_CR_SELECT | SP_CR_INIT, shortp_base + SP_CONTROL);

	return 0;
}

static void shortp_cleanup(void)
{
	/* Return the IRQ if we have one */
	if (shortp_irq >= 0) {
		outb(0x0, shortp_base + SP_CONTROL);   /* disable the interrupt */
		free_irq(shortp_irq, NULL);
	}

	/* All done with the device */
	unregister_chrdev(major, "shortprint");
	release_region(shortp_base,SHORTP_NR_PORTS);

	/* Don't leave any timers floating around.  Note that any active output
	   is effectively stopped by turning off the interrupt */
	if (shortp_output_active)
		del_timer_sync (&shortp_timer);
	flush_workqueue(shortp_workqueue);
	destroy_workqueue(shortp_workqueue);

	if (shortp_in_buffer)
		free_page(shortp_in_buffer);
	if (shortp_out_buffer)
		free_page((unsigned long) shortp_out_buffer);
}

module_init(shortp_init);
module_exit(shortp_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_simple">
			<text>
				<![CDATA[/*
 * Simple - REALLY simple memory mapping demonstration.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: simple.c,v 1.12 2005/01/31 16:15:31 rubini Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/kernel.h>   /* printk() */
#include <linux/slab.h>   /* kmalloc() */
#include <linux/fs.h>       /* everything... */
#include <linux/errno.h>    /* error codes */
#include <linux/types.h>    /* size_t */
#include <linux/mm.h>
#include <linux/kdev_t.h>
#include <asm/page.h>
#include <linux/cdev.h>

#include <linux/device.h>

static int simple_major = 0;
module_param(simple_major, int, 0);
MODULE_AUTHOR("Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");

/*
 * Open the device; in fact, there's nothing to do here.
 */
static int simple_open (struct inode *inode, struct file *filp)
{
	return 0;
}


/*
 * Closing is just as simpler.
 */
static int simple_release(struct inode *inode, struct file *filp)
{
	return 0;
}



/*
 * Common VMA ops.
 */

void simple_vma_open(struct vm_area_struct *vma)
{
	printk(KERN_NOTICE "Simple VMA open, virt %%lx, phys %%lx\n",
			vma->vm_start, vma->vm_pgoff << PAGE_SHIFT);
}

void simple_vma_close(struct vm_area_struct *vma)
{
	printk(KERN_NOTICE "Simple VMA close.\n");
}


/*
 * The remap_pfn_range version of mmap.  This one is heavily borrowed
 * from drivers/char/mem.c.
 */

static struct vm_operations_struct simple_remap_vm_ops = {
	.open =  simple_vma_open,
	.close = simple_vma_close,
};

static int simple_remap_mmap(struct file *filp, struct vm_area_struct *vma)
{
	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
			    vma->vm_end - vma->vm_start,
			    vma->vm_page_prot))
		return -EAGAIN;

	vma->vm_ops = &simple_remap_vm_ops;
	simple_vma_open(vma);
	return 0;
}



/*
 * The nopage version.
 */
struct page *simple_vma_nopage(struct vm_area_struct *vma,
                unsigned long address, int *type)
{
	struct page *pageptr;
	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
	unsigned long physaddr = address - vma->vm_start + offset;
	unsigned long pageframe = physaddr >> PAGE_SHIFT;

// Eventually remove these printks
	printk (KERN_NOTICE "---- Nopage, off %%lx phys %%lx\n", offset, physaddr);
	printk (KERN_NOTICE "VA is %%p\n", __va (physaddr));
	printk (KERN_NOTICE "Page at %%p\n", virt_to_page (__va (physaddr)));
	if (!pfn_valid(pageframe))
		return NOPAGE_SIGBUS;
	pageptr = pfn_to_page(pageframe);
	printk (KERN_NOTICE "page->index = %%ld mapping %%p\n", pageptr->index, pageptr->mapping);
	printk (KERN_NOTICE "Page frame %%ld\n", pageframe);
	get_page(pageptr);
	if (type)
		*type = VM_FAULT_MINOR;
	return pageptr;
}

static struct vm_operations_struct simple_nopage_vm_ops = {
	.open =   simple_vma_open,
	.close =  simple_vma_close,
	.nopage = simple_vma_nopage,
};

static int simple_nopage_mmap(struct file *filp, struct vm_area_struct *vma)
{
	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;

	if (offset >= __pa(high_memory) || (filp->f_flags & O_SYNC))
		vma->vm_flags |= VM_IO;
	vma->vm_flags |= VM_RESERVED;

	vma->vm_ops = &simple_nopage_vm_ops;
	simple_vma_open(vma);
	return 0;
}


/*
 * Set up the cdev structure for a device.
 */
static void simple_setup_cdev(struct cdev *dev, int minor,
		struct file_operations *fops)
{
	int err, devno = MKDEV(simple_major, minor);
    
	cdev_init(dev, fops);
	dev->owner = THIS_MODULE;
	dev->ops = fops;
	err = cdev_add (dev, devno, 1);
	/* Fail gracefully if need be */
	if (err)
		printk (KERN_NOTICE "Error %%d adding simple%%d", err, minor);
}


/*
 * Our various sub-devices.
 */
/* Device 0 uses remap_pfn_range */
static struct file_operations simple_remap_ops = {
	.owner   = THIS_MODULE,
	.open    = simple_open,
	.release = simple_release,
	.mmap    = simple_remap_mmap,
};

/* Device 1 uses nopage */
static struct file_operations simple_nopage_ops = {
	.owner   = THIS_MODULE,
	.open    = simple_open,
	.release = simple_release,
	.mmap    = simple_nopage_mmap,
};

#define MAX_SIMPLE_DEV 2

#if 0
static struct file_operations *simple_fops[MAX_SIMPLE_DEV] = {
	&simple_remap_ops,
	&simple_nopage_ops,
};
#endif

/*
 * We export two simple devices.  There's no need for us to maintain any
 * special housekeeping info, so we just deal with raw cdevs.
 */
static struct cdev SimpleDevs[MAX_SIMPLE_DEV];

/*
 * Module housekeeping.
 */
static int simple_init(void)
{
	int result;
	dev_t dev = MKDEV(simple_major, 0);

	/* Figure out our device number. */
	if (simple_major)
		result = register_chrdev_region(dev, 2, "simple");
	else {
		result = alloc_chrdev_region(&dev, 0, 2, "simple");
		simple_major = MAJOR(dev);
	}
	if (result < 0) {
		printk(KERN_WARNING "simple: unable to get major %%d\n", simple_major);
		return result;
	}
	if (simple_major == 0)
		simple_major = result;

	/* Now set up two cdevs. */
	simple_setup_cdev(SimpleDevs, 0, &simple_remap_ops);
	simple_setup_cdev(SimpleDevs + 1, 1, &simple_nopage_ops);
	return 0;
}


static void simple_cleanup(void)
{
	cdev_del(SimpleDevs);
	cdev_del(SimpleDevs + 1);
	unregister_chrdev_region(MKDEV(simple_major, 0), 2);
}


module_init(simple_init);
module_exit(simple_cleanup);
]]>
			</text>
		</p>
		<p n="xln_drv_skull_clean">
			<text>
				<![CDATA[#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>

#include <linux/ioport.h>

void skull_release(unsigned int port, unsigned int range)
{
    release_region(port,range);
}

void skull_cleanup(void)
{
    /* should put real values here ... */
    /* skull_release(0,0); */
}

module_exit(skull_cleanup);




]]>
			</text>
		</p>
		<p n="xlnx_drv_skull_init">
			<text>
				<![CDATA[/*
 * skull.c -- sample typeless module.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * BUGS:
 *   -it only runs on intel platforms.
 *   -readb() should be used (see short.c): skull doesn't work with 2.1
 *
 */

/* jc: cleaned up, but not yet run for anything */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>

#include <linux/kernel.h> /* printk */
#include <linux/ioport.h>
#include <linux/errno.h>
#include <asm/system.h> /* cli(), *_flags */
#include <linux/mm.h> /* vremap (2.0) */
#include <asm/io.h> /* ioremap */

/* The region we look at. */
#define ISA_REGION_BEGIN 0xA0000
#define ISA_REGION_END   0x100000
#define STEP 2048

/* have three symbols to export */
       void skull_fn1(void){}
static void skull_fn2(void){}
       int  skull_variable;

EXPORT_SYMBOL (skull_fn1);
EXPORT_SYMBOL (skull_fn2);
EXPORT_SYMBOL (skull_variable);


/* perform hardware autodetection */
int skull_probe_hw(unsigned int port, unsigned int range)
{
   /* do smart probing here */
   return -1; /* not found  :-) */
}

/* perform hardware initalizazion */
int skull_init_board(unsigned int port)
{
  /* do smart initalization here */
  return 0; /* done :-) */
}

/* detect the the device if the region is still free */
static int skull_detect(unsigned int port, unsigned int range)
{
    int err;

    if ((err = check_region(port,range)) < 0) return err; /* busy */
    if (skull_probe_hw(port,range) != 0) return -ENODEV;  /* not found */
    request_region(port,range,"skull");                   /* "Can't fail" */
    return 0;
}

/*
 * port ranges: the device can reside between
 * 0x280 and 0x300, in step of 0x10. It uses 0x10 ports.
 */
#define SKULL_PORT_FLOOR 0x280
#define SKULL_PORT_CEIL  0x300
#define SKULL_PORT_RANGE  0x010

/*
 * the following function performs autodetection, unless a specific
 * value was assigned by insmod to "skull_port_base"
 */

static int skull_port_base=0; /* 0 forces autodetection */
module_param(skull_port_base, int, 0);

static int skull_find_hw(void) /* returns the # of devices */
{
    /* base is either the load-time value or the first trial */
    int base = skull_port_base ? skull_port_base 
                             : SKULL_PORT_FLOOR; 
    int result = 0;

    /* loop one time if value assigned, try them all if autodetecting */
    do {
	if (skull_detect(base, SKULL_PORT_RANGE) == 0) {
	    skull_init_board(base);
	    result++;
	}
	base += SKULL_PORT_RANGE; /* prepare for next trial */
    }
    while (skull_port_base == 0 && base < SKULL_PORT_CEIL);

    return result;
}


int skull_init(void)
{
    /*
     * Print the isa region map, in blocks of 2K bytes.
     * This is not the best code, as it prints too many lines,
     * but it deserves to remain short to be included in the book.
     * Note also that read() should be used instead of pointers.
     */
    unsigned char oldval, newval; /* values read from memory   */
    unsigned long flags;          /* used to hold system flags */
    unsigned long add, i;
    void *base;
    
    /* Use ioremap to get a handle on our region */
    base = ioremap(ISA_REGION_BEGIN, ISA_REGION_END - ISA_REGION_BEGIN);
    base -= ISA_REGION_BEGIN;  /* Do the offset once */
    
    /* probe all the memory hole in 2KB steps */
    for (add = ISA_REGION_BEGIN; add < ISA_REGION_END; add += STEP) {
	/*
	 * Check for an already allocated region.
	 */
	if (check_mem_region (add, 2048)) {
		printk(KERN_INFO "%%lx: Allocated\n", add);
		continue;
	}
	/*
	 * Read and write the beginning of the region and see what happens.
	 */
	save_flags(flags); 
	cli();
	oldval = readb (base + add);  /* Read a byte */
	writeb (oldval^0xff, base + add);
	mb();
	newval = readb (base + add);
	writeb (oldval, base + add);
	restore_flags(flags);

	if ((oldval^newval) == 0xff) {  /* we re-read our change: it's ram */
	    printk(KERN_INFO "%%lx: RAM\n", add);
	    continue;
	}
	if ((oldval^newval) != 0) {  /* random bits changed: it's empty */
	    printk(KERN_INFO "%%lx: empty\n", add);
	    continue;
	}
	
	/*
	 * Expansion rom (executed at boot time by the bios)
	 * has a signature where the first byt is 0x55, the second 0xaa,
	 * and the third byte indicates the size of such rom
	 */
	if ( (oldval == 0x55) && (readb (base + add + 1) == 0xaa)) {
	    int size = 512 * readb (base + add + 2);
	    printk(KERN_INFO "%%lx: Expansion ROM, %%i bytes\n",
                   add, size);
	    add += (size & ~2048) - 2048; /* skip it */
	    continue;
	}
	
	/*
	 * If the tests above failed, we still don't know if it is ROM or
	 * empty. Since empty memory can appear as 0x00, 0xff, or the low
	 * address byte, we must probe multiple bytes: if at least one of
	 * them is different from these three values, then this is rom
	 * (though not boot rom).
	 */
	printk(KERN_INFO "%%lx: ", add);
	for (i=0; i<5; i++) {
	    unsigned long radd = add + 57*(i+1);  /* a "random" value */
	    unsigned char val = readb (base + radd);
	    if (val && val != 0xFF && val != ((unsigned long) radd&0xFF))
		break;
	}    
	printk("%%s\n", i==5 ? "empty" : "ROM");
    }

    /*
     * Find you hardware 
     */
    skull_find_hw();

    /*
     * Always fail to load (or suceed).
     */
    return 0;
}

module_init(skull_init);
]]>
			</text>
		</p>
		<p n="xlnx_drv_snull">
			<text>
				<![CDATA[/*
 * snull.c --  the Simple Network Utility
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: snull.c,v 1.21 2004/11/05 02:36:03 rubini Exp $
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/moduleparam.h>

#include <linux/sched.h>
#include <linux/kernel.h> /* printk() */
#include <linux/slab.h> /* kmalloc() */
#include <linux/errno.h>  /* error codes */
#include <linux/types.h>  /* size_t */
#include <linux/interrupt.h> /* mark_bh */

#include <linux/in.h>
#include <linux/netdevice.h>   /* struct device, and other headers */
#include <linux/etherdevice.h> /* eth_type_trans */
#include <linux/ip.h>          /* struct iphdr */
#include <linux/tcp.h>         /* struct tcphdr */
#include <linux/skbuff.h>

#include "snull.h"

#include <linux/in6.h>
#include <asm/checksum.h>

MODULE_AUTHOR("Alessandro Rubini, Jonathan Corbet");
MODULE_LICENSE("Dual BSD/GPL");


/*
 * Transmitter lockup simulation, normally disabled.
 */
static int lockup = 0;
module_param(lockup, int, 0);

static int timeout = SNULL_TIMEOUT;
module_param(timeout, int, 0);

/*
 * Do we run in NAPI mode?
 */
static int use_napi = 0;
module_param(use_napi, int, 0);


/*
 * A structure representing an in-flight packet.
 */
struct snull_packet {
	struct snull_packet *next;
	struct net_device *dev;
	int	datalen;
	u8 data[ETH_DATA_LEN];
};

int pool_size = 8;
module_param(pool_size, int, 0);

/*
 * This structure is private to each device. It is used to pass
 * packets in and out, so there is place for a packet
 */

struct snull_priv {
	struct net_device_stats stats;
	int status;
	struct snull_packet *ppool;
	struct snull_packet *rx_queue;  /* List of incoming packets */
	int rx_int_enabled;
	int tx_packetlen;
	u8 *tx_packetdata;
	struct sk_buff *skb;
	spinlock_t lock;
};

static void snull_tx_timeout(struct net_device *dev);
static void (*snull_interrupt)(int, void *, struct pt_regs *);

/*
 * Set up a device's packet pool.
 */
void snull_setup_pool(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	int i;
	struct snull_packet *pkt;

	priv->ppool = NULL;
	for (i = 0; i < pool_size; i++) {
		pkt = kmalloc (sizeof (struct snull_packet), GFP_KERNEL);
		if (pkt == NULL) {
			printk (KERN_NOTICE "Ran out of memory allocating packet pool\n");
			return;
		}
		pkt->dev = dev;
		pkt->next = priv->ppool;
		priv->ppool = pkt;
	}
}

void snull_teardown_pool(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	struct snull_packet *pkt;
    
	while ((pkt = priv->ppool)) {
		priv->ppool = pkt->next;
		kfree (pkt);
		/* FIXME - in-flight packets ? */
	}
}    

/*
 * Buffer/pool management.
 */
struct snull_packet *snull_get_tx_buffer(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	unsigned long flags;
	struct snull_packet *pkt;
    
	spin_lock_irqsave(&priv->lock, flags);
	pkt = priv->ppool;
	priv->ppool = pkt->next;
	if (priv->ppool == NULL) {
		printk (KERN_INFO "Pool empty\n");
		netif_stop_queue(dev);
	}
	spin_unlock_irqrestore(&priv->lock, flags);
	return pkt;
}


void snull_release_buffer(struct snull_packet *pkt)
{
	unsigned long flags;
	struct snull_priv *priv = netdev_priv(pkt->dev);
	
	spin_lock_irqsave(&priv->lock, flags);
	pkt->next = priv->ppool;
	priv->ppool = pkt;
	spin_unlock_irqrestore(&priv->lock, flags);
	if (netif_queue_stopped(pkt->dev) && pkt->next == NULL)
		netif_wake_queue(pkt->dev);
}

void snull_enqueue_buf(struct net_device *dev, struct snull_packet *pkt)
{
	unsigned long flags;
	struct snull_priv *priv = netdev_priv(dev);

	spin_lock_irqsave(&priv->lock, flags);
	pkt->next = priv->rx_queue;  /* FIXME - misorders packets */
	priv->rx_queue = pkt;
	spin_unlock_irqrestore(&priv->lock, flags);
}

struct snull_packet *snull_dequeue_buf(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	struct snull_packet *pkt;
	unsigned long flags;

	spin_lock_irqsave(&priv->lock, flags);
	pkt = priv->rx_queue;
	if (pkt != NULL)
		priv->rx_queue = pkt->next;
	spin_unlock_irqrestore(&priv->lock, flags);
	return pkt;
}

/*
 * Enable and disable receive interrupts.
 */
static void snull_rx_ints(struct net_device *dev, int enable)
{
	struct snull_priv *priv = netdev_priv(dev);
	priv->rx_int_enabled = enable;
}

    
/*
 * Open and close
 */

int snull_open(struct net_device *dev)
{
	/* request_region(), request_irq(), ....  (like fops->open) */

	/* 
	 * Assign the hardware address of the board: use "\0SNULx", where
	 * x is 0 or 1. The first byte is '\0' to avoid being a multicast
	 * address (the first byte of multicast addrs is odd).
	 */
	memcpy(dev->dev_addr, "\0SNUL0", ETH_ALEN);
	if (dev == snull_devs[1])
		dev->dev_addr[ETH_ALEN-1]++; /* \0SNUL1 */
	netif_start_queue(dev);
	return 0;
}

int snull_release(struct net_device *dev)
{
    /* release ports, irq and such -- like fops->close */

	netif_stop_queue(dev); /* can't transmit any more */
	return 0;
}

/*
 * Configuration changes (passed on by ifconfig)
 */
int snull_config(struct net_device *dev, struct ifmap *map)
{
	if (dev->flags & IFF_UP) /* can't act on a running interface */
		return -EBUSY;

	/* Don't allow changing the I/O address */
	if (map->base_addr != dev->base_addr) {
		printk(KERN_WARNING "snull: Can't change I/O address\n");
		return -EOPNOTSUPP;
	}

	/* Allow changing the IRQ */
	if (map->irq != dev->irq) {
		dev->irq = map->irq;
        	/* request_irq() is delayed to open-time */
	}

	/* ignore other fields */
	return 0;
}

/*
 * Receive a packet: retrieve, encapsulate and pass over to upper levels
 */
void snull_rx(struct net_device *dev, struct snull_packet *pkt)
{
	struct sk_buff *skb;
	struct snull_priv *priv = netdev_priv(dev);

	/*
	 * The packet has been retrieved from the transmission
	 * medium. Build an skb around it, so upper layers can handle it
	 */
	skb = dev_alloc_skb(pkt->datalen + 2);
	if (!skb) {
		if (printk_ratelimit())
			printk(KERN_NOTICE "snull rx: low on mem - packet dropped\n");
		priv->stats.rx_dropped++;
		goto out;
	}
	skb_reserve(skb, 2); /* align IP on 16B boundary */  
	memcpy(skb_put(skb, pkt->datalen), pkt->data, pkt->datalen);

	/* Write metadata, and then pass to the receive level */
	skb->dev = dev;
	skb->protocol = eth_type_trans(skb, dev);
	skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
	priv->stats.rx_packets++;
	priv->stats.rx_bytes += pkt->datalen;
	netif_rx(skb);
  out:
	return;
}
    

/*
 * The poll implementation.
 */
static int snull_poll(struct net_device *dev, int *budget)
{
	int npackets = 0, quota = min(dev->quota, *budget);
	struct sk_buff *skb;
	struct snull_priv *priv = netdev_priv(dev);
	struct snull_packet *pkt;
    
	while (npackets < quota && priv->rx_queue) {
		pkt = snull_dequeue_buf(dev);
		skb = dev_alloc_skb(pkt->datalen + 2);
		if (! skb) {
			if (printk_ratelimit())
				printk(KERN_NOTICE "snull: packet dropped\n");
			priv->stats.rx_dropped++;
			snull_release_buffer(pkt);
			continue;
		}
		skb_reserve(skb, 2); /* align IP on 16B boundary */  
		memcpy(skb_put(skb, pkt->datalen), pkt->data, pkt->datalen);
		skb->dev = dev;
		skb->protocol = eth_type_trans(skb, dev);
		skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
		netif_receive_skb(skb);
		
        	/* Maintain stats */
		npackets++;
		priv->stats.rx_packets++;
		priv->stats.rx_bytes += pkt->datalen;
		snull_release_buffer(pkt);
	}
	/* If we processed all packets, we're done; tell the kernel and reenable ints */
	*budget -= npackets;
	dev->quota -= npackets;
	if (! priv->rx_queue) {
		netif_rx_complete(dev);
		snull_rx_ints(dev, 1);
		return 0;
	}
	/* We couldn't process everything. */
	return 1;
}
	    
        
/*
 * The typical interrupt entry point
 */
static void snull_regular_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	int statusword;
	struct snull_priv *priv;
	struct snull_packet *pkt = NULL;
	/*
	 * As usual, check the "device" pointer to be sure it is
	 * really interrupting.
	 * Then assign "struct device *dev"
	 */
	struct net_device *dev = (struct net_device *)dev_id;
	/* ... and check with hw if it's really ours */

	/* paranoid */
	if (!dev)
		return;

	/* Lock the device */
	priv = netdev_priv(dev);
	spin_lock(&priv->lock);

	/* retrieve statusword: real netdevices use I/O instructions */
	statusword = priv->status;
	priv->status = 0;
	if (statusword & SNULL_RX_INTR) {
		/* send it to snull_rx for handling */
		pkt = priv->rx_queue;
		if (pkt) {
			priv->rx_queue = pkt->next;
			snull_rx(dev, pkt);
		}
	}
	if (statusword & SNULL_TX_INTR) {
		/* a transmission is over: free the skb */
		priv->stats.tx_packets++;
		priv->stats.tx_bytes += priv->tx_packetlen;
		dev_kfree_skb(priv->skb);
	}

	/* Unlock the device and we are done */
	spin_unlock(&priv->lock);
	if (pkt) snull_release_buffer(pkt); /* Do this outside the lock! */
	return;
}

/*
 * A NAPI interrupt handler.
 */
static void snull_napi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	int statusword;
	struct snull_priv *priv;

	/*
	 * As usual, check the "device" pointer for shared handlers.
	 * Then assign "struct device *dev"
	 */
	struct net_device *dev = (struct net_device *)dev_id;
	/* ... and check with hw if it's really ours */

	/* paranoid */
	if (!dev)
		return;

	/* Lock the device */
	priv = netdev_priv(dev);
	spin_lock(&priv->lock);

	/* retrieve statusword: real netdevices use I/O instructions */
	statusword = priv->status;
	priv->status = 0;
	if (statusword & SNULL_RX_INTR) {
		snull_rx_ints(dev, 0);  /* Disable further interrupts */
		netif_rx_schedule(dev);
	}
	if (statusword & SNULL_TX_INTR) {
        	/* a transmission is over: free the skb */
		priv->stats.tx_packets++;
		priv->stats.tx_bytes += priv->tx_packetlen;
		dev_kfree_skb(priv->skb);
	}

	/* Unlock the device and we are done */
	spin_unlock(&priv->lock);
	return;
}



/*
 * Transmit a packet (low level interface)
 */
static void snull_hw_tx(char *buf, int len, struct net_device *dev)
{
	/*
	 * This function deals with hw details. This interface loops
	 * back the packet to the other snull interface (if any).
	 * In other words, this function implements the snull behaviour,
	 * while all other procedures are rather device-independent
	 */
	struct iphdr *ih;
	struct net_device *dest;
	struct snull_priv *priv;
	u32 *saddr, *daddr;
	struct snull_packet *tx_buffer;
    
	/* I am paranoid. Ain't I? */
	if (len < sizeof(struct ethhdr) + sizeof(struct iphdr)) {
		printk("snull: Hmm... packet too short (%%i octets)\n",
				len);
		return;
	}

	if (0) { /* enable this conditional to look at the data */
		int i;
		PDEBUG("len is %%i\n" KERN_DEBUG "data:",len);
		for (i=14 ; i<len; i++)
			printk(" %%02x",buf[i]&0xff);
		printk("\n");
	}
	/*
	 * Ethhdr is 14 bytes, but the kernel arranges for iphdr
	 * to be aligned (i.e., ethhdr is unaligned)
	 */
	ih = (struct iphdr *)(buf+sizeof(struct ethhdr));
	saddr = &ih->saddr;
	daddr = &ih->daddr;

	((u8 *)saddr)[2] ^= 1; /* change the third octet (class C) */
	((u8 *)daddr)[2] ^= 1;

	ih->check = 0;         /* and rebuild the checksum (ip needs it) */
	ih->check = ip_fast_csum((unsigned char *)ih,ih->ihl);

	if (dev == snull_devs[0])
		PDEBUGG("%%08x:%%05i --> %%08x:%%05i\n",
				ntohl(ih->saddr),ntohs(((struct tcphdr *)(ih+1))->source),
				ntohl(ih->daddr),ntohs(((struct tcphdr *)(ih+1))->dest));
	else
		PDEBUGG("%%08x:%%05i <-- %%08x:%%05i\n",
				ntohl(ih->daddr),ntohs(((struct tcphdr *)(ih+1))->dest),
				ntohl(ih->saddr),ntohs(((struct tcphdr *)(ih+1))->source));

	/*
	 * Ok, now the packet is ready for transmission: first simulate a
	 * receive interrupt on the twin device, then  a
	 * transmission-done on the transmitting device
	 */
	dest = snull_devs[dev == snull_devs[0] ? 1 : 0];
	priv = netdev_priv(dest);
	tx_buffer = snull_get_tx_buffer(dev);
	tx_buffer->datalen = len;
	memcpy(tx_buffer->data, buf, len);
	snull_enqueue_buf(dest, tx_buffer);
	if (priv->rx_int_enabled) {
		priv->status |= SNULL_RX_INTR;
		snull_interrupt(0, dest, NULL);
	}

	priv = netdev_priv(dev);
	priv->tx_packetlen = len;
	priv->tx_packetdata = buf;
	priv->status |= SNULL_TX_INTR;
	if (lockup && ((priv->stats.tx_packets + 1) %% lockup) == 0) {
        	/* Simulate a dropped transmit interrupt */
		netif_stop_queue(dev);
		PDEBUG("Simulate lockup at %%ld, txp %%ld\n", jiffies,
				(unsigned long) priv->stats.tx_packets);
	}
	else
		snull_interrupt(0, dev, NULL);
}

/*
 * Transmit a packet (called by the kernel)
 */
int snull_tx(struct sk_buff *skb, struct net_device *dev)
{
	int len;
	char *data, shortpkt[ETH_ZLEN];
	struct snull_priv *priv = netdev_priv(dev);
	
	data = skb->data;
	len = skb->len;
	if (len < ETH_ZLEN) {
		memset(shortpkt, 0, ETH_ZLEN);
		memcpy(shortpkt, skb->data, skb->len);
		len = ETH_ZLEN;
		data = shortpkt;
	}
	dev->trans_start = jiffies; /* save the timestamp */

	/* Remember the skb, so we can free it at interrupt time */
	priv->skb = skb;

	/* actual deliver of data is device-specific, and not shown here */
	snull_hw_tx(data, len, dev);

	return 0; /* Our simple device can not fail */
}

/*
 * Deal with a transmit timeout.
 */
void snull_tx_timeout (struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);

	PDEBUG("Transmit timeout at %%ld, latency %%ld\n", jiffies,
			jiffies - dev->trans_start);
        /* Simulate a transmission interrupt to get things moving */
	priv->status = SNULL_TX_INTR;
	snull_interrupt(0, dev, NULL);
	priv->stats.tx_errors++;
	netif_wake_queue(dev);
	return;
}



/*
 * Ioctl commands 
 */
int snull_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	PDEBUG("ioctl\n");
	return 0;
}

/*
 * Return statistics to the caller
 */
struct net_device_stats *snull_stats(struct net_device *dev)
{
	struct snull_priv *priv = netdev_priv(dev);
	return &priv->stats;
}

/*
 * This function is called to fill up an eth header, since arp is not
 * available on the interface
 */
int snull_rebuild_header(struct sk_buff *skb)
{
	struct ethhdr *eth = (struct ethhdr *) skb->data;
	struct net_device *dev = skb->dev;
    
	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
	memcpy(eth->h_dest, dev->dev_addr, dev->addr_len);
	eth->h_dest[ETH_ALEN-1]   ^= 0x01;   /* dest is us xor 1 */
	return 0;
}


int snull_header(struct sk_buff *skb, struct net_device *dev,
                unsigned short type, void *daddr, void *saddr,
                unsigned int len)
{
	struct ethhdr *eth = (struct ethhdr *)skb_push(skb,ETH_HLEN);

	eth->h_proto = htons(type);
	memcpy(eth->h_source, saddr ? saddr : dev->dev_addr, dev->addr_len);
	memcpy(eth->h_dest,   daddr ? daddr : dev->dev_addr, dev->addr_len);
	eth->h_dest[ETH_ALEN-1]   ^= 0x01;   /* dest is us xor 1 */
	return (dev->hard_header_len);
}





/*
 * The "change_mtu" method is usually not needed.
 * If you need it, it must be like this.
 */
int snull_change_mtu(struct net_device *dev, int new_mtu)
{
	unsigned long flags;
	struct snull_priv *priv = netdev_priv(dev);
	spinlock_t *lock = &priv->lock;
    
	/* check ranges */
	if ((new_mtu < 68) || (new_mtu > 1500))
		return -EINVAL;
	/*
	 * Do anything you need, and the accept the value
	 */
	spin_lock_irqsave(lock, flags);
	dev->mtu = new_mtu;
	spin_unlock_irqrestore(lock, flags);
	return 0; /* success */
}

/*
 * The init function (sometimes called probe).
 * It is invoked by register_netdev()
 */
void snull_init(struct net_device *dev)
{
	struct snull_priv *priv;
#if 0
    	/*
	 * Make the usual checks: check_region(), probe irq, ...  -ENODEV
	 * should be returned if no device found.  No resource should be
	 * grabbed: this is done on open(). 
	 */
#endif

    	/* 
	 * Then, assign other fields in dev, using ether_setup() and some
	 * hand assignments
	 */
	ether_setup(dev); /* assign some of the fields */

	dev->open            = snull_open;
	dev->stop            = snull_release;
	dev->set_config      = snull_config;
	dev->hard_start_xmit = snull_tx;
	dev->do_ioctl        = snull_ioctl;
	dev->get_stats       = snull_stats;
	dev->change_mtu      = snull_change_mtu;  
	dev->rebuild_header  = snull_rebuild_header;
	dev->hard_header     = snull_header;
	dev->tx_timeout      = snull_tx_timeout;
	dev->watchdog_timeo = timeout;
	if (use_napi) {
		dev->poll        = snull_poll;
		dev->weight      = 2;
	}
	/* keep the default flags, just add NOARP */
	dev->flags           |= IFF_NOARP;
	dev->features        |= NETIF_F_NO_CSUM;
	dev->hard_header_cache = NULL;      /* Disable caching */

	/*
	 * Then, initialize the priv field. This encloses the statistics
	 * and a few private fields.
	 */
	priv = netdev_priv(dev);
	memset(priv, 0, sizeof(struct snull_priv));
	spin_lock_init(&priv->lock);
	snull_rx_ints(dev, 1);		/* enable receive interrupts */
	snull_setup_pool(dev);
}

/*
 * The devices
 */

struct net_device *snull_devs[2];



/*
 * Finally, the module stuff
 */

void snull_cleanup(void)
{
	int i;
    
	for (i = 0; i < 2;  i++) {
		if (snull_devs[i]) {
			unregister_netdev(snull_devs[i]);
			snull_teardown_pool(snull_devs[i]);
			free_netdev(snull_devs[i]);
		}
	}
	return;
}




int snull_init_module(void)
{
	int result, i, ret = -ENOMEM;

	snull_interrupt = use_napi ? snull_napi_interrupt : snull_regular_interrupt;

	/* Allocate the devices */
	snull_devs[0] = alloc_netdev(sizeof(struct snull_priv), "sn%%d",
			snull_init);
	snull_devs[1] = alloc_netdev(sizeof(struct snull_priv), "sn%%d",
			snull_init);
	if (snull_devs[0] == NULL || snull_devs[1] == NULL)
		goto out;

	ret = -ENODEV;
	for (i = 0; i < 2;  i++)
		if ((result = register_netdev(snull_devs[i])))
			printk("snull: error %%i registering device \"%%s\"\n",
					result, snull_devs[i]->name);
		else
			ret = 0;
   out:
	if (ret) 
		snull_cleanup();
	return ret;
}


module_init(snull_init_module);
module_exit(snull_cleanup);
]]>
			</text>
		</p>
		<p n="xlnx_drv_tiny_serial">
			<text>
				<![CDATA[/*
 * Tiny Serial driver
 *
 * Copyright (C) 2002-2004 Greg Kroah-Hartman (greg@kroah.com)
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, version 2 of the License.
 *
 * This driver shows how to create a minimal serial driver.  It does not rely on
 * any backing hardware, but creates a timer that emulates data being received
 * from some kind of hardware.
 */

#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/tty.h>
#include <linux/tty_flip.h>
#include <linux/serial.h>
#include <linux/serial_core.h>
#include <linux/module.h>


#define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>"
#define DRIVER_DESC "Tiny serial driver"

/* Module information */
MODULE_AUTHOR( DRIVER_AUTHOR );
MODULE_DESCRIPTION( DRIVER_DESC );
MODULE_LICENSE("GPL");

#define DELAY_TIME		HZ * 2	/* 2 seconds per character */
#define TINY_DATA_CHARACTER	't'

#define TINY_SERIAL_MAJOR	240	/* experimental range */
#define TINY_SERIAL_MINORS	1	/* only have one minor */
#define UART_NR			1	/* only use one port */

#define TINY_SERIAL_NAME	"ttytiny"

#define MY_NAME			TINY_SERIAL_NAME

static struct timer_list *timer;

static void tiny_stop_tx(struct uart_port *port, unsigned int tty_stop)
{
}

static void tiny_stop_rx(struct uart_port *port)
{
}

static void tiny_enable_ms(struct uart_port *port)
{
}

static void tiny_tx_chars(struct uart_port *port)
{
	struct circ_buf *xmit = &port->info->xmit;
	int count;

	if (port->x_char) {
		pr_debug("wrote %%2x", port->x_char);
		port->icount.tx++;
		port->x_char = 0;
		return;
	}
	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
		tiny_stop_tx(port, 0);
		return;
	}

	count = port->fifosize >> 1;
	do {
		pr_debug("wrote %%2x", xmit->buf[xmit->tail]);
		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
		port->icount.tx++;
		if (uart_circ_empty(xmit))
			break;
	} while (--count > 0);

	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
		uart_write_wakeup(port);

	if (uart_circ_empty(xmit))
		tiny_stop_tx(port, 0);
}

static void tiny_start_tx(struct uart_port *port, unsigned int tty_start)
{
}

static void tiny_timer(unsigned long data)
{
	struct uart_port *port;
	struct tty_struct *tty;


	port = (struct uart_port *)data;
	if (!port)
		return;
	if (!port->info)
		return;
	tty = port->info->tty;
	if (!tty)
		return;

	/* add one character to the tty port */
	/* this doesn't actually push the data through unless tty->low_latency is set */
	tty_insert_flip_char(tty, TINY_DATA_CHARACTER, 0);

	tty_flip_buffer_push(tty);

	/* resubmit the timer again */
	timer->expires = jiffies + DELAY_TIME;
	add_timer(timer);

	/* see if we have any data to transmit */
	tiny_tx_chars(port);
}

static unsigned int tiny_tx_empty(struct uart_port *port)
{
	return 0;
}

static unsigned int tiny_get_mctrl(struct uart_port *port)
{
	return 0;
}

static void tiny_set_mctrl(struct uart_port *port, unsigned int mctrl)
{
}

static void tiny_break_ctl(struct uart_port *port, int break_state)
{
}

static void tiny_set_termios(struct uart_port *port,
			     struct termios *new, struct termios *old)
{
	int baud, quot, cflag = new->c_cflag;
	/* get the byte size */
	switch (cflag & CSIZE) {
	case CS5:
		printk(KERN_DEBUG " - data bits = 5\n");
		break;
	case CS6:
		printk(KERN_DEBUG " - data bits = 6\n");
		break;
	case CS7:
		printk(KERN_DEBUG " - data bits = 7\n");
		break;
	default: // CS8
		printk(KERN_DEBUG " - data bits = 8\n");
		break;
	}

	/* determine the parity */
	if (cflag & PARENB)
		if (cflag & PARODD)
			pr_debug(" - parity = odd\n");
		else
			pr_debug(" - parity = even\n");
	else
		pr_debug(" - parity = none\n");

	/* figure out the stop bits requested */
	if (cflag & CSTOPB)
		pr_debug(" - stop bits = 2\n");
	else
		pr_debug(" - stop bits = 1\n");

	/* figure out the flow control settings */
	if (cflag & CRTSCTS)
		pr_debug(" - RTS/CTS is enabled\n");
	else
		pr_debug(" - RTS/CTS is disabled\n");

	/* Set baud rate */
        baud = uart_get_baud_rate(port, new, old, 0, port->uartclk/16);
        quot = uart_get_divisor(port, baud);
	
	//UART_PUT_DIV_LO(port, (quot & 0xff));
	//UART_PUT_DIV_HI(port, ((quot & 0xf00) >> 8));
}

static int tiny_startup(struct uart_port *port)
{
	/* this is the first time this port is opened */
	/* do any hardware initialization needed here */

	/* create our timer and submit it */
	if (!timer) {
		timer = kmalloc(sizeof(*timer), GFP_KERNEL);
		if (!timer)
			return -ENOMEM;
	}
	timer->data = (unsigned long)port;
	timer->expires = jiffies + DELAY_TIME;
	timer->function = tiny_timer;
	add_timer(timer);
	return 0;
}

static void tiny_shutdown(struct uart_port *port)
{
	/* The port is being closed by the last user. */
	/* Do any hardware specific stuff here */

	/* shut down our timer */
	del_timer(timer);
}

static const char *tiny_type(struct uart_port *port)
{
	return "tinytty";
}

static void tiny_release_port(struct uart_port *port)
{

}

static int tiny_request_port(struct uart_port *port)
{
	return 0;
}

static void tiny_config_port(struct uart_port *port, int flags)
{
}

static int tiny_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return 0;
}

static struct uart_ops tiny_ops = {
	.tx_empty	= tiny_tx_empty,
	.set_mctrl	= tiny_set_mctrl,
	.get_mctrl	= tiny_get_mctrl,
	.stop_tx	= tiny_stop_tx,
	.start_tx	= tiny_start_tx,
	.stop_rx	= tiny_stop_rx,
	.enable_ms	= tiny_enable_ms,
	.break_ctl	= tiny_break_ctl,
	.startup	= tiny_startup,
	.shutdown	= tiny_shutdown,
	.set_termios	= tiny_set_termios,
	.type		= tiny_type,
	.release_port	= tiny_release_port,
	.request_port	= tiny_request_port,
	.config_port	= tiny_config_port,
	.verify_port	= tiny_verify_port,
};

static struct uart_port tiny_port = {
	.ops		= &tiny_ops,
};

static struct uart_driver tiny_reg = {
	.owner		= THIS_MODULE,
	.driver_name	= TINY_SERIAL_NAME,
	.dev_name	= TINY_SERIAL_NAME,
	.major		= TINY_SERIAL_MAJOR,
	.minor		= TINY_SERIAL_MINORS,
	.nr		= UART_NR,
};

static int __init tiny_init(void)
{
	int result;

	printk(KERN_INFO "Tiny serial driver loaded\n");

	result = uart_register_driver(&tiny_reg);
	if (result)
		return result;

	result = uart_add_one_port(&tiny_reg, &tiny_port);
	if (result)
		uart_unregister_driver(&tiny_reg);

	return result;
}

module_init(tiny_init);
]]>
			</text>
		</p>
		<p n="xlnx_drv_tiny_tty">
			<text>
				<![CDATA[/*
 * Tiny TTY driver
 *
 * Copyright (C) 2002-2004 Greg Kroah-Hartman (greg@kroah.com)
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, version 2 of the License.
 *
 * This driver shows how to create a minimal tty driver.  It does not rely on
 * any backing hardware, but creates a timer that emulates data being received
 * from some kind of hardware.
 */

#include <linux/config.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/wait.h>
#include <linux/tty.h>
#include <linux/tty_driver.h>
#include <linux/tty_flip.h>
#include <linux/serial.h>
#include <asm/uaccess.h>


#define DRIVER_VERSION "v2.0"
#define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>"
#define DRIVER_DESC "Tiny TTY driver"

/* Module information */
MODULE_AUTHOR( DRIVER_AUTHOR );
MODULE_DESCRIPTION( DRIVER_DESC );
MODULE_LICENSE("GPL");

#define DELAY_TIME		HZ * 2	/* 2 seconds per character */
#define TINY_DATA_CHARACTER	't'

#define TINY_TTY_MAJOR		240	/* experimental range */
#define TINY_TTY_MINORS		4	/* only have 4 devices */

struct tiny_serial {
	struct tty_struct	*tty;		/* pointer to the tty for this device */
	int			open_count;	/* number of times this port has been opened */
	struct semaphore	sem;		/* locks this structure */
	struct timer_list	*timer;

	/* for tiocmget and tiocmset functions */
	int			msr;		/* MSR shadow */
	int			mcr;		/* MCR shadow */

	/* for ioctl fun */
	struct serial_struct	serial;
	wait_queue_head_t	wait;
	struct async_icount	icount;
};

static struct tiny_serial *tiny_table[TINY_TTY_MINORS];	/* initially all NULL */


static void tiny_timer(unsigned long timer_data)
{
	struct tiny_serial *tiny = (struct tiny_serial *)timer_data;
	struct tty_struct *tty;
	int i;
	char data[1] = {TINY_DATA_CHARACTER};
	int data_size = 1;

	if (!tiny)
		return;

	tty = tiny->tty;

	/* send the data to the tty layer for users to read.  This doesn't
	 * actually push the data through unless tty->low_latency is set */
	for (i = 0; i < data_size; ++i) {
		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
			tty_flip_buffer_push(tty);
		tty_insert_flip_char(tty, data[i], TTY_NORMAL);
	}
	tty_flip_buffer_push(tty);

	/* resubmit the timer again */
	tiny->timer->expires = jiffies + DELAY_TIME;
	add_timer(tiny->timer);
}

static int tiny_open(struct tty_struct *tty, struct file *file)
{
	struct tiny_serial *tiny;
	struct timer_list *timer;
	int index;

	/* initialize the pointer in case something fails */
	tty->driver_data = NULL;

	/* get the serial object associated with this tty pointer */
	index = tty->index;
	tiny = tiny_table[index];
	if (tiny == NULL) {
		/* first time accessing this device, let's create it */
		tiny = kmalloc(sizeof(*tiny), GFP_KERNEL);
		if (!tiny)
			return -ENOMEM;

		init_MUTEX(&tiny->sem);
		tiny->open_count = 0;
		tiny->timer = NULL;

		tiny_table[index] = tiny;
	}

	down(&tiny->sem);

	/* save our structure within the tty structure */
	tty->driver_data = tiny;
	tiny->tty = tty;

	++tiny->open_count;
	if (tiny->open_count == 1) {
		/* this is the first time this port is opened */
		/* do any hardware initialization needed here */

		/* create our timer and submit it */
		if (!tiny->timer) {
			timer = kmalloc(sizeof(*timer), GFP_KERNEL);
			if (!timer) {
				up(&tiny->sem);
				return -ENOMEM;
			}
			tiny->timer = timer;
		}
		tiny->timer->data = (unsigned long )tiny;
		tiny->timer->expires = jiffies + DELAY_TIME;
		tiny->timer->function = tiny_timer;
		add_timer(tiny->timer);
	}

	up(&tiny->sem);
	return 0;
}

static void do_close(struct tiny_serial *tiny)
{
	down(&tiny->sem);

	if (!tiny->open_count) {
		/* port was never opened */
		goto exit;
	}

	--tiny->open_count;
	if (tiny->open_count <= 0) {
		/* The port is being closed by the last user. */
		/* Do any hardware specific stuff here */

		/* shut down our timer */
		del_timer(tiny->timer);
	}
exit:
	up(&tiny->sem);
}

static void tiny_close(struct tty_struct *tty, struct file *file)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (tiny)
		do_close(tiny);
}	

static int tiny_write(struct tty_struct *tty, 
		      const unsigned char *buffer, int count)
{
	struct tiny_serial *tiny = tty->driver_data;
	int i;
	int retval = -EINVAL;

	if (!tiny)
		return -ENODEV;

	down(&tiny->sem);

	if (!tiny->open_count)
		/* port was not opened */
		goto exit;

	/* fake sending the data out a hardware port by
	 * writing it to the kernel debug log.
	 */
	printk(KERN_DEBUG "%%s - ", __FUNCTION__);
	for (i = 0; i < count; ++i)
		printk("%%02x ", buffer[i]);
	printk("\n");
		
exit:
	up(&tiny->sem);
	return retval;
}

static int tiny_write_room(struct tty_struct *tty) 
{
	struct tiny_serial *tiny = tty->driver_data;
	int room = -EINVAL;

	if (!tiny)
		return -ENODEV;

	down(&tiny->sem);
	
	if (!tiny->open_count) {
		/* port was not opened */
		goto exit;
	}

	/* calculate how much room is left in the device */
	room = 255;

exit:
	up(&tiny->sem);
	return room;
}

#define RELEVANT_IFLAG(iflag) ((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))

static void tiny_set_termios(struct tty_struct *tty, struct termios *old_termios)
{
	unsigned int cflag;

	cflag = tty->termios->c_cflag;

	/* check that they really want us to change something */
	if (old_termios) {
		if ((cflag == old_termios->c_cflag) &&
		    (RELEVANT_IFLAG(tty->termios->c_iflag) == 
		     RELEVANT_IFLAG(old_termios->c_iflag))) {
			printk(KERN_DEBUG " - nothing to change...\n");
			return;
		}
	}

	/* get the byte size */
	switch (cflag & CSIZE) {
		case CS5:
			printk(KERN_DEBUG " - data bits = 5\n");
			break;
		case CS6:
			printk(KERN_DEBUG " - data bits = 6\n");
			break;
		case CS7:
			printk(KERN_DEBUG " - data bits = 7\n");
			break;
		default:
		case CS8:
			printk(KERN_DEBUG " - data bits = 8\n");
			break;
	}
	
	/* determine the parity */
	if (cflag & PARENB)
		if (cflag & PARODD)
			printk(KERN_DEBUG " - parity = odd\n");
		else
			printk(KERN_DEBUG " - parity = even\n");
	else
		printk(KERN_DEBUG " - parity = none\n");

	/* figure out the stop bits requested */
	if (cflag & CSTOPB)
		printk(KERN_DEBUG " - stop bits = 2\n");
	else
		printk(KERN_DEBUG " - stop bits = 1\n");

	/* figure out the hardware flow control settings */
	if (cflag & CRTSCTS)
		printk(KERN_DEBUG " - RTS/CTS is enabled\n");
	else
		printk(KERN_DEBUG " - RTS/CTS is disabled\n");
	
	/* determine software flow control */
	/* if we are implementing XON/XOFF, set the start and 
	 * stop character in the device */
	if (I_IXOFF(tty) || I_IXON(tty)) {
		unsigned char stop_char  = STOP_CHAR(tty);
		unsigned char start_char = START_CHAR(tty);

		/* if we are implementing INBOUND XON/XOFF */
		if (I_IXOFF(tty))
			printk(KERN_DEBUG " - INBOUND XON/XOFF is enabled, "
				"XON = %%2x, XOFF = %%2x", start_char, stop_char);
		else
			printk(KERN_DEBUG" - INBOUND XON/XOFF is disabled");

		/* if we are implementing OUTBOUND XON/XOFF */
		if (I_IXON(tty))
			printk(KERN_DEBUG" - OUTBOUND XON/XOFF is enabled, "
				"XON = %%2x, XOFF = %%2x", start_char, stop_char);
		else
			printk(KERN_DEBUG" - OUTBOUND XON/XOFF is disabled");
	}

	/* get the baud rate wanted */
	printk(KERN_DEBUG " - baud rate = %%d", tty_get_baud_rate(tty));
}

/* Our fake UART values */
#define MCR_DTR		0x01
#define MCR_RTS		0x02
#define MCR_LOOP	0x04
#define MSR_CTS		0x08
#define MSR_CD		0x10
#define MSR_RI		0x20
#define MSR_DSR		0x40

static int tiny_tiocmget(struct tty_struct *tty, struct file *file)
{
	struct tiny_serial *tiny = tty->driver_data;

	unsigned int result = 0;
	unsigned int msr = tiny->msr;
	unsigned int mcr = tiny->mcr;

	result = ((mcr & MCR_DTR)  ? TIOCM_DTR  : 0) |	/* DTR is set */
             ((mcr & MCR_RTS)  ? TIOCM_RTS  : 0) |	/* RTS is set */
             ((mcr & MCR_LOOP) ? TIOCM_LOOP : 0) |	/* LOOP is set */
             ((msr & MSR_CTS)  ? TIOCM_CTS  : 0) |	/* CTS is set */
             ((msr & MSR_CD)   ? TIOCM_CAR  : 0) |	/* Carrier detect is set*/
             ((msr & MSR_RI)   ? TIOCM_RI   : 0) |	/* Ring Indicator is set */
             ((msr & MSR_DSR)  ? TIOCM_DSR  : 0);	/* DSR is set */

	return result;
}

static int tiny_tiocmset(struct tty_struct *tty, struct file *file,
                         unsigned int set, unsigned int clear)
{
	struct tiny_serial *tiny = tty->driver_data;
	unsigned int mcr = tiny->mcr;

	if (set & TIOCM_RTS)
		mcr |= MCR_RTS;
	if (set & TIOCM_DTR)
		mcr |= MCR_RTS;

	if (clear & TIOCM_RTS)
		mcr &= ~MCR_RTS;
	if (clear & TIOCM_DTR)
		mcr &= ~MCR_RTS;

	/* set the new MCR value in the device */
	tiny->mcr = mcr;
	return 0;
}

static int tiny_read_proc(char *page, char **start, off_t off, int count,
                          int *eof, void *data)
{
	struct tiny_serial *tiny;
	off_t begin = 0;
	int length = 0;
	int i;

	length += sprintf(page, "tinyserinfo:1.0 driver:%%s\n", DRIVER_VERSION);
	for (i = 0; i < TINY_TTY_MINORS && length < PAGE_SIZE; ++i) {
		tiny = tiny_table[i];
		if (tiny == NULL)
			continue;

		length += sprintf(page+length, "%%d\n", i);
		if ((length + begin) > (off + count))
			goto done;
		if ((length + begin) < off) {
			begin += length;
			length = 0;
		}
	}
	*eof = 1;
done:
	if (off >= (length + begin))
		return 0;
	*start = page + (off-begin);
	return (count < begin+length-off) ? count : begin + length-off;
}

#define tiny_ioctl tiny_ioctl_tiocgserial
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (cmd == TIOCGSERIAL) {
		struct serial_struct tmp;

		if (!arg)
			return -EFAULT;

		memset(&tmp, 0, sizeof(tmp));

		tmp.type		= tiny->serial.type;
		tmp.line		= tiny->serial.line;
		tmp.port		= tiny->serial.port;
		tmp.irq			= tiny->serial.irq;
		tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
		tmp.xmit_fifo_size	= tiny->serial.xmit_fifo_size;
		tmp.baud_base		= tiny->serial.baud_base;
		tmp.close_delay		= 5*HZ;
		tmp.closing_wait	= 30*HZ;
		tmp.custom_divisor	= tiny->serial.custom_divisor;
		tmp.hub6		= tiny->serial.hub6;
		tmp.io_type		= tiny->serial.io_type;

		if (copy_to_user((void __user *)arg, &tmp, sizeof(struct serial_struct)))
			return -EFAULT;
		return 0;
	}
	return -ENOIOCTLCMD;
}
#undef tiny_ioctl

#define tiny_ioctl tiny_ioctl_tiocmiwait
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (cmd == TIOCMIWAIT) {
		DECLARE_WAITQUEUE(wait, current);
		struct async_icount cnow;
		struct async_icount cprev;

		cprev = tiny->icount;
		while (1) {
			add_wait_queue(&tiny->wait, &wait);
			set_current_state(TASK_INTERRUPTIBLE);
			schedule();
			remove_wait_queue(&tiny->wait, &wait);

			/* see if a signal woke us up */
			if (signal_pending(current))
				return -ERESTARTSYS;

			cnow = tiny->icount;
			if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
			    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
				return -EIO; /* no change => error */
			if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
			    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
			    ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {
				return 0;
			}
			cprev = cnow;
		}

	}
	return -ENOIOCTLCMD;
}
#undef tiny_ioctl

#define tiny_ioctl tiny_ioctl_tiocgicount
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	struct tiny_serial *tiny = tty->driver_data;

	if (cmd == TIOCGICOUNT) {
		struct async_icount cnow = tiny->icount;
		struct serial_icounter_struct icount;

		icount.cts	= cnow.cts;
		icount.dsr	= cnow.dsr;
		icount.rng	= cnow.rng;
		icount.dcd	= cnow.dcd;
		icount.rx	= cnow.rx;
		icount.tx	= cnow.tx;
		icount.frame	= cnow.frame;
		icount.overrun	= cnow.overrun;
		icount.parity	= cnow.parity;
		icount.brk	= cnow.brk;
		icount.buf_overrun = cnow.buf_overrun;

		if (copy_to_user((void __user *)arg, &icount, sizeof(icount)))
			return -EFAULT;
		return 0;
	}
	return -ENOIOCTLCMD;
}
#undef tiny_ioctl

/* the real tiny_ioctl function.  The above is done to get the small functions in the book */
static int tiny_ioctl(struct tty_struct *tty, struct file *file,
                      unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
	case TIOCGSERIAL:
		return tiny_ioctl_tiocgserial(tty, file, cmd, arg);
	case TIOCMIWAIT:
		return tiny_ioctl_tiocmiwait(tty, file, cmd, arg);
	case TIOCGICOUNT:
		return tiny_ioctl_tiocgicount(tty, file, cmd, arg);
	}

	return -ENOIOCTLCMD;
}

static struct tty_operations serial_ops = {
	.open = tiny_open,
	.close = tiny_close,
	.write = tiny_write,
	.write_room = tiny_write_room,
	.set_termios = tiny_set_termios,
};

static struct tty_driver *tiny_tty_driver;

static int __init tiny_init(void)
{
	int retval;
	int i;

	/* allocate the tty driver */
	tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);
	if (!tiny_tty_driver)
		return -ENOMEM;

	/* initialize the tty driver */
	tiny_tty_driver->owner = THIS_MODULE;
	tiny_tty_driver->driver_name = "tiny_tty";
	tiny_tty_driver->name = "ttty";
	tiny_tty_driver->devfs_name = "tts/ttty%%d";
	tiny_tty_driver->major = TINY_TTY_MAJOR,
	tiny_tty_driver->type = TTY_DRIVER_TYPE_SERIAL,
	tiny_tty_driver->subtype = SERIAL_TYPE_NORMAL,
	tiny_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
	tiny_tty_driver->init_termios = tty_std_termios;
	tiny_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
	tty_set_operations(tiny_tty_driver, &serial_ops);

	/* hack to make the book purty, yet still use these functions in the
	 * real driver.  They really should be set up in the serial_ops
	 * structure above... */
	tiny_tty_driver->read_proc = tiny_read_proc;
	tiny_tty_driver->tiocmget = tiny_tiocmget;
	tiny_tty_driver->tiocmset = tiny_tiocmset;
	tiny_tty_driver->ioctl = tiny_ioctl;

	/* register the tty driver */
	retval = tty_register_driver(tiny_tty_driver);
	if (retval) {
		printk(KERN_ERR "failed to register tiny tty driver");
		put_tty_driver(tiny_tty_driver);
		return retval;
	}

	for (i = 0; i < TINY_TTY_MINORS; ++i)
		tty_register_device(tiny_tty_driver, i, NULL);

	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION);
	return retval;
}

static void __exit tiny_exit(void)
{
	struct tiny_serial *tiny;
	int i;

	for (i = 0; i < TINY_TTY_MINORS; ++i)
		tty_unregister_device(tiny_tty_driver, i);
	tty_unregister_driver(tiny_tty_driver);

	/* shut down all of the timers and free the memory */
	for (i = 0; i < TINY_TTY_MINORS; ++i) {
		tiny = tiny_table[i];
		if (tiny) {
			/* close the port */
			while (tiny->open_count)
				do_close(tiny);

			/* shut down our timer and free the memory */
			del_timer(tiny->timer);
			kfree(tiny->timer);
			kfree(tiny);
			tiny_table[i] = NULL;
		}
	}
}

module_init(tiny_init);
module_exit(tiny_exit);
]]>
			</text>
		</p>
		<p n="xlnx_drv_usb_skeleton">
			<text>
				<![CDATA[/*
 * USB Skeleton driver - 2.0
 *
 * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License as
 *	published by the Free Software Foundation, version 2.
 *
 * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c 
 * but has been rewritten to be easy to read and use, as no locks are now
 * needed anymore.
 *
 */

#include <linux/config.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/kref.h>
#include <linux/smp_lock.h>
#include <linux/usb.h>
#include <asm/uaccess.h>


/* Define these values to match your devices */
#define USB_SKEL_VENDOR_ID	0xfff0
#define USB_SKEL_PRODUCT_ID	0xfff0

/* table of devices that work with this driver */
static struct usb_device_id skel_table [] = {
	{ USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
	{ }					/* Terminating entry */
};
MODULE_DEVICE_TABLE (usb, skel_table);


/* Get a minor range for your devices from the usb maintainer */
#define USB_SKEL_MINOR_BASE	192

/* Structure to hold all of our device specific stuff */
struct usb_skel {
	struct usb_device *	udev;			/* the usb device for this device */
	struct usb_interface *	interface;		/* the interface for this device */
	unsigned char *		bulk_in_buffer;		/* the buffer to receive data */
	size_t			bulk_in_size;		/* the size of the receive buffer */
	__u8			bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
	__u8			bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
	struct kref		kref;
};
#define to_skel_dev(d) container_of(d, struct usb_skel, kref)

static struct usb_driver skel_driver;

static void skel_delete(struct kref *kref)
{	
	struct usb_skel *dev = to_skel_dev(kref);

	usb_put_dev(dev->udev);
	kfree (dev->bulk_in_buffer);
	kfree (dev);
}

static int skel_open(struct inode *inode, struct file *file)
{
	struct usb_skel *dev;
	struct usb_interface *interface;
	int subminor;
	int retval = 0;

	subminor = iminor(inode);

	interface = usb_find_interface(&skel_driver, subminor);
	if (!interface) {
		err ("%%s - error, can't find device for minor %%d",
		     __FUNCTION__, subminor);
		retval = -ENODEV;
		goto exit;
	}

	dev = usb_get_intfdata(interface);
	if (!dev) {
		retval = -ENODEV;
		goto exit;
	}
	
	/* increment our usage count for the device */
	kref_get(&dev->kref);

	/* save our object in the file's private structure */
	file->private_data = dev;

exit:
	return retval;
}

static int skel_release(struct inode *inode, struct file *file)
{
	struct usb_skel *dev;

	dev = (struct usb_skel *)file->private_data;
	if (dev == NULL)
		return -ENODEV;

	/* decrement the count on our device */
	kref_put(&dev->kref, skel_delete);
	return 0;
}

static ssize_t skel_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
{
	struct usb_skel *dev;
	int retval = 0;

	dev = (struct usb_skel *)file->private_data;
	
	/* do a blocking bulk read to get data from the device */
	retval = usb_bulk_msg(dev->udev,
			      usb_rcvbulkpipe(dev->udev, dev->bulk_in_endpointAddr),
			      dev->bulk_in_buffer,
			      min(dev->bulk_in_size, count),
			      &count, HZ*10);

	/* if the read was successful, copy the data to userspace */
	if (!retval) {
		if (copy_to_user(buffer, dev->bulk_in_buffer, count))
			retval = -EFAULT;
		else
			retval = count;
	}

	return retval;
}

static void skel_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
{
	/* sync/async unlink faults aren't errors */
	if (urb->status && 
	    !(urb->status == -ENOENT || 
	      urb->status == -ECONNRESET ||
	      urb->status == -ESHUTDOWN)) {
		dbg("%%s - nonzero write bulk status received: %%d",
		    __FUNCTION__, urb->status);
	}

	/* free up our allocated buffer */
	usb_buffer_free(urb->dev, urb->transfer_buffer_length, 
			urb->transfer_buffer, urb->transfer_dma);
}

static ssize_t skel_write(struct file *file, const char __user *user_buffer, size_t count, loff_t *ppos)
{
	struct usb_skel *dev;
	int retval = 0;
	struct urb *urb = NULL;
	char *buf = NULL;

	dev = (struct usb_skel *)file->private_data;

	/* verify that we actually have some data to write */
	if (count == 0)
		goto exit;

	/* create a urb, and a buffer for it, and copy the data to the urb */
	urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!urb) {
		retval = -ENOMEM;
		goto error;
	}

	buf = usb_buffer_alloc(dev->udev, count, GFP_KERNEL, &urb->transfer_dma);
	if (!buf) {
		retval = -ENOMEM;
		goto error;
	}
	if (copy_from_user(buf, user_buffer, count)) {
		retval = -EFAULT;
		goto error;
	}

	/* initialize the urb properly */
	usb_fill_bulk_urb(urb, dev->udev,
			  usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),
			  buf, count, skel_write_bulk_callback, dev);
	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;

	/* send the data out the bulk port */
	retval = usb_submit_urb(urb, GFP_KERNEL);
	if (retval) {
		err("%%s - failed submitting write urb, error %%d", __FUNCTION__, retval);
		goto error;
	}

	/* release our reference to this urb, the USB core will eventually free it entirely */
	usb_free_urb(urb);

exit:
	return count;

error:
	usb_buffer_free(dev->udev, count, buf, urb->transfer_dma);
	usb_free_urb(urb);
	kfree(buf);
	return retval;
}

static struct file_operations skel_fops = {
	.owner =	THIS_MODULE,
	.read =		skel_read,
	.write =	skel_write,
	.open =		skel_open,
	.release =	skel_release,
};

/* 
 * usb class driver info in order to get a minor number from the usb core,
 * and to have the device registered with devfs and the driver core
 */
static struct usb_class_driver skel_class = {
	.name = "usb/skel%%d",
	.fops = &skel_fops,
	.mode = S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH,
	.minor_base = USB_SKEL_MINOR_BASE,
};

static int skel_probe(struct usb_interface *interface, const struct usb_device_id *id)
{
	struct usb_skel *dev = NULL;
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor *endpoint;
	size_t buffer_size;
	int i;
	int retval = -ENOMEM;

	/* allocate memory for our device state and initialize it */
	dev = kmalloc(sizeof(struct usb_skel), GFP_KERNEL);
	if (dev == NULL) {
		err("Out of memory");
		goto error;
	}
	memset(dev, 0x00, sizeof (*dev));
	kref_init(&dev->kref);

	dev->udev = usb_get_dev(interface_to_usbdev(interface));
	dev->interface = interface;

	/* set up the endpoint information */
	/* use only the first bulk-in and bulk-out endpoints */
	iface_desc = interface->cur_altsetting;
	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;

		if (!dev->bulk_in_endpointAddr &&
		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
					== USB_ENDPOINT_XFER_BULK)) {
			/* we found a bulk in endpoint */
			buffer_size = endpoint->wMaxPacketSize;
			dev->bulk_in_size = buffer_size;
			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
			if (!dev->bulk_in_buffer) {
				err("Could not allocate bulk_in_buffer");
				goto error;
			}
		}

		if (!dev->bulk_out_endpointAddr &&
		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
					== USB_ENDPOINT_XFER_BULK)) {
			/* we found a bulk out endpoint */
			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
		}
	}
	if (!(dev->bulk_in_endpointAddr && dev->bulk_out_endpointAddr)) {
		err("Could not find both bulk-in and bulk-out endpoints");
		goto error;
	}

	/* save our data pointer in this interface device */
	usb_set_intfdata(interface, dev);

	/* we can register the device now, as it is ready */
	retval = usb_register_dev(interface, &skel_class);
	if (retval) {
		/* something prevented us from registering this driver */
		err("Not able to get a minor for this device.");
		usb_set_intfdata(interface, NULL);
		goto error;
	}

	/* let the user know what node this device is now attached to */
	info("USB Skeleton device now attached to USBSkel-%%d", interface->minor);
	return 0;

error:
	if (dev)
		kref_put(&dev->kref, skel_delete);
	return retval;
}

static void skel_disconnect(struct usb_interface *interface)
{
	struct usb_skel *dev;
	int minor = interface->minor;

	/* prevent skel_open() from racing skel_disconnect() */
	lock_kernel();

	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);

	/* give back our minor */
	usb_deregister_dev(interface, &skel_class);

	unlock_kernel();

	/* decrement our usage count */
	kref_put(&dev->kref, skel_delete);

	info("USB Skeleton #%%d now disconnected", minor);
}

static struct usb_driver skel_driver = {
	.owner = THIS_MODULE,
	.name = "skeleton",
	.id_table = skel_table,
	.probe = skel_probe,
	.disconnect = skel_disconnect,
};

static int __init usb_skel_init(void)
{
	int result;

	/* register this driver with the USB subsystem */
	result = usb_register(&skel_driver);
	if (result)
		err("usb_register failed. Error number %%d", result);

	return result;
}

static void __exit usb_skel_exit(void)
{
	/* deregister this driver with the USB subsystem */
	usb_deregister(&skel_driver);
}

module_init (usb_skel_init);
module_exit (usb_skel_exit);

MODULE_LICENSE("GPL");
]]>
			</text>
		</p>
		<p n="xlnx_drv_ldbus_H">
			<text>/*
 * Definitions for the virtual LDD bus.
 *
 * $Id: lddbus.h,v 1.4 2004/08/20 18:49:44 corbet Exp $
 */

//extern struct device ldd_bus;
extern struct bus_type ldd_bus_type;


/*
 * The LDD driver type.
 */

struct ldd_driver {
	char *version;
	struct module *module;
	struct device_driver driver;
	struct driver_attribute version_attr;
};

#define to_ldd_driver(drv) container_of(drv, struct ldd_driver, driver);

/*
 * A device type for things "plugged" into the LDD bus.
 */

struct ldd_device {
	char *name;
	struct ldd_driver *driver;
	struct device dev;
};

#define to_ldd_device(dev) container_of(dev, struct ldd_device, dev);

extern int register_ldd_device(struct ldd_device *);
extern void unregister_ldd_device(struct ldd_device *);
extern int register_ldd_driver(struct ldd_driver *);
extern void unregister_ldd_driver(struct ldd_driver *);
			</text>
		</p>
		<p n="xlnx_drv_sbull_H">
			<text>
				<![CDATA[
/*
 * sbull.h -- definitions for the char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */


#include <linux/ioctl.h>

/* Multiqueue only works on 2.4 */
#ifdef SBULL_MULTIQUEUE
#    warning "Multiqueue only works on 2.4 kernels"
#endif

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SBULL_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "sbull: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */


#define SBULL_MAJOR 0       /* dynamic major by default */
#define SBULL_DEVS 2        /* two disks */
#define SBULL_RAHEAD 2      /* two sectors */
#define SBULL_SIZE 2048     /* two megs each */
#define SBULL_BLKSIZE 1024  /* 1k blocks */
#define SBULL_HARDSECT 512  /* 2.2 and 2.4 can used different values */

#define SBULLR_MAJOR 0      /* Dynamic major for raw device */
/*
 * The sbull device is removable: if it is left closed for more than
 * half a minute, it is removed. Thus use a usage count and a
 * kernel timer
 */

typedef struct Sbull_Dev {
   int size;
   int usage;
   struct timer_list timer;
   spinlock_t lock;
   u8 *data;
#ifdef SBULL_MULTIQUEUE
   request_queue_t *queue;
   int busy;
#endif
}              Sbull_Dev;
]]>
			</text>
		</p>
		<p n="xlnx_drv_scull_H">
			<text>
				<![CDATA[/*
 * scull.h -- definitions for the char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: scull.h,v 1.15 2004/11/04 17:51:18 rubini Exp $
 */

#ifndef _SCULL_H_
#define _SCULL_H_

#include <linux/ioctl.h> /* needed for the _IOW etc stuff used later */

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULL_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scull: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#ifndef SCULL_MAJOR
#define SCULL_MAJOR 0   /* dynamic major by default */
#endif

#ifndef SCULL_NR_DEVS
#define SCULL_NR_DEVS 4    /* scull0 through scull3 */
#endif

#ifndef SCULL_P_NR_DEVS
#define SCULL_P_NR_DEVS 4  /* scullpipe0 through scullpipe3 */
#endif

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scull_dev->data" points to an array of pointers, each
 * pointer refers to a memory area of SCULL_QUANTUM bytes.
 *
 * The array (quantum-set) is SCULL_QSET long.
 */
#ifndef SCULL_QUANTUM
#define SCULL_QUANTUM 4000
#endif

#ifndef SCULL_QSET
#define SCULL_QSET    1000
#endif

/*
 * The pipe device is a simple circular buffer. Here its default size
 */
#ifndef SCULL_P_BUFFER
#define SCULL_P_BUFFER 4000
#endif

/*
 * Representation of scull quantum sets.
 */
struct scull_qset {
	void **data;
	struct scull_qset *next;
};

struct scull_dev {
	struct scull_qset *data;  /* Pointer to first quantum set */
	int quantum;              /* the current quantum size */
	int qset;                 /* the current array size */
	unsigned long size;       /* amount of data stored here */
	unsigned int access_key;  /* used by sculluid and scullpriv */
	struct semaphore sem;     /* mutual exclusion semaphore     */
	struct cdev cdev;	  /* Char device structure		*/
};

/*
 * Split minors in two parts
 */
#define TYPE(minor)	(((minor) >> 4) & 0xf)	/* high nibble */
#define NUM(minor)	((minor) & 0xf)		/* low  nibble */


/*
 * The different configurable parameters
 */
extern int scull_major;     /* main.c */
extern int scull_nr_devs;
extern int scull_quantum;
extern int scull_qset;

extern int scull_p_buffer;	/* pipe.c */


/*
 * Prototypes for shared functions
 */

int     scull_p_init(dev_t dev);
void    scull_p_cleanup(void);
int     scull_access_init(dev_t dev);
void    scull_access_cleanup(void);

int     scull_trim(struct scull_dev *dev);

ssize_t scull_read(struct file *filp, char __user *buf, size_t count,
                   loff_t *f_pos);
ssize_t scull_write(struct file *filp, const char __user *buf, size_t count,
                    loff_t *f_pos);
loff_t  scull_llseek(struct file *filp, loff_t off, int whence);
int     scull_ioctl(struct inode *inode, struct file *filp,
                    unsigned int cmd, unsigned long arg);


/*
 * Ioctl definitions
 */

/* Use 'k' as magic number */
#define SCULL_IOC_MAGIC  'k'
/* Please use a different 8-bit number in your code */

#define SCULL_IOCRESET    _IO(SCULL_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly with the argument value
 * G means "Get": reply by setting through a pointer
 * Q means "Query": response is on the return value
 * X means "eXchange": switch G and S atomically
 * H means "sHift": switch T and Q atomically
 */
#define SCULL_IOCSQUANTUM _IOW(SCULL_IOC_MAGIC,  1, int)
#define SCULL_IOCSQSET    _IOW(SCULL_IOC_MAGIC,  2, int)
#define SCULL_IOCTQUANTUM _IO(SCULL_IOC_MAGIC,   3)
#define SCULL_IOCTQSET    _IO(SCULL_IOC_MAGIC,   4)
#define SCULL_IOCGQUANTUM _IOR(SCULL_IOC_MAGIC,  5, int)
#define SCULL_IOCGQSET    _IOR(SCULL_IOC_MAGIC,  6, int)
#define SCULL_IOCQQUANTUM _IO(SCULL_IOC_MAGIC,   7)
#define SCULL_IOCQQSET    _IO(SCULL_IOC_MAGIC,   8)
#define SCULL_IOCXQUANTUM _IOWR(SCULL_IOC_MAGIC, 9, int)
#define SCULL_IOCXQSET    _IOWR(SCULL_IOC_MAGIC,10, int)
#define SCULL_IOCHQUANTUM _IO(SCULL_IOC_MAGIC,  11)
#define SCULL_IOCHQSET    _IO(SCULL_IOC_MAGIC,  12)

/*
 * The other entities only have "Tell" and "Query", because they're
 * not printed in the book, and there's no need to have all six.
 * (The previous stuff was only there to show different ways to do it.
 */
#define SCULL_P_IOCTSIZE _IO(SCULL_IOC_MAGIC,   13)
#define SCULL_P_IOCQSIZE _IO(SCULL_IOC_MAGIC,   14)
/* ... more to come */

#define SCULL_IOC_MAXNR 14

#endif /* _SCULL_H_ */
]]>
			</text>
		</p>
		<p n="xlnx_drv_scullc_H">
			<text>
				<![CDATA[/* -*- C -*-
 * scullc.h -- definitions for the scullc char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLC_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scullc: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLC_MAJOR 0   /* dynamic major by default */

#define SCULLC_DEVS 4    /* scullc0 through scullc3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scullc_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLC_QSET long.
 */
#define SCULLC_QUANTUM  4000 /* use a quantum size like scull */
#define SCULLC_QSET     500

struct scullc_dev {
	void **data;
	struct scullc_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int quantum;              /* the current allocation size */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
};

extern struct scullc_dev *scullc_devices;

extern struct file_operations scullc_fops;

/*
 * The different configurable parameters
 */
extern int scullc_major;     /* main.c */
extern int scullc_devs;
extern int scullc_order;
extern int scullc_qset;

/*
 * Prototypes for shared functions
 */
int scullc_trim(struct scullc_dev *dev);
struct scullc_dev *scullc_follow(struct scullc_dev *dev, int n);


#ifdef SCULLC_DEBUG
#  define SCULLC_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLC_IOC_MAGIC  'K'

#define SCULLC_IOCRESET    _IO(SCULLC_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLC_IOCSQUANTUM _IOW(SCULLC_IOC_MAGIC,  1, int)
#define SCULLC_IOCTQUANTUM _IO(SCULLC_IOC_MAGIC,   2)
#define SCULLC_IOCGQUANTUM _IOR(SCULLC_IOC_MAGIC,  3, int)
#define SCULLC_IOCQQUANTUM _IO(SCULLC_IOC_MAGIC,   4)
#define SCULLC_IOCXQUANTUM _IOWR(SCULLC_IOC_MAGIC, 5, int)
#define SCULLC_IOCHQUANTUM _IO(SCULLC_IOC_MAGIC,   6)
#define SCULLC_IOCSQSET    _IOW(SCULLC_IOC_MAGIC,  7, int)
#define SCULLC_IOCTQSET    _IO(SCULLC_IOC_MAGIC,   8)
#define SCULLC_IOCGQSET    _IOR(SCULLC_IOC_MAGIC,  9, int)
#define SCULLC_IOCQQSET    _IO(SCULLC_IOC_MAGIC,  10)
#define SCULLC_IOCXQSET    _IOWR(SCULLC_IOC_MAGIC,11, int)
#define SCULLC_IOCHQSET    _IO(SCULLC_IOC_MAGIC,  12)

#define SCULLC_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_sculld_H">
			<text>
				<![CDATA[/* -*- C -*-
 * sculld.h -- definitions for the sculld char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include "../include/lddbus.h"

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLD_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "sculld: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLD_MAJOR 0   /* dynamic major by default */

#define SCULLD_DEVS 4    /* sculld0 through sculld3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "sculld_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLD_QSET long.
 */
#define SCULLD_ORDER    0 /* one page at a time */
#define SCULLD_QSET     500

struct sculld_dev {
	void **data;
	struct sculld_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int order;                /* the current allocation order */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
	char devname[20];
	struct ldd_device ldev;
};

extern struct sculld_dev *sculld_devices;

extern struct file_operations sculld_fops;

/*
 * The different configurable parameters
 */
extern int sculld_major;     /* main.c */
extern int sculld_devs;
extern int sculld_order;
extern int sculld_qset;

/*
 * Prototypes for shared functions
 */
int sculld_trim(struct sculld_dev *dev);
struct sculld_dev *sculld_follow(struct sculld_dev *dev, int n);


#ifdef SCULLD_DEBUG
#  define SCULLD_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLD_IOC_MAGIC  'K'

#define SCULLD_IOCRESET    _IO(SCULLD_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLD_IOCSORDER   _IOW(SCULLD_IOC_MAGIC,  1, int)
#define SCULLD_IOCTORDER   _IO(SCULLD_IOC_MAGIC,   2)
#define SCULLD_IOCGORDER   _IOR(SCULLD_IOC_MAGIC,  3, int)
#define SCULLD_IOCQORDER   _IO(SCULLD_IOC_MAGIC,   4)
#define SCULLD_IOCXORDER   _IOWR(SCULLD_IOC_MAGIC, 5, int)
#define SCULLD_IOCHORDER   _IO(SCULLD_IOC_MAGIC,   6)
#define SCULLD_IOCSQSET    _IOW(SCULLD_IOC_MAGIC,  7, int)
#define SCULLD_IOCTQSET    _IO(SCULLD_IOC_MAGIC,   8)
#define SCULLD_IOCGQSET    _IOR(SCULLD_IOC_MAGIC,  9, int)
#define SCULLD_IOCQQSET    _IO(SCULLD_IOC_MAGIC,  10)
#define SCULLD_IOCXQSET    _IOWR(SCULLD_IOC_MAGIC,11, int)
#define SCULLD_IOCHQSET    _IO(SCULLD_IOC_MAGIC,  12)

#define SCULLD_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_scullp_H">
			<text>
				<![CDATA[/* -*- C -*-
 * scullp.h -- definitions for the scullp char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLP_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scullp: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLP_MAJOR 0   /* dynamic major by default */

#define SCULLP_DEVS 4    /* scullp0 through scullp3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scullp_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLP_QSET long.
 */
#define SCULLP_ORDER    0 /* one page at a time */
#define SCULLP_QSET     500

struct scullp_dev {
	void **data;
	struct scullp_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int order;                /* the current allocation order */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
};

extern struct scullp_dev *scullp_devices;

extern struct file_operations scullp_fops;

/*
 * The different configurable parameters
 */
extern int scullp_major;     /* main.c */
extern int scullp_devs;
extern int scullp_order;
extern int scullp_qset;

/*
 * Prototypes for shared functions
 */
int scullp_trim(struct scullp_dev *dev);
struct scullp_dev *scullp_follow(struct scullp_dev *dev, int n);


#ifdef SCULLP_DEBUG
#  define SCULLP_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLP_IOC_MAGIC  'K'

#define SCULLP_IOCRESET    _IO(SCULLP_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLP_IOCSORDER   _IOW(SCULLP_IOC_MAGIC,  1, int)
#define SCULLP_IOCTORDER   _IO(SCULLP_IOC_MAGIC,   2)
#define SCULLP_IOCGORDER   _IOR(SCULLP_IOC_MAGIC,  3, int)
#define SCULLP_IOCQORDER   _IO(SCULLP_IOC_MAGIC,   4)
#define SCULLP_IOCXORDER   _IOWR(SCULLP_IOC_MAGIC, 5, int)
#define SCULLP_IOCHORDER   _IO(SCULLP_IOC_MAGIC,   6)
#define SCULLP_IOCSQSET    _IOW(SCULLP_IOC_MAGIC,  7, int)
#define SCULLP_IOCTQSET    _IO(SCULLP_IOC_MAGIC,   8)
#define SCULLP_IOCGQSET    _IOR(SCULLP_IOC_MAGIC,  9, int)
#define SCULLP_IOCQQSET    _IO(SCULLP_IOC_MAGIC,  10)
#define SCULLP_IOCXQSET    _IOWR(SCULLP_IOC_MAGIC,11, int)
#define SCULLP_IOCHQSET    _IO(SCULLP_IOC_MAGIC,  12)

#define SCULLP_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_scullv_H">
			<text>
				<![CDATA[/* -*- C -*-
 * scullv.h -- definitions for the scullv char module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

#include <linux/ioctl.h>
#include <linux/cdev.h>

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SCULLV_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "scullv: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */

#define SCULLV_MAJOR 0   /* dynamic major by default */

#define SCULLV_DEVS 4    /* scullv0 through scullv3 */

/*
 * The bare device is a variable-length region of memory.
 * Use a linked list of indirect blocks.
 *
 * "scullv_dev->data" points to an array of pointers, each
 * pointer refers to a memory page.
 *
 * The array (quantum-set) is SCULLV_QSET long.
 */
#define SCULLV_ORDER    4 /* 16 pages at a time */
#define SCULLV_QSET     500

struct scullv_dev {
	void **data;
	struct scullv_dev *next;  /* next listitem */
	int vmas;                 /* active mappings */
	int order;                /* the current allocation order */
	int qset;                 /* the current array size */
	size_t size;              /* 32-bit will suffice */
	struct semaphore sem;     /* Mutual exclusion */
	struct cdev cdev;
};

extern struct scullv_dev *scullv_devices;

extern struct file_operations scullv_fops;

/*
 * The different configurable parameters
 */
extern int scullv_major;     /* main.c */
extern int scullv_devs;
extern int scullv_order;
extern int scullv_qset;

/*
 * Prototypes for shared functions
 */
int scullv_trim(struct scullv_dev *dev);
struct scullv_dev *scullv_follow(struct scullv_dev *dev, int n);


#ifdef SCULLV_DEBUG
#  define SCULLV_USE_PROC
#endif

/*
 * Ioctl definitions
 */

/* Use 'K' as magic number */
#define SCULLV_IOC_MAGIC  'K'

#define SCULLV_IOCRESET    _IO(SCULLV_IOC_MAGIC, 0)

/*
 * S means "Set" through a ptr,
 * T means "Tell" directly
 * G means "Get" (to a pointed var)
 * Q means "Query", response is on the return value
 * X means "eXchange": G and S atomically
 * H means "sHift": T and Q atomically
 */
#define SCULLV_IOCSORDER   _IOW(SCULLV_IOC_MAGIC,  1, int)
#define SCULLV_IOCTORDER   _IO(SCULLV_IOC_MAGIC,   2)
#define SCULLV_IOCGORDER   _IOR(SCULLV_IOC_MAGIC,  3, int)
#define SCULLV_IOCQORDER   _IO(SCULLV_IOC_MAGIC,   4)
#define SCULLV_IOCXORDER   _IOWR(SCULLV_IOC_MAGIC, 5, int)
#define SCULLV_IOCHORDER   _IO(SCULLV_IOC_MAGIC,   6)
#define SCULLV_IOCSQSET    _IOW(SCULLV_IOC_MAGIC,  7, int)
#define SCULLV_IOCTQSET    _IO(SCULLV_IOC_MAGIC,   8)
#define SCULLV_IOCGQSET    _IOR(SCULLV_IOC_MAGIC,  9, int)
#define SCULLV_IOCQQSET    _IO(SCULLV_IOC_MAGIC,  10)
#define SCULLV_IOCXQSET    _IOWR(SCULLV_IOC_MAGIC,11, int)
#define SCULLV_IOCHQSET    _IO(SCULLV_IOC_MAGIC,  12)

#define SCULLV_IOC_MAXNR 12



]]>
			</text>
		</p>
		<p n="xlnx_drv_shortprint_H">
			<text>
				<![CDATA[/*
 * Useful info describing the parallel port device.
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 */

/*
 * Register offsets
 */
#define SP_DATA    0x00
#define SP_STATUS  0x01
#define SP_CONTROL 0x02
#define SP_NPORTS     3

/*
 * Status register bits.
 */
#define SP_SR_BUSY 	0x80
#define SP_SR_ACK	0x40
#define SP_SR_PAPER	0x20
#define SP_SR_ONLINE	0x10
#define SP_SR_ERR	0x08

/*
 * Control register.
 */
#define SP_CR_IRQ	0x10
#define SP_CR_SELECT	0x08
#define SP_CR_INIT	0x04
#define SP_CR_AUTOLF	0x02
#define SP_CR_STROBE	0x01

/*
 * Minimum space before waking up a writer.
 */
#define SP_MIN_SPACE	PAGE_SIZE/2
]]>
			</text>
		</p>
		<p n="xlnx_drv_snull_H">
			<text>
				<![CDATA[
/*
 * snull.h -- definitions for the network module
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 */

/*
 * Macros to help debugging
 */

#undef PDEBUG             /* undef it, just in case */
#ifdef SNULL_DEBUG
#  ifdef __KERNEL__
     /* This one if debugging is on, and kernel space */
#    define PDEBUG(fmt, args...) printk( KERN_DEBUG "snull: " fmt, ## args)
#  else
     /* This one for user space */
#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
#  endif
#else
#  define PDEBUG(fmt, args...) /* not debugging: nothing */
#endif

#undef PDEBUGG
#define PDEBUGG(fmt, args...) /* nothing: it's a placeholder */


/* These are the flags in the statusword */
#define SNULL_RX_INTR 0x0001
#define SNULL_TX_INTR 0x0002

/* Default timeout period */
#define SNULL_TIMEOUT 5   /* In jiffies */

extern struct net_device *snull_devs[];




]]>
			</text>
		</p>
		<p n="xlnx_drv_attribute_H">
			<text>
				<![CDATA[/****************************************** 

* File Name : attribute.h

* Creation Date : 22-09-2018

* Last Modified :

* Created By : Mihai Constantin constant.mihai@googlemail.com

* License : 

******************************************/

/**
 * Purpose
 */

#ifndef _PRETTY_ATTRIBUTE_H_
#define _PRETTY_ATTRIBUTE_H_

/**
 * ******************************************************
 * @brief 
 * ******************************************************
**/
#if __GNUC_  _ >= 3
# undef  inline
# define inline         inline __attribute_  _ ((always_inline))
# define __noinline     __attribute__ ((noinline))
# define __pure         __attribute__ ((pure))
# define __const        __attribute__ ((const))
# define __noreturn     __attribute__ ((noreturn))
# define __malloc       __attribute__ ((malloc))
# define __must_check   __attribute__ ((warn_unused_result))
# define __deprecated   __attribute__ ((deprecated))
# define __used         __attribute__ ((used))
# define __unused       __attribute__ ((unused))
# define __packed       __attribute__ ((packed))
# define __align(x)     __attribute__ ((aligned (x)))
# define __align_max    __attribute__ ((aligned))
# define likely(x)      __builtin_expect (!!(x), 1)
# define unlikely(x)    __builtin_expect (!!(x), 0)
#else
# define __noinline     /* no noinline */
# define __pure         /* no pure */
# define __const        /* no const */
# define __noreturn     /* no noreturn */
# define __malloc       /* no malloc */
# define __must_check   /* no warn_unused_result */
# define __deprecated   /* no deprecated */
# define __used         /* no used */
# define __unused       /* no unused */
# define __packed       /* no packed */
# define __align(x)     /* no aligned */
# define __align_max    /* no align_max */
# define likely(x)      (x)
# define unlikely(x)    (x)
#endif

#endif
]]>
			</text>
		</p>
	</language.aliases>
	<language.aliases n="language.java.aliases" version="1">
		<p n="xj_myjavach02">
			<text>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class myjavach02
{
	public static void main(String[] args)
	{
		JFrame frame =new JFrame("TESTmyJava");
		JFrame frame2 = new JFrame( "HelloJava2" );
		JFrame frame3 = new JFrame( "mYtESTJava3" );
		JLabel label = new JLabel("TESTmyJavaLabel!", JLabel.CENTER );
		label.setBounds(20,80,100,40);
		label.setText("LABEL");
		frame.getContentPane().add( label );
		frame.add(new TESTmyJavaComponent());
		frame.setSize(500,500);
		frame.setVisible(true);
		//
		
		frame2.add( new HelloComponent2("Hello Java!") );
		frame2.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame2.setSize( 300, 300 );
		frame2.setVisible( true );
		//
		frame3.add( new HelloComponent3("Javaframe3!") );
		frame3.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame3.setSize( 300, 300 );
		frame3.setVisible( true );
		//
		JFrame frame4 = new JFrame( "jframe4" );
		frame4.add( new HelloComponent4("TEST4!") );
		frame4.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame4.setSize( 600, 600 );
		frame4.setVisible( true );
		//
	}
}
class TESTmyJavaComponent extends JComponent
{
	public void paintComponent(java.awt.Graphics g)
	{
		g.drawString("TestMYjava",300,200);
	}
}

class HelloComponent2 extends JComponent
	implements MouseMotionListener
{
  String theMessage;
  int messageX = 125, messageY = 95; // Coordinates of the message

  public HelloComponent2( String message ) {
    theMessage = message;
    addMouseMotionListener(this);
  }

  public void paintComponent( Graphics g ) {
    g.drawString(theMessage, messageX, messageY);
  }

  public void mouseDragged(MouseEvent e) {
    // Save the mouse coordinates and paint the message.
    messageX = e.getX();
    messageY = e.getY();
    repaint();
  }

  public void mouseMoved(MouseEvent e) { }
}

class HelloComponent3 extends JComponent
	implements MouseMotionListener, ActionListener
{
  String theMessage;
  int messageX = 125, messageY = 95;  // Coordinates of the message

  JButton theButton;

  int colorIndex;  // Current index into someColors
  static Color[] someColors = {
	Color.black, Color.red, Color.green, Color.blue, Color.magenta };

  public HelloComponent3( String message ) {
    theMessage = message;
    theButton = new JButton("Change Color");
    setLayout( new FlowLayout() );
    add( theButton );
    theButton.addActionListener( this );
    addMouseMotionListener( this );
  }

  public void paintComponent( Graphics g ) {
    g.drawString(theMessage, messageX, messageY);
  }

  public void mouseDragged( MouseEvent e ) {
    messageX = e.getX();
    messageY = e.getY();
    repaint();
  }

  public void mouseMoved( MouseEvent e ) {}

  public void actionPerformed( ActionEvent e ) {
    // Did somebody push our button?
    if (e.getSource() == theButton)
      changeColor();
  }

  synchronized private void changeColor() {
    // Change the index to the next color, awkwardly.
    if (++colorIndex == someColors.length)
      colorIndex = 0;
    setForeground(currentColor(  )); // Use the new color.
    repaint(  ); // Paint again so we can see the change.
  }

  synchronized private Color currentColor() {
    return someColors[colorIndex];
  }
}

class HelloComponent4 extends JComponent
    implements MouseMotionListener, ActionListener, Runnable
{
  String theMessage;
  int messageX = 125, messageY = 95; // Coordinates of the message

  JButton theButton;

  int colorIndex; // Current index into someColors.
  static Color[] someColors = {
	Color.black, Color.red, Color.green, Color.blue, Color.magenta };

  boolean blinkState;

  public HelloComponent4( String message ) 
  {
    theMessage = message;
    theButton = new JButton("Change Color");
    setLayout( new FlowLayout() );
    add( theButton );
    theButton.addActionListener( this );
    addMouseMotionListener( this );
    Thread t = new Thread( this );
    t.start();
  }

  public void paintComponent( Graphics g ) {
    g.setColor(blinkState ? getBackground() : currentColor(  ));
    g.drawString(theMessage, messageX, messageY);
  }

  public void mouseDragged(MouseEvent e) {
    messageX = e.getX();
    messageY = e.getY();
    repaint();
  }

  public void mouseMoved(MouseEvent e) { }

  public void actionPerformed( ActionEvent e ) {
    if ( e.getSource() == theButton )
      changeColor();
  }

  synchronized private void changeColor() {
    if (++colorIndex == someColors.length)
      colorIndex = 0;
    setForeground( currentColor() );
    repaint();
  }

  synchronized private Color currentColor(  ) {
    return someColors[colorIndex];
  }

  public void run(  ) {
    try {
      while(true) {
        blinkState = !blinkState; // Toggle blinkState.
        repaint(); // Show the change.
        Thread.sleep(300);
      }
    } catch (InterruptedException ie) { }
  }
}
			</text>
		</p>
		<p n="xj_socket">
			<text>import java.net.*;

public class seprj {
	public static void main(String args[]) throws Exception
	{
		try 
		{
			Socket s = new Socket("192.168.1.102", 80);
			System.out.println("Connected!");
		}
		catch (SecurityException e) 
		{
		  System.out.println("SecurityException: could not connect.");
		}
	}
}
			</text>
		</p>
		<p n="xj_genericreflect">
			<text>
				<![CDATA[import java.util.*;
import java.util.HashMap; 
import java.lang.reflect.*;
//import java.awt.*;
import java.awt.event.*;
import javax.swing.*;


class Sheep implements Cloneable { 
    HashMap flock = new HashMap( ); 
 
    public Sheep clone( ) { 
        try { 
            return (Sheep)super.clone( ); 
        } catch (CloneNotSupportedException e ) {  
            throw new Error("This should never happen!"); 
        } 
    } 
}

class TESTmyJavaComponent extends JComponent
{
	public void paintComponent(java.awt.Graphics g)
	{
		g.drawString("TestMYjava",300,200);
	}
}


public class seprj 
{
	public static void mymethod()
	{
		//int i=0;
		JFrame frame =new JFrame("TESTmymethod");
		JLabel label = new JLabel("TESTmyJavaLabel!", JLabel.CENTER );
		label.setBounds(20,80,100,40);
		label.setText("LABEL");
		frame.getContentPane().add( label );
		frame.add(new TESTmyJavaComponent());
		frame.setSize(500,500);
		frame.setVisible(true);
		//return 0;
	}
	public static void main(String args[]) 
	{
		TypeVariable []	tv = List.class.getTypeParameters();
		System.out.println( tv[0].getName() ); // E

		class StringList extends ArrayList<String> { }

		Type type = StringList.class.getGenericSuperclass();
		System.out.println( type );  //java.util.ArrayList<java.lang.String>
		ParameterizedType pt = (ParameterizedType)type;
		System.out.println( pt.getActualTypeArguments()[0] );
		System.out.println("\n"+args[0]);
		System.out.println("\n" + args[1]);
		try
		{

		  Class c = Class.forName( args[0] );
		  Method m = c.getMethod( args[1] );
		  //Object arg=null;
		  //Object ret =  m.invoke( new seprj(),arg);
		  //Object ret =  m.invoke( new seprj(),args);
		  Object ret =  m.invoke( null);
		  System.out.println("\n"+args[0]);
		  System.out.println("\n"+args[1]);
		  System.out.println(
			  "Invoked static method: " + args[1]
			  + " of class: " + args[0]
			  + " with no args\nResults: ");
		}
		catch ( ClassNotFoundException e )
		{
			System.out.println( e );
		  // Class.forName(  ) can't find the class
		}
		catch ( NoSuchMethodException e2 )
		{
			System.out.println("\nTEST\n");
			System.out.println( e2 );
		  // that method doesn't exist
		}
		catch ( IllegalAccessException e3 )
		{
			System.out.println( e3 );
		  // we don't have permission to invoke that method
		}
		catch ( InvocationTargetException e )
		{
			System.out.println( e );
			// an exception ocurred while invoking that method
			System.out.println("Method threw an: " + e.getTargetException(  ) );
		}
		Sheep one = new Sheep();
		Sheep two = one.clone();
	}
	
}

]]>
			</text>
		</p>
		<p n="xj_reflect">
			<text>import java.util.*;
import java.lang.reflect.*;

public class Reflect 
{

	public static void main( String [] args )throws Exception
	{
		Method method = Object.class.getDeclaredMethod( "clone" );
		System.out.println( Modifier.isProtected(method.getModifiers()) );
	}

}
			</text>
		</p>
		<p n="xj_typeinference">
			<text>
				<![CDATA[class Base { }
class Sub1 extends Base implements Runnable { public void run() { } }
class Sub2 extends Base implements Runnable { public void run() { } }

public class TypeInference 
{
	static <T extends Base> T infer( T t1, T t2 ) { return null; }

	public static void main( String [] args )
	{
		Base base = infer( new Sub1(), new Sub2() );
		// Note: Eclipse 3.1 says this is an error, but it's not
		Runnable runnable = infer( new Sub1(), new Sub2() );
	}

}
]]>
			</text>
		</p>
		<p n="xj_variant">
			<text>import java.util.*;

public class Variant 
{
	Object get() { return null; }
}

class Variant2 extends Variant
{
	Date get() { return (Date)super.get(); }
}

class Variant3 {
	public static void main(String [] args) {
		Date d = new Variant2().get();
	}
}
			</text>
		</p>
		<p n="xj_weekday">
			<text>
public enum Weekday {

    Sunday(8), Monday(0), Tuesday(1), Wednesday(2), Thursday(4), 
      Friday(6), Saturday(10) { };

	enum Sub { A, B }
	
    int fun;

    Weekday( int fun ) { this.fun = fun; }

    public int getFun() { return fun; }

}

			</text>
		</p>
		<p n="xj_cast2">
			<text>
				<![CDATA[import java.util.*;

interface A { static int FOO=1; String getFoo(); }
interface B { static int FOO=2; Date getDoo(); }

public class Cast2<T extends A & B>
{
	public void foo( T t )
	{
		System.out.println( t.FOO );
	}

}
]]>
			</text>
		</p>
		<p n="xj_type1">
			<text>
				<![CDATA[import java.util.*;

public class Type1<T>
{
	static T t;

	public static void main( String [] args )
	{
	}

}
]]>
			</text>
		</p>
		<p n="xj_typeinference2">
			<text>
				<![CDATA[//package .export.home.space.pat.lj5.generics;
/** @author Pat Niemeyer (pat@pat.net) */
import java.util.*;

public class TypeInference2
{
	static <T> T infer( T t1, T t2 ) { return null; }

	public static void main( String [] args )
	{
		infer( "foo", new Date() );
	}

}
]]>
			</text>
		</p>
		<p n="xj_a">
			<text>
				<![CDATA[import java.util.*;

class DateList extends ArrayList<Date> { }

class A {
	//ok public <T,S extends T> void foo( T t, S s ) { }
	//illegal forward ref public <S extends T, T> void foo( T t, S s ) { }
	//no public void foo( ? extends Date s ) { }
	//no public void foo( <? extends Date> s ) { }
	//no public void foo( <?> s ) { }


	//<T> T writeAll(Collection<T> coll, Collection<? super T> snk) { return null; }
	//<T, S extends T> S writeAll(Collection<T> coll, Collection<S> snk) { return null; }

	// generic method 
	<T> void take( T t ) { }

	void foo() {
		// for public <T,S extends T> T foo( S arg ) { return arg; }
		//ok Date date = foo( new MyDate() );
		//ok Date date = foo( new Date() );
		//no MyDate myDate = foo( new Date() );
		//ok MyDate myDate = foo( new MyDate() );

		//Set<?> s = new HashSet();
		//s.put("foo");
		//s.put(new Date());

		//Collection<?> [] ca = new Collection<?> [5];

		//List<? extends Date> list = new ArrayList<Date>(); // ok
		//new ArrayList<? extends Date>(); // error
		//List<Date>[] ldates = new List<Date>[5]; // error, array creation

		// List<?> list = new ArrayList<?>(); // err

		// can't use generic in instanceof
		// boolean b = null instanceof List<String>;
		
		//<String>take( "foo" ); // old syntax in spec doesn't work, no
		//explicit generic method types
			
		//List<Date> dl = new DateList();
		//List l = new ArrayList(); //ok
		//l.add("foo"); // warn

		//new ArrayHolder<List<Date>>();
		//ArrayHolder<?> ah = new ArrayHolder<?>();
		//ah.take( new ArrayList<?> [5] ); //err

		// List<?>[] la = new ArrayList<?>[10]; // ok
		// List<?>[] la = new ArrayList<? extends Date>[10]; // err

		//List<Object> lo = new ArrayList<Object>();
		//List<? extends Date> ld = new ArrayList<Date>();

		List l = new ArrayList();
		List<Date> ldfo = (List<Date>)l; // unchecked warning, ineffective
		Date d = ldfo.get(0); // unsafe at runtime


		//List<?> lany = new ArrayList<Date>();
		//lany.put( new Object() );
		//String s = (String)lany.get(0);

		//List<Date> ld = (List<Date>)lany; ok

		//Collection<Integer> ci = new ArrayList<Integer>();
		//List<Integer> li = new ArrayList<Integer>();
		//ci = li;
		
		//Collection<Object> co = new ArrayList<Object>();
		//Collection<Integer> ci = new ArrayList<Integer>();
		//co=(Collection<Object>)ci; //err
	}

	//void throwme() throws Exception<E> { } err

	static <T extends Comparable> T compare( T t1, T t2 ) { return null; }

	void bar() { 
		int i = compare( 1, 2 );
	}

}

	
class ArrayHolder<T> {
	T[] ta;
	void take( T [] ta ) { 
		this.ta = ta;
	}
}

/*
class B<?>//no {
	//public <T> T foo() { return null; }
}

*/
]]>
			</text>
		</p>
		<p n="xj_ar">
			<text>
				<![CDATA[import java.util.*;

public class AR 
{
	public static void main( String [] args )
	{
		List<Date> [] la = new ArrayList[5]; // unchecked warning





		List<Date> ld = la[0];
		
	}

}
]]>
			</text>
		</p>
		<p n="xj_arrays">
			<text>
				<![CDATA[//package bsh.util;
/** @author Pat Niemeyer (pat@pat.net) */
import java.util.*;

public class Arrays 
{
	public static void main( String [] args )
	{
		// List<?>[] la = new ArrayList<?>[10]; // ok
		// List<?>[] la = new ArrayList<? extends Date>[10]; // err

		//List<? extends Date>[] la = new ArrayList[5];
		//Date d = la[0].get(0);

		List<Date>[] lda = new ArrayList[5];
		Object [] foo = lda;
		foo[0] = "foo";
		List<Date> ld = lda[0];

	}

}
]]>
			</text>
		</p>
		<p n="xj_b">
			<text>
				<![CDATA[import java.util.*;

/*
	When subclassing in Java the best we 
*/
/*
	Start with extending an arbitrary type

	go through subclassing exercise
class B <E extends Date> 
{
	void take( E element ) { }

}

// this is ok, but unchecked warnings on all methods
//class C extends B { }
// when extending must limit the bounds again, else compiler warning that E is
// not within its bounds
class C<E extends Date> extends B<E> { }

class Main {
	public static void main( String[] args ) 
	{
		System.out.println("main");

		// unchecked warning
		// new C().take( new Date() );
		new C<Date>().take( new Date() );

		// a B<Date> is a B
		System.out.println( new B<Date>() instanceof B ); // true
		System.out.println( new B<Date>() instanceof B<Date> ); // error

		System.out.println("done");
	}
}

*/

/*
	Now have it extend itself

class B <E extends B> 
{
	void take( E element ) { }

}

class C<E extends B> extends B<E> { }

class Main {
	public static void main( String[] args ) 
	{
		System.out.println("main");

		// plain extends B all ok
		new B<B>();
		// here's the problem, any B works
		// A B<anything> is a still a B
		new B<B>().take( new B() ); 
		new B<B>().take( new B<B>() );
		new C<B>().take( new C<B>() );
		new C<B>().take( new B<B>() );
		new C<C>().take( new C<C>() );


		System.out.println("done");
	}
}

*/

/*
	Now try to limit param type to a specific paramaterization of B
*/
class B <E extends B<E>> 
{
	void take( E element ) { }

}

class C<E extends C<E>> extends B<E> { }

class Main {
	public static void main( String[] args ) 
	{
		System.out.println("main");

		//new C<C>(); // no
		//new C<B>();
		//new B<B>();

		System.out.println("done");
	}
}
]]>
			</text>
		</p>
		<p n="xj_bounds1">
			<text>
				<![CDATA[import java.util.*;


public class Bounds1 < T extends java.io.Serializable & Runnable >
{
	Runnable r;

	public void take( T t ) { 
		this.r = t;
	}

	public T get() { return null; }
}
/*

class MyDate extends Date { }

class Main {

	public static void main( String [] args ) 
	{
		Bounds1<MyDate> bd = new Bounds1<MyDate>();
		bd.take( new MyDate() );
		MyDate md = bd.get();
	}
}
*/
]]>
			</text>
		</p>
		<p n="xj_c">
			<text>
				<![CDATA[import java.util.*;

/*
public class C<E extends C<E>> 
{
	void take( E element ) { }
}
*/

//class D extends C<D> { }
//class D<E> extends C<D<E>> { }

class Main {
	public static void main( String [] args ) {
		enum Foo { A, B }

	}
}
]]>
			</text>
		</p>
		<p n="xj_cat">
			<text>
enum Cat { Persian, Himalayan, ShortHair };
			</text>
		</p>
		<p n="xj_df">
			<text>import java.util.*;

public class DF 
{
	private int x=5;
	public int y =6;

	public static void main( String [] args )
	{
	}

}
			</text>
		</p>
		<p n="xj_e">
			<text>
				<![CDATA[
public class E< T extends Throwable >
{
	void test( Class<T> type ) throws T { 
		throw type.newInstance();
	}

	static void foo() {
		new E<ClassNotFoundException>().test( Exception.class );
	}
}
]]>
			</text>
		</p>
		<p n="xj_e3">
			<text>import java.util.*;
import static java.util.concurrent.TimeUnit.*;

public class E3 
{

	public static void main( String [] args ) throws Exception
	{
		SECONDS.sleep(3);
	}

}
			</text>
		</p>
		<p n="xj_enumexample">
			<text>
import java.util.*;

public class EnumExample
{
	public static void main( String [] args )
	{
		System.out.println( Cat.values());
		System.out.println( Cat.Persian.ordinal() ); // 0
		System.out.println( Cat.Himalayan.ordinal() ); // 1

		System.out.println( Cat.Persian.compareTo( Cat.ShortHair ) ); // -2
		System.out.println( Cat.Persian.compareTo( Cat.Himalayan) ); // -1
		System.out.println( Cat.ShortHair.compareTo( Cat.Persian ) ); // 2
		//System.out.println( Cat.Persian.compareTo("foo") );  // no!


		// to string and back within type
		System.out.println( Cat.Persian.name() ); // "Persian"
		System.out.println( Cat.Persian ); // "Persian"
		Cat cat = Enum.valueOf( Cat.class, "Persian" );
		System.out.println( "class = "+cat );

		System.out.println( Cat.Persian.getDeclaringClass() );  // Cat

		Weekdays.Saturday.foo();

		switch ( cat ) {
			case Persian: System.out.println("here");
		}

		//Cat cat = Cat.Simon;
		//System.out.println( Cat.Simon.getClass() );
		//new HashMap().put( Cat.Simon, "foo" );

	}

	private static void print( Object o ) { System.out.println(o); }
	private static void print( long o ) { System.out.println(o); }
	private static void print( double o ) { System.out.println(o); }
	private static long time() { return System.currentTimeMillis(); }
}
			</text>
		</p>
		<p n="xj_GenericMethods">
			<text>
				<![CDATA[import java.util.*;

public class GenericMethods
{

	static <A,B> A doit( B b ) { return null; }


	public static void main( String [] args ) 
	{
		String s = doit( 42 );
	}

}
]]>
			</text>
		</p>
		<p n="xj_GenericMethod2">
			<text>
				<![CDATA[import java.util.*;

public class GenericMethods2 
{
	/*
	static <T> List<T> arrayToList( Object [] oa ) {
		List<T> lt = new ArrayList<T>();
		for( Object o : oa )
			lt.add( o );
		return lt;
	}
	*/

	static <T> T foo() { }

	public static void main( String [] args )
	{
	}

}
]]>
			</text>
		</p>
		<p n="xj_genericMethod3">
			<text>
				<![CDATA[import java.util.*;

public class GenericMethods3 
{
	/*
	no...
	static <T> List<T> arrayToList( Object [] oa ) {
		List<T> lt = new ArrayList<T>();
		for( Object o : oa )
			lt.add( o );
		return lt;
	}
	*/

	static <T> T foo() 
	{ 
		Number num = new Integer(42);
		T t = num;
		return t ;
	}

	public static void main( String [] args )
	{
		Number n = foo();
	}

}
]]>
			</text>
		</p>
		<p n="xj_GM">
			<text>
				<![CDATA[import java.util.*;

public class GM 
{
	static void foo( List<String> ls ) { }
	static <T> void bar( T t ) { }

	public static void main( String [] args )
	{
		foo( new ArrayList<String>() );
		bar( new ArrayList<String>() );
	}

}
]]>
			</text>
		</p>
		<p n="xj_lower">
			<text>
				<![CDATA[import java.util.*;

class MyDate extends Date { }

public class Lower 
{

	public static void main( String [] args )
	{
		List< ? extends Date super MyDate > lsd = new ArrayList<Date>();
		//lsd.add( new Date() );
		lsd.add( new MyDate() );
		Object o = lsd.get( 0 );

	}

}
]]>
			</text>
		</p>
		<p n="xj_M">
			<text>
				<![CDATA[
interface Foo {
	public static int FOO = 1;
}

public class M< T extends Foo >
{
	public void main( String [] args )
	{
		int i = T.FOO;
	}

}
]]>
			</text>
		</p>
		<p n="xj_mathutils">
			<text>
				<![CDATA[import java.util.*;

public class MathUtils {

    public static <T> T max( T x, T y ) { 
		if ( x > y )
			return x;
		else
			return y;
	}    

	public static void main( String [] args )
	{
		Long l = MathUtils.<Long>max( 42L, 42L );
	}

}
]]>
			</text>
		</p>
		<p n="xj_operation">
			<text>
public enum Operation {
  PLUS   { double eval(double x, double y) { return x + y; } },
  MINUS  { double eval(double x, double y) { return x - y; } },
  TIMES  { double eval(double x, double y) { return x * y; } },
  DIVIDE { double eval(double x, double y) { return x / y; } };

  // Do arithmetic op represented by this constant
  abstract double eval(double x, double y);
}

			</text>
		</p>
		<p n="xj_q">
			<text>
public final class Q 
{
	public static final int A=1;
	public static final int B=2;
}
			</text>
		</p>
		<p n="xj_q2">
			<text>
				<![CDATA[import java.util.*;

public class Q2 
{
	public static void main( String [] args )
	{
		new Q1<Date>();
	}

}
]]>
			</text>
		</p>
		<p n="xj_raw">
			<text>import java.util.*;

public class Raw 
{

	@SuppressWarnings(value={"unchecked"})
	public static void main( String [] args )
	{
		List list = new ArrayList();
		list.add("foo");
	}

}
			</text>
		</p>
		<p n="xj_rt">
			<text>
				<![CDATA[import java.util.*;

public class RT 
{
	List<? extends Date> foo() { return new ArrayList<Date>(); }

}
]]>
			</text>
		</p>
		<p n="xj_sc">
			<text>import java.util.*;

public class SC 
{

	public static void main( String [] args ) throws Exception
	{
		String s = String.class.newInstance();
	}

}
			</text>
		</p>
		<p n="xj_staticimport">
			<text>import java.util.*;
import Q;
import static Q.*;

public class StaticImport 
{

	public static void main( String [] args )
	{
		System.out.println( Q.class );
	}

}
			</text>
		</p>
		<p n="xj_swap">
			<text>
				<![CDATA[import java.util.*;

public class Swap
{
	List<?> swap( List<?> list ) {
		return swap( list );
	}

	<T> List<T> swap( List<T> list ) {
		T tmp = list.get( 0 );
		list.set( 0, list.get(1) );
		list.set( 1, tmp );
		return list;
	}

	public static void main( String [] args )
	{
	}

}
]]>
			</text>
		</p>
		<p n="xj_t">
			<text>
				<![CDATA[import java.util.*;

public class T1 < 
{
	private static void print( Object o ) { System.out.println(o); }
	private static void print( long o ) { System.out.println(o); }
	private static void print( double o ) { System.out.println(o); }
	private static long time() { return System.currentTimeMillis(); }

	public static void main( String [] args )
	{
	}

}
]]>
			</text>
		</p>
		<p n="xj_t1">
			<text>
				<![CDATA[import java.util.*;
public class T1<T extends Date>
{
	
	List<? extends Date & Runnable> l1;

}
]]>
			</text>
		</p>
		<p n="xj_t2">
			<text>
				<![CDATA[class T2<K,V> { } 
class T3<K,V> extends T2<K,V> { void foo() { } }
class T4<K,V> extends T2<K,V> { void foo() { } }
class T5<K,V> extends T3<K,V> { }

class Main  {
	void foo() {
		T2<String, Number> t2 = null;
		T3 t3 = (T3<String, Number>)t2;
	}
}
]]>
			</text>
		</p>
		<p n="xj_t3">
			<text>
				<![CDATA[public class T3 
{
	<?> void foo( T t ) { }

	public static void main( String [] args )
	{
	}

}
]]>
			</text>
		</p>
		<p n="xj_assert">
			<text>
/**
*/
public class Test 
{
	public static void main( String [] args )
	{
		assert true;
	}

}
			</text>
		</p>
		<p n="xj_unbounded">
			<text>
				<![CDATA[
import java.util.*;
/** @author Pat Niemeyer (pat@pat.net) */

public class Unbounded 
{
	void hasNulls( Collection<?> c ) {
		for( Object o : c ) { }
	}

	void foo() {
		hasNulls( new ArrayList<String>() );
	}

}
]]>
			</text>
		</p>
		<p n="xj_a2">
			<text>
				<![CDATA[import java.util.*;

public class A<E extends Date>
{
	E get() { return null; }
}

class B 
{ 
	<T extends Date> void take( T date ) { }

	void go() 
	{
		A<String> a = new A<String>();
		String s = a.get();
		//List<?> wordlist = new ArrayList<?>();
		Vector [] v = new Vector<?>[10];
	}
}
]]>
			</text>
		</p>
		<p n="xj_array2">
			<text>
				<![CDATA[import java.util.*;

/**
	
	@author Pat Niemeyer (pat@pat.net)
*/
public class Arrays 
{
	public static void main( String [] args )
	{
		List<?>[] lsa = new ArrayList[10];
	}

}
]]>
			</text>
		</p>
		<p n="xj_b2">
			<text>
				<![CDATA[import java.util.*;
/**
	
	@author Pat Niemeyer (pat@pat.net)
*/
public class B 
{
	public static void main( String [] args )
	{
		List<E extends Date> dl = new ArrayList<E extends Date>();
	}

}
]]>
			</text>
		</p>
		<p n="xj_bound2">
			<text>
				<![CDATA[import java.util.*;

interface Foo {
	public int X=42;
	void foo();
}
interface Bar {
	public int X=43;
	void bar();
}
/**
	
	@author Pat Niemeyer (pat@pat.net)
*/
public class Bounds<E extends Runnable & Foo & Bar>
{
	void go(E e) {
		int i = e.X;
	}

	public static void main( String [] args )
	{
	}

}
]]>
			</text>
		</p>
		<p n="xj_c2">
			<text>import java.util.*;

public class C 
{
	void printCollection( Collection c ) {
		for( Object e: c )
			System.out.println(e);
	}

}
			</text>
		</p>
		<p n="xj_classtest">
			<text>
				<![CDATA[
import java.util.*;
/**
	
	@author Pat Niemeyer (pat@pat.net)
*/
public class ClassTest 
{
	public static void main( String [] args )
	{
		Class<String> cs = String.class;
		// error
		//Class<String> cs2 = Integer.class;
		Map<String,String> ms;
	}

	private static void print( Object o ) { System.out.println(o); }
	private static void print( long o ) { System.out.println(o); }
	private static void print( double o ) { System.out.println(o); }
	private static long time() { return System.currentTimeMillis(); }
}
]]>
			</text>
		</p>
		<p n="xj_extending">
			<text>
				<![CDATA[import java.util.*;

/**
	
	@author Pat Niemeyer (pat@pat.net)
*/
interface Extending extends List<String>
{

}

interface ThreadList extends List<Thread>
{
}

class A {
	void go() { 
		ThreadList tl = null;
		Thread t = tl.get(1);
	}
}
]]>
			</text>
		</p>
		<p n="xj_generics1">
			<text>
				<![CDATA[/**
	
	@author Pat Niemeyer (pat@pat.net)
*/
import java.util.*;

public class Generics1 
{
	public static void main( String [] args )
	{
		ArrayList<String> als = new ArrayList();
	}

}
]]>
			</text>
		</p>
		<p n="xj_mixed">
			<text>
				<![CDATA[import java.util.*;

/**
	
	@author Pat Niemeyer (pat@pat.net)
*/
public class Mixed
{
	public static void main( String [] args )
	{
		Map m = new HashMap();
		Map m2 = new HashMap<String,String>();
		Map<String,String> ms = new HashMap<String,String>();

		//unchecked warning
		// why? obviously compiler knows the var type and can enforce, but it
		// can't guarantee safety of unchecked map assigned to it...
		//Map<String,String> ms2 = new HashMap();
	}

	private static void print( Object o ) { System.out.println(o); }
	private static void print( long o ) { System.out.println(o); }
	private static void print( double o ) { System.out.println(o); }
	private static long time() { return System.currentTimeMillis(); }
}
]]>
			</text>
		</p>
		<p n="xj_parammethod">
			<text>
				<![CDATA[import java.util.*;

public class ParamMethod
{
	<T,U extends T> void add2(List<T> to, List<U> from) {
	  //for (Iterator<U extends T> i = from.iterator(); i.hasNext(); )
	      //to.add(i.next());
	}

	<T,U,V> void tuv() { }
	<T,U super T,V> void tuv2() { }
}

]]>
			</text>
		</p>
		<p n="xj_clock">
			<text>//file: Clock.java
public class Clock extends UpdateApplet {
    public void paint( java.awt.Graphics graphics ) {
        graphics.drawString( new java.util.Date().toString(), 10, 25 );
    }
}
			</text>
		</p>
		<p n="xj_consumer">
			<text>//file: Consumer.java
import java.util.Vector;

public class Consumer implements Runnable 
{
    Producer producer;

    Consumer( Producer producer ) {
        this.producer = producer;
    }

    public void run() {
        while ( true ) {
            String message = producer.getMessage();
            System.out.println("Got message: " + message);
			try { 
				Thread.sleep( 2000 ); 
			} catch ( InterruptedException e ) { }
        }
    }

    public static void main(String args[]) {
        Producer producer = new Producer();
        new Thread( producer ).start();
        Consumer consumer = new Consumer( producer );
        new Thread( consumer ).start();
    }
}
			</text>
		</p>
		<p n="xj_executorhttpd">
			<text>
				<![CDATA[import java.net.*;
import java.io.*;
import java.util.regex.*;
import java.util.concurrent.*;

public class ExecutorHttpd 
{
  ExecutorService executor = Executors.newFixedThreadPool(3);

  public void start( int port ) throws IOException
  {
    final ServerSocket ss = new ServerSocket( port );
    while ( !executor.isShutdown() )
      executor.submit( new TinyHttpdConnection( ss.accept() ) );
  }

  public void shutdown() throws InterruptedException {
    executor.shutdown();
    executor.awaitTermination( 30, TimeUnit.SECONDS );
    executor.shutdownNow();
  }

  public static void main( String argv[] ) throws Exception 
  {
    new ExecutorHttpd().start( Integer.parseInt(argv[0]) );
  }
}

/*
  This class is copied from the TinyHttpd example in Chapter 13.
class TinyHttpdConnection implements Runnable {
  Socket client;
  TinyHttpdConnection ( Socket client ) throws SocketException {
    this.client = client;
  }
  public void run() {
    try {
      BufferedReader in = new BufferedReader(
        new InputStreamReader(client.getInputStream(), "8859_1" ) );
      OutputStream out = client.getOutputStream();
      PrintWriter pout = new PrintWriter(
        new OutputStreamWriter(out, "8859_1"), true );
      String request = in.readLine();
      System.out.println( "Request: "+request);

    Matcher get = Pattern.compile("GET /?(\\S*).*").matcher( request );
    if ( get.matches() ) {
    request = get.group(1);
        if ( request.endsWith("/") || request.equals("") )
          request = request + "index.html";
        try {
          FileInputStream fis = new FileInputStream ( request );
          byte [] data = new byte [ 64*1024 ];
      for(int read; (read = fis.read( data )) > -1; )
        out.write( data, 0, read );
          out.flush();
        } catch ( FileNotFoundException e ) {
          pout.println( "404 Object Not Found" ); }
      } else
        pout.println( "400 Bad Request" );
      client.close();
    } catch ( IOException e ) {
      System.out.println( "I/O error " + e ); }
  }
}
*/

]]>
			</text>
		</p>
		<p n="xj_mandelbrot">
			<text>
				<![CDATA[import java.awt.*;
import javax.swing.*;
import java.awt.image.*;
import java.util.concurrent.*;

public class Mandelbrot extends JFrame
{
    @Override public void paint( Graphics g ) {
        BufferedImage image = new BufferedImage( getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB );
        ForkJoinPool pool = new ForkJoinPool(); // defaults thread per processor
        pool.invoke( new MandelbrotTask( image, 0, image.getWidth()-1, 0, image.getHeight()-1 ) );
        g.drawImage( image, 0, 0, null );
    }

    public static void main( String[] args ) {
        Mandelbrot mandy = new Mandelbrot();
        mandy.setSize( 768, 768 );
        mandy.setVisible( true );
    }
}

class MandelbrotTask extends RecursiveAction
{
    private static double size = 3.0, offsetX = -0.7, thresholdSq = 100;
    private static int maxIterations = 30;
    private BufferedImage image;
    private int xStart, xEnd, yStart, yEnd;
    private static int taskSplitThreshold = 1024;

    MandelbrotTask( BufferedImage image, int xStart, int xEnd, int yStart, int yEnd ) {
        this.image = image;
        this.xStart = xStart; this.xEnd = xEnd; this.yStart = yStart; this.yEnd = yEnd;
    }

    public void renderFull()
    {
        for ( int x = xStart; x <= xEnd; x++ ) {
            for ( int y = yStart; y <= yEnd; y++ )  {
                double r = x * size / image.getWidth() -size/2 + offsetX;
                double i = y * size / image.getHeight() -size/2;
                double zr=0, zi=0;
                int iter;
                for ( iter = 0; iter < maxIterations; iter++ ) {
                    double nzr = zr*zr - zi*zi + r;
                    double nzi = 2*zr*zi + i;
                    if ( nzr*nzr + nzi*nzi > thresholdSq ) { break; }
                    zr = nzr; zi=nzi;
                }
                image.setRGB( x, y, Color.HSBtoRGB( 0.5f * iter / maxIterations, 1.0f, 1.0f) );
            }
        }
    }

    @Override protected void compute()
    {
        int width = xEnd-xStart,  height = yEnd-yStart;
        if ( width*height < taskSplitThreshold ) {
            renderFull();
        } else {
            invokeAll(
                new MandelbrotTask( image, xStart, xStart+width/2, yStart, yStart+height/2 ),
                new MandelbrotTask( image, xStart+width/2+1, xEnd, yStart, yStart+height/2 ),
                new MandelbrotTask( image, xStart, xStart+width/2, yStart+height/2+1, yEnd ),
                new MandelbrotTask( image, xStart+width/2+1, xEnd, yStart+height/2+1, yEnd )
            );
        }
    }
}

]]>
			</text>
		</p>
		<p n="xj_namedconsumer">
			<text>//file: NamedConsumer.java

public class NamedConsumer implements Runnable 
{
    Producer producer;
    String name;

    NamedConsumer(String name, Producer producer) {
        this.producer = producer;
        this.name = name;
    }

    public void run() {
        while ( true ) {
            String message = producer.getMessage();
            System.out.println(name + " got message: " + message);
			try { 
				Thread.sleep( 2000 ); 
			} catch ( InterruptedException e ) { }
        }
    }

    public static void main(String args[]) {
        Producer producer = new Producer();
        new Thread( producer ).start();

        NamedConsumer consumer = new NamedConsumer( "One", producer );
        new Thread( consumer ).start();
        consumer = new NamedConsumer( "Two", producer );
        new Thread( consumer ).start();
    }
}
			</text>
		</p>
		<p n="xj_producer">
			<text>
				<![CDATA[import java.util.*;

public class Producer implements Runnable
{
    static final int MAXQUEUE = 5;
    private List messages = new ArrayList();

    public void run() {
		while ( true ) {
			putMessage();
            try { 
				Thread.sleep( 1000 ); 
			} catch ( InterruptedException e ) { }
		}
    }

    private synchronized void putMessage() 
	{
        while ( messages.size() >= MAXQUEUE )
			try {
				wait();
			} catch( InterruptedException e ) { }

        messages.add( new java.util.Date().toString() );
        notify();
    }

    // called by Consumer
    public synchronized String getMessage()
	{
        while ( messages.size() == 0 )
			try {
				notify();
				wait();
			} catch( InterruptedException e ) { }
        String message = (String)messages.remove(0);
		notify();
        return message;
    }
} 

]]>
			</text>
		</p>
		<p n="xj_showstates">
			<text>
				<![CDATA[import java.util.*;
import java.net.*;
import java.io.*;

public class ShowStates 
{

	public static void main( String [] args ) throws Exception
	{
		new Thread() {
			public void run() {
				try {
				new ServerSocket(1234).accept();
				} catch ( IOException e ) { }
			}
		}.start();
		Thread.sleep(2000);

		while( true ) 
		{
		Thread [] threads = new Thread [ 10 ]; // max threads
		int num = Thread.enumerate( threads );
		for( int i = 0; i < num; i++ )
		{
			System.out.println( threads[i] );
			System.out.println( threads[i].getState() );
		}
		Thread.sleep(1000);
		}
	}

}
]]>
			</text>
		</p>
		<p n="xj_sitetimer">
			<text>
				<![CDATA[import java.util.*;
import java.util.concurrent.*;
import java.net.*;
import java.io.IOException;

public class SiteTimer 
{
	CyclicBarrier barrier;
	List<Result> results = new ArrayList<Result>();

	private class Result implements Comparable<Result> {
		Long time;
		String site;
		Result( Long time, String site ) { 
			this.time = time; 
			this.site = site;
		}
		public int compareTo( Result r ) { return time.compareTo( r.time ); }
	}

	static long timeConnect( String site )
	{
		long start = System.currentTimeMillis();
		try { 
			new URL( site ).openConnection().connect(); 
		} catch ( IOException e ) { 
			return -1;
		}
		return System.currentTimeMillis() - start;
	}
	
	void showResults() {
		Collections.sort( results );
		for( Result result : results )
			System.out.printf( "%%-30.30s : %%d\n", result.site, result.time );
		System.out.println("------------------");
	}

	public void start( String [] args )
	{
		Runnable showResultsAction = new Runnable() { 
			public void run() { 
				showResults(); 
				results.clear();
			} };
		barrier = new CyclicBarrier( args.length, showResultsAction );

		for ( final String site : args )
			new Thread() {
				public void run() {
					while( true ) {
						long time = timeConnect( site );
						results.add( new Result( time, site ) );
						try {
							barrier.await();
						} catch ( BrokenBarrierException e ) { return; 
						} catch ( InterruptedException e ) { return; }
					}
				}
			}.start();
	}

	public static void main( String [] args ) throws IOException {
		new SiteTimer().start( args );
	}
}
]]>
			</text>
		</p>
		<p n="xj_thready">
			<text>public class Thready {
    public static void main( String args [] ) {
        Thread foo = new ShowThread("Foo");
		foo.setPriority( Thread.NORM_PRIORITY);
		foo.start();

        Thread bar = new ShowThread("Bar");
		bar.setPriority( Thread.NORM_PRIORITY+1 );
        bar.start();
    }

	static class ShowThread extends Thread {
		String message;

		ShowThread( String message ) {
			this.message = message;
		}
		public void run(  ) {
			while ( true )
				System.out.println( message );
		}
	}
}
			</text>
		</p>
		<p n="xj_uncaught">
			<text>import java.util.*;

public class Uncaught implements Runnable
{

	public static void main( String [] args )
	{
		Thread thread = new Thread( new Uncaught() );
		thread.setUncaughtExceptionHandler( 
			new Thread.UncaughtExceptionHandler() {
				public void uncaughtException( Thread t, Throwable e ) {
					System.err.println( t + " threw exception: " + e );
				}
		} );
		thread.start();
	}

	public void run() {
		throw new ArithmeticException();
	}

}
			</text>
		</p>
		<p n="xj_updateapplet">
			<text>public class UpdateApplet extends java.applet.Applet
    implements Runnable 
{
	Thread thread;
    boolean running;
    int updateInterval = 1000;

    public void run() {
        while ( running ) 
		{
            repaint();
            try {
                Thread.sleep( updateInterval );
            } catch ( InterruptedException e ) {
				System.out.println("interrupted...");
                return;
            }
        }
    }

    public void start() {
		System.out.println("starting...");
        if ( !running ) // naive approach
		{
			running = true;
            thread = new Thread(this);
            thread.start();
		}
    }

    public void stop() {
		System.out.println("stopping...");
		thread.interrupt();
		running = false;
    }
}
			</text>
		</p>
		<p n="xj_call">
			<text>
				<![CDATA[import java.util.*;
import java.util.concurrent.*;

public class Call 
{

	public static void main( String [] args )
	{
		new Callable<Integer>() {
			public Integer call() { return 2+2; }
		};
	}

}
]]>
			</text>
		</p>
		<p n="xj_executorhttpd2">
			<text>
				<![CDATA[import java.net.*;
import java.io.*;
import java.util.regex.*;
import java.util.concurrent.*;

public class ExecutorHttpd2
{
  ExecutorService executor = Executors.newFixedThreadPool(3);

  public void start( int port ) throws IOException
  {
    final ServerSocket ss = new ServerSocket( port );

    executor.submit( new Runnable() {
      public void run() {
        while ( !executor.isShutdown() )
          try {
            executor.submit( new TinyHttpdConnection( ss.accept() ) );
          } catch ( IOException e ) { }
      }
    } );
  }

  public void shutdown() throws InterruptedException {
    executor.shutdown();
    executor.awaitTermination( 30, TimeUnit.SECONDS );
    executor.shutdownNow();
  }

  public static void main( String argv[] ) throws Exception 
  {
    new ExecutorHttpd().start( Integer.parseInt(argv[0]) );
  }
}

/*
  This class is copied from the TinyHttpd example in Chapter 13.
*/
class TinyHttpdConnection implements Runnable {
  Socket client;
  TinyHttpdConnection ( Socket client ) throws SocketException {
    this.client = client;
  }
  public void run() {
    try {
      BufferedReader in = new BufferedReader(
        new InputStreamReader(client.getInputStream(), "8859_1" ) );
      OutputStream out = client.getOutputStream();
      PrintWriter pout = new PrintWriter(
        new OutputStreamWriter(out, "8859_1"), true );
      String request = in.readLine();
      System.out.println( "Request: "+request);

    Matcher get = Pattern.compile("GET /?(\\S*).*").matcher( request );
    if ( get.matches() ) {
    request = get.group(1);
        if ( request.endsWith("/") || request.equals("") )
          request = request + "index.html";
        try {
          FileInputStream fis = new FileInputStream ( request );
          byte [] data = new byte [ 64*1024 ];
      for(int read; (read = fis.read( data )) > -1; )
        out.write( data, 0, read );
          out.flush();
        } catch ( FileNotFoundException e ) {
          pout.println( "404 Object Not Found" ); }
      } else
        pout.println( "400 Bad Request" );
      client.close();
    } catch ( IOException e ) {
      System.out.println( "I/O error " + e ); }
  }
}
]]>
			</text>
		</p>
		<p n="xj_rwlock">
			<text>import java.util.*;
import java.util.concurrent.locks.*;

public class RWLock 
{

	public static void main( String [] args )
	{
		ReadWriteLock rwlock = new ReentrantReadWriteLock();
		rwlock.readLock().lock();
		System.out.println("here1");
		rwlock.writeLock().lock();
		System.out.println("here2");
	}

}
			</text>
		</p>
		<p n="xj_testcondition">
			<text>import java.util.*;
import java.util.concurrent.locks.*;
import java.util.concurrent.*;

public class TestCondition 
{

	public static void main( String [] args ) throws Exception
	{
		Lock lock = new ReentrantLock();
		Condition cond = lock.newCondition();
		lock.lock();
		cond.await( 1, TimeUnit.SECONDS );
		lock.unlock();
	}

}
			</text>
		</p>
		<p n="xj_testsemaphore">
			<text>import java.util.*;
import java.util.concurrent.*;

public class TestSemaphore 
{
	int concurrentUsers = 5;
	boolean fair = true;
	Semaphore sem = new Semaphore( concurrentUsers, fair );

	Data readData() throws InterruptedException {
		sem.acquire();
		// read data ...
		sem.release();

		return null /*data*/;
	}

	public static void main( String [] args )
	{
	}

	class Data { }
}
			</text>
		</p>
		<p n="xj_resourcebundle">
			<text>//file: Hello.java
import java.util.*;

public class Hello {
  public static void main(String[] args) {
    ResourceBundle bun;
    bun = ResourceBundle.getBundle("Message", Locale.ITALY);
    System.out.println(bun.getString("HelloMessage"));
    bun = ResourceBundle.getBundle("Message", Locale.US);
    System.out.println(bun.getString("HelloMessage"));
  }
}
			</text>
		</p>
		<p n="xj_printf">
			<text>import java.util.*;
import static java.lang.System.*;

public class PrintfExamples
{
	public static void main( String [] args )
	{
		System.out.printf("a %%1$s is a %%1$s is a %%1$s...", "rose" );
		System.out.printf("bool is %%b\n", "a" );

		//char value is a
		System.out.printf("char value is %%c\n", 'a' );
		// why doesn't this work?
		//System.out.printf("char value is %%1$c, %%1$C\n", 'a' );

		Date date = new Date(1099629120657L);

		//The date is Wed Oct 20 01:45:17 CDT 2004
		System.out.printf("The date is %%s\n", date );
		//The date is Wed Oct 20 01:45:17 CDT 2004
		System.out.printf("The date is %%tc\n", date );
		//The DATE is WED OCT 20 01:45:17 CDT 2004
		System.out.printf("The DATE is %%Tc\n", date );

		System.out.printf("The DATE is %%tD\n", date );
		System.out.printf("The DATE is %%tF\n", date );
		System.out.printf("The DATE is %%tr\n", date );
		System.out.printf("The DATE is %%tR\n", date );
		System.out.printf("The DATE is %%tT\n", date );

		System.out.printf( Locale.ITALIAN, "The date is %%tc\n", date );
		System.out.printf( Locale.CHINA, "The date is %%tc\n", date );
		System.out.printf( Locale.FRENCH, "The date is %%tc\n", date );
		System.out.printf( Locale.GERMAN, "The date is %%tc\n", date );

		System.out.printf("The DATE is %%tC\n", date );
		System.out.printf("The DATE is %%tz\n", date );

		System.out.printf("String is '%%5s'\n", "A");
		System.out.printf("String is '%%-5s'\n", "A");
		System.out.printf("String is '%%.5s'\n", "Happy Birthday!");

		String [] words = 
			new String [] { "abalone", "ape", "antidisestablishmentarianism" };
		System.out.printf( "%%-10s %%s\n", "Word", "Length" );
		for ( String word : words )
			System.out.printf( "%%-10.10s %%s\n", word, word.length() );

		out.printf("num is %%s\n", 5);
		out.printf("char is %%s\n", 'a');
		out.printf("char is %%S\n", 'a');
		out.printf("bool is %%s\n", true );

		//My name is Joe
		System.out.printf("My name is %%s\n", "Joe");
		//http://host/path
		System.out.printf("%%s://%%s/%%s\n", "http", "host", "path");
		//http://host/path
		System.out.printf("%%1$s://%%2$s/%%3$s\n", "http", "host", "path");

		// num is 3.141593
		out.printf("num is %%f\n", Math.PI );
		// num is 3.14
		out.printf("num is %%.2f\n", Math.PI );

		//num is 005
		out.printf("num is %%03d\n", 5 );

		out.printf("num is %%03f\n", 3.14159265 );
		out.printf("num is {%%07.3f}\n", 3.14 );
		out.printf("06.3 num is %%06.3f\n", 3.14159265 );
		out.printf(".3 num is %%.3f\n", 3.14159265 );
		out.printf("9.99 num is %%4.2f\n", 9.999999999 );

		out.printf("1.0 5f num is %%5f\n", 1.0 );
		out.printf("1.0 4f num is %%4f\n", 1.0 );

		out.printf("sci not num is %%e\n", 3.14159265*10000 );
		out.printf("sci not num is %%g\n", 3.14159265*10000 );
		out.printf("sci not num is %%e\n", 0.123456789 );
		out.printf("sci not num is %%g\n", 0.123456789 );
		out.printf("sci not num is %%e\n", 3000000.0 );
		out.printf("hex num is %%h\n", 1.0 );
		out.printf("num is %%h\n", 0xCAFE );


		//boolean value is true, TRUE
		System.out.printf("boolean value is %%1$b, %%1$B\n", true );

		//hex value is b5151397, B5151397
		System.out.printf("hex value is %%1$h, %%1$H\n", new Date() );
		//hex value 
		System.out.printf("hex value is %%1$h, %%1$H\n", 0xCAFE );
		//hex value 
		System.out.printf("hex value is %%1$x, %%1$X\n", 0xCAFE );
		System.out.printf("hex value is %%1$#x, %%1$#X\n", 0xCAFE );

		System.out.printf( Locale.ITALIAN, "value: %%f\n", 3.14 );

		// flags
		out.printf("num is %%d\n", 5000000);

		out.printf("float is %%f\n", 1.23456789);
		out.printf("float is %%.3f\n", 1.23456789);
		out.printf("float is %%.1f\n", 1.23456789);
		out.printf("float is %%.0f\n", 1.23456789);

		out.printf("float is %%-20f!\n", 1.23456789);
	}

}
			</text>
		</p>
		<p n="xj_template">
			<text>
				<![CDATA[import java.util.*;
import java.util.regex.*;

public class Template 
{
	Properties values = new Properties();
	Pattern templateComment = 
		Pattern.compile("(?si)<!--\\s*TEMPLATE:(\\w+).*?-->");

	public void set( String name, String value	) {
		values.setProperty( name, value );
	}

	public String fillIn( String text ) {
		Matcher matcher = templateComment.matcher( text );

		StringBuffer buffer = new StringBuffer();
		while( matcher.find() ) {
			String name = matcher.group(1);
			String value = values.getProperty( name );
			matcher.appendReplacement( buffer, value );
		}
		matcher.appendTail( buffer );
		return buffer.toString();
	}

	public static void main( String	[] args	) 
	{
		String templateText = 
			"<html><head>\n"+
			"<body>\n"+
			"This is some text.\n"+
			"<!-- TEMPLATE:foo  -->\n"+
			"Some more text.\n"+
			"\n"+
			"<!--template:bar This is text -->\n"+
			"More text.\n"+
			"<!-- TEMPLATE:bar \n"+
			"-->\n"+
			"</body></html>\n";
			
		Template template = new Template();
		template.set( "foo", "FooTemplate");
		template.set( "bar", "BarTemplate");
		System.out.println( templateText );
		System.out.println( template.fillIn(templateText) );
	}

}


]]>
			</text>
		</p>
		<p n="xj_loglistener">
			<text>
import java.io.*;
import java.net.*;
import java.util.logging.*;

public class LogListener {
        public static void main( String [] args ) throws IOException
        {
                int port = Integer.parseInt( args[0] );
                ServerSocket server = new ServerSocket( port );
                Socket client = server.accept();
                BufferedReader in = new BufferedReader( 
                        new InputStreamReader( client.getInputStream() ) );

                String line;
                while ( (line = in.readLine() ) != null )
                        System.out.println( line );
        }

}

			</text>
		</p>
		<p n="xj_logtest">
			<text>
import java.util.logging.*;

public class LogTest {
    public static void main(String argv[]) {
        Logger logger = Logger.getLogger("com.oreilly.LogTest");

        logger.severe("Power lost - running on backup!");
        logger.warning("Database connection lost, retrying...");
        logger.info("Startup complete.");
        logger.config("Server configuration: standalone, JVM version 1.4");
        logger.fine("Loading graphing package.");
        logger.finer("Doing pie chart");
        logger.finest("Starting bubble sort: value ="+42);
    }
}

			</text>
		</p>
		<p n="xj_logtest2">
			<text>
				<![CDATA[
import java.util.logging.*;

public class LogTest2 
{
    public static void main(String argv[]) {
        Logger logger = Logger.getLogger("DeviceLog");

        logger.info("<Device id=\"99\"/>");
    }
}

]]>
			</text>
		</p>
		<p n="xj_messageboard">
			<text>//file: MessageBoard.java
import java.util.*;

public class MessageBoard extends Observable {
    private String message;

    public String getMessage(  ) {
        return message;
    }
    public void changeMessage( String message ) {
        this.message = message;
        setChanged(  );
        notifyObservers( message );
    }
    public static void main( String [] args ) {
        MessageBoard board = new MessageBoard(  );
        Student bob = new Student(  );
        Student joe = new Student(  );
        board.addObserver( bob );
        board.addObserver( joe );
        board.changeMessage("More Homework!");
    }
} // end of class MessageBoard

class Student implements Observer {
    public void update(Observable o, Object arg) {
        System.out.println( "Message board changed: " + arg );
    }
}
			</text>
		</p>
		<p n="xj_wordsort">
			<text>
				<![CDATA[import java.io.*;
import java.util.*;

public class WordSort 
{
  public static void main(String[] args) throws IOException 
  {
    if ( args.length < 2 ) {
      System.out.println("Usage: WordSort inputfile outputfile");
      return;
    }
    String inputfile = args[0];
    String outputfile = args[1];


    /*  Create the word map. Each key is a word and each value is an
        Integer that represents the number of times the word occurs
        in the input file.
    */
    Map<String,Integer> map = new TreeMap<String,Integer>();

    Scanner scanner = new Scanner( new File(inputfile) );
    while ( scanner.hasNext() ) {
        String word = scanner.next();
        Integer count = map.get( word );
        count = ( count == null ? 1 : count +1 );
        map.put( word, count );
    }
    scanner.close();

    // get the map's keys 
    List<String> keys = new ArrayList<String>( map.keySet() );
	//Collections.sort( keys );

    // write the results to the output file
    PrintWriter out = new PrintWriter( new FileWriter(outputfile) );
    for ( String key : keys )
      out.println( key + " : " + map.get(key) );
    out.close();
  }
}
]]>
			</text>
		</p>
		<p n="xj_copychannels">
			<text>
				<![CDATA[import java.io.*;
import java.nio.*;
import java.nio.channels.*;

public class CopyChannels {
	public static void main( String [] args ) throws Exception
	{
		String fromFileName = args[0];
		String toFileName = args[1];
		FileChannel in = new FileInputStream( fromFileName ).getChannel();
		FileChannel out = new FileOutputStream( toFileName ).getChannel();
		
		ByteBuffer buff = ByteBuffer.allocate( 32*1024 );

		while ( in.read( buff ) > 0 ) {
			buff.flip();
			out.write( buff );
			buff.clear();
		}

		in.close();
		out.close();
	}
}
]]>
			</text>
		</p>
		<p n="xj_copychannels2">
			<text>
				<![CDATA[import java.io.*;
import java.nio.*;
import java.nio.channels.*;

public class CopyChannels2 {
	public static void main( String [] args ) throws Exception
	{
		String fromFileName = args[0];
		String toFileName = args[1];
		FileChannel in = new FileInputStream( fromFileName ).getChannel();
		FileChannel out = new FileOutputStream( toFileName ).getChannel();
		
		ByteBuffer buff = ByteBuffer.allocateDirect( 32*1024 );

		while ( in.read( buff ) > 0 ) {
			buff.flip();
			out.write( buff );
			buff.clear();
		}

		in.close();
		out.close();
	}
}
]]>
			</text>
		</p>
		<p n="xj_copychannels3">
			<text>import java.io.*;
import java.nio.*;
import java.nio.channels.*;

public class CopyChannels3 {
	public static void main( String [] args ) throws Exception
	{
		String fromFileName = args[0];
		String toFileName = args[1];
		FileChannel in = new FileInputStream( fromFileName ).getChannel();
		FileChannel out = new FileOutputStream( toFileName ).getChannel();
		in.transferTo( 0, (int)in.size(), out );
		in.close();
		out.close();
	}
}
			</text>
		</p>
		<p n="xj_copyfile">
			<text>import java.nio.channels.*;
import java.nio.file.*;
import static java.nio.file.StandardOpenOption.*;

public class CopyFile
{
    public static void main( String [] args ) throws Exception
    {
        FileSystem fs = FileSystems.getDefault();
        Path fromFile = fs.getPath( args[0] );
        Path toFile = fs.getPath( args[1] );

        try (
            FileChannel in = FileChannel.open( fromFile );
            FileChannel out = FileChannel.open( toFile, CREATE, WRITE ); )
        {
            in.transferTo( 0, (int)in.size(), out );
        }
    }
}
			</text>
		</p>
		<p n="xj_copystreams">
			<text>
				<![CDATA[import java.io.*;

public class CopyStreams {
	public static void main( String [] args ) throws Exception
	{
		String fromFileName = args[0];
		String toFileName = args[1];
		BufferedInputStream in = new BufferedInputStream(
			new FileInputStream( fromFileName ) );
		BufferedOutputStream out = new BufferedOutputStream(
			new FileOutputStream( toFileName ) );
		byte [] buff = new byte [ 32*1024 ];
		int len;
		while ( (len = in.read( buff )) > 0 )
			out.write( buff, 0, len );
		in.close();
		out.close();
	}
}
]]>
			</text>
		</p>
		<p n="xj_findresources">
			<text>//file: FindResources.java
package mypackage;
import java.net.URL;
import java.io.IOException;

public class FindResources {
  public static void main( String [] args ) throws IOException {
    // absolute from the classpath
    URL url = FindResources.class.getResource("/mypackage/foo.txt");
    // relative to the class location
    url = FindResources.class.getResource("foo.txt");
    // another relative document
    url = FindResources.class.getResource("docs/bar.txt");
  }
}
			</text>
		</p>
		<p n="xj_gunzip">
			<text>//file: GUnzip.java
import java.io.*;
import java.util.zip.*;

public class GUnzip {
  public static int sChunk = 8192;
  public static void main(String[] args) {
    if (args.length != 1) {
      System.out.println("Usage: GUnzip source");
      return;
    }
    // create input stream
    String zipname, source;
    if (args[0].endsWith(".gz")) {
      zipname = args[0];
      source = args[0].substring(0, args[0].length(  ) - 3);
    }
    else {
      zipname = args[0] + ".gz";
      source = args[0];
    }
    GZIPInputStream zipin;
    try {
      FileInputStream in = new FileInputStream(zipname);
      zipin = new GZIPInputStream(in);
    }
    catch (IOException e) {
      System.out.println("Couldn't open " + zipname + ".");
      return;
    }
    byte[] buffer = new byte[sChunk];
    // decompress the file
    try {
      FileOutputStream out = new FileOutputStream(source);
      int length;
      while ((length = zipin.read(buffer, 0, sChunk)) != -1)
        out.write(buffer, 0, length);
      out.close(  );
    }
    catch (IOException e) {
      System.out.println("Couldn't decompress " + args[0] + ".");
    }
    try { zipin.close(  ); }
    catch (IOException e) {}
  }
}
			</text>
		</p>
		<p n="xj_gzip">
			<text>//file: GZip.java
import java.io.*;
import java.util.zip.*;

public class GZip {
  public static int sChunk = 8192;

  public static void main(String[] args) {
    if (args.length != 1) {
      System.out.println("Usage: GZip source");
      return;
    }
    // create output stream
    String zipname = args[0] + ".gz";
    GZIPOutputStream zipout;
    try {
      FileOutputStream out = new FileOutputStream(zipname);
      zipout = new GZIPOutputStream(out);
    }
    catch (IOException e) {
      System.out.println("Couldn't create " + zipname + ".");
      return;
    }
    byte[] buffer = new byte[sChunk];
    // compress the file
    try {
      FileInputStream in = new FileInputStream(args[0]);
      int length;
      while ((length = in.read(buffer, 0, sChunk)) != -1)
        zipout.write(buffer, 0, length);
      in.close(  );
    }
    catch (IOException e) {
      System.out.println("Couldn't compress " + args[0] + ".");
    }
    try { zipout.close(  ); }
    catch (IOException e) {}
  }
}
			</text>
		</p>
		<p n="xj_listit">
			<text>
				<![CDATA[import java.io.*;

public class ListIt
{
    public static void main ( String args[] ) throws Exception {
        File file =  new File( args[0] );

        if ( !file.exists() || !file.canRead(  ) ) {
            System.out.println( "Can't read " + file );
            return;
        }

        if ( file.isDirectory(  ) ) {
            String [] files = file.list(  );
            for (int i=0; i< files.length; i++)
                System.out.println( files[i] );
        }
        else
            try {
                Reader ir = new InputStreamReader( new FileInputStream( file ) );
                BufferedReader in = new BufferedReader( ir );
                String line;
                while ((line = in.readLine(  )) != null)
                System.out.println(line);
            }
            catch ( FileNotFoundException e ) {
                System.out.println( "File Disappeared" );
            }
    }
}
]]>
			</text>
		</p>
		<p n="xj_load">
			<text>//file: Load.java
import java.io.*;
import java.util.*;

public class Load {
  public static void main(String[] args) {
    try {
      FileInputStream fileIn = new FileInputStream("h.ser");
      ObjectInputStream in = new ObjectInputStream(fileIn);
      Hashtable h = (Hashtable)in.readObject(  );
      System.out.println(h.toString(  ));
    }
    catch (Exception e) {
      System.out.println(e);
    }
  }
}
			</text>
		</p>
		<p n="xj_loggerdaemon">
			<text>//file: LoggerDaemon.java
import java.io.*;

class LoggerDaemon extends Thread {
    PipedReader in = new PipedReader(  );

    LoggerDaemon(  ) {
        start(  );
    }

    public void run(  ) {
        BufferedReader bin = new BufferedReader( in );
        String s;

        try {
           while ( (s = bin.readLine(  )) != null ) {
                // process line of data
                // ...
            }
        }
        catch (IOException e ) { }
    }

    PrintWriter getWriter(  ) throws IOException {
        return new PrintWriter( new PipedWriter( in ) );
    }
}
			</text>
		</p>
		<p n="xj_rot13inputstream">
			<text>
				<![CDATA[//file: rot13InputStream.java
package learningjava.io;
import java.io.*;

public class rot13InputStream extends FilterInputStream {

    public rot13InputStream ( InputStream i ) {
        super( i );
    }

    public int read(  ) throws IOException {
        return rot13( in.read(  ) );
    }

    private int rot13 ( int c ) {
        if ( (c >= 'A') && (c <= 'Z') )
            c=(((c-'A')+13)%%26)+'A';
        if ( (c >= 'a') && (c <= 'z') )
            c=(((c-'a')+13)%%26)+'a';
        return c;
    }
}
]]>
			</text>
		</p>
		<p n="xj_save">
			<text>//file: Save.java
import java.io.*;
import java.util.*;

public class Save {
  public static void main(String[] args) {
    Hashtable h = new Hashtable(  );
    h.put("string", "Gabriel Garcia Marquez");
    h.put("int", new Integer(26));
    h.put("double", new Double(Math.PI));

    try {
      FileOutputStream fileOut = new FileOutputStream("h.ser");
      ObjectOutputStream out = new ObjectOutputStream(fileOut);
      out.writeObject(h);
    }
    catch (Exception e) {
      System.out.println(e);
    }
  }
}
			</text>
		</p>
		<p n="xj_ziptest">
			<text>
				<![CDATA[import java.io.*;
import java.net.URI;
import java.nio.file.*;
import java.util.*;

public class ZipTest
{
    public static void main( String[] args ) throws IOException
    {
        // Construct the URI pointing to the ZIP archive
        URI fsURI = URI.create("jar:file:/Users/pat/tmp/MyArchive.zip");

        // Open or creat it and write a file
        Map<String, String> env = new HashMap<>();
        //env.put("create", "true");
        try ( FileSystem zipfs = FileSystems.newFileSystem( fsURI, env ) )
        {
            Path path = zipfs.getPath("/README.txt");
            OutputStream out = Files.newOutputStream( path );
            try ( PrintWriter pw = new PrintWriter( new OutputStreamWriter( out ) ) ) {
                pw.println("Hello World!");
            }
        }

        // Move the file
        try ( FileSystem zipfs = FileSystems.newFileSystem( fsURI, env ) )
        {
            Path path = zipfs.getPath("/README.txt");
            Path toPath = zipfs.getPath( "/README2.txt" );
            Files.move( path, toPath );
        }

    }
}
]]>
			</text>
		</p>
		<p n="xj_client">
			<text>//file: Client.java
import java.net.*;
import java.io.*;

public class Client {
  public static void main( String argv[] ) {
    try {
      Socket server =
        new Socket( argv[0], Integer.parseInt(argv[1]) );
      ObjectOutputStream out =
        new ObjectOutputStream( server.getOutputStream(  ) );
      ObjectInputStream in =
        new ObjectInputStream( server.getInputStream(  ) );

      out.writeObject( new DateRequest(  ) );
      out.flush(  );
      System.out.println( in.readObject(  ) );

      out.writeObject( new MyCalculation( 2 ) );
      out.flush(  );
      System.out.println( in.readObject(  ) );

      server.close(  );
    } catch ( IOException e ) {
      System.out.println( "I/O error " + e ); // I/O error
    } catch ( ClassNotFoundException e2 ) {
      System.out.println( e2 ); // unknown type of response object
    }
  }
}
			</text>
		</p>
		<p n="xj_dateathost">
			<text>
				<![CDATA[//file: DateAtHost.java
import java.net.Socket;
import java.io.*;

public class DateAtHost extends java.util.Date {
    static int timePort = 37;
    // seconds from start of 20th century to Jan 1, 1970 00:00 GMT
    static final long offset = 2208988800L;

    public DateAtHost( String host ) throws IOException {
        this( host, timePort );
    }

    public DateAtHost( String host, int port ) throws IOException {
        Socket server = new Socket( host, port );
        DataInputStream din =
          new DataInputStream( server.getInputStream(  ) );
        int time = din.readInt(  );
        server.close(  );

        setTime( (((1L << 32) + time) - offset) * 1000 );
    }
}
]]>
			</text>
		</p>
		<p n="xj_daterequest">
			<text>//file: DateRequest.java
public class DateRequest extends Request {}
			</text>
		</p>
		<p n="xj_heartbeat">
			<text>//file: HeartBeat.java
import java.net.*;
import java.io.*;

public class HeartBeat extends java.applet.Applet {
    String myHost;
    int myPort;

    public void init(  ) {
        myHost = getCodeBase().getHost(  );
        myPort = Integer.parseInt( getParameter("myPort") );
    }

    private void sendMessage( String message ) {
        try {
            byte [] data = message.getBytes("UTF-8");
            InetAddress addr = InetAddress.getByName( myHost );
            DatagramPacket pack =
              new DatagramPacket( data, data.length, addr, myPort );
            DatagramSocket ds = new DatagramSocket();
            ds.send( pack );
            ds.close();
        } catch ( IOException e ) {
            System.out.println( e );  // Error creating socket
        }
    }

    public void start(  ) {
        sendMessage("Arrived");
    }
    public void stop(  ) {
        sendMessage("Departed");
    }
}
			</text>
		</p>
		<p n="xj_heartbeat2">
			<text>//file: HeartBeat.java
import java.net.*;
import java.io.*;

public class HeartBeat2 {
    private String myHost;
    private int myPort;

    public HeartBeat2( String host, int port  ) {
        myHost = host;
        myPort = port;
    }

    public void sendMessage( String message ) {
        try {
            byte [] data = message.getBytes("UTF-8");
            InetAddress addr = InetAddress.getByName( myHost );
            DatagramPacket pack =
              new DatagramPacket( data, data.length, addr, myPort );
            DatagramSocket ds = new DatagramSocket();
            ds.send( pack );
            ds.close();
        } catch ( IOException e ) {
            System.out.println( e );  // Error creating socket
        }
    }

	public static void main( String[] args ) {
		String host = args[0];
		int port = Integer.parseInt( args[1] );
		HeartBeat2 hb = new HeartBeat2( host, port );
		hb.sendMessage( "Ping!" );
	}
}
			</text>
		</p>
		<p n="xj_largerhttpd">
			<text>
				<![CDATA[import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import java.net.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;
import java.util.regex.*;

public class LargerHttpd
{
	Selector clientSelector;

	public void run( int port, int threads ) throws IOException 
	{
		clientSelector = Selector.open();
		ServerSocketChannel ssc = ServerSocketChannel.open();
		ssc.configureBlocking(false);
        InetSocketAddress sa =  new InetSocketAddress( InetAddress.getLoopbackAddress(), port );
		ssc.socket().bind( sa );
		ssc.register( clientSelector, SelectionKey.OP_ACCEPT );
	
		Executor executor = Executors.newFixedThreadPool( threads );

		while ( true ) {
            try {
                while ( clientSelector.select(100) == 0 );
                Set<SelectionKey> readySet = clientSelector.selectedKeys();
                for(Iterator<SelectionKey> it=readySet.iterator(); it.hasNext();)
                {
                    final SelectionKey key = it.next();
                    it.remove();
                    if ( key.isAcceptable() ) {
                        acceptClient( ssc );
                    } else {
                        key.interestOps( 0 );
                        executor.execute( new Runnable() {
                          public void run() {
                            try {
                                handleClient( key );
                              } catch ( IOException e) { System.out.println(e); }
                          }
                        } );
                    }
                }
            } catch ( IOException e ) { System.out.println(e); }
        }
	}

	void acceptClient( ServerSocketChannel ssc ) throws IOException
    {
		SocketChannel clientSocket = ssc.accept();
		clientSocket.configureBlocking(false);
		SelectionKey key =  clientSocket.register( clientSelector, SelectionKey.OP_READ );
		HttpdConnection client = new HttpdConnection( clientSocket );
		key.attach( client );
	}

	void handleClient( SelectionKey key ) throws IOException
    {
		HttpdConnection client = (HttpdConnection)key.attachment();
		if ( key.isReadable() ) {
			client.read( key );
        } else {
			client.write( key );
        }
		clientSelector.wakeup();
	}

	public static void main( String argv[] ) throws IOException {
		//new LargerHttpd().run( Integer.parseInt(argv[0]), 3/*threads*/ );
        new LargerHttpd().run( 1235, 3/*threads*/ );
	}
}

class HttpdConnection {
	static Charset charset = Charset.forName("8859_1");
	static Pattern httpGetPattern = Pattern.compile("(?s)GET /?(\\S*).*");
	SocketChannel clientSocket;
	ByteBuffer buff = ByteBuffer.allocateDirect( 64*1024 );
	String request;
	String response;
	FileChannel file;
	int filePosition;

	HttpdConnection ( SocketChannel clientSocket ) {
		this.clientSocket = clientSocket;
	}

	void read( SelectionKey key ) throws IOException {
		if ( request == null && (clientSocket.read( buff ) == -1 
				|| buff.get( buff.position()-1 ) == '\n' ) )
			processRequest( key );
		else
			key.interestOps( SelectionKey.OP_READ );
	}

	void processRequest( SelectionKey key ) {
		buff.flip();
		request = charset.decode( buff ).toString();
		Matcher get = httpGetPattern.matcher( request );
		if ( get.matches() ) {
			request = get.group(1);
			if ( request.endsWith("/") || request.equals("") )
				request = request + "index.html";
			System.out.println( "Request: "+request);
			try {
				file = new FileInputStream ( request ).getChannel();
			} catch ( FileNotFoundException e ) {
				response = "404 Object Not Found";
			}
		} else
			response = "400 Bad Request" ;

		if ( response != null ) {
			buff.clear();
			charset.newEncoder().encode( 
				CharBuffer.wrap( response ), buff, true );
			buff.flip();
		}
		key.interestOps( SelectionKey.OP_WRITE );
	}

	void write( SelectionKey key ) throws IOException {
		if ( response != null ) {
			clientSocket.write( buff );
			if ( buff.remaining() == 0 ) 
				response = null;
		} else if ( file != null ) {
			int remaining = (int)file.size()-filePosition;
			long sent = file.transferTo( filePosition, remaining, clientSocket);
			if ( sent >= remaining || remaining <= 0 ) {
				file.close();
				file = null;
			} else
				filePosition += sent;
		} 
		if ( response == null && file == null ) {
			clientSocket.close();
			key.cancel();		
		} else 
			key.interestOps( SelectionKey.OP_WRITE );
	}
}
]]>
			</text>
		</p>
		<p n="xj_mycalculation">
			<text>//file: MyCalculation.java
public class MyCalculation extends WorkRequest {
    int n;

    public MyCalculation( int n ) {
        this.n = n;
    }
    public Object execute(  ) {
        return new Integer( n * n );
    }
}
			</text>
		</p>
		<p n="xj_myclient">
			<text>//file: MyClient.java
import java.rmi.*;
import java.util.*;

public class MyClient {

    public static void main(String [] args)
      throws RemoteException {
        new MyClient( args[0] );
    }

    public MyClient(String host) {
        try {
            RemoteServer server = (RemoteServer)
                Naming.lookup("rmi://"+host+"/NiftyServer");
            System.out.println( server.getDate(  ) );
            System.out.println(
              server.execute( new MyCalculation(2) ) );
        } catch (java.io.IOException e) {
              // I/O Error or bad URL
			  System.out.println( e );
        } catch (NotBoundException e) {
              // NiftyServer isn't registered
			  System.out.println( e );
        }
    }
}
			</text>
		</p>
		<p n="xj_myclientasync">
			<text>import java.rmi.*;
import java.util.*;

public class MyClientAsync 
	extends java.rmi.server.UnicastRemoteObject implements WorkListener 
{

    public MyClientAsync(String host) throws RemoteException 
	{
        try {
            RemoteServer server = (RemoteServer)
                Naming.lookup("rmi://"+host+"/NiftyServer");

			StringIterator si = server.getList();
			while( si.hasNext() ) {
				System.out.println( si.next() );
			}

			server.asyncExecute( new MyCalculation(100), this );
        } catch (java.io.IOException e) {
			System.out.println(e);
            // I/O Error or bad URL
        } catch (NotBoundException e) {
			System.out.println(e);
            // NiftyServer isn't registered
        }
    }

	public void workCompleted( WorkRequest request, Object result ) 
		throws RemoteException 
	{
		System.out.println("Async result: "+result );
	}

    public static void main(String [] args) throws RemoteException {
        new MyClientAsync( args[0] );
    }

}
			</text>
		</p>
		<p n="xj_myserver">
			<text>//file: MyServer.java
import java.rmi.*;
import java.util.*;

public class MyServer
    extends java.rmi.server.UnicastRemoteObject
    implements RemoteServer {

    public MyServer(  ) throws RemoteException { }

    // implement the RemoteServer interface
    public Date getDate(  ) throws RemoteException {
        return new Date(  );
    }

    public Object execute( WorkRequest work ) throws RemoteException {
        return work.execute(  );
    }

    public StringIterator getList() throws RemoteException {
      return new MyStringIterator(
          new String [] { "Foo", "Bar", "Gee" } );
    }

	public void asyncExecute( 
		final WorkRequest request, final WorkListener listener )
		throws RemoteException 
	{
		new Thread() {
			public void run() {
				try {
					Thread.sleep(1000);
				} catch ( Exception e ) { }
				
				Object result = request.execute(); 
				try {
					listener.workCompleted( request, result ); 
				} catch ( RemoteException e ) {
					System.out.println( e ); // error calling client
				}
			}}.start();
	}

    public static void main(String args[]) {
        try {
            RemoteServer server = new MyServer(  );
            Naming.rebind("NiftyServer", server);
        } catch (java.io.IOException e) {
            // problem registering server
        }
    }
}
			</text>
		</p>
		<p n="xj_mystringiterator">
			<text>
				<![CDATA[//file: MyStringIterator.java
import java.rmi.*;

public class MyStringIterator
  extends java.rmi.server.UnicastRemoteObject
  implements StringIterator {

    String [] list;
    int index = 0;

    public MyStringIterator( String [] list )
      throws RemoteException {
        this.list = list;
    }
    public boolean hasNext(  ) throws RemoteException {
        return index < list.length;
    }
    public String next(  ) throws RemoteException {
        return list[index++];
    }
}
]]>
			</text>
		</p>
		<p n="xj_pulse">
			<text>//file: Pulse.java
import java.net.*;
import java.io.*;

public class Pulse {
    public static void main( String [] argv ) throws IOException {
        DatagramSocket s =
          new DatagramSocket( Integer.parseInt(argv[0]) );

        while ( true ) {
            DatagramPacket packet =
              new DatagramPacket( new byte [1024], 1024 );
            s.receive( packet );
            System.out.println( "packet length = "+packet.getData().length );
            String message = new String( packet.getData(), "UTF-8" );
            System.out.println( "Heartbeat from: "
              + packet.getAddress().getHostName()
              + " - " + message );
        }
    }
}
			</text>
		</p>
		<p n="xj_remoteserver">
			<text>//file: RemoteServer.java
import java.rmi.*;
import java.util.*;

public interface RemoteServer extends Remote {
    Date getDate(  ) throws RemoteException;
    StringIterator getList() throws RemoteException;
    Object execute( WorkRequest work ) throws RemoteException;
    void asyncExecute( WorkRequest work, WorkListener listener ) 
		throws RemoteException;
}
			</text>
		</p>
		<p n="xj_request">
			<text>//file: Request.java
public class Request implements java.io.Serializable {}
			</text>
		</p>
		<p n="xj_server">
			<text>//file: Server.java
import java.net.*;
import java.io.*;

public class Server {
  public static void main( String argv[] ) throws IOException {
    ServerSocket ss = new ServerSocket( Integer.parseInt(argv[0]) );
    while ( true )
      new ServerConnection( ss.accept() ).start(  );
  }
} // end of class Server

class ServerConnection extends Thread {
  Socket client;
  ServerConnection ( Socket client ) throws SocketException {
    this.client = client;
    setPriority( NORM_PRIORITY - 1 );
  }

  public void run(  ) {
    try {
      ObjectInputStream in =
        new ObjectInputStream( client.getInputStream(  ) );
      ObjectOutputStream out =
        new ObjectOutputStream( client.getOutputStream(  ) );
      while ( true ) {
        out.writeObject( processRequest( in.readObject(  ) ) );
        out.flush(  );
      }
    } catch ( EOFException e3 ) { // Normal EOF
      try {
        client.close(  );
      } catch ( IOException e ) { }
    } catch ( IOException e ) {
      System.out.println( "I/O error " + e ); // I/O error
    } catch ( ClassNotFoundException e2 ) {
      System.out.println( e2 ); // unknown type of request object
    }
  }

  private Object processRequest( Object request ) {
    if ( request instanceof DateRequest )
      return new java.util.Date(  );
    else if ( request instanceof WorkRequest )
      return ((WorkRequest)request).execute(  );
    else
      return null;
  }
}
			</text>
		</p>
		<p n="xj_stringiterator">
			<text>//file: StringIterator.java
import java.rmi.*;

public interface StringIterator extends Remote {
    public boolean hasNext(  ) throws RemoteException;
    public String next(  ) throws RemoteException;
}
			</text>
		</p>
		<p n="xj_tinyhttpd">
			<text>
				<![CDATA[import java.net.*;
import java.io.*;
import java.util.regex.*;
import java.util.concurrent.*;

public class TinyHttpd {
  public static void main( String argv[] ) throws IOException {
    Executor executor = Executors.newFixedThreadPool(3);
    ServerSocket ss = new ServerSocket( Integer.parseInt(argv[0]) );
    while ( true )
      executor.execute( new TinyHttpdConnection( ss.accept() ) );
  }
}

class TinyHttpdConnection implements Runnable {
  Socket client;
  TinyHttpdConnection ( Socket client ) throws SocketException {
    this.client = client;
  }
  public void run() {
    try {
      BufferedReader in = new BufferedReader(
        new InputStreamReader(client.getInputStream(), "8859_1" ) );
      OutputStream out = client.getOutputStream();
      PrintWriter pout = new PrintWriter(
        new OutputStreamWriter(out, "8859_1"), true );
      String request = in.readLine();
      System.out.println( "Request: "+request);

      Matcher get = Pattern.compile("GET /?(\\S*).*").matcher( request );
      if ( get.matches() ) {
        request = get.group(1);
        if ( request.endsWith("/") || request.equals("") )
          request = request + "index.html";
        try {
          FileInputStream fis = new FileInputStream ( request );
          byte [] data = new byte [ 64*1024 ];
          for(int read; (read = fis.read( data )) > -1; )
              out.write( data, 0, read );
          out.flush();
        } catch ( FileNotFoundException e ) {
          pout.println( "404 Object Not Found" ); }
      } else
        pout.println( "400 Bad Request" );
      client.close();
    } catch ( IOException e ) {
      System.out.println( "I/O error " + e ); }
  }
}
]]>
			</text>
		</p>
		<p n="xj_worklistener">
			<text>//file: WorkListener.java
import java.rmi.*;

public interface WorkListener extends Remote {
    public void workCompleted(WorkRequest request, Object result )
        throws RemoteException;
}
			</text>
		</p>
		<p n="xj_workrequest">
			<text>//file: WorkRequest.java
public abstract class WorkRequest extends Request {
    public abstract Object execute(  );
}
			</text>
		</p>
		<p n="xj_post">
			<text>
				<![CDATA[//file: Post.java
import java.net.*;
import java.io.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class Post extends JPanel implements ActionListener {
  JTextField nameField, passwordField;
  String postURL;

  GridBagConstraints constraints = new GridBagConstraints(  );
  
  void addGB( Component component, int x, int y ) {
    constraints.gridx = x;  constraints.gridy = y;
    add ( component, constraints );
  }

  public Post( String postURL ) {
	  
	this.postURL = postURL;  
	  
	setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 5));
    JButton postButton = new JButton("Post");
    postButton.addActionListener( this );
    setLayout( new GridBagLayout(  ) );
    constraints.fill = GridBagConstraints.HORIZONTAL;
    addGB( new JLabel("Name ", JLabel.TRAILING), 0, 0 );
    addGB( nameField = new JTextField(20), 1, 0 );
    addGB( new JLabel("Password ", JLabel.TRAILING), 0, 1 );
    addGB( passwordField = new JPasswordField(20), 1, 1 );
    constraints.fill = GridBagConstraints.NONE;
    constraints.gridwidth = 2;
    constraints.anchor = GridBagConstraints.EAST;
    addGB( postButton, 1, 2 );
  }

  public void actionPerformed(ActionEvent e) {
    postData(  );
  }

  protected void postData(  ) {
    StringBuffer sb = new StringBuffer(  );
    sb.append( URLEncoder.encode("Name") + "=" );
    sb.append( URLEncoder.encode(nameField.getText(  )) );
    sb.append( "&" + URLEncoder.encode("Password") + "=" );
    sb.append( URLEncoder.encode(passwordField.getText(  )) );
    String formData = sb.toString(  );

    try {
      URL url = new URL( postURL );
      HttpURLConnection urlcon =
          (HttpURLConnection) url.openConnection(  );
      urlcon.setRequestMethod("POST");
      urlcon.setRequestProperty("Content-type",
          "application/x-www-form-urlencoded");
      urlcon.setDoOutput(true);
      urlcon.setDoInput(true);
      PrintWriter pout = new PrintWriter( new OutputStreamWriter(
          urlcon.getOutputStream(  ), "8859_1"), true );
      pout.print( formData );
      pout.flush(  );

      // read results...
      if ( urlcon.getResponseCode(  ) != HttpURLConnection.HTTP_OK )
        System.out.println("Posted ok!");
      else {
        System.out.println("Bad post...");
        return;
      }
      //InputStream in = urlcon.getInputStream(  );
      // ...

    } catch (MalformedURLException e) {
      System.out.println(e);     // bad postURL
    } catch (IOException e2) {
      System.out.println(e2);    // I/O error
    }
  }

  public static void main( String [] args ) {
    JFrame frame = new JFrame("SimplePost");
    frame.add( new Post( args[0] ), "Center" );
    frame.pack(  );
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_backgroundwaitservice">
			<text>import javax.servlet.*;
import javax.servlet.annotation.*;
import java.util.concurrent.*;

@WebListener
public class BackgroundWaitService implements ServletContextListener
{
    ScheduledExecutorService executor;

    public void contextInitialized( ServletContextEvent sce )
    {
        this.executor = Executors.newScheduledThreadPool( 3 );
        sce.getServletContext().setAttribute( "BackgroundWaitExecutor", executor );
    }

    public void contextDestroyed(ServletContextEvent sce)
    {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool( 3 );
        executor.shutdownNow();
    }
}
			</text>
		</p>
		<p n="xj_backgroundwaitservlet">
			<text>
				<![CDATA[import javax.servlet.*;
import javax.servlet.annotation.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.concurrent.*;

@WebServlet(
    urlPatterns={"/bgwait"},
    asyncSupported = true
)
public class BackgroundWaitServlet extends HttpServlet
{
    public void doGet( HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException
    {
        final AsyncContext asyncContext = request.startAsync();
        ScheduledExecutorService executor =
            (ScheduledExecutorService)request.getServletContext().getAttribute("BackgroundWaitExecutor");
        executor.schedule( new RespondLaterJob( asyncContext ), 5, TimeUnit.SECONDS );
    }
}

class RespondLaterJob implements Runnable
{
    private AsyncContext asyncContext;

    RespondLaterJob( AsyncContext asyncContext ) {
        this.asyncContext = asyncContext;
    }

    @Override
    public void run()
    {
        try {
            ServletResponse response = asyncContext.getResponse();
            response.setContentType("text/html");
            PrintWriter out = response.getWriter();
            out.println("<html><body><h1>WaitServlet Response</h1></body></html>");
        } catch ( IOException e ) { throw new RuntimeException( e ); }

        asyncContext.complete();
    }
}
]]>
			</text>
		</p>
		<p n="xj_conlimitfilter">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.annotation.*;
import javax.servlet.http.*;

/*
    <filter>
        <filter-name>confilter1</filter-name>
        <filter-class>ConLimitFilter</filter-class>
		<init-param>
			<param-name>limit</param-name>
			<param-value>3</param-value>
		</init-param>
    </filter>
    <filter-mapping>
		<filter-name>confilter1</filter-name>
		<url-pattern>/*</url-pattern>
    </filter-mapping>
 */
@WebFilter(
    urlPatterns = "/*",
    initParams = {
        @WebInitParam(name="limit", value="3")
    }
)
public class ConLimitFilter implements Filter
{
	int limit;
	volatile int count;

    public void init( FilterConfig filterConfig )
		throws ServletException
	{
		String s = filterConfig.getInitParameter("limit");
		if ( s == null )
			throw new ServletException("Missing init parameter: "+limit);
		limit = Integer.parseInt( s );
    }


    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		if ( count > limit ) {
			HttpServletResponse httpRes = (HttpServletResponse)res;
			httpRes.sendError( httpRes.SC_SERVICE_UNAVAILABLE, "Too Busy.");
		} else {
			++count;
			chain.doFilter( req, res );
			--count;
		}
    }

    public void destroy() { }
}

]]>
			</text>
		</p>
		<p n="xj_cookiecutter">
			<text>
				<![CDATA[//file: CookieCutter.java
import java.io.*;
import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;

/*
    <servlet>
        <servlet-name>cookiecutter1</servlet-name>
        <servlet-class>CookieCutter</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>cookiecutter1</servlet-name>
        <url-pattern>/cookiecutter</url-pattern>
    </servlet-mapping>
 */
@WebServlet(urlPatterns={"/cookiecutter"})
public class CookieCutter extends HttpServlet
{
    public void doGet(HttpServletRequest request, HttpServletResponse response)
      throws IOException, ServletException
    {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );

        if ( request.getParameter("setcookie") != null ) {
            Cookie cookie = new Cookie("Learningjava", "Cookies!");
            cookie.setMaxAge(3600);
            response.addCookie(cookie);
            out.println("<html><body><h1>Cookie Set...</h1>");
        } else {
            out.println("<html><body>");
            Cookie[] cookies = request.getCookies(  );
            if ( cookies.length == 0 ) {
                out.println("<h1>No cookies found...</h1>");
            } else {
                for (int i = 0; i < cookies.length; i++)
                    out.print("<h1>Name: "+ cookies[i].getName() + "<br>"
                              + "Value: " + cookies[i].getValue() + "</h1>" );
            }
            out.println("<p><a href=\""+ request.getRequestURI()
              +"?setcookie=true\">"
              +"Reset the Learning Java cookie.</a>");
        }
        out.println("</body></html>");
    }
}
]]>
			</text>
		</p>
		<p n="xj_errorresponsefilter">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.annotation.*;
import javax.servlet.http.*;

/*
    <filter>
        <filter-name>errorfilter1</filter-name>
        <filter-class>ErrorResponseFilter</filter-class>
		<init-param>
			<param-name>error-503</param-name>
			<param-value>http://www.pat.net/</param-value>
		</init-param>
    </filter>
    <filter-mapping>
		<filter-name>errorfilter1</filter-name>
		<url-pattern>/*</url-pattern>
    </filter-mapping>
 */
@WebFilter(
    //urlPatterns = "/*",
    servletNames = "waitservlet1",
    initParams = {
        @WebInitParam(name="error-503", value="http://pat.net")
    }
)
public class ErrorResponseFilter implements Filter 
{
	FilterConfig filterConfig;

    public void init( FilterConfig filterConfig )
		throws ServletException
	{ 
		this.filterConfig = filterConfig;
	}

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		WrappedResponse wrappedResponse = 
			new WrappedResponse( (HttpServletResponse)res );
		chain.doFilter( req, wrappedResponse );
    }

    public void destroy() { }

	class WrappedResponse extends HttpServletResponseWrapper 
	{
		WrappedResponse( HttpServletResponse res ) {
			super( res );
		}

		public void sendError( int errorCode, String msg ) throws IOException { 
			String url = filterConfig.getInitParameter("error-"+errorCode);
			if ( url != null )
				sendRedirect( url );
			else
				super.sendError( errorCode, msg );
		}

		public void sendError( int errorCode ) throws IOException {
			sendError( errorCode, "error" );
		} 
	}
}

]]>
			</text>
		</p>
		<p n="xj_getresource">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.net.*;

public class GetResource extends HttpServlet 
{
    public void doGet( HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException 
	{
		URL url = getServletContext().getResource("/WEB-INF/web.xml");

        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
		
        out.println("<html><body><h1>GetRes Response</h1>");
		out.println( getStringFromStream( url.openStream() ) );
		out.println("</body></html>");
		out.close();
    }

	public static String getStringFromStream( InputStream ins )
		throws IOException
	{
		return getStringFromStream( new	InputStreamReader( ins ) );
	}

	public static String getStringFromStream( Reader reader	)
		throws IOException
	{
		StringBuffer sb	= new StringBuffer();
		BufferedReader br = new	BufferedReader(	reader );
		String line;
		while (	( line = br.readLine() ) != null )
			sb.append( line	+"\n");

		return sb.toString();
	}
}

]]>
			</text>
		</p>
		<p n="xj_helloclient">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import javax.servlet.annotation.*;

/*
    <servlet>
        <servlet-name>helloclient1</servlet-name>
        <servlet-class>HelloClient</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>helloclient1</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>

@ServletSecurity(
    //value = @HttpConstraint(rolesAllowed = "secretagent"),
    httpMethodConstraints = @HttpMethodConstraint( value="GET", transportGuarantee = ServletSecurity.TransportGuarantee.CONFIDENTIAL)
)
 */
@WebServlet( urlPatterns={"/hello", "/hola"} )
public class HelloClient extends HttpServlet
{
    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException 
	{
        response.setContentType("text/html"); // must come first
        PrintWriter out = response.getWriter();
        out.println(
            "<html><head><title>Hello Client!</title></head><body>"
            + "<h1>Hello Client!</h1>"
            + "</body></html>" );
    }
}

]]>
			</text>
		</p>
		<p n="xj_linkresponsefilter">
			<text>
				<![CDATA[import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.annotation.WebInitParam;
import javax.servlet.http.*;

/*
    <filter>
        <filter-name>linkfilter1</filter-name>
        <filter-class>LinkResponseFilter</filter-class>
		<init-param>
			<param-name>[Ss]ervlet</param-name>
			<param-value>http://www.ora.com/catalog/learnjava</param-value>
		</init-param>
    </filter>

    <filter-mapping>
		<filter-name>linkfilter1</filter-name>
		<servlet-name>waitservlet1</servlet-name>
    </filter-mapping>

 */
@WebFilter(
    servletNames = "waitservlet1",
    initParams = {
        @WebInitParam(name="[Ss]ervlet", value="http://www.ora.com/catalog/learnjava4")
    }
)
public class LinkResponseFilter implements Filter
{
	FilterConfig filterConfig;

    public void init( FilterConfig filterConfig ) 
		throws ServletException 
	{ 
		this.filterConfig = filterConfig;
	}

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		WrappedResponse wrappedResponse = 
			new WrappedResponse( (HttpServletResponse)res );
		chain.doFilter( req, wrappedResponse );
		wrappedResponse.close();
    }

    public void destroy() { }

	class WrappedResponse extends HttpServletResponseWrapper 
	{
		boolean linkText;
		PrintWriter client;

		WrappedResponse( HttpServletResponse res ) {
			super( res );
		}

		public void setContentType( String mime ) {
			super.setContentType( mime );
			if ( mime.startsWith("text/html") )
				linkText = true;
		}

		public PrintWriter getWriter() throws IOException {
			if ( client == null )
				if ( linkText )
					client = new LinkWriter( 
						super.getWriter(), new ByteArrayOutputStream() );
				else
					client = super.getWriter();
			return client;
		}

		void close() {
			if ( client != null )
				client.close();
		}
	}

	class LinkWriter extends PrintWriter
	{
		ByteArrayOutputStream buffer;
		Writer client;

		LinkWriter( Writer client, ByteArrayOutputStream buffer ) {
			super( buffer );
			this.buffer = buffer;
			this.client = client;
		}

		public void close() {
			try {
				flush();
				client.write( linkText( buffer.toString() ) );
				client.close();
			} catch ( IOException e ) { 
				setError();
			}
		}

		String linkText( String text ) {
			Enumeration en = filterConfig.getInitParameterNames(); 
			while ( en.hasMoreElements() ) {
				String pattern = (String)en.nextElement();
				String value = filterConfig.getInitParameter( pattern );
				text = text.replaceAll( pattern, "<a href="+value+">$0</a>");
			}
			return text;
		}
	}
}

]]>
			</text>
		</p>
		<p n="xj_mylogin">
			<text>import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.annotation.HttpMethodConstraint;
import javax.servlet.annotation.ServletSecurity;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;

@ServletSecurity(
    httpMethodConstraints = @HttpMethodConstraint( value="POST", transportGuarantee = ServletSecurity.TransportGuarantee.CONFIDENTIAL)
)
@WebServlet( urlPatterns={"/mylogin"} )
public class MyLogin extends HttpServlet
{
    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException
    {
       String user = request.getParameter("user");
       String password = request.getParameter("pass");
       request.login( user, password );
       // Dispatch or redirect to the next page...
    }
}

			</text>
		</p>
		<p n="xj_requestdefaultsfilter">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.annotation.WebInitParam;
import javax.servlet.http.*;

/*
<filter>
    <filter-name>defaultsfilter1</filter-name>
    <filter-class>RequestDefaultsFilter</filter-class>
    <init-param>
        <param-name>time</param-name>
        <param-value>3</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>defaultsfilter1</filter-name>
    <servlet-name>waitservlet1</servlet-name>
</filter-mapping>
*/
@WebFilter(
    //urlPatterns = "/*",
    servletNames = "waitservlet1",
    initParams = {
        @WebInitParam(name="time", value="3")
    }
)
public class RequestDefaultsFilter implements Filter
{
	FilterConfig filterConfig;

    public void init( FilterConfig filterConfig ) throws ServletException
	{ 
		this.filterConfig = filterConfig;
	}

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		WrappedRequest wrappedRequest = 
			new WrappedRequest( (HttpServletRequest)req );
		chain.doFilter( wrappedRequest, res );
    }

    public void destroy() { }

	class WrappedRequest extends HttpServletRequestWrapper 
	{
		WrappedRequest( HttpServletRequest req ) {
			super( req );
		}

		public String getParameter( String name ) { 
			String value = super.getParameter( name );
			if ( value == null )
				value = filterConfig.getInitParameter( name );
			return value;
		}
	}

}

]]>
			</text>
		</p>
		<p n="xj_shoppingcart">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;

/*
    <servlet>
        <servlet-name>shoppingcart1</servlet-name>
        <servlet-class>ShoppingCart</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>shoppingcart1</servlet-name>
        <url-pattern>/shoppingcart</url-pattern>
    </servlet-mapping>
 */
@WebServlet(urlPatterns={"/shoppingcart"})
public class ShoppingCart extends HttpServlet
{
    String [] items = new String [] {
        "Chocolate Covered Crickets", "Raspberry Roaches",
        "Buttery Butterflies", "Chicken Flavored Chicklets(tm)" };

    public void doPost( 
		HttpServletRequest request, HttpServletResponse response) 
		throws IOException, ServletException 
	{
        doGet( request, response );
    }

    public void doGet( 
		HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException 
	{
        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );

        // get or create the session information
        HttpSession session = request.getSession(  );
        int [] purchases = (int [])session.getAttribute("purchases");
        if ( purchases == null ) {
            purchases = new int [ items.length ];
            session.setAttribute( "purchases", purchases );
        }

        out.println( "<html><head><title>Shopping Cart</title>"
                     + "</title></head><body><p>" );

        if ( request.getParameter("checkout") != null )
            out.println("<h1>Thanks for ordering!</h1>");
        else  {
            if ( request.getParameter("add") != null ) {
                addPurchases( request, purchases );
                out.println(
                    "<h1>Purchase added.  Please continue</h1>");
            } else {
                if ( request.getParameter("clear") != null )
                    for (int i=0; i<purchases.length; i++)
                         purchases[i] = 0;
                out.println("<h1>Please Select Your Items!</h1>");
            }
            doForm( out, request.getRequestURI(  ) );
        }
        showPurchases( out, purchases );
        out.close(  );
    }

    void addPurchases( HttpServletRequest request, int [] purchases ) {
        for (int i=0; i<items.length; i++) {
            String added = request.getParameter( items[i] );
            if ( added !=null && !added.equals("") )
                purchases[i] += Integer.parseInt( added );
        }
    }

    void doForm( PrintWriter out, String requestURI ) {
        out.println( "<form method=POST action="+ requestURI +">" );

        for(int i=0; i< items.length; i++)
            out.println( "Quantity <input name=\"" + items[i]
              + "\" value=0 size=3> of: " + items[i] + "<br>");
        out.println(
          "<p><input type=submit name=add value=\"Add To Cart\">"
          + "<input type=submit name=checkout value=\"Check Out\">"
          + "<input type=submit name=clear value=\"Clear Cart\">"
          + "</form>" );
    }

    void showPurchases( PrintWriter out, int [] purchases )
        throws IOException {

        out.println("<hr><h2>Your Shopping Basket</h2>");
        for (int i=0; i<items.length; i++)
            if ( purchases[i] != 0 )
                out.println( purchases[i] +"  "+ items[i] +"<br>" );
    }
}
]]>
			</text>
		</p>
		<p n="xj_showparameters">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.util.*;

/*
    <servlet>
        <servlet-name>showparameters1</servlet-name>
        <servlet-class>ShowParameters</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>showparameters1</servlet-name>
        <url-pattern>/showparameters</url-pattern>
    </servlet-mapping>
 */
@WebServlet(urlPatterns={"/showparameters"})
public class ShowParameters extends HttpServlet
{
    public void doGet(HttpServletRequest request, HttpServletResponse response)
      throws IOException
    {
        showRequestParameters( request, response );
    }

    void showRequestParameters(HttpServletRequest request, HttpServletResponse response)
        throws IOException
    {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();

        out.println(
          "<html><head><title>Show Parameters</title></head><body>"
          + "<h1>Parameters</h1><ul>");

        Map<String, String[]> params = request.getParameterMap();
        for ( String name : params.keySet() )
        {
            String [] values = params.get( name );
            out.println("<li>"+ name +" = "+ Arrays.asList(values) );
        }

        out.close(  );
    }
}
]]>
			</text>
		</p>
		<p n="xj_showsession">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.util.Enumeration;

/*
    <servlet>
        <servlet-name>showsession1</servlet-name>
        <servlet-class>ShowSession</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>showsession1</servlet-name>
        <url-pattern>/showsession</url-pattern>
    </servlet-mapping>
 */
@WebServlet(urlPatterns={"/showsession"})
public class ShowSession extends HttpServlet
{
    public void doPost(
		HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{ 
        doGet( request, response );
    }

    public void doGet(
		HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException 
	{
        HttpSession session = request.getSession(  );
        boolean clear = request.getParameter("clear") != null;
		if ( clear )
			session.invalidate();
		else {
			String name = request.getParameter("Name");
			String value = request.getParameter("Value");
			if ( name != null && value != null )
				session.setAttribute( name, value );
		}

        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );
        out.println(
          "<html><head><title>Show Session</title></head><body>");

		if ( clear )
        	out.println("<h1>Session Cleared:</h1>");
		else {
			out.println("<h1>In this session:</h1><ul>");

			Enumeration names = session.getAttributeNames();
			while ( names.hasMoreElements() ) {
				String name = (String)names.nextElement();
				out.println( "<li>"+name+" = " +session.getAttribute( name ) );
			}
		}

        out.println(
          "</ul><p><hr><h1>Add String</h1>"
          + "<form method=\"POST\" action=\""
          + request.getRequestURI(  ) +"\">"
          + "Name: <input name=\"Name\" size=20><br>"
          + "Value: <input name=\"Value\" size=20><br>"
          + "<br><input type=\"submit\" value=\"Submit\">"
          + "<input type=\"submit\" name=\"clear\" value=\"Clear\"></form>"
        );
    }
}
]]>
			</text>
		</p>
		<p n="xj_testfilter">
			<text>import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class TestFilter implements Filter 
{
	int limit;
	int count;

    public void init( FilterConfig filterConfig )
		throws ServletException
	{
    }

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		System.out.println("test filter");
		chain.doFilter( req, res );
    }

    public void destroy() { }
}

			</text>
		</p>
		<p n="xj_waitservlet">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;

/*
    <servlet>
        <servlet-name>waitservlet1</servlet-name>
        <servlet-class>WaitServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>waitservlet1</servlet-name>
        <url-pattern>/wait</url-pattern>
    </servlet-mapping>
 */
@WebServlet(
    name = "waitservlet1",
    urlPatterns={"/wait"}
)
public class WaitServlet extends HttpServlet
{
    public void doGet( HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException 
	{
		String waitStr = request.getParameter("time");
		if ( waitStr == null )
			throw new ServletException("Missing parameter: time");
		int wait = Integer.parseInt(waitStr);

		try {
			Thread.sleep( wait * 1000 );
		} catch( InterruptedException e ) { 
			throw new ServletException(e); 
		}

        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html><body><h1>WaitServlet Response</h1></body></html>");
    }
}

]]>
			</text>
		</p>
		<p n="xj_conlimitfilter2">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ConLimitFilter implements Filter 
{
	int limit;
	int count;

    public void init( FilterConfig filterConfig )
		throws ServletException
	{
		String s = filterConfig.getInitParameter("limit");
		if ( s == null )
			throw new ServletException("Missing init parameter: "+limit);
		limit = Integer.parseInt( s );
    }

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		if ( count > limit ) {
			HttpServletResponse httpRes = (HttpServletResponse)res;
			httpRes.sendError( httpRes.SC_SERVICE_UNAVAILABLE, "Too Busy.");
		} else {
			++count;
			chain.doFilter( req, res );
			--count;
		}
    }

    public void destroy() { }
}

]]>
			</text>
		</p>
		<p n="xj_cookiecutter2">
			<text>
				<![CDATA[//file: CookieCutter.java
import java.io.*;
import java.text.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class CookieCutter extends HttpServlet {

    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
      throws IOException, ServletException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );

        if ( request.getParameter("setcookie") != null ) {
            Cookie cookie = new Cookie("Learningjava", "Cookies!");
            cookie.setMaxAge(3600);
            response.addCookie(cookie);
            out.println("<html><body><h1>Cookie Set...</h1>");
        } else {
            out.println("<html><body>");
            Cookie[] cookies = request.getCookies(  );
            if ( cookies.length == 0 )
                out.println("<h1>No cookies found...</h1>");
            else
                for (int i = 0; i < cookies.length; i++)
                    out.print("<h1>Name: "+ cookies[i].getName(  )
                              + "<br>"
                              + "Value: " + cookies[i].getValue(  )
                              + "</h1>" );
            out.println("<p><a href=\""+ request.getRequestURI(  )
              +"?setcookie=true\">"
              +"Reset the Learning Java cookie.</a>");
        }
        out.println("</body></html>");
        out.close(  );
    }
}
]]>
			</text>
		</p>
		<p n="xj_errorresponsefilter2">
			<text>import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ErrorResponseFilter implements Filter 
{
	FilterConfig filterConfig;

    public void init( FilterConfig filterConfig )
		throws ServletException
	{ 
		this.filterConfig = filterConfig;
	}

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		WrappedResponse wrappedResponse = 
			new WrappedResponse( (HttpServletResponse)res );
		chain.doFilter( req, wrappedResponse );
    }

    public void destroy() { }

	class WrappedResponse extends HttpServletResponseWrapper 
	{
		WrappedResponse( HttpServletResponse res ) {
			super( res );
		}

		public void sendError( int errorCode, String msg ) throws IOException { 
			String url = filterConfig.getInitParameter("error-"+errorCode);
			if ( url != null )
				sendRedirect( url );
			else
				super.sendError( errorCode, msg );
		}

		public void sendError( int errorCode ) throws IOException {
			sendError( errorCode, "error" );
		} 
	}
}

			</text>
		</p>
		<p n="xj_getresource2">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.net.*;

public class GetResource extends HttpServlet 
{
    public void doGet( HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException 
	{
		URL url = getServletContext().getResource("/WEB-INF/web.xml");
System.out.println("url = "+url);

        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
		
        out.println("<html><body><h1>GetRes Response</h1>");
		out.println( getStringFromStream( url.openStream() ) );
		out.println("</body></html>");
		out.close();
    }

	public static String getStringFromStream( InputStream ins )
		throws IOException
	{
		return getStringFromStream( new	InputStreamReader( ins ) );
	}

	public static String getStringFromStream( Reader reader	)
		throws IOException
	{
		StringBuffer sb	= new StringBuffer();
		BufferedReader br = new	BufferedReader(	reader );
		String line;
		while (	( line = br.readLine() ) != null )
			sb.append( line	+"\n");

		return sb.toString();
	}
}

]]>
			</text>
		</p>
		<p n="xj_hellpclient">
			<text>
				<![CDATA[//file: HelloClient.java
import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.http.*;

public class HelloClient extends HttpServlet {

    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
        throws ServletException, IOException {

        // must come first
        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );

        out.println(
            "<html><head><title>Hello Client</title></head><body>"
            + "<h1> Hello Client </h1>"
            + "</body></html>" );
        out.close(  );
    }
}
]]>
			</text>
		</p>
		<p n="xj_linresponsefilter">
			<text>
				<![CDATA[import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class LinkResponseFilter implements Filter 
{
	FilterConfig filterConfig;

    public void init( FilterConfig filterConfig ) 
		throws ServletException 
	{ 
		this.filterConfig = filterConfig;
	}

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		WrappedResponse wrappedResponse = 
			new WrappedResponse( (HttpServletResponse)res );
		chain.doFilter( req, wrappedResponse );
		wrappedResponse.close();
    }

    public void destroy() { }

	class WrappedResponse extends HttpServletResponseWrapper 
	{
		boolean linkText;
		PrintWriter client;

		WrappedResponse( HttpServletResponse res ) {
			super( res );
		}

		public void setContentType( String mime ) {
			super.setContentType( mime );
			if ( mime.startsWith("text/html") )
				linkText = true;
		}

		public PrintWriter getWriter() throws IOException {
			if ( client == null )
				if ( linkText )
					client = new LinkWriter( 
						super.getWriter(), new ByteArrayOutputStream() );
				else
					client = super.getWriter();
			return client;
		}

		void close() {
			if ( client != null )
				client.close();
		}
	}

	class LinkWriter extends PrintWriter
	{
		ByteArrayOutputStream buffer;
		Writer client;

		LinkWriter( Writer client, ByteArrayOutputStream buffer ) {
			super( buffer );
			this.buffer = buffer;
			this.client = client;
		}

		public void close() {
			try {
				flush();
				client.write( linkText( buffer.toString() ) );
				client.close();
			} catch ( IOException e ) { 
				setError();
			}
		}

		String linkText( String text ) {
			Enumeration en = filterConfig.getInitParameterNames(); 
			while ( en.hasMoreElements() ) {
				String pattern = (String)en.nextElement();
				String value = filterConfig.getInitParameter( pattern );
				text = text.replaceAll( pattern, "<a href="+value+">$0</a>");
			}
			return text;
		}
	}
}

]]>
			</text>
		</p>
		<p n="xj_requestdefaultsfilter2">
			<text>import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class RequestDefaultsFilter implements Filter 
{
	FilterConfig filterConfig;

    public void init( FilterConfig filterConfig ) throws ServletException
	{ 
		this.filterConfig = filterConfig;
	}

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		WrappedRequest wrappedRequest = 
			new WrappedRequest( (HttpServletRequest)req );
		chain.doFilter( wrappedRequest, res );
    }

    public void destroy() { }

	class WrappedRequest extends HttpServletRequestWrapper 
	{
		WrappedRequest( HttpServletRequest req ) {
			super( req );
		}

		public String getParameter( String name ) { 
			String value = super.getParameter( name );
			if ( value == null )
				value = filterConfig.getInitParameter( name );
			return value;
		}
	}

}

			</text>
		</p>
		<p n="xj_shoppingcart2">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.util.Enumeration;

public class ShoppingCart extends HttpServlet {
    String [] items = new String [] {
        "Chocolate Covered Crickets", "Raspberry Roaches",
        "Buttery Butterflies", "Chicken Flavored Chicklets(tm)" };

    public void doPost( 
		HttpServletRequest request, HttpServletResponse response) 
		throws IOException, ServletException 
	{
        doGet( request, response );
    }

    public void doGet( 
		HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException 
	{
        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );

        // get or create the session information
        HttpSession session = request.getSession(  );
        int [] purchases = (int [])session.getAttribute("purchases");
        if ( purchases == null ) {
            purchases = new int [ items.length ];
            session.setAttribute( "purchases", purchases );
        }

        out.println( "<html><head><title>Shopping Cart</title>"
                     + "</title></head><body><p>" );

        if ( request.getParameter("checkout") != null )
            out.println("<h1>Thanks for ordering!</h1>");
        else  {
            if ( request.getParameter("add") != null ) {
                addPurchases( request, purchases );
                out.println(
                    "<h1>Purchase added.  Please continue</h1>");
            } else {
                if ( request.getParameter("clear") != null )
                    for (int i=0; i<purchases.length; i++)
                         purchases[i] = 0;
                out.println("<h1>Please Select Your Items!</h1>");
            }
            doForm( out, request.getRequestURI(  ) );
        }
        showPurchases( out, purchases );
        out.close(  );
    }

    void addPurchases( HttpServletRequest request, int [] purchases ) {
        for (int i=0; i<items.length; i++) {
            String added = request.getParameter( items[i] );
            if ( added !=null && !added.equals("") )
                purchases[i] += Integer.parseInt( added );
        }
    }

    void doForm( PrintWriter out, String requestURI ) {
        out.println( "<form method=POST action="+ requestURI +">" );

        for(int i=0; i< items.length; i++)
            out.println( "Quantity <input name=\"" + items[i]
              + "\" value=0 size=3> of: " + items[i] + "<br>");
        out.println(
          "<p><input type=submit name=add value=\"Add To Cart\">"
          + "<input type=submit name=checkout value=\"Check Out\">"
          + "<input type=submit name=clear value=\"Clear Cart\">"
          + "</form>" );
    }

    void showPurchases( PrintWriter out, int [] purchases )
        throws IOException {

        out.println("<hr><h2>Your Shopping Basket</h2>");
        for (int i=0; i<items.length; i++)
            if ( purchases[i] != 0 )
                out.println( purchases[i] +"  "+ items[i] +"<br>" );
    }
}
]]>
			</text>
		</p>
		<p n="xj_showparameters2">
			<text>
				<![CDATA[//file: ShowParameters.java
import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.util.Enumeration;

public class ShowParameters extends HttpServlet {

    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
      throws ServletException, IOException {
        showRequestParameters( request, response );
    }

    void showRequestParameters(HttpServletRequest request,
                               HttpServletResponse response)
      throws IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );

        out.println(
          "<html><head><title>Show Parameters</title></head><body>"
          + "<h1>Parameters</h1><ul>");

        for ( Enumeration e=request.getParameterNames(  );
              e.hasMoreElements(  ); ) {
            String name = (String)e.nextElement(  );
            String value = request.getParameter( name );
            if (! value.equals("") )
                out.println("<li>"+ name +" = "+ value );
        }

        out.close(  );
    }
}
]]>
			</text>
		</p>
		<p n="xj_showsession2">
			<text>
				<![CDATA[//file: ShowSession.java
import java.io.*;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import java.util.Enumeration;

public class ShowSession extends HttpServlet {

    public void doPost( 
		HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{ 
        doGet( request, response );
    }

    public void doGet(
		HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException 
	{
        HttpSession session = request.getSession(  );
        boolean clear = request.getParameter("clear") != null;
		if ( clear )
			session.invalidate();
		else {
			String name = request.getParameter("Name");
			String value = request.getParameter("Value");
			if ( name != null && value != null )
				session.setAttribute( name, value );
		}

        response.setContentType("text/html");
        PrintWriter out = response.getWriter(  );
        out.println(
          "<html><head><title>Show Session</title></head><body>");

		if ( clear )
        	out.println("<h1>Session Cleared:</h1>");
		else {
			out.println("<h1>In this session:</h1><ul>");
			Enumeration names = session.getAttributeNames();
			while ( names.hasMoreElements() ) {
				String name = (String)names.nextElement();
				out.println( "<li>"+name+" = " +session.getAttribute( name ) );
			}
		}

        out.println(
          "</ul><p><hr><h1>Add String</h1>"
          + "<form method=\"POST\" action=\""
          + request.getRequestURI(  ) +"\">"
          + "Name: <input name=\"Name\" size=20><br>"
          + "Value: <input name=\"Value\" size=20><br>"
          + "<br><input type=\"submit\" value=\"Submit\">"
          + "<input type=\"submit\" name=\"clear\" value=\"Clear\"></form>"
        );
    }
}
]]>
			</text>
		</p>
		<p n="xj_testfilter2">
			<text>import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class TestFilter implements Filter 
{
	int limit;
	int count;

    public void init( FilterConfig filterConfig )
		throws ServletException
	{
    }

    public void doFilter ( 
		ServletRequest req, ServletResponse res, FilterChain chain ) 
			throws IOException, ServletException 
	{
		System.out.println("test filter");
		chain.doFilter( req, res );
    }

    public void destroy() { }
}

			</text>
		</p>
		<p n="xj_waitservlet2">
			<text>
				<![CDATA[import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class WaitServlet extends HttpServlet 
{
    public void doGet( HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException 
	{
		String waitStr = request.getParameter("time");
		if ( waitStr == null )
			throw new ServletException("Missing parameter: time");
		int wait = Integer.parseInt(waitStr);

		try {
			Thread.sleep( wait * 1000 );
		} catch( InterruptedException e ) { 
			throw new ServletException(e); 
		}

        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html><body><h1>WaitServlet Response</h1></body></html>");
    }
}

]]>
			</text>
		</p>
		<p n="xj_echoclient">
			<text>package learningjava.client;

import learningjava.client.impl.*;
import learningjava.client.impl.Echo;
import learningjava.client.impl.MyObject;

public class EchoClient
{
	public static void main( String [] args ) throws java.rmi.RemoteException
	{
        Echo service = new EchoService().getEchoPort();
        int i = service.echoInt( 42 );
		System.out.println( i );
		String s = service.echoString( "Hello!" );
		System.out.println( s );
        MyObject myObject = new MyObject();
        myObject.setIntValue( 42 );
        myObject.setStringValue( "Foo!" );
        MyObject myObj = service.echoMyObject( myObject );
		System.out.println( myObj.getStringValue() );

        new learningjava.service.Echo();
	}
}
			</text>
		</p>
		<p n="xj_echo">
			<text>package learningjava.service;

import javax.jws.*;
import javax.xml.ws.Endpoint;

@WebService
public class Echo
{
    @WebMethod
    public int echoInt( int value ) { return value; }

    @WebMethod
    public String echoString( String value ) { return value; }

    @WebMethod
    public MyObject echoMyObject( MyObject value ) { return value; }

    public static void main( String[] args )
    {
        Endpoint.publish( "http://localhost:8080/echo", new Echo() );
    }
}

			</text>
		</p>
		<p n="xc_myobject">
			<text>package learningjava.service;

public class MyObject 
{
	int intValue;
	String stringValue;

	public MyObject() { }

	public MyObject( int i, String s ) {
		this.intValue = i;
		this.stringValue = s;
	}

	public int getIntValue() { return intValue; }
	public void setIntValue( int intValue ) { this.intValue = intValue; }

	public String getStringValue() { 
		return stringValue; 
	}
	public void setStringValue( String stringValue ) { 
		this.stringValue = stringValue;
	}

	public String toString() {
		return String.format( "MyObject: %%i, %%s", intValue, stringValue );
	}
}
			</text>
		</p>
		<p n="xj_mangomango1">
			<text>//file: MangoMango1.java
import java.awt.*;
import javax.swing.*;

public class MangoMango1 {
  public static void main(String[] args) {
    JFrame frame = new JFrame("The Frame");

    Container content = frame.getContentPane(  );
    content.setLayout(new FlowLayout(  ));
    content.add(new JLabel("Mango"));
    content.add(new JButton("Mango"));

    frame.setLocation(100, 100);
    frame.pack();
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_mangomango2">
			<text>//file: MangoMango2.java
import java.awt.*;
import javax.swing.*;

public class MangoMango2 {
  public static void main(String[] args) {
    JFrame frame = new JFrame("The Frame");

    Container content = new JPanel(  );
    content.add(new JLabel("Mango"));
    content.add(new JButton("Mango"));
    frame.setContentPane(content);

    frame.setLocation(100, 100);
    frame.pack();
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_toplevelwindows">
			<text>//file: TopLevelWindows.java
import javax.swing.*;

public class TopLevelWindows {
  public static void main(String[] args) {
    JFrame f = new JFrame("The Frame");
    f.setSize(300, 300);
    f.setLocation(100, 100);

    JWindow w = new JWindow(  );
    w.setSize(300, 300);
    w.setLocation(500, 100);

    f.setVisible(true);
    w.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_borders">
			<text>//file: Borders.java
import java.awt.*;
import javax.swing.*;
import javax.swing.border.*;

public class Borders {
  public static void main(String[] args) {
    // create a JFrame to hold everything
    JFrame frame = new JFrame("Borders");

    // Create labels with borders.
    int center = SwingConstants.CENTER;
    JLabel labelOne = new JLabel("raised BevelBorder", center);
    labelOne.setBorder(
        BorderFactory.createBevelBorder(BevelBorder.RAISED));
    JLabel labelTwo = new JLabel("EtchedBorder", center);
    labelTwo.setBorder(BorderFactory.createEtchedBorder(  ));
    JLabel labelThree = new JLabel("MatteBorder", center);
    labelThree.setBorder(
        BorderFactory.createMatteBorder(10, 10, 10, 10, Color.pink));
    JLabel labelFour = new JLabel("TitledBorder", center);
    Border etch = BorderFactory.createEtchedBorder(  );
    labelFour.setBorder(
        BorderFactory.createTitledBorder(etch, "Title"));
    JLabel labelFive = new JLabel("TitledBorder", center);
    Border low = BorderFactory.createLoweredBevelBorder(  );
    labelFive.setBorder(
        BorderFactory.createTitledBorder(low, "Title",
        TitledBorder.RIGHT, TitledBorder.BOTTOM));
    JLabel labelSix = new JLabel("CompoundBorder", center);
    Border one = BorderFactory.createEtchedBorder(  );
    Border two =
        BorderFactory.createMatteBorder(4, 4, 4, 4, Color.blue);
    labelSix.setBorder(BorderFactory.createCompoundBorder(one, two));

    // add components to the content pane
    Container c = frame.getContentPane(); // unecessary in 1.5+
    c.setLayout(new GridLayout(3, 2));
    c.add(labelOne);
    c.add(labelTwo);
    c.add(labelThree);
    c.add(labelFour);
    c.add(labelFive);
    c.add(labelSix);

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
	frame.pack();
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_contextmenu">
			<text>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class ContextMenu implements ActionListener
{
  JTextArea textArea = new JTextArea();

  public ContextMenu() 
  {
  	final JPopupMenu contextMenu = new JPopupMenu("Edit");
    contextMenu.add(makeMenuItem("Save"));
    contextMenu.add(makeMenuItem("Save As"));
    contextMenu.add(makeMenuItem("Close"));

    JFrame frame = new JFrame("ContextMenu v1.0");
	JPanel panel = new JPanel();
	panel.setLayout( new BorderLayout() );
	frame.add( panel );
	panel.setComponentPopupMenu( contextMenu );

	textArea.setInheritsPopupMenu( true );
	panel.add( BorderLayout.CENTER, textArea );

	JTextField textField = new JTextField();
	textField.setInheritsPopupMenu( true );
	panel.add( BorderLayout.SOUTH, textField );

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
	frame.setSize(400,200);
    frame.setVisible(true);
  }

  public void actionPerformed( ActionEvent e ) {
    textArea.append( e.getActionCommand() +"\n" );
  }

  private JMenuItem makeMenuItem(String label) {
    JMenuItem item = new JMenuItem(label);
    item.addActionListener( this );
    return item;
  }

  public static void main(String[] args) {
     new ContextMenu();
  }
}
			</text>
		</p>
		<p n="xj_dateselector">
			<text>import javax.swing.*;
import javax.swing.event.*;
import java.util.*;

public class DateSelector {

  public static void main(String[] args) 
  {
    JFrame frame = new JFrame("Date Selector 1.0");

	Calendar now = Calendar.getInstance();
	Calendar earliest = (Calendar)now.clone(); 
	earliest.add( Calendar.MONTH, -6 );
	Calendar latest = (Calendar)now.clone(); 
	latest.add( Calendar.MONTH, 6 );
	SpinnerModel model = new SpinnerDateModel( 
		now.getTime(), earliest.getTime(), latest.getTime(), 
		Calendar.WEEK_OF_YEAR);
	final JSpinner spinner = new JSpinner(model);
	
	model.addChangeListener( new ChangeListener() {
		public void stateChanged(ChangeEvent e) {
			System.out.println( ((SpinnerDateModel)e.getSource()).getDate() );
		}
	} );

	frame.getContentPane().add( "North", new JLabel("Choose a week") );
	frame.getContentPane().add( "Center", spinner );
	frame.pack();
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_dinnermenu">
			<text>//file: DinnerMenu.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class DinnerMenu 
{
  public static void main(String[] args) {
    JFrame frame = new JFrame("Dinner Menu");

    // create the Utensils menu
    JMenu utensils = new JMenu("Utensils");
    utensils.setMnemonic(KeyEvent.VK_U);
    utensils.add(new JMenuItem("Fork"));
    utensils.add(new JMenuItem("Knife"));
    utensils.add(new JMenuItem("Spoon"));
    JMenu hybrid = new JMenu("Hybrid");
    hybrid.add(new JMenuItem("Spork"));
    hybrid.add(new JMenuItem("Spife"));
    hybrid.add(new JMenuItem("Knork"));
    utensils.add(hybrid);
    utensils.addSeparator(  );

    // do some fancy stuff with the Quit item
    JMenuItem quitItem = new JMenuItem("Quit");
    quitItem.setMnemonic(KeyEvent.VK_Q);
    quitItem.setAccelerator(
        KeyStroke.getKeyStroke(KeyEvent.VK_Q, Event.CTRL_MASK));
    quitItem.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent e) { System.exit(0); }
    });
    utensils.add(quitItem);

    // create the Spices menu
    JMenu spices = new JMenu("Spices");
    spices.setMnemonic(KeyEvent.VK_S);
    spices.add(new JCheckBoxMenuItem("Thyme"));
    spices.add(new JCheckBoxMenuItem("Rosemary"));
    spices.add(new JCheckBoxMenuItem("Oregano", true));
    spices.add(new JCheckBoxMenuItem("Fennel"));

    // create the Cheese menu
    JMenu cheese = new JMenu("Cheese");
    cheese.setMnemonic(KeyEvent.VK_C);
    ButtonGroup group = new ButtonGroup(  );
    JRadioButtonMenuItem rbmi;
    rbmi = new JRadioButtonMenuItem("Regular", true);
    group.add(rbmi);
    cheese.add(rbmi);
    rbmi = new JRadioButtonMenuItem("Extra");
    group.add(rbmi);
    cheese.add(rbmi);
    rbmi = new JRadioButtonMenuItem("Blue");
    group.add(rbmi);
    cheese.add(rbmi);

    // create a menu bar and use it in this JFrame
    JMenuBar menuBar = new JMenuBar(  );
    menuBar.add(utensils);
    menuBar.add(spices);
    menuBar.add(cheese);
    frame.setJMenuBar(menuBar);

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
	frame.setSize(200,200);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_drivethrough">
			<text>//file: DriveThrough.java
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;

public class DriveThrough 
{
  public static void main(String[] args) {
    JFrame frame = new JFrame("DriveThrough v1.0");

    JPanel entreePanel = new JPanel();
    final ButtonGroup entreeGroup = new ButtonGroup();
    JRadioButton radioButton;
    entreePanel.add(radioButton = new JRadioButton("Beef"));
    radioButton.setActionCommand("Beef");
    entreeGroup.add(radioButton);
    entreePanel.add(radioButton = new JRadioButton("Chicken"));
    radioButton.setActionCommand("Chicken");
    entreeGroup.add(radioButton);
    entreePanel.add(radioButton = new JRadioButton("Veggie", true));
    radioButton.setActionCommand("Veggie");
    entreeGroup.add(radioButton);

    final JPanel condimentsPanel = new JPanel();
    condimentsPanel.add(new JCheckBox("Ketchup"));
    condimentsPanel.add(new JCheckBox("Mustard"));
    condimentsPanel.add(new JCheckBox("Pickles"));

    JPanel orderPanel = new JPanel();
    JButton orderButton = new JButton("Place Order");
    orderPanel.add(orderButton);

    Container content = frame.getContentPane(); // unecessary in 1.5+
    content.setLayout(new GridLayout(3, 1));
    content.add(entreePanel);
    content.add(condimentsPanel);
    content.add(orderPanel);

    orderButton.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent ae) {
        String entree =
          entreeGroup.getSelection().getActionCommand();
        System.out.println(entree + " sandwich");
        Component[] components = condimentsPanel.getComponents();
        for ( Component c : components ) {
          JCheckBox cb = (JCheckBox)c;
          if (cb.isSelected())
            System.out.println("With " + cb.getText());
        }
      }
    });

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(300, 150);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_editor">
			<text>import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.swing.*;

public class Editor extends JFrame implements ActionListener 
{
  private JEditorPane textPane = new JEditorPane( );
  
  public Editor( ) {
    super("Editor v1.0");
    Container content = getContentPane( ); // unecessary in 1.5+
    content.add(new JScrollPane(textPane), BorderLayout.CENTER);
    JMenu menu = new JMenu("File");
    menu.add(makeMenuItem("Open"));
    menu.add(makeMenuItem("Save"));
    menu.add(makeMenuItem("Quit"));
    JMenuBar menuBar = new JMenuBar( );
    menuBar.add(menu);
    setJMenuBar(menuBar);
    setSize(300, 300);
	setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
  }
  
  public void actionPerformed(ActionEvent e) {
    String command = e.getActionCommand( );
    if (command.equals("Quit")) System.exit(0);
    else if (command.equals("Open")) loadFile( );
    else if (command.equals("Save")) saveFile( );
  }
  
  private void loadFile ( ) {
    JFileChooser chooser = new JFileChooser( );
    int result = chooser.showOpenDialog(this);
    if (result == JFileChooser.CANCEL_OPTION) return;
    try {
      File file = chooser.getSelectedFile( );
      java.net.URL url = file.toURL( );
      textPane.setPage(url);
    }
    catch (Exception e) {
      textPane.setText("Could not load file: " + e);
    }
  }
  
  private void saveFile( ) {
    JFileChooser chooser = new JFileChooser( );
    chooser.showSaveDialog(this);
    // Save file data...
  }
  
  private JMenuItem makeMenuItem( String name ) {
    JMenuItem m = new JMenuItem( name );
    m.addActionListener( this );
    return m;
  }

  public static void main(String[] s) { 
	new Editor().setVisible(true);
  }
}

			</text>
		</p>
		<p n="xj_exerciseoptions">
			<text>import javax.swing.*;

public class ExerciseOptions {
  public static void main(String[] args) {
    JFrame frame = new JFrame("ExerciseOptions v1.0");
    frame.setSize(200, 200);
    frame.setVisible(true);
    
    JOptionPane.showMessageDialog(frame, "You have mail.");
    JOptionPane.showMessageDialog(frame, "You are low on memory.",
        "Apocalyptic message", JOptionPane.WARNING_MESSAGE);
    
    int result = JOptionPane.showConfirmDialog(null,
        "Do you want to remove Windows now?");
    switch (result) {
      case JOptionPane.YES_OPTION:
        System.out.println("Yes"); break;
      case JOptionPane.NO_OPTION:
        System.out.println("No"); break;
      case JOptionPane.CANCEL_OPTION:
        System.out.println("Cancel"); break;
      case JOptionPane.CLOSED_OPTION:
        System.out.println("Closed"); break;
    }
    
    String name = JOptionPane.showInputDialog(null,
        "Please enter your name.");
    System.out.println(name);
    
    JTextField userField = new JTextField( );
    JPasswordField passField = new JPasswordField( );
    String message = "Please enter your user name and password.";
    result = JOptionPane.showOptionDialog(frame,
        new Object[] { message, userField, passField },
        "Login", JOptionPane.OK_CANCEL_OPTION,
        JOptionPane.QUESTION_MESSAGE,
        null, null, null);
    if (result == JOptionPane.OK_OPTION)
      System.out.println(userField.getText( ) +
          " " +  new String(passField.getPassword( )));
    
    System.exit(0);
  }
}

			</text>
		</p>
		<p n="xj_lister">
			<text>//file: Lister.java
import java.awt.*; 
import java.awt.event.*;
import javax.swing.*;

public class Lister {
  public static void main(String[] args) {
    JFrame frame = new JFrame("Lister v1.0");
    
    // create a combo box
    String [] items = { "uno", "due", "tre", "quattro", "cinque",
                        "sei", "sette", "otto", "nove", "deici",
                        "undici", "dodici" };
    JComboBox comboBox = new JComboBox(items);
    comboBox.setEditable(true);

    // create a list with the same data model
    final JList list = new JList(comboBox.getModel( ));
    
    // create a button; when it's pressed, print out
    // the selection in the list
    JButton button = new JButton("Per favore");
    button.addActionListener(new ActionListener( ) {
      public void actionPerformed(ActionEvent ae) {
        Object[] selection = list.getSelectedValues( );
        System.out.println("-----");
        for ( Object s : selection )
          System.out.println( s );
      }
    });
    
    // put the controls the content pane
    Container c = frame.getContentPane(); // unecessary in 1.5+
    JPanel comboPanel = new JPanel();
    comboPanel.add(comboBox);
    c.add(comboPanel, BorderLayout.NORTH);
    c.add(new JScrollPane(list), BorderLayout.CENTER);
    c.add(button, BorderLayout.SOUTH);

    frame.setSize(200, 200);
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }    
}

			</text>
		</p>
		<p n="xj_localcolor">
			<text>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class LocalColor {
  public static void main(String[] args) {
    final JFrame frame = new JFrame("LocalColor v1.0");
    final Container content = frame.getContentPane( ); // unecessary in 1.5+
    content.setLayout(new GridBagLayout( ));
    JButton button = new JButton("Change color...");
    content.add(button);
    
    button.addActionListener(new ActionListener( ) {
      public void actionPerformed(ActionEvent e) {
        Color c = JColorChooser.showDialog(frame,
            "Choose a color", content.getBackground( ));
        if (c != null) content.setBackground(c);
      }
    });
    
    frame.setSize(200, 200);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}

			</text>
		</p>
		<p n="xj_picturebutton">
			<text>
import java.awt.event.*;
import javax.swing.*;

public class PictureButton
{
  public static void main(String[] args) 
  {
    JFrame frame = new JFrame();

    Icon icon = new ImageIcon("rhino.gif");
    JButton button = new JButton(icon);
    button.addActionListener( new ActionListener() {
      public void actionPerformed(ActionEvent ae) {
        System.out.println("Urp!");
      }
    });

    frame.getContentPane().add( button );
	frame.pack();
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_popupcolormenu">
			<text>//file: PopUpColorMenu.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class PopUpColorMenu implements ActionListener
{
  Component selectedComponent;

  public PopUpColorMenu() {
    JFrame frame = new JFrame("PopUpColorMenu v1.0");

  	final JPopupMenu colorMenu = new JPopupMenu("Color");
    colorMenu.add(makeMenuItem("Red"));
    colorMenu.add(makeMenuItem("Green"));
    colorMenu.add(makeMenuItem("Blue"));

    MouseListener mouseListener = new MouseAdapter() {
      public void mousePressed(MouseEvent e) { checkPopup(e); }
      public void mouseClicked(MouseEvent e) { checkPopup(e); }
      public void mouseReleased(MouseEvent e) { checkPopup(e); }
      private void checkPopup(MouseEvent e) {
        if (e.isPopupTrigger(  )) {
          selectedComponent = e.getComponent(  );
          colorMenu.show(e.getComponent(), e.getX(), e.getY(  ));
        }
      }
    };

    Container content = frame.getContentPane(); // unecessary in 1.5+
    content.setLayout(new FlowLayout(  ));
    JButton button = new JButton("Uno");
    button.addMouseListener(mouseListener);
    content.add(button);
    button = new JButton("Due");
    button.addMouseListener(mouseListener);
    content.add(button);
    button = new JButton("Tre");
    button.addMouseListener(mouseListener);
    content.add(button);

    frame.getContentPane().addMouseListener(mouseListener);

	frame.setSize(200,50);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }

  public void actionPerformed(ActionEvent e) {
    String color = e.getActionCommand(  );
    if (color.equals("Red"))
      selectedComponent.setBackground(Color.red);
    else if (color.equals("Green"))
      selectedComponent.setBackground(Color.green);
    else if (color.equals("Blue"))
      selectedComponent.setBackground(Color.blue);
  }

  private JMenuItem makeMenuItem(String label) {
    JMenuItem item = new JMenuItem(label);
    item.addActionListener( this );
    return item;
  }

  public static void main(String[] args) {
     new PopUpColorMenu();
  }
}
			</text>
		</p>
		<p n="xj_popupcolormenu2">
			<text>//file: PopUpColorMenu.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class PopUpColorMenu2 implements ActionListener
{
  public PopUpColorMenu2() {
    JFrame frame = new JFrame("PopUpColorMenu v2.0");

	JPanel panel = new JPanel();
    JButton button = new JButton("Uno");
	button.setInheritsPopupMenu(true);
    panel.add(button);
    button = new JButton("Due");
	button.setInheritsPopupMenu(true);
    panel.add(button);
    button = new JButton("Tre");
	button.setInheritsPopupMenu(true);
    panel.add(button);

  	final JPopupMenu colorMenu = new JPopupMenu("Color");
    colorMenu.add(makeMenuItem("Red"));
    colorMenu.add(makeMenuItem("Green"));
    colorMenu.add(makeMenuItem("Blue"));
	panel.setComponentPopupMenu( colorMenu );
	panel.setBackground(Color.BLUE);

	frame.setBackground( Color.RED );
	frame.add( BorderLayout.CENTER, panel );
	frame.setSize(200,50);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }

  public void actionPerformed( ActionEvent e ) {
  	System.out.println( e );
  	System.out.println( e.getSource() );
	/*
    String color = e.getActionCommand();
    if (color.equals("Red"))
      selectedComponent.setBackground(Color.red);
    else if (color.equals("Green"))
      selectedComponent.setBackground(Color.green);
    else if (color.equals("Blue"))
      selectedComponent.setBackground(Color.blue);
	 */
  }

  private JMenuItem makeMenuItem(String label) {
    JMenuItem item = new JMenuItem(label);
    item.addActionListener( this );
    return item;
  }

  public static void main(String[] args) {
     new PopUpColorMenu2();
  }
}
			</text>
		</p>
		<p n="xj_robotexample">
			<text>import java.awt.*;
import java.awt.event.*;

public class RobotExample
{
    public static void main( String [] args ) throws Exception 
    {
        Robot r = new Robot();
        r.mouseMove(35,35);
        r.mousePress( InputEvent.BUTTON1_MASK );
        r.mouseRelease( InputEvent.BUTTON1_MASK );
        Thread.sleep(50);
        r.mousePress( InputEvent.BUTTON1_MASK );
        r.mouseRelease( InputEvent.BUTTON1_MASK );
    }
}

			</text>
		</p>
		<p n="xj_scrollpaneframe">
			<text>
				<![CDATA[//file: ScrollPaneFrame.java
import javax.swing.*;

public class ScrollPaneFrame 
{
  public static void main(String[] args) {
    String filename = "Piazza di Spagna.jpg";
    if (args.length > 0)
      filename = args[0];

    JFrame frame = new JFrame("ScrollPaneFrame v1.0");
	JLabel image = new JLabel( new ImageIcon(filename) );
    frame.getContentPane().add( new JScrollPane(image) );

    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_slippery">
			<text>//file: Slippery.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;

public class Slippery {
  public static void main(String[] args) 
  {
	JFrame frame = new JFrame("Slippery v1.0");
	Container content = frame.getContentPane(  ); // unecessary in 1.5+

	JPanel main = new JPanel(new GridLayout(2, 1));
	JPanel scrollBarPanel = new JPanel();
	final JScrollBar scrollBar =
		new JScrollBar(JScrollBar.HORIZONTAL, 0, 48, 0, 255);
	int height = scrollBar.getPreferredSize(  ).height;
	scrollBar.setPreferredSize(new Dimension(175, height));
	scrollBarPanel.add(scrollBar);
	main.add(scrollBarPanel);

	JPanel sliderPanel = new JPanel();
	final JSlider slider =
		new JSlider(JSlider.HORIZONTAL, 0, 255, 128);
	slider.setMajorTickSpacing(48);
	slider.setMinorTickSpacing(16);
	slider.setPaintTicks(true);
	sliderPanel.add(slider);
	main.add(sliderPanel);

	content.add(main, BorderLayout.CENTER);

	final JLabel statusLabel =
		new JLabel("Welcome to Slippery v1.0");
	content.add(statusLabel, BorderLayout.SOUTH);

	// wire up the event handlers
	scrollBar.addAdjustmentListener(new AdjustmentListener(  ) {
	  public void adjustmentValueChanged(AdjustmentEvent e) {
		statusLabel.setText("JScrollBar's current value = "
							+ scrollBar.getValue(  ));
	  }
	});

	slider.addChangeListener(new ChangeListener(  ) {
	  public void stateChanged(ChangeEvent e) {
		statusLabel.setText("JSlider's current value = "
							+ slider.getValue(  ));
	  }
	});

	frame.pack();
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
	frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_splitpaneframe">
			<text>
				<![CDATA[//file: SplitPaneFrame.java
import java.awt.*;
import javax.swing.*;

public class SplitPaneFrame {
  public static void main(String[] args) {
    String fileOne = "Piazza di Spagna.jpg";
    String fileTwo = "L1-Light.jpg";
    if (args.length > 0) fileOne = args[0];
    if (args.length > 1) fileTwo = args[1];

    JFrame frame = new JFrame("SplitPaneFrame");

	JLabel leftImage = new JLabel( new ImageIcon( fileOne ) );
    Component left = new JScrollPane(leftImage);
	JLabel rightImage = new JLabel( new ImageIcon( fileTwo ) );
    Component right = new JScrollPane(rightImage);

    JSplitPane split =
      new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, left, right);
    split.setDividerLocation(100);
    frame.getContentPane().add(split);

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(300, 200);
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_tabbedpaneframe">
			<text>//file: TabbedPaneFrame.java
import javax.swing.*;

public class TabbedPaneFrame {
  public static void main(String[] args) 
  {
    JFrame frame = new JFrame("TabbedPaneFrame");
    JTabbedPane tabby = new JTabbedPane();

    // create the controls pane
    JPanel controls = new JPanel(  );
    controls.add(new JLabel("Service:"));
    JList list = new JList(
        new String[] { "Web server", "FTP server" });
    list.setBorder(BorderFactory.createEtchedBorder(  ));
    controls.add(list);
    controls.add(new JButton("Start"));

    // create an image pane
    String filename = "Piazza di Spagna.jpg";
	JLabel image = new JLabel( new ImageIcon(filename) );
    JComponent picture = new JScrollPane(image);
    tabby.addTab("Controls", controls);
    tabby.addTab("Picture", picture);

    frame.getContentPane().add(tabby);

    frame.setSize(200, 200);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_canisminor">
			<text>
				<![CDATA[//file: CanisMinor.java
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import javax.swing.*;
import javax.swing.event.*;

public class CanisMinor extends JFrame {
  protected JEditorPane mEditorPane;
  protected JTextField mURLField;

  public CanisMinor(String urlString) {
    super("CanisMinor v1.0");
    createGUI(urlString);
  }

  protected void createGUI( String urlString ) {
    Container content = getContentPane();
    content.setLayout(new BorderLayout());

    JToolBar urlToolBar = new JToolBar(  );
    mURLField = new JTextField(urlString, 40);
    urlToolBar.add(new JLabel("Location:"));
    urlToolBar.add(mURLField);
    content.add(urlToolBar, BorderLayout.NORTH);

    mEditorPane = new JEditorPane(  );
    mEditorPane.setEditable(false);
    content.add(new JScrollPane(mEditorPane), BorderLayout.CENTER);

    openURL(urlString);  

    mURLField.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent ae) {
        openURL(ae.getActionCommand(  ));
      }
    });

    mEditorPane.addHyperlinkListener(new LinkActivator(  ));

    setSize(500, 600);
    setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
  }

  protected void openURL(String urlString) {
    try {
      URL url = new URL(urlString);
      mEditorPane.setPage(url);
      mURLField.setText(url.toExternalForm(  ));
    }
    catch (Exception e) {
      System.out.println("Couldn't open " + urlString + ":" + e);
    }
  }

  class LinkActivator implements HyperlinkListener {
    public void hyperlinkUpdate(HyperlinkEvent he) {
      HyperlinkEvent.EventType type = he.getEventType(  );
      if (type == HyperlinkEvent.EventType.ACTIVATED)
        openURL(he.getURL().toExternalForm(  ));
    }
  }

  public static void main(String[] args) {
    String urlString = "http://www.oreilly.com/catalog/java2d/";
    if (args.length > 0)
       urlString = args[0];
    new CanisMinor( urlString ).setVisible( true );
  }
}
]]>
			</text>
		</p>
		<p n="xj_desktop">
			<text>
				<![CDATA[//file: Desktop.java
import javax.swing.*;

public class Desktop {
  public static void main(String[] args) {
    JFrame frame = new JFrame("Desktop");

    JDesktopPane desktop = new JDesktopPane(  );
    for (int i = 0; i < 5; i++) {
      JInternalFrame internal =
          new JInternalFrame("Frame " + i, true, true, true, true);
      internal.setSize(180, 180);
      internal.setLocation(i * 20, i * 20);
      internal.setVisible(true);
      desktop.add(internal);
    }

    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setContentPane(desktop);
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_docfilter">
			<text>import javax.swing.*;
import javax.swing.text.*;

public class DocFilter
{
	public static void main( String[] args ) throws Exception 
	{
		JTextField field = new JTextField(30);
		
		((AbstractDocument)(field.getDocument())).setDocumentFilter( 
			new DocumentFilter() 
		{
  			public void insertString(
				FilterBypass fb, int offset, String string, AttributeSet attr) 
					throws BadLocationException
				{
System.out.println("insert");
					fb.insertString( offset, string.toUpperCase(), attr );
				}

  			public void replace(
				FilterBypass fb, int offset, int length, String string, 
				AttributeSet attr) throws BadLocationException
				{
System.out.println("replace");
					fb.replace( offset, length, string.toUpperCase(), attr );
				}
		} );

		JFrame frame = new JFrame("User Information");
		frame.getContentPane().add( field );
		frame.pack();
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.setVisible(true);
	}
}
			</text>
		</p>
		<p n="xj_dullshiptable">
			<text>//file: DullShipTable.java
import javax.swing.*;

public class DullShipTable {
  public static void main(String[] args) {
    // create some tabular data
    String[] headings =
      new String[] {"Number", "Hot?", "Origin",
                    "Destination", "Ship Date", "Weight" };
    Object[][] data = new Object[][] {
      { "100420", Boolean.FALSE, "Des Moines IA", "Spokane WA",
          "02/06/2000", new Float(450) },
      { "202174", Boolean.TRUE, "Basking Ridge NJ", "Princeton NJ",
          "05/20/2000", new Float(1250) },
      { "450877", Boolean.TRUE, "St. Paul MN", "Austin TX",
          "03/20/2000", new Float(1745) },
      { "101891", Boolean.FALSE, "Boston MA", "Albany NY",
          "04/04/2000", new Float(88) }
    };

    // create the data model and the JTable
    JTable table = new JTable(data, headings);

    JFrame frame = new JFrame("DullShipTable v1.0");
    frame.getContentPane().add(new JScrollPane(table));

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(500, 200);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_formattedfields">
			<text>import java.text.*;
import javax.swing.*;
import javax.swing.text.*;
import java.util.Date;

public class FormattedFields 
{
	public static void main( String[] args ) throws Exception {
		Box form = Box.createVerticalBox();
		form.add( new JLabel("Name:") );
		form.add( new JTextField("Joe User") );

		form.add( new JLabel("Birthday:") );
		JFormattedTextField birthdayField =
			new JFormattedTextField(new SimpleDateFormat("MM/dd/yy"));
		birthdayField.setValue( new Date() );
		form.add( birthdayField );

		form.add( new JLabel("Age:") );
		form.add(new JFormattedTextField(new Integer(32)));

		form.add( new JLabel("Hairs on Body:") );
		JFormattedTextField hairsField 
			= new JFormattedTextField( new DecimalFormat("###,###") );
		hairsField.setValue(new Integer(100000));
		form.add( hairsField );

		form.add( new JLabel("Phone Number:") );
		JFormattedTextField phoneField = 
			new JFormattedTextField( new MaskFormatter("(###)###-####") );
		phoneField.setValue("(314)555-1212");
		form.add( phoneField );

		JFrame frame = new JFrame("User Information");
		frame.getContentPane().add(form);
		frame.pack();
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.setVisible(true);
	}
}
			</text>
		</p>
		<p n="xj_partstree">
			<text>//file: PartsTree.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;

public class PartsTree {
  public static void main(String[] args) {
    // create a hierarchy of nodes
    MutableTreeNode root = new DefaultMutableTreeNode("Parts");
    MutableTreeNode beams = new DefaultMutableTreeNode("Beams");
    MutableTreeNode gears = new DefaultMutableTreeNode("Gears");
    root.insert(beams, 0);
    root.insert(gears, 1);
    beams.insert(new DefaultMutableTreeNode("1x4 black"), 0);
    beams.insert(new DefaultMutableTreeNode("1x6 black"), 1);
    beams.insert(new DefaultMutableTreeNode("1x8 black"), 2);
    beams.insert(new DefaultMutableTreeNode("1x12 black"), 3);
    gears.insert(new DefaultMutableTreeNode("8t"), 0);
    gears.insert(new DefaultMutableTreeNode("24t"), 1);
    gears.insert(new DefaultMutableTreeNode("40t"), 2);
    gears.insert(new DefaultMutableTreeNode("worm"), 3);
    gears.insert(new DefaultMutableTreeNode("crown"), 4);

    // create the JTree
    final DefaultTreeModel model = new DefaultTreeModel(root);
    final JTree tree = new JTree(model);

    // create a text field and button to modify the data model
    final JTextField nameField = new JTextField("16t");
    final JButton button = new JButton("Add a part");
    button.setEnabled(false);
    button.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent e) {
        TreePath tp = tree.getSelectionPath(  );
        MutableTreeNode insertNode =
            (MutableTreeNode)tp.getLastPathComponent(  );
        int insertIndex = 0;
        if (insertNode.getParent(  ) != null) {
          MutableTreeNode parent =
              (MutableTreeNode)insertNode.getParent(  );
          insertIndex = parent.getIndex(insertNode) + 1;
          insertNode = parent;
        }
        MutableTreeNode node =
            new DefaultMutableTreeNode(nameField.getText(  ));
        model.insertNodeInto(node, insertNode, insertIndex);
      }
    });
    JPanel addPanel = new JPanel(new GridLayout(2, 1));
    addPanel.add(nameField);
    addPanel.add(button);

    // listen for selections
    tree.addTreeSelectionListener(new TreeSelectionListener(  ) {
      public void valueChanged(TreeSelectionEvent e) {
        TreePath tp = e.getNewLeadSelectionPath(  );
        button.setEnabled(tp != null);
      }
    });

    // create a JFrame to hold the tree
    JFrame frame = new JFrame("PartsTree v1.0");

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(200, 200);
    frame.getContentPane().add(new JScrollPane(tree));
    frame.getContentPane().add(addPanel, BorderLayout.SOUTH);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_quickchange">
			<text>
				<![CDATA[//file: QuickChange.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class QuickChange extends JFrame {

  public QuickChange() {
    super("QuickChange v1.0");
    createGUI();
  }

  protected void createGUI(  ) {
    setSize(300, 200);

    // create a simple File menu
    JMenu file = new JMenu("File", true);
    JMenuItem quit = new JMenuItem("Quit");
    file.add(quit);
    quit.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent e) { System.exit(0); }
    });

    // create the Look & Feel menu
    JMenu lnf = new JMenu("Look & Feel", true);
    ButtonGroup buttonGroup = new ButtonGroup(  );
    final UIManager.LookAndFeelInfo[] info =
        UIManager.getInstalledLookAndFeels(  );
    for (int i = 0; i < info.length; i++) {
      JRadioButtonMenuItem item = new
          JRadioButtonMenuItem(info[i].getName(  ), i == 0);
      final String className = info[i].getClassName(  );
      item.addActionListener(new ActionListener(  ) {
        public void actionPerformed(ActionEvent ae) {
          try { UIManager.setLookAndFeel(className); }
          catch (Exception e) { System.out.println(e); }
          SwingUtilities.updateComponentTreeUI(QuickChange.this);
        }
      });
      buttonGroup.add(item);
      lnf.add(item);
    }

    // add the menu bar
    JMenuBar mb = new JMenuBar(  );
    mb.add(file);
    mb.add(lnf);
    setJMenuBar(mb);

    // add some components
    JPanel jp = new JPanel(  );
    jp.add(new JCheckBox("JCheckBox"));
    String[] names =
      new String[] { "Tosca", "Cavaradossi", "Scarpia",
                     "Angelotti", "Spoletta", "Sciarrone",
                     "Carceriere", "Il sagrestano", "Un pastore" };
    jp.add(new JComboBox(names));
    jp.add(new JButton("JButton"));
    jp.add(new JLabel("JLabel"));
    jp.add(new JTextField("JTextField"));
    JPanel main = new JPanel(new GridLayout(1, 2));
    main.add(jp);
    main.add(new JScrollPane(new JList(names)));
    setContentPane(main);
	setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
  }

  public static void main(String[] args) {
    new QuickChange().setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_sharedmodel">
			<text>//file: SharedModel.java
import java.awt.*;
import javax.swing.*;

public class SharedModel {

  public static void main(String[] args) {
	JFrame frame = new JFrame("Shared Model");

    JTextArea areaFiftyOne = new JTextArea(  );
    JTextArea areaFiftyTwo = new JTextArea(  );
    areaFiftyTwo.setDocument(areaFiftyOne.getDocument(  ));
    JTextArea areaFiftyThree = new JTextArea(  );
    areaFiftyThree.setDocument(areaFiftyOne.getDocument(  ));

    Container content = frame.getContentPane();
    content.setLayout(new GridLayout(3, 1));
    content.add(new JScrollPane(areaFiftyOne));
    content.add(new JScrollPane(areaFiftyTwo));
    content.add(new JScrollPane(areaFiftyThree));

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(300, 300);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_shiptable">
			<text>//file: ShipTable.java
import javax.swing.*;
import javax.swing.table.*;

public class ShipTable {
  public static class ShipTableModel extends AbstractTableModel {
    private String[] headings = new String[] {
      "Number", "Hot?", "Origin", "Destination", "Ship Date", "Weight"
    };
    private Object[][] data = new Object[][] {
      { "100420", Boolean.FALSE, "Des Moines IA", "Spokane WA",
          "02/06/2000", new Float(450) },
      { "202174", Boolean.TRUE, "Basking Ridge NJ", "Princeton NJ",
          "05/20/2000", new Float(1250) },
      { "450877", Boolean.TRUE, "St. Paul MN", "Austin TX",
          "03/20/2000", new Float(1745) },
      { "101891", Boolean.FALSE, "Boston MA", "Albany NY",
          "04/04/2000", new Float(88) }
    };

    public int getRowCount(  ) { return data.length; }
    public int getColumnCount(  ) { return data[0].length; }

    public Object getValueAt(int row, int column) {
      return data[row][column];
    }

    public String getColumnName(int column) {
      return headings[column];
    }

    public Class getColumnClass(int column) {
      return data[0][column].getClass(  );
    }
  }

  public static void main(String[] args) 
  {
    // create the data model and the JTable
    TableModel model = new ShipTableModel(  );
    JTable table = new JTable(model);

    table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

    JFrame frame = new JFrame("ShipTable v1.0");
    frame.getContentPane().add(new JScrollPane(table));
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(500, 200);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_spreadsheetmodel">
			<text>
				<![CDATA[//file: SpreadsheetModel.java
import java.util.StringTokenizer;
import javax.swing.*;
import javax.swing.table.AbstractTableModel;

public class SpreadsheetModel extends AbstractTableModel {
  Expression [][] data;

  public SpreadsheetModel( int rows, int cols ) {
    data = new Expression [rows][cols];
  }

  public void setValueAt(Object value, int row, int col) {
    data[row][col] = new Expression( (String)value );
    fireTableDataChanged(  );
  }

  public Object getValueAt( int row, int col ) {
    if ( data[row][col] != null )
      try { return data[row][col].eval(  ) + ""; }
      catch ( BadExpression e ) { return "Error"; }
    return "";
  }
  public int getRowCount(  ) { return data.length; }
  public int getColumnCount(  ) { return data[0].length; }
  public boolean isCellEditable(int row, int col) { return true; }

  class Expression {
    String text;
    StringTokenizer tokens;
    String token;

    Expression( String text ) { this.text = text.trim(  ); }

    float eval(  ) throws BadExpression {
      tokens = new StringTokenizer( text, " */+-(  )", true );
      try { return sum(  ); }
      catch ( Exception e ) { throw new BadExpression(  ); }
    }

    private float sum(  ) {
      float value = term(  );
      while( more(  ) && match("+-") )
        if ( match("+") ) { consume(); value = value + term(  ); }
        else { consume(); value = value - term(  ); }
      return value;
    }
    private float term(  ) {
      float value = element(  );
      while( more(  ) && match( "*/") )
        if ( match("*") ) { consume(); value = value * element(  ); }
        else { consume(); value = value / element(  ); }
      return value;
    }
    private float element(  ) {
      float value;
      if ( match( "(") ) { consume(); value = sum(  ); }
      else {
        String svalue;
        if ( Character.isLetter( token(  ).charAt(0) ) ) {
        int col = findColumn( token(  ).charAt(0) + "" );
        int row = Character.digit( token(  ).charAt(1), 10 );
        svalue = (String)getValueAt( row, col );
      } else
        svalue = token(  );
        value = Float.parseFloat( svalue );
      }
      consume(  ); // ")" or value token
      return value;
    }
    private String token(  ) {
      if ( token == null )
        while ( (token=tokens.nextToken(  )).equals(" ") );
      return token;
    }
    private void consume(  ) { token = null; }
    private boolean match( String s ) { return s.indexOf( token(  ) )!=-1; }
    private boolean more() { return tokens.hasMoreTokens(  ); }
  }

  class BadExpression extends Exception { }

  public static void main( String [] args ) {
    JFrame frame = new JFrame("Excelsior!");
    JTable table = new JTable( new SpreadsheetModel(15, 5) );
    table.setPreferredScrollableViewportSize( table.getPreferredSize() );
    table.setCellSelectionEnabled(true);
    frame.getContentPane().add( new JScrollPane( table ) );
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.pack(); 
	frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_styling">
			<text>//file: Styling.java
import java.awt.*;
import javax.swing.*;
import javax.swing.text.*;

public class Styling extends JFrame {
  private JTextPane textPane;

  public Styling() {
    super("Styling v1.0");
    setSize(300, 200);

    textPane = new JTextPane(  );
    textPane.setFont(new Font("Serif", Font.PLAIN, 24));

    // create some handy attribute sets
    SimpleAttributeSet red = new SimpleAttributeSet(  );
    StyleConstants.setForeground(red, Color.red);
    StyleConstants.setBold(red, true);
    SimpleAttributeSet blue = new SimpleAttributeSet(  );
    StyleConstants.setForeground(blue, Color.blue);
    SimpleAttributeSet italic = new SimpleAttributeSet(  );
    StyleConstants.setItalic(italic, true);
    StyleConstants.setForeground(italic, Color.orange);

    // add the text
    append("In a ", null);
    append("sky", blue);
    append(" full of people\nOnly some want to ", null);
    append("fly", italic);
    append("\nIsn't that ", null);
    append("crazy", red);
    append("?", null);

    Container content = getContentPane(  );
    content.add(new JScrollPane(textPane), BorderLayout.CENTER);
	setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
  }

  protected void append(String s, AttributeSet attributes) {
    Document d = textPane.getDocument(  );
    try { d.insertString(d.getLength(  ), s, attributes); }
    catch (BadLocationException ble) {}
  }

  public static void main(String[] args) {
    new Styling().setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_textentrybox">
			<text>//file: TextEntryBox.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class TextEntryBox {

  public static void main(String[] args) {
    JFrame frame = new JFrame("Text Entry Box");

    final JTextArea area = new JTextArea();
    area.setFont(new Font("Serif", Font.BOLD, 18));
    area.setText("Howdy!\n");
    final JTextField field = new JTextField();

    Container content = frame.getContentPane();
    content.add(new JScrollPane(area), BorderLayout.CENTER);
    content.add(field, BorderLayout.SOUTH);
    field.requestFocus();

    field.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent ae) {
        area.append(field.getText(  ) + '\n');
        field.setText("");
      }
    });

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(200, 300);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_validator">
			<text>
				<![CDATA[import javax.swing.*;

public class Validator
{
	public static void main( String[] args ) throws Exception {
		Box form = Box.createVerticalBox();
		form.add( new JLabel("Any Number") );
		form.add( new JTextField("5000") );
	
		form.add( new JLabel("Only 0-100") );
		JTextField rangeField = new JTextField("50");
		rangeField.setInputVerifier( new InputVerifier() {
			public boolean verify( JComponent comp ) {
				JTextField field = (JTextField)comp;
				boolean passed = false;
				try {
					int n = Integer.parseInt(field.getText());
					passed = ( 0 <= n && n <= 100 );
				} catch (NumberFormatException e) { }
				if ( !passed ) {
					comp.getToolkit().beep();
					field.selectAll();
				}
				return passed;
			}
		} );
		form.add( rangeField );

		JFrame frame = new JFrame("User Information");
		frame.getContentPane().add(form);
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.pack();
		frame.setVisible(true);
	}
}
]]>
			</text>
		</p>
		<p n="xj_textentrybox2">
			<text>//file: TextEntryBox2.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

import javax.swing.text.*;

public class TextEntryBox2 {

  public static void main(String[] args) {
    JFrame frame = new JFrame("Text Entry Box");

    final JTextArea area = new JTextArea();
    area.setFont(new Font("Serif", Font.BOLD, 18));
    area.setText("Howdy!\n");

	area.setEditable(false);
	Caret caret = area.getCaret();
	System.out.println(caret);
	((DefaultCaret)caret).setUpdatePolicy( DefaultCaret.ALWAYS_UPDATE );

    final JTextField field = new JTextField();

    Container content = frame.getContentPane();
    content.add(new JScrollPane(area), BorderLayout.CENTER);
    content.add(field, BorderLayout.SOUTH);
    field.requestFocus();

    field.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent ae) {
        area.append(field.getText(  ) + '\n');
        field.setText("");
      }
    });

	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(200, 300);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_border1">
			<text>//file:	Border1.java
import java.awt.*;
import javax.swing.*;

public class Border1 extends JPanel {

  public Border1() {
    setLayout(new BorderLayout(	));
    add(new JButton("North"), BorderLayout.NORTH);
    add(new JButton("South"), BorderLayout.SOUTH);
    add(new JButton("East"), BorderLayout.EAST);
    add(new JButton("West"), BorderLayout.WEST);
    add(new JButton("Center"), BorderLayout.CENTER);
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("Border1");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(300, 300);
    frame.setLocation(200, 200);
    frame.setContentPane(new Border1());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_border2">
			<text>//file:	Border2.java
import java.awt.*;
import javax.swing.*;

public class Border2 extends JPanel {

  public Border2() {
    setLayout(new BorderLayout(	));
    JPanel p = new JPanel();
    p.add(new JButton("North"));
    add(p, BorderLayout.NORTH);
    p =	new JPanel();
    p.add(new JButton("South"));
    add(p, BorderLayout.SOUTH);
    p =	new JPanel();
    p.add(new JButton("East"));
    add(p, BorderLayout.EAST);
    p =	new JPanel();
    p.add(new JButton("West"));
    add(p, BorderLayout.WEST);
    p =	new JPanel();
    p.add(new JButton("Center"));
    add(p, BorderLayout.CENTER);
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("Border2");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(225, 150);
    frame.setLocation(200, 200);
    frame.setContentPane(new Border2());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_boxer">
			<text>//file:	Boxer.java
import java.awt.*;
import javax.swing.*;

public class Boxer extends JPanel {
  public static	void main(String[] args) {
    JFrame frame = new JFrame("Boxer");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(250, 250);
    frame.setLocation(200, 200);
    Container box = Box.createHorizontalBox();
    box.add(Box.createHorizontalGlue());
    box.add(new	JButton("In the"));
    box.add(Box.createHorizontalGlue());
    box.add(new	JButton("clearing"));
    box.add(Box.createHorizontalStrut(10));
    box.add(new	JButton("stands"));
    box.add(Box.createHorizontalStrut(10));
    box.add(new	JButton("a"));
    box.add(Box.createHorizontalGlue());
    box.add(new	JButton("boxer"));
    box.add(Box.createHorizontalGlue());
    frame.getContentPane().add(box, BorderLayout.CENTER);
    frame.pack(	);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_calculator">
			<text>
				<![CDATA[//file:	Calculator.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class Calculator	extends	JPanel implements ActionListener {
  GridBagConstraints gbc = new GridBagConstraints();
  JTextField theDisplay	= new JTextField();

  public Calculator() {
    gbc.weightx	= 1.0;	gbc.weighty = 1.0;
    gbc.fill = GridBagConstraints.BOTH;
    ContainerListener listener = new ContainerAdapter() {
      public void componentAdded(ContainerEvent	e) {
	Component comp = e.getChild();
	if (comp instanceof JButton)
	  ((JButton)comp).addActionListener(Calculator.this);
      }
    };
    addContainerListener(listener);
    gbc.gridwidth = 4;
    addGB(this,	theDisplay, 0, 0);
    // make the	top row
    JPanel topRow = new	JPanel(	);
    topRow.addContainerListener(listener);
    gbc.gridwidth = 1;
    gbc.weightx	= 1.0;
    addGB(topRow, new JButton("C"), 0, 0);
    gbc.weightx	= 0.33;
    addGB(topRow, new JButton("%%"), 1, 0);
    gbc.weightx	= 1.0;
    addGB(topRow, new JButton("+"), 2, 0 );
    gbc.gridwidth = 4;
    addGB(this,	topRow,	0, 1);
    gbc.weightx	= 1.0;	gbc.gridwidth =	1;
    // make the	digits
    for(int j=0; j<3; j++)
	for(int	i=0; i<3; i++)
	    addGB(this,	new JButton("" + ((2-j)*3+i+1) ), i, j+2);
    // -, x, and divide
    addGB(this,	new JButton("-"), 3, 2);
    addGB(this,	new JButton("x"), 3, 3);
    addGB(this,	new JButton("\u00F7"), 3, 4);
    // make the	bottom row
    JPanel bottomRow = new JPanel();
    bottomRow.addContainerListener(listener);
    gbc.weightx	= 1.0;
    addGB(bottomRow, new JButton("0"), 0, 0);
    gbc.weightx	= 0.33;
    addGB(bottomRow, new JButton("."), 1, 0);
    gbc.weightx	= 1.0;
    addGB(bottomRow, new JButton("="), 2, 0);
    gbc.gridwidth = 4;
    addGB(this,	bottomRow, 0, 5);
  }

  void addGB(Container cont, Component comp, int x, int	y) {
    if ((cont.getLayout() instanceof GridBagLayout) ==	false)
      cont.setLayout(new GridBagLayout(	));
    gbc.gridx =	x; gbc.gridy = y;
    cont.add(comp, gbc);
  }

  public void actionPerformed(ActionEvent e) {
    if (e.getActionCommand().equals("C"))
      theDisplay.setText("");
    else
      theDisplay.setText(theDisplay.getText()
			 + e.getActionCommand());
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("Calculator");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(200, 250);
    frame.setLocation(200, 200);
    frame.setContentPane(new Calculator());
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_card">
			<text>//file:	Card.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class Card extends JPanel {
  CardLayout cards = new CardLayout();

  public Card() {
    setLayout(cards);
    ActionListener listener = new ActionListener() {
      public void actionPerformed(ActionEvent e) {
	cards.next(Card.this);
      }
    };
    JButton button;
    button = new JButton("one");
    button.addActionListener(listener);
    add(button,	"one");
    button = new JButton("two");
    button.addActionListener(listener);
    add(button,	"two");
    button = new JButton("three");
    button.addActionListener(listener);
    add(button,	"three");
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("Card");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(200, 200);
    frame.setLocation(200, 200);
    frame.setContentPane(new Card());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_flow">
			<text>//file:	Flow.java
import javax.swing.*;

public class Flow extends JPanel {

  public Flow() {
    // FlowLayout is default layout manager for	a JPanel
    add(new JButton("One"));
    add(new JButton("Two"));
    add(new JButton("Three"));
    add(new JButton("Four"));
    add(new JButton("Five"));
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("Flow");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );

    frame.setSize(400, 75);
    frame.setLocation(200, 200);
    Flow flow =	new Flow();
    frame.setContentPane(flow);
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_grid">
			<text>//file:	Grid.java
import java.awt.*;
import javax.swing.*;

public class Grid extends JPanel {

  public Grid() {
    setLayout(new GridLayout(3,	2));
    add(new JButton("One"));
    add(new JButton("Two"));
    add(new JButton("Three"));
    add(new JButton("Four"));
    add(new JButton("Five"));
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("Grid");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(200, 200);
    frame.setLocation(200, 200);
    frame.setContentPane(new Grid());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_gridbag1">
			<text>//file:	GridBag1.java
import java.awt.*;
import javax.swing.*;

public class GridBag1 extends JPanel {
  GridBagConstraints constraints = new GridBagConstraints();

  public GridBag1() {
    setLayout(new GridBagLayout());
    int	x, y;  // for clarity
    addGB(new JButton("North"),	 x = 1,	y = 0);
    addGB(new JButton("West"),	 x = 0,	y = 1);
    addGB(new JButton("Center"), x = 1,	y = 1);
    addGB(new JButton("East"),	 x = 2,	y = 1);
    addGB(new JButton("South"),	 x = 1,	y = 2);
  }

  void addGB(Component component, int x, int y)	{
    constraints.gridx =	x;
    constraints.gridy =	y;
    add(component, constraints);
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("GridBag1");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(225, 150);
    frame.setLocation(200, 200);
    frame.setContentPane(new GridBag1());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_gridbag2">
			<text>//file:	GridBag2.java
import java.awt.*;
import javax.swing.*;

public class GridBag2 extends JPanel {
  GridBagConstraints constraints = new GridBagConstraints();

  public GridBag2() {
    setLayout(new GridBagLayout());
    constraints.weightx	= 1.0;
    constraints.weighty	= 1.0;
    constraints.fill = GridBagConstraints.BOTH;
    int	x, y;  // for clarity
    addGB(new JButton("North"),	 x = 1,	y = 0);
    addGB(new JButton("West"),	 x = 0,	y = 1);
    addGB(new JButton("Center"), x = 1,	y = 1);
    addGB(new JButton("East"),	 x = 2,	y = 1);
    addGB(new JButton("South"),	 x = 1,	y = 2);
  }

  void addGB(Component component, int x, int y)	{
    constraints.gridx =	x;
    constraints.gridy =	y;
    add(component, constraints);
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("GridBag2");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(225, 150);
    frame.setLocation(200, 200);
    frame.setContentPane(new GridBag2());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_gridbag3">
			<text>//file:	GridBag3.java
import java.awt.*;
import javax.swing.*;

public class GridBag3 extends JPanel {
  GridBagConstraints constraints = new GridBagConstraints();

  public GridBag3() {
    setLayout(new GridBagLayout());
    constraints.weightx	= 1.0;
    constraints.weighty	= 1.0;
    constraints.fill = GridBagConstraints.BOTH;
    int	x, y;  // for clarity
    constraints.gridheight = 2;	// span	two rows
    addGB(new JButton("one"),	x = 0, y = 0);
    constraints.gridheight = 1;	// set it back
    addGB(new JButton("two"),	x = 1, y = 0);
    addGB(new JButton("three"),	x = 2, y = 0);
    constraints.gridwidth = 2; // span two columns
    addGB(new JButton("four"),	x = 1, y = 1);
    constraints.gridwidth = 1; // set it back
  }

  void addGB(Component component, int x, int y)	{
    constraints.gridx =	x;
    constraints.gridy =	y;
    add(component, constraints);
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("GridBag3");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(200, 200);
    frame.setLocation(200, 200);
    frame.setContentPane(new GridBag3());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_girdbag4">
			<text>//file:	GridBag4.java
import java.awt.*;
import javax.swing.*;

public class GridBag4 extends JPanel {
  GridBagConstraints constraints = new GridBagConstraints();

  public GridBag4() {
    setLayout(new GridBagLayout());
    constraints.fill = GridBagConstraints.BOTH;
    constraints.weighty	= 1.0;
    int	x, y; // for clarity
    constraints.weightx	= 0.1;
    addGB(new JButton("one"),	x = 0, y = 0);
    constraints.weightx	= 0.5;
    addGB(new JButton("two"),	++x,   y);
    constraints.weightx	= 1.0;
    addGB(new JButton("three"),	++x,   y);
  }

  void addGB(Component component, int x, int y)	{
    constraints.gridx =	x;
    constraints.gridy =	y;
    add(component, constraints);
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("GridBag4");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(300, 100);
    frame.setLocation(200, 200);
    frame.setContentPane(new GridBag4());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_gridbag5">
			<text>//file:	GridBag5.java
import java.awt.*;
import javax.swing.*;

public class GridBag5 extends JPanel {
  GridBagConstraints constraints = new GridBagConstraints();

  public GridBag5() {
    setLayout(new GridBagLayout());
    int	x, y;  // for clarity
    addGB(new JButton("North"),	 x = 1,	y = 0);
    constraints.ipadx =	25;  //	add padding
    constraints.ipady =	25;
    addGB(new JButton("West"),	 x = 0,	y = 1);
    constraints.ipadx =	0;   //	remove padding
    constraints.ipady =	0;
    addGB(new JButton("Center"), x = 1,	y = 1);
    addGB(new JButton("East"),	 x = 2,	y = 1);
    addGB(new JButton("South"),	 x = 1,	y = 2);
  }

  void addGB(Component component, int x, int y)	{
    constraints.gridx =	x;
    constraints.gridy =	y;
    add(component, constraints);
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("GridBag5");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );

    frame.setSize(250, 250);
    frame.setLocation(200, 200);
    frame.setContentPane(new GridBag5());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_movebutton">
			<text>//file:	MoveButton.java
import java.awt.event.*;
import javax.swing.*;

public class MoveButton	extends	JPanel {
  JButton button = new JButton("I Move");

  public MoveButton() {
    setLayout(null);
    add(button);
    button.setSize(button.getPreferredSize());
    button.setLocation(20, 20);
    addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent e) {
      button.setLocation(e.getX(), e.getY());
      }
    });
  }

  public static	void main(String[] args) {
    JFrame frame = new JFrame("MoveButton");
    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(250, 200);
    frame.setLocation(200, 200);
    frame.setContentPane(new MoveButton());
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_clippeddragimage">
			<text>
				<![CDATA[import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class ClippedDragImage extends DragImage 
{
  int oldX, oldY;

  public ClippedDragImage( Image i ) { super(i); }

  public void mouseDragged(MouseEvent e) {
    imageX = e.getX();
    imageY = e.getY();
    Rectangle r = getAffectedArea(
		oldX, oldY, imageX, imageY, imageWidth, imageHeight);
    repaint(r);  // repaint just the affected part of the component
    oldX = imageX;
    oldY = imageY;
  }

  private Rectangle getAffectedArea( 
	int oldx, int oldy, int newx, int newy, int width, int height) 
  {
    int x = Math.min(oldx, newx);
    int y = Math.min(oldy, newy);
    int w = (Math.max(oldx, newx) + width) - x;
    int h = (Math.max(oldy, newy) + height) - y;
    return new Rectangle(x, y, w, h);
  }

  public static void main(String[] args) {
    String imageFile = "L1-Light.jpg";
    if (args.length > 0)
      imageFile = args[0];

	// Turn off double buffering
	//RepaintManager.currentManager(null).setDoubleBufferingEnabled(false);

    Image image = Toolkit.getDefaultToolkit().getImage(
        ClippedDragImage.class.getResource(imageFile));
	image = image.getScaledInstance(imageWidth,imageHeight,Image.SCALE_DEFAULT);
    JFrame frame = new JFrame("ClippedDragImage");
    frame.getContentPane().add( new ClippedDragImage(image) );
    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_doodlepad">
			<text>//file: DoodlePad.java
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class DoodlePad 
{
  public static void main(String[] args) 
  {
    JFrame frame = new JFrame("DoodlePad");
    Container content = frame.getContentPane();
    content.setLayout(new BorderLayout());
    final DrawPad drawPad = new DrawPad(  );
    content.add(drawPad, BorderLayout.CENTER);
    JPanel panel = new JPanel();
    JButton clearButton = new JButton("Clear");
    clearButton.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent e) {
        drawPad.clear( );
      }
    });
    panel.add(clearButton);
    content.add(panel, BorderLayout.SOUTH);
    frame.setSize(280, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }

} // end of class DoodlePad

class DrawPad extends JComponent 
{
  Image image;
  Graphics2D graphics2D;
  int currentX, currentY, oldX, oldY;

  public DrawPad() {
    setDoubleBuffered(false);
    addMouseListener(new MouseAdapter(  ) {
      public void mousePressed(MouseEvent e) {
        oldX = e.getX();
        oldY = e.getY();
      }
    });
    addMouseMotionListener(new MouseMotionAdapter() {
      public void mouseDragged(MouseEvent e) {
        currentX = e.getX();
        currentY = e.getY();
        if (graphics2D != null)
          graphics2D.drawLine(oldX, oldY, currentX, currentY);
        repaint();
        oldX = currentX;
        oldY = currentY;
      }
    });
  }

  public void paintComponent(Graphics g) {
    if (image == null) {
      image = createImage(getSize().width, getSize(  ).height);
      graphics2D = (Graphics2D)image.getGraphics();
      graphics2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
          RenderingHints.VALUE_ANTIALIAS_ON);
      clear();
    }
    g.drawImage(image, 0, 0, null);
  }

  public void clear(  ) {
    graphics2D.setPaint(Color.white);
    graphics2D.fillRect(0, 0, getSize().width, getSize(  ).height);
    graphics2D.setPaint(Color.black);
    repaint();
  }
}
			</text>
		</p>
		<p n="xj_dragimage">
			<text>
				<![CDATA[import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class DragImage extends JComponent 
	implements MouseMotionListener 
{
  static int imageWidth=60, imageHeight=60;
  int grid = 10;
  int imageX, imageY;
  Image image;

  public DragImage(Image i) {
    image = i;
    addMouseMotionListener(this);
  }

  public void mouseDragged(MouseEvent e) {
    imageX = e.getX();
    imageY = e.getY();
    repaint();
  }

  public void mouseMoved(MouseEvent e) {}

  public void paint(Graphics g) {
    Graphics2D g2 = (Graphics2D)g;

    int w = getSize().width / grid;
    int h = getSize().height / grid;
    boolean black = false;
    for (int y = 0; y <= grid; y++)
      for (int x = 0; x <= grid; x++) {
        g2.setPaint(black ? Color.black : Color.white);
        black = !black;
        g2.fillRect(x * w, y * h, w, h);
      }
    g2.drawImage(image, imageX, imageY, this);
  }

  public static void main(String[] args) {
    String imageFile = "L1-Light.jpg";
    if (args.length > 0)
      imageFile = args[0];

	// Turn off double buffering
	//RepaintManager.currentManager(null).setDoubleBufferingEnabled(false);

    Image image = Toolkit.getDefaultToolkit().getImage(
        DragImage.class.getResource(imageFile));
	image = image.getScaledInstance(imageWidth,imageHeight,Image.SCALE_DEFAULT);
    JFrame frame = new JFrame("DragImage");
    frame.getContentPane().add( new DragImage(image) );
    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_fontshow">
			<text>
				<![CDATA[//file: FontShow.java
import java.awt.*;
import java.awt.event.*;
import java.awt.font.*;
import javax.swing.*;

public class FontShow extends JComponent 
{
  private static final int PAD = 25;   // frilly line padding
  private boolean bigFont = true;
  private String message;

  public FontShow(String message) {
    this.message = message;
    addMouseListener(new MouseAdapter() {
      public void mouseClicked(MouseEvent e) {
        bigFont = !bigFont;
        repaint();
      }
    });
  }

  public void paint(Graphics g) 
  {
    Graphics2D g2 = (Graphics2D)g;

    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
        RenderingHints.VALUE_ANTIALIAS_ON);

    int size = bigFont ? 96 : 64;
    Font font = new Font("Dialog", Font.PLAIN, size);
    g2.setFont(font);
    int width = getSize().width;
    int height = getSize().height;

    FontRenderContext frc = g2.getFontRenderContext();
    LineMetrics metrics = font.getLineMetrics(message, frc);
    float messageWidth =
        (float)font.getStringBounds(message, frc).getWidth();

    // center text
    float ascent = metrics.getAscent();
    float descent = metrics.getDescent();
    float x = (width - messageWidth) / 2;
    float y = (height + metrics.getHeight()) / 2 - descent;

    g2.setPaint(getBackground());
    g2.fillRect(0, 0, width, height);

    g2.setPaint(getForeground());
    g2.drawString(message, x, y);

    g2.setPaint(Color.white);  // Base lines
    drawLine(g2, x - PAD, y, x + messageWidth + PAD, y);
    drawLine(g2, x, y + PAD, x, y - ascent - PAD);
    g2.setPaint(Color.green);  // Ascent line
    drawLine(g2, x - PAD, y - ascent,
             x + messageWidth + PAD, y - ascent);
    g2.setPaint(Color.red);    // Descent line
    drawLine(g2, x - PAD, y + descent,
             x + messageWidth + PAD, y + descent);
  }

  private void drawLine(Graphics2D g2,
      double x0, double y0, double x1, double y1) {
    Shape line = new java.awt.geom.Line2D.Double(x0, y0, x1, y1);
    g2.draw(line);
  }

  public static void main(String args[]) {
    String message = "Lemming";
    if (args.length > 0) message = args[0];

    JFrame frame = new JFrame("FontShow");
    frame.setSize(420, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.getContentPane().add(new FontShow(message));
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_iguana">
			<text>//file: Iguana.java
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;

public class Iguana extends JComponent {
  private Image image;
  private int theta;

  public Iguana() {
    image = Toolkit.getDefaultToolkit().getImage(
        "Piazza di Spagna.small.jpg");
    theta = 0;
    addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent me) {
        theta = (theta + 15) %% 360;
        repaint();
      }
    });
  }

  public void paint(Graphics g) {
    Graphics2D g2 = (Graphics2D)g;

    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
        RenderingHints.VALUE_ANTIALIAS_ON);

    int cx = getSize().width / 2;
    int cy = getSize().height / 2;

    g2.translate(cx, cy);
    g2.rotate(theta * Math.PI / 180);

    Shape oldClip = g2.getClip();
    Shape e = new Ellipse2D.Float(-cx, -cy, cx * 2, cy * 2);
    g2.clip(e);

    Shape c = new Ellipse2D.Float(-cx, -cy, cx * 3 / 4, cy * 2);
    g2.setPaint(new GradientPaint(40, 40, Color.blue,
        60, 50, Color.white, true));
    g2.fill(c);

    g2.setPaint(Color.yellow);
    g2.fillOval(cx / 4, 0, cx, cy);

    g2.setClip(oldClip);

    g2.setFont(new Font("Times New Roman", Font.PLAIN, 64));
    g2.setPaint(new GradientPaint(-cx, 0, Color.red,
        cx, 0, Color.black, false));
    g2.drawString("Hello, 2D!", -cx * 3 / 4, cy / 4);

    AlphaComposite ac = AlphaComposite.getInstance(
        AlphaComposite.SRC_OVER, (float).75);
    g2.setComposite(ac);

    Shape r = new RoundRectangle2D.Float(0, -cy * 3 / 4,
        cx * 3 / 4, cy * 3 / 4, 20, 20);
    g2.setStroke(new BasicStroke(4));
    g2.setPaint(Color.magenta);
    g2.fill(r);
    g2.setPaint(Color.green);
    g2.draw(r);

    g2.drawImage(image, -cx / 2, -cy / 2, this);
  }

  public static void main(String[] args) {
    JFrame frame = new JFrame("Iguana");
    Container c = frame.getContentPane();
    c.setLayout(new BorderLayout());
    c.add(new Iguana(), BorderLayout.CENTER);
    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_showfonts">
			<text>
				<![CDATA[//file: ShowFonts.java
import java.awt.*;

public class ShowFonts {
  public static void main(String[] args) {
    Font[] fonts;
    fonts =
     GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts(  );
    for (int i = 0; i < fonts.length; i++) {
      System.out.print(fonts[i].getFontName(  ) + " : ");
      System.out.print(fonts[i].getFamily(  ) + " : ");
      System.out.print(fonts[i].getName(  ));
      System.out.println(  );
    }
  }
}
]]>
			</text>
		</p>
		<p n="xj_unbelievablysimpleprint">
			<text>
				<![CDATA[//file: UnbelievablySimplePrint.java
import java.awt.*;
import java.awt.print.*;

public class UnbelievablySimplePrint implements Printable 
{
  private static Font sFont = new Font("Serif", Font.PLAIN , 64);

  public int print(Graphics g, PageFormat Pf, int pageIndex)
      throws PrinterException 
  {
    if (pageIndex > 0) return NO_SUCH_PAGE;
    Graphics2D g2 = (Graphics2D)g;
    g2.setFont(sFont);
    g2.setPaint(Color.black);
    g2.drawString("Save a tree!", 96, 144);
    return PAGE_EXISTS;
  }

  public static void main(String[] args) {
    PrinterJob job = PrinterJob.getPrinterJob();
    job.setPrintable(new UnbelievablySimplePrint());
    if (job.printDialog()) {
      try {
        job.print();
      }
      catch (PrinterException e) {}
    }
    System.exit(0);
  }
}
]]>
			</text>
		</p>
		<p n="xj_colorpan">
			<text>
				<![CDATA[//file: ColorPan.java
import java.awt.*;
import java.awt.image.*;
import javax.swing.*;

public class ColorPan extends JComponent {
  BufferedImage image;

  public void initialize(  ) {
    int width = getSize().width;
    int height = getSize().height;
    int[] data = new int [width * height];
    int i = 0;
    for (int y = 0; y < height; y++) {
      int red = (y * 255) / (height - 1);
      for (int x = 0; x < width; x++) {
        int green = (x * 255) / (width - 1);
        int blue = 128;
        data[i++] = (red << 16) | (green << 8 ) | blue;
      }
    }
    image = new BufferedImage(width, height,
        BufferedImage.TYPE_INT_RGB);
    image.setRGB(0, 0, width, height, data, 0, width);
  }

  public void paint(Graphics g) {
    if (image == null) 
        initialize();
    g.drawImage(image, 0, 0, this);
  }

  public void setBounds(int x, int y, int width, int height) {
	super.setBounds(x,y,width,height);
	initialize();
  }

  public static void main(String[] args) {
    JFrame frame = new JFrame("ColorPan");
    frame.getContentPane().add(new ColorPan(  ));
    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_hypnosis">
			<text>
				<![CDATA[//file: Hypnosis.java
import java.awt.*;
import java.awt.geom.GeneralPath;
import javax.swing.*;

public class Hypnosis extends JComponent implements Runnable {
  private int[] coordinates;
  private int[] deltas;
  private Paint paint;

  public Hypnosis(int numberOfSegments) {
    int numberOfCoordinates = numberOfSegments * 4 + 2;
    coordinates = new int[numberOfCoordinates];
    deltas = new int[numberOfCoordinates];
    for (int i = 0 ; i < numberOfCoordinates; i++) {
      coordinates[i] = (int)(Math.random(  ) * 300);
      deltas[i] = (int)(Math.random(  ) * 4 + 3);
      if (deltas[i] > 4) deltas[i] = -(deltas[i] - 3);
    }
    paint = new GradientPaint(0, 0, Color.blue,
        20, 10, Color.red, true);

    Thread t = new Thread(this);
    t.start(  );
  }

  public void run(  ) {
    try {
      while (true) {
        timeStep(  );
        repaint(  );
        Thread.sleep(1000 / 24);
      }
    }
    catch (InterruptedException ie) {}
  }

  public void paint(Graphics g) {
    Graphics2D g2 = (Graphics2D)g;
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
        RenderingHints.VALUE_ANTIALIAS_ON);
    Shape s = createShape(  );
    g2.setPaint(paint);
    g2.fill(s);
    g2.setPaint(Color.white);
    g2.draw(s);
  }

  private void timeStep(  ) {
    Dimension d = getSize(  );
    if (d.width == 0 || d.height == 0) return;
    for (int i = 0; i < coordinates.length; i++) {
      coordinates[i] += deltas[i];
      int limit = (i %% 2 == 0) ? d.width : d.height;
      if (coordinates[i] < 0) {
        coordinates[i] = 0;
        deltas[i] = -deltas[i];
      }
      else if (coordinates[i] > limit) {
        coordinates[i] = limit - 1;
        deltas[i] = -deltas[i];
      }
    }
  }

  private Shape createShape(  ) {
    GeneralPath path = new GeneralPath(  );
    path.moveTo(coordinates[0], coordinates[1]);
    for (int i = 2; i < coordinates.length; i += 4)
      path.quadTo(coordinates[i], coordinates[i + 1],
          coordinates[i + 2], coordinates[i + 3]);
    path.closePath(  );
    return path;
  }

  public static void main(String[] args) {
    JFrame frame = new JFrame("Hypnosis");
    frame.getContentPane().add( new Hypnosis(4) );
    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
]]>
			</text>
		</p>
		<p n="xj_imageprocessor">
			<text>//file: ImageProcessor.java
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.awt.image.*;
import javax.swing.*;

public class ImageProcessor extends JComponent {
  private BufferedImage source, destination;
  private JComboBox options;

  public ImageProcessor( BufferedImage image ) {
    source = destination = image;
    setBackground(Color.white);
    setLayout(new BorderLayout());
    // create a panel to hold the combo box
    JPanel controls = new JPanel();
    // create the combo box with the names of the area operators
    options = new JComboBox(
      new String[] { "[source]", "brighten", "darken", "rotate", "scale" }
    );
    // perform some processing when the selection changes
    options.addItemListener(new ItemListener() {
      public void itemStateChanged(ItemEvent ie) {
        // retrieve the selection option from the combo box
        String option = (String)options.getSelectedItem();
        // process the image according to the selected option
        BufferedImageOp op = null;
        if (option.equals("[source]"))
          destination = source;
        else if (option.equals("brighten"))
          op = new RescaleOp(1.5f, 0, null);
        else if (option.equals("darken"))
          op = new RescaleOp(.5f, 0, null);
        else if (option.equals("rotate"))
          op = new AffineTransformOp(
              AffineTransform.getRotateInstance(Math.PI / 6), null);
        else if (option.equals("scale"))
          op = new AffineTransformOp(
              AffineTransform.getScaleInstance(.5, .5), null);
        if (op != null) destination = op.filter(source, null);
        repaint();
      }
    });
    controls.add(options);
    add(controls, BorderLayout.SOUTH);
  }

  public void paintComponent(Graphics g) {
    int imageWidth = destination.getWidth();
    int imageHeight = destination.getHeight();
    int width = getSize().width;
    int height = getSize().height;
    g.drawImage(destination,
        (width - imageWidth) / 2, (height - imageHeight) / 2, null);
  }

  public static void main(String[] args) {
    String filename = args[0];

	ImageIcon icon = new ImageIcon(filename);
	Image i = icon.getImage();

    // draw the Image into a BufferedImage
    int w = i.getWidth(null), h = i.getHeight(null);
    BufferedImage buffImage = new BufferedImage(w, h,
        BufferedImage.TYPE_INT_RGB);
    Graphics2D imageGraphics = buffImage.createGraphics();
    imageGraphics.drawImage(i, 0, 0, null);

    JFrame frame = new JFrame("ImageProcessor");
    frame.getContentPane().add(new ImageProcessor(buffImage));
    frame.setSize(buffImage.getWidth(), buffImage.getHeight());
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_mediaplayer">
			<text>import java.net.URL;
import javax.swing.*;
import javax.media.*;
import java.awt.Component;

public class MediaPlayer 
{
	public static void main( String[] args ) throws Exception {
		final JFrame frame = new JFrame("MediaPlayer");
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		URL url = new URL( args[0] );
		final Player player = Manager.createPlayer( url );


		player.addControllerListener( new ControllerListener() {
			public void controllerUpdate( ControllerEvent ce ) {
				if ( ce instanceof RealizeCompleteEvent ) 
				{
					Component visual = player.getVisualComponent();
					Component control = player.getControlPanelComponent();
					if ( visual != null ) 
						frame.getContentPane().add( visual, "Center" );
					frame.getContentPane().add( control, "South" );
					frame.pack();
					frame.setVisible( true );
					player.start();
				}
			}
		});

		player.realize();
	}
}
			</text>
		</p>
		<p n="xj_myobserver">
			<text>
				<![CDATA[//file: MyObserver.java
import java.awt.*;
import java.awt.image.*;

class MyObserver implements ImageObserver {

	public boolean imageUpdate( 
		Image image, int flags, int x, int y, int width, int height) {

    if ( (flags & HEIGHT) !=0 )
      System.out.println("Image height = " + height );

    if ( (flags & WIDTH ) !=0 )
      System.out.println("Image width = " + width );

    if ( (flags & FRAMEBITS) != 0 )
      System.out.println("Another frame finished.");

    if ( (flags & SOMEBITS) != 0 )
      System.out.println("Image section :"
             + new Rectangle( x, y, width, height ) );

    if ( (flags & ALLBITS) != 0 )
      System.out.println("Image finished!");

    if ( (flags & ABORT) != 0 ) 
      System.out.println("Image load aborted...");

    return true;
  }
}
]]>
			</text>
		</p>
		<p n="xj_noisybutton">
			<text>//file: NoisyButton.java
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class NoisyButton {

  public static void main(String[] args) throws Exception {
    JFrame frame = new JFrame("NoisyButton");
    java.io.File file = new java.io.File( args[0] );
    final AudioClip sound = Applet.newAudioClip(file.toURL(  ));

    // set up the button
    JButton button = new JButton("Woof!");
    button.addActionListener(new ActionListener(  ) {
      public void actionPerformed(ActionEvent e) { sound.play(  ); }
    });

	Container content = frame.getContentPane();
    content.setBackground(Color.pink);
    content.setLayout(new GridBagLayout());
    content.add(button);
    frame.setVisible(true);
    frame.setSize(200, 200);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
	frame.setVisible(true);
  }
}
			</text>
		</p>
		<p n="xj_observeimageload">
			<text>
				<![CDATA[//file: ObserveImageLoad.java
import java.awt.*;
import java.awt.image.*;

public class ObserveImageLoad {

  public static void main( String [] args) 
  {
	ImageObserver myObserver = new ImageObserver() {
		public boolean imageUpdate( 
			Image image, int flags, int x, int y, int width, int height) 
		{
			if ( (flags & HEIGHT) !=0 )
			  System.out.println("Image height = " + height );
			if ( (flags & WIDTH ) !=0 )
			  System.out.println("Image width = " + width );
			if ( (flags & FRAMEBITS) != 0 )
			  System.out.println("Another frame finished.");
			if ( (flags & SOMEBITS) != 0 )
				System.out.println("Image section :"
					 + new Rectangle( x, y, width, height ) );
			if ( (flags & ALLBITS) != 0 )
			  System.out.println("Image finished!");
			if ( (flags & ABORT) != 0 ) 
			  System.out.println("Image load aborted...");
			return true;
	  }
	};

    Toolkit toolkit = Toolkit.getDefaultToolkit();
    Image img = toolkit.getImage( args[0] );
    toolkit.prepareImage( img, -1, -1, myObserver );
  }

}
]]>
			</text>
		</p>
		<p n="xj_staticgenerator">
			<text>//file: StaticGenerator.java
import java.awt.*;
import java.awt.image.*;
import java.util.Random;
import javax.swing.*;

public class StaticGenerator extends JComponent implements Runnable {
  byte[] data;
  BufferedImage image;
  Random random;

  public void initialize() {
    int w = getSize().width, h = getSize().height;
    int length = ((w + 7) * h) / 8;
    data = new byte[length];
    DataBuffer db = new DataBufferByte(data, length);
    WritableRaster wr = Raster.createPackedRaster(db, w, h, 1, null);
    ColorModel cm = new IndexColorModel(1, 2,
        new byte[] { (byte)0, (byte)255 },
        new byte[] { (byte)0, (byte)255 },
        new byte[] { (byte)0, (byte)255 });
    image = new BufferedImage(cm, wr, false, null);
    random = new Random();
  }

  public void run() {
	if ( random == null )
		initialize();
    while (true) {
      random.nextBytes(data);
      repaint();
      try { Thread.sleep(1000 / 24); }
      catch( InterruptedException e ) { /* die */ }
    }
  }

  public void paint(Graphics g) {
    if (image == null) initialize();
    g.drawImage(image, 0, 0, this);
  }

  public void setBounds(int x, int y, int width, int height) {
	super.setBounds(x,y,width,height);
	initialize();
  }

  public static void main(String[] args) {
	//RepaintManager.currentManager(null).setDoubleBufferingEnabled(false);
    JFrame frame = new JFrame("StaticGenerator");
    StaticGenerator staticGen = new StaticGenerator();
    frame.getContentPane().add( staticGen );
    frame.setSize(300, 300);
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setVisible(true);
	new Thread( staticGen ).start();
  }
}
			</text>
		</p>
		<p n="xj_statusimage">
			<text>//file: StatusImage.java
import java.awt.*;
import javax.swing.*;

public class StatusImage extends JComponent
{
  boolean loaded = false;
  String message = "Loading...";
  Image image;

  public StatusImage( Image image ) { this.image = image; }

  public void paint(Graphics g) {
    if (loaded) 
		g.drawImage(image, 0, 0, this);
    else {
      g.drawRect(0, 0, getSize().width - 1, getSize(  ).height - 1);
      g.drawString(message, 20, 20);
    }
  }
  public void loaded() {
	loaded = true;
	repaint();
  }
  public void setMessage( String msg ) {
	message = msg;
	repaint();
  }

  public static void main( String [] args ) { 
	JFrame frame = new JFrame("TrackImage");
    Image image = Toolkit.getDefaultToolkit().getImage( args[0] );
	StatusImage statusImage = new StatusImage( image );
	frame.getContentPane().add( statusImage );
	frame.setSize(300,300);
	frame.setVisible(true);

    MediaTracker tracker = new MediaTracker( statusImage );
	int MAIN_IMAGE = 0;
    tracker.addImage(image, MAIN_IMAGE);
    try { 
		tracker.waitForID(MAIN_IMAGE); }
    catch (InterruptedException e) {}
    if ( tracker.isErrorID(MAIN_IMAGE) ) 
		statusImage.setMessage("Error");
    else 
		statusImage.loaded();
  }
}
			</text>
		</p>
		<p n="xj_backfromthedead">
			<text>//file: BackFromTheDead.java
import java.awt.Component;
import javax.swing.*; 
import java.beans.*; 
 
public class BackFromTheDead extends JFrame
{ 
	public BackFromTheDead( String name ) 
	{ 
		super("Revived Beans!"); 
		try { 
			Object bean = Beans.instantiate(  
				getClass().getClassLoader(), name ); 

			if ( Beans.isInstanceOf(bean, JComponent.class) ) { 
				JComponent comp = (JComponent)
					Beans.getInstanceOf( bean, JComponent.class ); 
				getContentPane().add("Center", comp); 
			} else {
				System.out.println("Bean is not a Component..."); 
			}
		} catch ( java.io.IOException e1 ) { 
			System.out.println("Error loading the serialized object");
		} catch ( ClassNotFoundException e2 ) { 
			System.out.println(
				"Can't find the class that goes with the object");
		} 
	 } 
 
	public static void main(String [] args) { 
		JFrame frame = new BackFromTheDead( args[0] );
		frame.pack();
		//frame.setSize(300,300);
		frame.setVisible(true);
	} 
}

			</text>
		</p>
		<p n="xj_dynamichookup">
			<text>//file: DynamicHookup.java
import javax.swing.*;
import java.awt.event.*;
import java.beans.EventHandler;

public class DynamicHookup extends JFrame {
  JLabel label = new JLabel( "Ready...", JLabel.CENTER );
  int count;

  public DynamicHookup() {
    JButton launchButton = new JButton("Launch!");
    getContentPane().add( launchButton, "South" );
    getContentPane().add( label, "Center" );
	launchButton.addActionListener( 
		(ActionListener)EventHandler.create(
			ActionListener.class, this, "launchTheMissiles"));
  }

  public void launchTheMissiles() {
    label.setText("Launched: "+ count++ );
  }

  public static void main( String[] args ) {
    JFrame frame = new DynamicHookup();
	frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize(150, 150);
    frame.setVisible( true );
  }
}
			</text>
		</p>
		<p n="xj_serializejuggler">
			<text>import magicbeans.sunw.demo.juggler.Juggler;
import java.io.*;

public class SerializeJuggler {
	public static void main( String [] args ) throws Exception
	{
		Juggler duke = new Juggler(  );
		ObjectOutputStream oout = new ObjectOutputStream(
			new FileOutputStream("juggler.ser") );
		oout.writeObject( duke );
		oout.close();
	}
}
			</text>
		</p>
		<p n="xj_dial">
			<text>
				<![CDATA[package magicbeans;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;

public class Dial extends JComponent {
  int minValue, nvalue, maxValue, radius;

  public Dial() { this(0, 100, 0); }

  public Dial(int minValue, int maxValue, int value) {
    setMinimum( minValue );
    setMaximum( maxValue );
    setValue( value );
    setForeground( Color.lightGray );

    addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent e) { spin(e); }
    });
    addMouseMotionListener(new MouseMotionAdapter() {
      public void mouseDragged(MouseEvent e) { spin(e); }
    });
  }

  protected void spin( MouseEvent e ) {
    int y = e.getY();
    int x = e.getX();
    double th = Math.atan((1.0 * y - radius) / (x - radius));
    int value=(int)(th / (2 * Math.PI) * (maxValue - minValue));
    if (x < radius)
      setValue( value + (maxValue-minValue) / 2 + minValue);
    else if (y < radius)
      setValue( value + maxValue );
    else
      setValue( value + minValue);
  }

  public void paintComponent(Graphics g) {
    Graphics2D g2 = (Graphics2D)g;
    int tick = 10;
    radius = Math.min( getSize().width,getSize().height )/2 - tick;
    g2.setPaint( getForeground().darker() );
    g2.drawLine( radius * 2 + tick / 2, radius, 
       radius * 2 + tick, radius);
    g2.setStroke( new BasicStroke(2) );
    draw3DCircle( g2, 0, 0, radius, true );
    int knobRadius = radius / 7;
    double th = nvalue * (2 * Math.PI) / (maxValue - minValue);
    int x = (int)(Math.cos(th) * (radius - knobRadius * 3)),
    y = (int)(Math.sin(th) * (radius - knobRadius * 3));
    g2.setStroke(new BasicStroke(1));
    draw3DCircle(g2, x + radius - knobRadius, 
       y + radius - knobRadius, knobRadius, false );
  }

  private void draw3DCircle( 
      Graphics g, int x, int y, int radius, boolean raised) 
  {
    Color foreground = getForeground();
    Color light = foreground.brighter();
    Color dark = foreground.darker();
    g.setColor(foreground);
    g.fillOval(x, y, radius * 2, radius * 2);
    g.setColor(raised ? light : dark);
    g.drawArc(x, y, radius * 2, radius * 2, 45, 180);
    g.setColor(raised ? dark : light);
    g.drawArc(x, y, radius * 2, radius * 2, 225, 180);
  }

  public Dimension getPreferredSize() {
    return new Dimension(100, 100);
  }

  public void setValue( int value ) {
    this.nvalue = value - minValue;
    repaint();
    fireEvent();
  }
  public int getValue()  { return nvalue+minValue; }
  public void setMinimum(int minValue)  { this.minValue = minValue; }
  public int getMinimum()  { return minValue; }
  public void setMaximum(int maxValue)  { this.maxValue = maxValue; }
  public int getMaximum()  { return maxValue; }

  public void addDialListener(DialListener listener) {
    listenerList.add( DialListener.class, listener );
  }
  public void removeDialListener(DialListener listener) {
    listenerList.remove( DialListener.class, listener );
  }

  void fireEvent() {
    for ( DialListener listener : getListeners( DialListener.class) )
        listener.dialAdjusted( new DialEvent(this, getValue()) );
  }

  public static void main(String[] args) {
    JFrame frame = new JFrame("Dial v1.0");
    final JLabel statusLabel = new JLabel("Welcome to Dial v1.0");
    final Dial dial = new Dial();
    frame.getContentPane().add(dial, BorderLayout.CENTER);
    frame.getContentPane().add(statusLabel, BorderLayout.SOUTH);

    dial.addDialListener(new DialListener() {
      public void dialAdjusted(DialEvent e) {
        statusLabel.setText("Value is " + e.getValue());
      }
    });

    frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
    frame.setSize( 150, 150 );
    frame.setVisible( true );
  }
}

]]>
			</text>
		</p>
		<p n="xj_dialbeaninfor">
			<text>package magicbeans;

import java.beans.*;

public class DialBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            PropertyDescriptor value = 
				new PropertyDescriptor("value", Dial.class);
            PropertyDescriptor minimum = 
            	new PropertyDescriptor("minimum", Dial.class);
            PropertyDescriptor maximum = 
            	new PropertyDescriptor("maximum", Dial.class);
			
            value.setBound(true);
			minimum.setBound(false);
			maximum.setBound(false);

            return new PropertyDescriptor [] { value, minimum, maximum };
        } catch (IntrospectionException e) {
			return null; 
        }
    }

    public EventSetDescriptor[] getEventSetDescriptors() {
        try {
            EventSetDescriptor dial = new EventSetDescriptor( Dial.class, 
				"dialAdjusted", DialListener.class, "dialAdjusted");
            dial.setDisplayName("Dial Adjusted");

            EventSetDescriptor changed = new EventSetDescriptor( Dial.class,
				"propertyChange", PropertyChangeListener.class, 
				"propertyChange" );
            changed.setDisplayName("Bound property change");
	
            return new EventSetDescriptor [] { dial, changed };
        } catch (IntrospectionException e) {
			return null; 
        }
    }

/*
    public BeanDescriptor getBeanDescriptor() {
        return new BeanDescriptor( Dial.class );
    }
*/

    public java.awt.Image getIcon(int iconKind) {

        if (iconKind == BeanInfo.ICON_COLOR_16x16) {
            return loadImage("DialIconColor16.gif");
        } else
        if (iconKind == BeanInfo.ICON_COLOR_32x32) {
            return loadImage("DialIconColor32.gif");
        } else
        if (iconKind == BeanInfo.ICON_MONO_16x16) {
            return loadImage("DialIconMono16.gif");
        } else
        if (iconKind == BeanInfo.ICON_MONO_32x32) {
            return loadImage("DialIconMono32.gif");
        }
        return null;
    }
}

			</text>
		</p>
		<p n="xj_dialevent">
			<text>package magicbeans;

import java.awt.*;

public class DialEvent extends java.util.EventObject {
	int value;

	DialEvent( Dial source, int value ) {
		super( source );
		this.value = value;
	}
	public int getValue() {
		return value;
	}
}
			</text>
		</p>
		<p n="xj_diallistener">
			<text>package magicbeans;

public interface DialListener extends java.util.EventListener {
	void dialAdjusted( DialEvent e );
}
			</text>
		</p>
		<p n="xj_multiplier">
			<text>package magicbeans;

import java.beans.*;

public class Multiplier implements java.io.Serializable {
	private double a, b, c;
	
	synchronized public void setA( double val ) { 
		a = val; 
		multiply();
	}

	synchronized public double getA() { 
		return a; 
	}

	synchronized public void setB( double val ) { 
		b = val; 
		multiply();
	}

	synchronized public double getB() { 
		return b; 
	}

	synchronized public double getC() { 
		return c; 
	} 	

	synchronized public void setC( double val ) { 
		multiply();
	} 	

	private void multiply() {
		double oldC = c;
		c = a * b;
		propChanges.firePropertyChange( 
			"C", new Double(oldC) , new Double(c) );
	}

    private PropertyChangeSupport propChanges = new PropertyChangeSupport(this);

	public void addPropertyChangeListener(PropertyChangeListener listener) {
        propChanges.addPropertyChangeListener(listener);
    }
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        propChanges.removePropertyChangeListener(listener);
	}
}
			</text>
		</p>
		<p n="xj_numbericfield">
			<text>package magicbeans;

import javax.swing.*;
import java.awt.event.*;

public class NumericField extends JTextField {
	static int defaultFieldSize = 6;
	private double value;

    public NumericField() { 
		super( defaultFieldSize );
		setInputVerifier( new InputVerifier() {
			public boolean verify( JComponent comp ) {
				JTextField field = (JTextField)comp;
				boolean passed = false;
				try {
					setValue( Double.parseDouble( field.getText() ) );
				} catch ( NumberFormatException e ) {
					comp.getToolkit().beep();
					field.selectAll();
					return false;
				}
				return true;
			}
		} );

		addActionListener( new ActionListener() {
			public void actionPerformed( ActionEvent e ) {
				getInputVerifier().verify( NumericField.this );
			}
		} );

	}
 
	public double getValue() {
		return value;
	}
	public void setValue( double newValue ) {
		double oldValue = value;
		value = newValue;
		setText( "" + newValue );
		firePropertyChange( "value", oldValue, newValue );
	}
}
			</text>
		</p>
		<p n="xj_showcontext">
			<text>
				<![CDATA[package magicbeans;

import javax.swing.*;
import java.beans.beancontext.*;
import java.util.*;

public class ShowContext extends JTabbedPane implements BeanContextProxy {
	BeanContext context;
	BeanContextServices services;
	JList servicesList = new JList(), beansList = new JList();

	public ShowContext() {
		addTab( "Beans", new JScrollPane( beansList ) );
		addTab( "Services", new JScrollPane( servicesList ) );
	}

    private BeanContextChildSupport beanContextChild = 
		new BeanContextChildSupport() {

		public void initializeBeanContextResources()	{
			context= getBeanContext();
			try	{
				services = (BeanContextServices)context;
			} catch (ClassCastException	ex) { /* No BeanContextServices */ } 

			updateBeanList();
			updateServicesList();

			context.addBeanContextMembershipListener( 
				new BeanContextMembershipListener() {
					public void childrenAdded( BeanContextMembershipEvent e ) { 
						updateBeanList();
					}
					public void childrenRemoved( BeanContextMembershipEvent e ){
						updateBeanList();
					}
				} );
			services.addBeanContextServicesListener( 
				new BeanContextServicesListener() {
					public void serviceAvailable( 
								BeanContextServiceAvailableEvent e ) {
						updateServicesList();
					}
					public void serviceRevoked( 
								BeanContextServiceRevokedEvent e ) {
						updateServicesList();
					}
				} );
		}
    };

	void updateServicesList() {
		if ( services == null )
			return;
		Iterator it = services.getCurrentServiceClasses();
		Vector<Object> v = new Vector<Object>();
		while( it.hasNext() )
			v.addElement( it.next() );
		servicesList.setListData( v );
	}
	void updateBeanList() {
		Iterator it = context.iterator();
		Vector<Object> v = new Vector<Object>();
		while( it.hasNext() )
			v.addElement( it.next() );
		beansList.setListData( v );
	}

    public BeanContextChild getBeanContextProxy() {
		return beanContextChild;
    }
}
]]>
			</text>
		</p>
		<p n="xj_timer">
			<text>
				<![CDATA[package magicbeans;

import java.util.*;

public class Timer implements Runnable
{
	long delay = 200;
	Thread thread;
	boolean stopped = true;
	List<TimerListener> listeners = new ArrayList<TimerListener>();

	public Timer() { 
		start();
	}

	public void run() {
		while( !stopped )
		{
			fireEvent();
			try {
				Thread.sleep( delay );
			} catch ( InterruptedException e ) {
				return; // die
			}
		}
	}

	public void addTimerListener(TimerListener listener) {
		listeners.add( listener );
	}

	public void removeTimerListener(TimerListener listener) {
		listeners.remove( listener );
	}

	void fireEvent() {
		for ( TimerListener listener : listeners )
			listener.timerFired( new TimerEvent(this) );
	}

	public void setDelay( long delay ) { this.delay = delay; }
	public long getDelay() { return this.delay; }

	public boolean isRunning() { return !stopped; }
	public void setRunning( boolean b ) { 
		if ( b ) 
			start();
		else
			stop();
	}

	public synchronized void stop() { 
		if ( !stopped )
		{
			stopped = true;
			if ( thread != null )
				thread.interrupt();
		}
	}
	public synchronized void start() {
		if ( stopped )
		{
			stopped = false;
			thread = new Thread(this);
			thread.start();
		}
	}
}
]]>
			</text>
		</p>
		<p n="xj_timerbeaninfo">
			<text>package magicbeans;

import java.beans.*;

public class TimerBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            PropertyDescriptor delay = 
				new PropertyDescriptor("delay", Timer.class );
            delay.setBound(false);
			
			PropertyDescriptor running =
				new PropertyDescriptor("running", Timer.class );


            return new PropertyDescriptor [] { delay, running };
        } catch (IntrospectionException e) {
			return null; 
        }
    }

    public EventSetDescriptor[] getEventSetDescriptors() {
        try {
            EventSetDescriptor timer = new EventSetDescriptor( 
				Timer.class, 
				"timerFired", TimerListener.class, "timerFired");
            timer.setDisplayName("Timer Fired");

            return new EventSetDescriptor [] { timer };
        } catch (IntrospectionException e) {
			return null; 
        }
    }

}

			</text>
		</p>
		<p n="xj_timerevent">
			<text>package magicbeans;

import java.awt.*;

public class TimerEvent extends java.util.EventObject {
	int value;

	TimerEvent( Timer source ) {
		super( source );
	}
}
			</text>
		</p>
		<p n="xj_timerlistener">
			<text>package magicbeans;

public interface TimerListener extends java.util.EventListener {
	void timerFired( TimerEvent e );
}
			</text>
		</p>
		<p n="xj_trivial">
			<text>package magicbeans;

public class Trivial implements java.io.Serializable {
	boolean foo = false;
	public void setFoo( boolean b ) {
		foo=b;
	}
	public boolean getFoo() {
		return foo;
	}

	boolean bar = false;
	public void setBar( boolean b ) {
		bar=b;
	}
	public boolean isBar() {
		return bar;
	}
}
			</text>
		</p>
		<p n="xj_trivialcomponent">
			<text>package magicbeans;

import javax.swing.*;
import java.awt.Graphics;

public class TrivialComponent extends JComponent {

	public void paintComponent( Graphics g ) { 
		g.setColor( getBackground() );
		g.fillRect( 0, 0, getSize().width, getSize().height );
	}

}
			</text>
		</p>
		<p n="xj_juggler">
			<text>
				<![CDATA[
package magicbeans.sunw.demo.juggler;

/**
 * A simple JavaBean demonstration class that displays an animation
 * of Duke juggling a couple of coffee beans.    The Juggler class
 * is a good simple example of how to write readObject/writeObject
 * serialization methods that restore transient state.    In this case
 * the transient state is an array of images and a Thread.
 */
// Updates and Modifications for LearningJava
// 02/2002, Niemeyer
// Added image pre-loading
// Added setJuggling() property
// Added readObject() support for serialization
// 12/2004 Changed package to avoid conflict with original Sun JavaBeans
//   examples which don't play well in NetBeans 4.x.

import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.net.URL;
import java.beans.*;
import java.beans.DesignMode.*;
import javax.swing.*;
import java.io.*;

public class Juggler extends JComponent
implements Runnable, PropertyChangeListener, DesignMode {
    private transient Image[] images;
    private transient Thread animationThread;
    private int rate = 125;
    private transient int loop;
    private boolean stopped = true;
    private boolean debug = false;
    private boolean dmode = false;
    
    public Juggler() {
        initialize();
        setJuggling(true);
    }
    
    /**
     * method: start the Juggler .
     */
    
    public synchronized void start() {
        startJuggling();
    }
    
    /**
     * method: stop the Juggler .
     */
    
    public synchronized void stop() {
        stopJuggling();
    }
    
    /**
     * Initialize the Juggler .
     */
    private void initialize() 
    {
        // Load the image resources:
        images = new Image[5];
        for (int i = 0; i < 5; i++) {
            String imageName = "Juggler" + i + ".gif";
            images[i] = loadImage(imageName);
            if (images[i] == null) {
                System.err.println("Couldn't load image " + imageName);
                return;
            }
        }
    }
    
    
    /**
     * This is an internal utility method to load GIF icons.
     * It takes the name of a resource file associated with the
     * current object's class-loader and loads a GIF image
     * from that file.
     * <p>
     * @return    a GIF image object.    May be null if the load failed.
     */
    private java.awt.Image loadImage(String name) {
        try {
            java.net.URL url = getClass().getResource(name);
            
            ImageIcon icon = new ImageIcon(url);
            Image i = icon.getImage();
            return i;
        } catch (Exception ex) {
            return null;
        }
    }
    
    
    /**
     * Draw the current frame.
     */
    public void paintComponent(Graphics g) {
        int index = (loop%%4) + 1;
        // If the animation is stopped, show the startup image.
        if (stopped) {
            index = 0;
        }
        if (images == null || index >= images.length) {
            return;
        }
        Image img = images[index];
        if (img != null) {
            g.drawImage(img, 0, 0, this);
        }
    }
    
    
    /**
     * If false, suspend the animation thread.
     */
    public synchronized void setEnabled(boolean x) {
        super.setEnabled(x);
        notify();
    }
    
    
    /**
     * Resume the animation thread if we're enabled.
     * @see #stopJuggling
     * @see #setEnabled
     */
    public synchronized void startJuggling() {
        if (images == null) {
            initialize();
        }
        if (animationThread == null) {
            animationThread = new Thread(this);
            animationThread.start();
        }
        stopped = false;
        notify();
    }
    
    /**
     * Suspend the animation thread if neccessary.
     * @see #startJuggling
     * @see #setEnabled
     */
    public synchronized void stopJuggling() {
        stopped = true;
        loop = 0;
        // Draw the stopped frame.
        Graphics g = getGraphics();
        if (g == null || images == null) {
            return;
        }
        Image img = images[0];
        if (img != null) {
            g.drawImage(img, 0, 0, this);
        }
    }
    
    
    /**
     * An event handling method that calls startJuggling.    This method
     * can be used to connect a Button or a MenuItem to the Juggler.
     *
     */
    public void startJuggling(ActionEvent x) {
        startJuggling();
    }
    
    /**
     * This method can be used to connect a Button or a MenuItem
     * to the Juggler.stopJuggling method.
     */
    public void stopJuggling(ActionEvent x) {
        stopJuggling();
    }
    
    
    /**
     * Returns false if the Juggler is stopped, true otherwise.
     */
    public boolean isJuggling() {
        return !stopped;
    }
    
    public int getAnimationDelay() {
        return rate;
    }
    
    public void setAnimationDelay(int x) {
        rate = x;
    }
    
    
    public Dimension getMinimumSize() {
        return new Dimension(144, 125);
    }
    
    public Dimension getPreferredSize() {
        return getMinimumSize();
    }
    
    /*
     * PropertyChangeListener method.  Currently only listen for designMode.
     */
    public void propertyChange( PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals("designMode")) {
            boolean dmode = (boolean)((Boolean)evt.getNewValue()).booleanValue();
            setDesignTime(dmode);
        }
    }
    
    /*
     * If switching to runtime, turn off method tracing if it was enabled.
     * If switching to design time and debugging is true, then enable
     * method tracing if the service is available.
     */
    public void setDesignTime(boolean dmode) {
        this.dmode = dmode;
    }
    
   /*
    * Returns true if we're in design mode, false if in runtime mode.
    */
    public boolean isDesignTime() {
        return dmode;
    }
    
    public void run() {
        try {
            while(true) {
                // First wait until the animation is not stopped.
                synchronized (this) {
                    while (stopped || !isEnabled()) {
                        wait();
                    }
                }
                loop++;
                // Now draw the current frame.
                Graphics g = getGraphics();
                Image img = images[(loop %% 4) + 1];
                if (g != null && img != null) {
                    g.drawImage(img, 0, 0, this);
                }
                Thread.sleep(rate);
            }
        } catch (InterruptedException e) {
        }
    }
    
    public void setJuggling( boolean b ) {
        if ( b )
            start();
        else
            stop();
    }
    
    private void readObject(ObjectInputStream s)
    throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        initialize();
        if ( !stopped )
            start();
    }
    
}
]]>
			</text>
		</p>
		<p n="xj_jugglerbeaninfo">
			<text>
/** 
 * The only thing we define in the Juggler BeanInfo is a GIF icon.
 */

package magicbeans.sunw.demo.juggler;

import java.beans.*;

public class JugglerBeanInfo extends SimpleBeanInfo {

    public java.awt.Image getIcon(int iconKind) {
	if (iconKind == BeanInfo.ICON_COLOR_16x16) {
	    java.awt.Image img = loadImage("JugglerIcon.gif");
	    return img;
	}
	return null;
    }

    public PropertyDescriptor[] getPropertyDescriptors() {
	try {
	    PropertyDescriptor animationRate =
		new PropertyDescriptor("animationRate", beanClass);

	    PropertyDescriptor name =
		new PropertyDescriptor("name", beanClass);

	    PropertyDescriptor juggling =
		new PropertyDescriptor("juggling", beanClass);

	    animationRate.setBound(true);
	    name.setBound(true);

	    PropertyDescriptor rv[] = { juggling, animationRate, name};
	    return rv;
	} catch( IntrospectionException e) {
	    throw new Error(e.toString());
	}
    }

    public int getDefaultPropertyIndex() {
	// the index for the animationRate property.
	return 1;
    }

    private final static Class beanClass = Juggler.class;
}
			</text>
		</p>
		<p n="xj_atom">
			<text>
				<![CDATA[/*
 * A set of classes to parse, represent and display Chemical compounds in
 * .xyz format (see http://chem.leeds.ac.uk/Project/MIME.html)
 */

package magicbeans.sunw.demo.molecule;

import java.awt.*;
import java.awt.image.*;

class Atom {
    private static java.awt.Component panel;
    private static byte[] data;
    private final static int R = 40;
    private final static int hx = 15;
    private final static int hy = 15;
    private final static int bgGrey = 192;
    private final static int nBalls = 16;
    private static int maxr;

    private int Rl;
    private int Gl;
    private int Bl;
    private Image balls[];

    static {
	data = new byte[R * 2 * R * 2];
	int mr = 0;
	for (int Y = 2 * R; --Y >= 0;) {
	    int x0 = (int) (Math.sqrt(R * R - (Y - R) * (Y - R)) + 0.5);
	    int p = Y * (R * 2) + R - x0;
	    for (int X = -x0; X < x0; X++) {
		int x = X + hx;
		int y = Y - R + hy;
		int r = (int) (Math.sqrt(x * x + y * y) + 0.5);
		if (r > mr)
		    mr = r;
		data[p++] = r <= 0 ? 1 : (byte) r;
	    }
	}
	maxr = mr;
    }
    static void setComponent(java.awt.Component app) {
	panel = app;
    }
    Atom(int Rl, int Gl, int Bl) {
	this.Rl = Rl;
	this.Gl = Gl;
	this.Bl = Bl;
    }
    private final int blend(int fg, int bg, float fgfactor) {
	return (int) (bg + (fg - bg) * fgfactor);
    }
    private synchronized void Setup() {
	balls = new Image[nBalls];
	byte red[] = new byte[256];
	red[0] = (byte) bgGrey;
	byte green[] = new byte[256];
	green[0] = (byte) bgGrey;
	byte blue[] = new byte[256];
	blue[0] = (byte) bgGrey;
	for (int r = 0; r < nBalls; r++) {
	    float b = (float) (r+1) / nBalls;
	    for (int i = maxr; i >= 1; --i) {
		float d = (float) i / maxr;
		red[i] = (byte) blend(blend(Rl, 255, d), bgGrey, b);
		green[i] = (byte) blend(blend(Gl, 255, d), bgGrey, b);
		blue[i] = (byte) blend(blend(Bl, 255, d), bgGrey, b);
	    }
	    IndexColorModel model = new IndexColorModel(8, maxr + 1,
							red, green, blue, 0);
	    balls[r] = panel.createImage(
		new MemoryImageSource(R*2, R*2, model, data, 0, R*2));
	}
    }
    synchronized void paint(Graphics gc, int x, int y, int radius) {
	if (balls == null) {
	    Setup();
	}
	Image i = balls[radius];
	int size = 10 + radius;
	gc.drawImage(i, x - (size/2), y - (size/2), size, size, panel);
    }
}
]]>
			</text>
		</p>
		<p n="xj_matrix3d">
			<text>
				<![CDATA[
/** A fairly conventional 3D matrix object that can transform sets of
    3D points and perform a variety of manipulations on the transform */

package magicbeans.sunw.demo.molecule;

class Matrix3D {
    float xx, xy, xz, xo;
    float yx, yy, yz, yo;
    float zx, zy, zz, zo;
    static final double pi = 3.14159265;
    /** Create a new unit matrix */
    Matrix3D () {
	xx = 1.0f;
	yy = 1.0f;
	zz = 1.0f;
    }
    /** Scale by f in all dimensions */
    void scale(float f) {
	xx *= f;
	xy *= f;
	xz *= f;
	xo *= f;
	yx *= f;
	yy *= f;
	yz *= f;
	yo *= f;
	zx *= f;
	zy *= f;
	zz *= f;
	zo *= f;
    }
    /** Scale along each axis independently */
    void scale(float xf, float yf, float zf) {
	xx *= xf;
	xy *= xf;
	xz *= xf;
	xo *= xf;
	yx *= yf;
	yy *= yf;
	yz *= yf;
	yo *= yf;
	zx *= zf;
	zy *= zf;
	zz *= zf;
	zo *= zf;
    }
    /** Translate the origin */
    void translate(float x, float y, float z) {
	xo += x;
	yo += y;
	zo += z;
    }
    /** rotate theta degrees about the y axis */
    void yrot(double theta) {
	theta *= (pi / 180);
	double ct = Math.cos(theta);
	double st = Math.sin(theta);

	float Nxx = (float) (xx * ct + zx * st);
	float Nxy = (float) (xy * ct + zy * st);
	float Nxz = (float) (xz * ct + zz * st);
	float Nxo = (float) (xo * ct + zo * st);

	float Nzx = (float) (zx * ct - xx * st);
	float Nzy = (float) (zy * ct - xy * st);
	float Nzz = (float) (zz * ct - xz * st);
	float Nzo = (float) (zo * ct - xo * st);

	xo = Nxo;
	xx = Nxx;
	xy = Nxy;
	xz = Nxz;
	zo = Nzo;
	zx = Nzx;
	zy = Nzy;
	zz = Nzz;
    }
    /** rotate theta degrees about the x axis */
    void xrot(double theta) {
	theta *= (pi / 180);
	double ct = Math.cos(theta);
	double st = Math.sin(theta);

	float Nyx = (float) (yx * ct + zx * st);
	float Nyy = (float) (yy * ct + zy * st);
	float Nyz = (float) (yz * ct + zz * st);
	float Nyo = (float) (yo * ct + zo * st);

	float Nzx = (float) (zx * ct - yx * st);
	float Nzy = (float) (zy * ct - yy * st);
	float Nzz = (float) (zz * ct - yz * st);
	float Nzo = (float) (zo * ct - yo * st);

	yo = Nyo;
	yx = Nyx;
	yy = Nyy;
	yz = Nyz;
	zo = Nzo;
	zx = Nzx;
	zy = Nzy;
	zz = Nzz;
    }
    /** rotate theta degrees about the z axis */
    void zrot(double theta) {
	theta *= (pi / 180);
	double ct = Math.cos(theta);
	double st = Math.sin(theta);

	float Nyx = (float) (yx * ct + xx * st);
	float Nyy = (float) (yy * ct + xy * st);
	float Nyz = (float) (yz * ct + xz * st);
	float Nyo = (float) (yo * ct + xo * st);

	float Nxx = (float) (xx * ct - yx * st);
	float Nxy = (float) (xy * ct - yy * st);
	float Nxz = (float) (xz * ct - yz * st);
	float Nxo = (float) (xo * ct - yo * st);

	yo = Nyo;
	yx = Nyx;
	yy = Nyy;
	yz = Nyz;
	xo = Nxo;
	xx = Nxx;
	xy = Nxy;
	xz = Nxz;
    }
    /** Multiply this matrix by a second: M = M*R */
    void mult(Matrix3D rhs) {
	float lxx = xx * rhs.xx + yx * rhs.xy + zx * rhs.xz;
	float lxy = xy * rhs.xx + yy * rhs.xy + zy * rhs.xz;
	float lxz = xz * rhs.xx + yz * rhs.xy + zz * rhs.xz;
	float lxo = xo * rhs.xx + yo * rhs.xy + zo * rhs.xz + rhs.xo;

	float lyx = xx * rhs.yx + yx * rhs.yy + zx * rhs.yz;
	float lyy = xy * rhs.yx + yy * rhs.yy + zy * rhs.yz;
	float lyz = xz * rhs.yx + yz * rhs.yy + zz * rhs.yz;
	float lyo = xo * rhs.yx + yo * rhs.yy + zo * rhs.yz + rhs.yo;

	float lzx = xx * rhs.zx + yx * rhs.zy + zx * rhs.zz;
	float lzy = xy * rhs.zx + yy * rhs.zy + zy * rhs.zz;
	float lzz = xz * rhs.zx + yz * rhs.zy + zz * rhs.zz;
	float lzo = xo * rhs.zx + yo * rhs.zy + zo * rhs.zz + rhs.zo;

	xx = lxx;
	xy = lxy;
	xz = lxz;
	xo = lxo;

	yx = lyx;
	yy = lyy;
	yz = lyz;
	yo = lyo;

	zx = lzx;
	zy = lzy;
	zz = lzz;
	zo = lzo;
    }

    /** Reinitialize to the unit matrix */
    void unit() {
	xo = 0;
	xx = 1;
	xy = 0;
	xz = 0;
	yo = 0;
	yx = 0;
	yy = 1;
	yz = 0;
	zo = 0;
	zx = 0;
	zy = 0;
	zz = 1;
    }
    /** Transform nvert points from v into tv.  v contains the input
        coordinates in floating point.  Three successive entries in
	the array constitute a point.  tv ends up holding the transformed
	points as integers; three successive entries per point */
    void transform(float v[], int tv[], int nvert) {
	float lxx = xx, lxy = xy, lxz = xz, lxo = xo;
	float lyx = yx, lyy = yy, lyz = yz, lyo = yo;
	float lzx = zx, lzy = zy, lzz = zz, lzo = zo;
	for (int i = nvert * 3; (i -= 3) >= 0;) {
	    float x = v[i];
	    float y = v[i + 1];
	    float z = v[i + 2];
	    tv[i    ] = (int) (x * lxx + y * lxy + z * lxz + lxo);
	    tv[i + 1] = (int) (x * lyx + y * lyy + z * lyz + lyo);
	    tv[i + 2] = (int) (x * lzx + y * lzy + z * lzz + lzo);
	}
    }
    public String toString() {
	return ("[" + xo + "," + xx + "," + xy + "," + xz + ";"
		+ yo + "," + yx + "," + yy + "," + yz + ";"
		+ zo + "," + zx + "," + zy + "," + zz + "]");
    }
}
]]>
			</text>
		</p>
		<p n="xj_molecute">
			<text>
				<![CDATA[/**
 * A bean to parse, represent and display Chemical compounds in
 * .xyz format (see http://chem.leeds.ac.uk/Project/MIME.html)
 */

// Modifications and updates for LearningJava
// 02/2002, Niemeyer
package magicbeans.sunw.demo.molecule;

import java.io.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/* A Bean to display a Chemical model */

public class Molecule extends JComponent 
	implements Serializable, MouseListener, MouseMotionListener 
{
    private static int ourVersion = 3;
    XYZChemModel md;
    float xfac;
    int prevx;
    int prevy;
    float xtheta;
    float ytheta;
    float scalefudge;
    Matrix3D amat;
    Matrix3D tmat;
    String message = null;
    Image backBuffer;
    Graphics backGC;
    int width;
    int height;

    public Molecule() {
	reset();
	amat.yrot(20);
	amat.xrot(20);
	setBackground(java.awt.Color.white);
	addMouseListener(this);
	addMouseMotionListener(this);
    }

    public java.awt.Dimension getPreferredSize() {
	return new java.awt.Dimension(150,150);
    }

    public synchronized void initialize() {

	InputStream is = null;

	try {
	    width = getSize().width;
	    height = getSize().height;

	    is = this.getClass().getResourceAsStream(moleculeName + ".xyz");

	    XYZChemModel m = new XYZChemModel(is);
	    Atom.setComponent(this);
	    md = m;
	    m.findBB();
	    float xw = m.xmax - m.xmin;
	    float yw = m.ymax - m.ymin;
	    float zw = m.zmax - m.zmin;
	    if (yw > xw) {
		xw = yw;
	    }
	    if (zw > xw) {
		xw = zw;
	    }
	    float f1 = width / xw;
	    float f2 = height / xw;
	    xfac = 0.7f * (f1 < f2 ? f1 : f2) * scalefudge;
	    backBuffer = createImage(width, height);
	    backGC = backBuffer.getGraphics();
	} catch(Exception e) {
	    e.printStackTrace();
	    md = null;
	    message = e.toString();
	}
	try {
	    if (is != null) {
		is.close();
	    }
	} catch(Exception e) {
	}
    }

    private synchronized void rotate(int x, int y) {
	tmat.unit();
	float xtheta = (prevy - y) * (360.0f / width);
	float ytheta = (x - prevx) * (360.0f / height);
	tmat.xrot(xtheta);
	tmat.yrot(ytheta);
	amat.mult(tmat);
        repaint();
	prevx = x;
	prevy = y;
    }

    //----------------------------------------------------------------------

    // Mouse listener methods.

    public void mouseClicked(MouseEvent evt) {
    }

    public synchronized void mousePressed(MouseEvent evt) {
	prevx = evt.getX();
	prevy = evt.getY();
    }

    public void mouseReleased(MouseEvent evt) {
    }

    public void mouseEntered(MouseEvent evt) {
    }

    public void mouseExited(MouseEvent evt) {
    }

    public void mouseDragged(MouseEvent evt) { 
        rotate(evt.getX(), evt.getY());
    }

    public void mouseMoved(MouseEvent evt) {
    }

    //----------------------------------------------------------------------

    public synchronized void rotateOnY() {
	int x = prevx;
	int y = (prevy + 10)%%height;
	rotate(x, y);
    }

    public synchronized void rotateY(ActionEvent b) {
	rotateOnY();
    }

    public synchronized void rotateOnX() {
	int x = (prevx + 10)%%width;
	int y = prevy;
	rotate(x, y);
    }

    public synchronized void rotateX(ActionEvent b) {

         rotateOnX();
    }

    public synchronized void update(Graphics g) {
	if (backBuffer == null) {
	    g.clearRect(0, 0, getSize().width, getSize().height);
	}
	paint(g);
    }

    public synchronized void paint(Graphics g) {

	if (backBuffer == null || getSize().width != width 
				   || getSize().height != height) {
	    initialize();
	}

	if (md != null) {
	    md.mat.unit();
	    md.mat.translate(-(md.xmin + md.xmax) / 2,
			     -(md.ymin + md.ymax) / 2,
			     -(md.zmin + md.zmax) / 2);
	    md.mat.mult(amat);
	    // md.mat.scale(xfac, -xfac, 8 * xfac / getSize().width);
	    md.mat.scale(xfac, -xfac, 16 * xfac / getSize().width);
	    md.mat.translate(getSize().width / 2, getSize().height / 2, 8);
	    md.transformed = false;

	    backGC.setColor(getBackground());
	    backGC.fillRect(0,0,getSize().width, getSize().height);
	    md.paint(backGC);
	    g.drawImage(backBuffer, 0, 0, this);

	} else if (message != null) {
	    g.drawString("Error in model:", 3, 20);
	    g.drawString(message, 10, 40);
	}
    }

    // Support for serialization.  KGH 6/2/96

    private void writeObject(java.io.ObjectOutputStream s)
        		throws java.io.IOException {
	s.writeInt(ourVersion);
	s.writeObject(moleculeName);
    }

    private void readObject(java.io.ObjectInputStream s)
        		throws java.lang.ClassNotFoundException,
			       java.io.IOException {
	// Compensate for missing constructor.
	reset();
	if (s.readInt() != ourVersion) {
	    throw new IOException("Molecule.readObject: version mismatch");
	}
	moleculeName = (String) s.readObject();
    }

    private synchronized void reset() {
	md = null;
	xfac = (float)0.0;
	prevx = 0;
	prevy = 0;
	xtheta = (float)0.0;
	ytheta = (float)0.0;
	scalefudge = 1;
        amat = new Matrix3D();
        tmat = new Matrix3D();
	message = null;
	backBuffer = null;
	backGC = null;
    }

    //-----------------------------------------------------------------
    // Beans properties.

    public String getMoleculeName() {
	return moleculeName;
    }

    public void setMoleculeName(String name) {
	moleculeName = name;
	reset();
	repaint();
    }

    private String moleculeName = "HyaluronicAcid";

}
]]>
			</text>
		</p>
		<p n="xj_moleculebeaninfo">
			<text>
package magicbeans.sunw.demo.molecule;

/**
 * BeanInfo for a molecule.  We simply expose a single property
 * the molecule name, with a custome proeprty editor.
 */

import java.beans.*;

public class MoleculeBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
	try {
	    PropertyDescriptor pd = new PropertyDescriptor("moleculeName",
					    		Molecule.class);
	    pd.setPropertyEditorClass(MoleculeNameEditor.class);
	    PropertyDescriptor result[] = { pd };
	    return result;
	} catch (Exception ex) {
	    System.err.println("MoleculeBeanInfo: unexpected exeption: " + ex);
	    return null;
	}
    }

}
			</text>
		</p>
		<p n="xj_moleculenameeditor">
			<text>
package magicbeans.sunw.demo.molecule;

/**
 * Special case property editor for molecule names.
 */

public class MoleculeNameEditor
		extends java.beans.PropertyEditorSupport {

    public String[] getTags() {
	String result[] = {
	    "HyaluronicAcid",
	    "benzene",
	    "buckminsterfullerine",
	    "cyclohexane",
	    "ethane",
	    "water"};
	return result;
    }

    public String getJavaInitializationString() {
	return (String)getValue();
    }

}

			</text>
		</p>
		<p n="xj_xyzchemmodel">
			<text>
				<![CDATA[/*
 * A set of classes to parse, represent and display Chemical compounds in
 * .xyz format (see http://chem.leeds.ac.uk/Project/MIME.html)
 */
 // Made atomTable generic Map 12/2004 - Pat Niemeyer

package magicbeans.sunw.demo.molecule;

import java.io.*;
import java.util.*;


/** The representation of a Chemical .xyz model */
class XYZChemModel {
    float vert[];
    Atom atoms[];
    int tvert[];
    int ZsortMap[];
    int nvert, maxvert;

    static Map<String,Atom> atomTable = new HashMap<String,Atom>();
    static Atom defaultAtom;
    static {
	atomTable.put("c", new Atom(0, 0, 0));
	atomTable.put("h", new Atom(210, 210, 210));
	atomTable.put("n", new Atom(0, 0, 255));
	atomTable.put("o", new Atom(255, 0, 0));
	atomTable.put("p", new Atom(255, 0, 255));
	atomTable.put("s", new Atom(255, 255, 0));
	atomTable.put("hn", new Atom(150, 255, 150)); /* !!*/
	defaultAtom = new Atom(255, 100, 200);
    }

    boolean transformed;
    Matrix3D mat;

    float xmin, xmax, ymin, ymax, zmin, zmax;


    XYZChemModel () {
	mat = new Matrix3D();
	mat.xrot(20);
	mat.yrot(30);
    }


    /** Create a Chemical model by parsing an input stream */
    XYZChemModel (InputStream is) {
	this();
        try {
	    StreamTokenizer st = new StreamTokenizer(
			new BufferedReader(new InputStreamReader(is)));
	    st.eolIsSignificant(true);
	    st.commentChar('#');
	    int slot = 0;
scan:
	    while (true) {
	        switch (st.nextToken()) {
	          case StreamTokenizer.TT_EOF:
		    break scan;
	          default:
		    break;
	          case StreamTokenizer.TT_WORD:
		    String name = st.sval;
		    double x = 0, y = 0, z = 0;
		    if (st.nextToken() == StreamTokenizer.TT_NUMBER) {
		        x = st.nval;
		        if (st.nextToken() == StreamTokenizer.TT_NUMBER) {
			    y = st.nval;
			    if (st.nextToken() == StreamTokenizer.TT_NUMBER)
			        z = st.nval;
		        }
		    }
		    addVert(name, (float) x, (float) y, (float) z);
		    while (st.ttype != StreamTokenizer.TT_EOL &&
			    st.ttype != StreamTokenizer.TT_EOF)
		        st.nextToken();
	        }
	    }
	    is.close();
	    if (st.ttype != StreamTokenizer.TT_EOF)
	        throw new Error(st.toString());
        } catch (Exception ex) {
    	    throw new Error("Input error: " + ex);
	}
    }

    /** Add a vertex to this model */
    int addVert(String name, float x, float y, float z) {
	int i = nvert;
	if (i >= maxvert)
	    if (vert == null) {
		maxvert = 100;
		vert = new float[maxvert * 3];
		atoms = new Atom[maxvert];
	    } else {
		maxvert *= 2;
		float nv[] = new float[maxvert * 3];
		System.arraycopy(vert, 0, nv, 0, vert.length);
		vert = nv;
		Atom na[] = new Atom[maxvert];
		System.arraycopy(atoms, 0, na, 0, atoms.length);
		atoms = na;
	    }
	Atom a = (Atom) atomTable.get(name.toLowerCase());
	if (a == null) a = defaultAtom;
	atoms[i] = a;
	i *= 3;
	vert[i] = x;
	vert[i + 1] = y;
	vert[i + 2] = z;
	return nvert++;
    }

    /** Transform all the points in this model */
    void transform() {
	if (transformed || nvert <= 0)
	    return;
	if (tvert == null || tvert.length < nvert * 3)
	    tvert = new int[nvert * 3];
	mat.transform(vert, tvert, nvert);
	transformed = true;
    }


    /**
     * Paint this model to a graphics context.  It uses the matrix associated
     * with this model to map from model space to screen space.
     * The next version of the browser should have double buffering,
     * which will make this *much* nicer 
     */
    synchronized void paint(java.awt.Graphics g) {
	if (vert == null || nvert <= 0)
	    return;
	transform();
	int v[] = tvert;
	int zs[] = ZsortMap;
	if (zs == null) {
	    ZsortMap = zs = new int[nvert];
	    for (int i = nvert; --i >= 0;)
		zs[i] = i * 3;
	}

	/*
	 * I use a bubble sort since from one iteration to the next, the sort
	 * order is pretty stable, so I just use what I had last time as a
	 * "guess" of the sorted order.  With luck, this reduces O(N log N)
	 * to O(N)
	 */

	for (int i = nvert - 1; --i >= 0;) {
	    boolean flipped = false;
	    for (int j = 0; j <= i; j++) {
		int a = zs[j];
		int b = zs[j + 1];
		if (v[a + 2] > v[b + 2]) {
		    zs[j + 1] = a;
		    zs[j] = b;
		    flipped = true;
		}
	    }
	    if (!flipped)
		break;
	}

	int lg = 0;
	int lim = nvert;
	Atom ls[] = atoms;
	if (lim <= 0 || nvert <= 0) {
	    return;
	}
	for (int i = 0; i < lim; i++) {
	    int j = zs[i];
	    int radius = v[j + 2];
	    if (radius < 0) {
		radius = 0;
	    } else if (radius > 15) {
		radius = 15;
	    }
	    atoms[j/3].paint(g, v[j], v[j + 1], radius);
	}
    }

    /** Find the bounding box of this model */
    void findBB() {
	if (nvert <= 0)
	    return;
	float v[] = vert;
	float xmin = v[0], xmax = xmin;
	float ymin = v[1], ymax = ymin;
	float zmin = v[2], zmax = zmin;
	for (int i = nvert * 3; (i -= 3) > 0;) {
	    float x = v[i];
	    if (x < xmin)
		xmin = x;
	    if (x > xmax)
		xmax = x;
	    float y = v[i + 1];
	    if (y < ymin)
		ymin = y;
	    if (y > ymax)
		ymax = y;
	    float z = v[i + 2];
	    if (z < zmin)
		zmin = z;
	    if (z > zmax)
		zmax = z;
	}
	this.xmax = xmax;
	this.xmin = xmin;
	this.ymax = ymax;
	this.ymin = ymin;
	this.zmax = zmax;
	this.zmin = zmin;
    }
}
]]>
			</text>
		</p>
		<p n="xj_serializejugglerxml">
			<text>import magicbeans.sunw.demo.juggler.Juggler;
import java.io.*;

/*
	Not implemented by bean deserialization.
*/
public class SerializeJugglerXMl {
	public static void main( String [] args ) throws Exception
	{
		Juggler duke = new Juggler(  );
		// no, Encoder... XMLOutputStream xmlout = new XMLOutputStream(
			new FileOutputStream("juggler.xml") );
		xmlout.writeObject( duke );
		xmlout.close();
	}
}
			</text>
		</p>
		<p n="xj_showapplet">
			<text>import javax.swing.*;
import java.awt.event.*;

public class ShowApplet extends JApplet {
	JTextArea text = new JTextArea();
	int startCount;

	public void init() 
	{
		JButton button = new JButton("Press Me");
		button.addActionListener( new ActionListener() {
			public void actionPerformed( ActionEvent e ) {
				text.append("Button Pressed!\n"); 
			}
		} );
		getContentPane().add( "Center", new JScrollPane( text ) );
		JPanel panel = new JPanel();
		panel.add( button );
		getContentPane().add( "South", panel );
		text.append( "Java Version: "+System.getProperty("java.version")+"\n" );
		text.append( "Applet init()\n" );
	}
	public void start() {
		text.append( "Applet started: "+ startCount++ +"\n" );
	}
	public void stop() {
		text.append( "Applet stopped.\n" );
	}
}

			</text>
		</p>
		<p n="xj_testwrite">
			<text>import java.awt.event.*;
import javax.swing.*;
import java.io.*;

public class TestWrite extends JApplet 
	implements ActionListener
{
	JTextArea ta = new JTextArea();

	public void init() {
		JButton button = new JButton("Test Write");
		button.addActionListener( this );
		JPanel p = new JPanel();
		p.add( button );
		getContentPane().add( "North", p );
		getContentPane().add( "Center", new JScrollPane(ta) );
	}

	public void actionPerformed( ActionEvent e ) 
	{
		try {
			String fname = "." + File.separator + "testwrite.xxx";
			write("Attempting to write file: "+fname);
			FileOutputStream file = new FileOutputStream( fname );
			new PrintStream( file ).println("Hello...");
			file.close();
			write("Success!");
		} catch ( Exception e2 ) {
			write( "Caught Exception: " + e2 );
			write("Failed to write file...");
		}
	}

	private void write( String s ) {
		ta.append( s + "\n" );
	}
}

			</text>
		</p>
	</language.aliases>
	<language.aliases n="language.fundamental.aliases" version="1">
		<p n="xj_aliases">
			<text>
				<![CDATA[import java.util.*;

public class GM 
{
	static void foo( List<String> ls ) { }
	static <T> void bar( T t ) { }

	public static void main( String [] args )
	{
		foo( new ArrayList<String>() );
		bar( new ArrayList<String>() );
	}

}
]]>
			</text>
		</p>
	</language.aliases>
</options>
